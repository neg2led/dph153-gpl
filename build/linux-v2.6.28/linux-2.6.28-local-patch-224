diff -Naur pico_2.6.28/arch/arm/configs/firecracker_defconfig ipa_2.6.28/arch/arm/configs/firecracker_defconfig
--- pico_2.6.28/arch/arm/configs/firecracker_defconfig	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/arch/arm/configs/firecracker_defconfig	2011-04-26 14:51:35.000000000 +0100
@@ -1,8 +1,21 @@
+################################################################################
+# 
+# Copyright (c) 2009 ip.access Ltd.
+#
+#  This program is free software; you can redistribute  it and/or modify it
+#  under  the terms of  the GNU General  Public License as published by the
+#  Free Software Foundation;  either version 2 of the  License, or (at your
+#  option) any later version.
+#
+# 22 Apr 2009 Created by Simon D Hughes.
 #
 # Automatically generated make config: don't edit
 # Linux kernel version: 2.6.28
 # Mon Sep 28 14:28:41 2009
 #
+##############################################################################
+# Filename: 
+##############################################################################
 CONFIG_ARM=y
 CONFIG_SYS_SUPPORTS_APM_EMULATION=y
 CONFIG_GENERIC_GPIO=y
@@ -58,11 +71,11 @@
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_ALL is not set
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
-CONFIG_HOTPLUG=y
+# CONFIG_HOTPLUG is not set
 CONFIG_PRINTK=y
 CONFIG_BUG=y
 CONFIG_ELF_CORE=y
-CONFIG_COMPAT_BRK=y
+# CONFIG_COMPAT_BRK is not set
 CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_ANON_INODES=y
@@ -78,10 +91,11 @@
 # CONFIG_SLOB is not set
 CONFIG_PROFILING=y
 # CONFIG_MARKERS is not set
-CONFIG_OPROFILE=y
+CONFIG_OPROFILE=m
 CONFIG_HAVE_OPROFILE=y
-CONFIG_KPROBES=y
-CONFIG_KRETPROBES=y
+# CONFIG_KPROBES is not set
+# CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS is not set
+# CONFIG_HAVE_IOREMAP_PROT is not set
 CONFIG_HAVE_KPROBES=y
 CONFIG_HAVE_KRETPROBES=y
 CONFIG_HAVE_GENERIC_DMA_COHERENT=y
@@ -90,9 +104,9 @@
 # CONFIG_TINY_SHMEM is not set
 CONFIG_BASE_SMALL=0
 CONFIG_MODULES=y
-CONFIG_MODULE_FORCE_LOAD=y
+# CONFIG_MODULE_FORCE_LOAD is not set
 CONFIG_MODULE_UNLOAD=y
-CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
 CONFIG_MODVERSIONS=y
 # CONFIG_MODULE_SRCVERSION_ALL is not set
 CONFIG_KMOD=y
@@ -119,6 +133,17 @@
 # CONFIG_FREEZER is not set
 
 #
+# IPAccess 3GAP Oyster Product Variant Options
+#
+CONFIG_IPACCESS_IP202FF=y
+# CONFIG_IPACCESS_IP202FF_686 is not set
+# CONFIG_IPACCESS_IP202FF_XB is not set
+# CONFIG_IPACCESS_IP202FF_XBPLUS is not set
+CONFIG_IPACCESS_IP202FF_XC=y
+# CONFIG_IPACCESS_IP202FF_XCMINUS is not set
+# CONFIG_IPACCESS_IP202FF_XE is not set
+
+#
 # System Type
 #
 CONFIG_MMU=y
@@ -167,9 +192,11 @@
 #
 CONFIG_MACH_PC72052_I10_REVB=y
 CONFIG_MACH_PC7802=y
+CONFIG_IP202FF_XC=y
 # CONFIG_FIRECRACKER_DMA_TEST is not set
 CONFIG_FIRECRACKER_DMA_DEBUG=0
 CONFIG_FIRECRACKER_EMAC_DEBUG=0
+CONFIG_FIRECRACKER_ASYNC_OPROF=y
 
 #
 # Boot options
@@ -196,7 +223,7 @@
 #
 # Processor Features
 #
-CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMB is not set
 # CONFIG_CPU_ICACHE_DISABLE is not set
 # CONFIG_CPU_DCACHE_DISABLE is not set
 # CONFIG_CPU_DCACHE_WRITETHROUGH is not set
@@ -223,7 +250,7 @@
 CONFIG_HZ=1000
 # CONFIG_ARM_ASM_UNIFIED is not set
 CONFIG_AEABI=y
-CONFIG_OABI_COMPAT=y
+# CONFIG_OABI_COMPAT is not set
 CONFIG_ARCH_DISCONTIGMEM_ENABLE=y
 # CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
 # CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
@@ -266,8 +293,7 @@
 #
 # At least one emulation must be selected
 #
-CONFIG_FPE_NWFPE=y
-# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_NWFPE is not set
 # CONFIG_FPE_FASTFPE is not set
 # CONFIG_VFP is not set
 
@@ -283,10 +309,7 @@
 #
 # Power management options
 #
-CONFIG_PM=y
-# CONFIG_PM_DEBUG is not set
-# CONFIG_SUSPEND is not set
-# CONFIG_APM_EMULATION is not set
+# CONFIG_PM is not set
 CONFIG_ARCH_SUSPEND_POSSIBLE=y
 CONFIG_NET=y
 
@@ -297,28 +320,35 @@
 CONFIG_PACKET_MMAP=y
 CONFIG_UNIX=y
 CONFIG_XFRM=y
-# CONFIG_XFRM_USER is not set
+CONFIG_XFRM_USER=y
 # CONFIG_XFRM_SUB_POLICY is not set
 # CONFIG_XFRM_MIGRATE is not set
 # CONFIG_XFRM_STATISTICS is not set
-# CONFIG_NET_KEY is not set
+CONFIG_XFRM_IPCOMP=y
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
 CONFIG_INET=y
 # CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ASK_IP_FIB_HASH=y
+# CONFIG_IP_FIB_TRIE is not set
 CONFIG_IP_FIB_HASH=y
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+# CONFIG_IP_ROUTE_VERBOSE is not set
 CONFIG_IP_PNP=y
 CONFIG_IP_PNP_DHCP=y
 CONFIG_IP_PNP_BOOTP=y
 # CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
+CONFIG_NET_IPIP=y
 # CONFIG_NET_IPGRE is not set
 # CONFIG_ARPD is not set
 # CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_INET_XFRM_TUNNEL is not set
-# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+CONFIG_INET_IPCOMP=y
+CONFIG_INET_XFRM_TUNNEL=y
+CONFIG_INET_TUNNEL=y
 CONFIG_INET_XFRM_MODE_TRANSPORT=y
 CONFIG_INET_XFRM_MODE_TUNNEL=y
 CONFIG_INET_XFRM_MODE_BEET=y
@@ -329,22 +359,104 @@
 CONFIG_TCP_CONG_CUBIC=y
 CONFIG_DEFAULT_TCP_CONG="cubic"
 # CONFIG_TCP_MD5SIG is not set
+# CONFIG_IP_VS is not set
 # CONFIG_IPV6 is not set
 # CONFIG_NETWORK_SECMARK is not set
-# CONFIG_NETFILTER is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+
+#
+# Core Netfilter Configuration
+#
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CT_ACCT=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+# CONFIG_NF_CT_PROTO_DCCP is not set
+# CONFIG_NF_CT_PROTO_SCTP is not set
+# CONFIG_NF_CT_PROTO_UDPLITE is not set
+# CONFIG_NF_CONNTRACK_AMANDA is not set
+# CONFIG_NF_CONNTRACK_FTP is not set
+# CONFIG_NF_CONNTRACK_H323 is not set
+# CONFIG_NF_CONNTRACK_IRC is not set
+# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
+# CONFIG_NF_CONNTRACK_PPTP is not set
+# CONFIG_NF_CONNTRACK_SANE is not set
+# CONFIG_NF_CONNTRACK_SIP is not set
+# CONFIG_NF_CONNTRACK_TFTP is not set
+# CONFIG_NF_CT_NETLINK is not set
+CONFIG_NETFILTER_XTABLES=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+# CONFIG_NETFILTER_XT_TARGET_CONNMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_RATEEST=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+CONFIG_NETFILTER_XT_MATCH_DSCP=y
+CONFIG_NETFILTER_XT_MATCH_ESP=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_OWNER=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_RATEEST=y
+CONFIG_NETFILTER_XT_MATCH_REALM=y
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=y
+# CONFIG_IP_NF_MATCH_RECENT is not set
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_MATCH_ADDRTYPE=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_IP_NF_TARGET_ULOG=y
+# CONFIG_NF_NAT is not set
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_TARGET_ECN is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+# CONFIG_IP_NF_RAW is not set
+# CONFIG_IP_NF_ARPTABLES is not set
 # CONFIG_IP_DCCP is not set
-CONFIG_IP_SCTP=y
-# CONFIG_SCTP_DBG_MSG is not set
-# CONFIG_SCTP_DBG_OBJCNT is not set
-# CONFIG_SCTP_HMAC_NONE is not set
-# CONFIG_SCTP_HMAC_SHA1 is not set
-CONFIG_SCTP_HMAC_MD5=y
+# CONFIG_IP_SCTP is not set
 # CONFIG_TIPC is not set
 # CONFIG_ATM is not set
 # CONFIG_BRIDGE is not set
-# CONFIG_NET_DSA is not set
-CONFIG_VLAN_8021Q=y
-# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_VLAN_8021Q is not set
 # CONFIG_DECNET is not set
 # CONFIG_LLC2 is not set
 # CONFIG_IPX is not set
@@ -354,6 +466,7 @@
 # CONFIG_ECONET is not set
 # CONFIG_WAN_ROUTER is not set
 # CONFIG_NET_SCHED is not set
+CONFIG_NET_CLS_ROUTE=y
 
 #
 # Network testing
@@ -392,7 +505,7 @@
 # CONFIG_MTD_CONCAT is not set
 CONFIG_MTD_PARTITIONS=y
 # CONFIG_MTD_REDBOOT_PARTS is not set
-# CONFIG_MTD_CMDLINE_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
 # CONFIG_MTD_AFS_PARTS is not set
 # CONFIG_MTD_AR7_PARTS is not set
 
@@ -443,16 +556,20 @@
 # Mapping drivers for chip access
 #
 # CONFIG_MTD_COMPLEX_MAPPINGS is not set
-# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_PHYSMAP_START=0x20000000
+CONFIG_MTD_PHYSMAP_LEN=0x10000000
+CONFIG_MTD_PHYSMAP_BANKWIDTH=2
 # CONFIG_MTD_ARM_INTEGRATOR is not set
 # CONFIG_MTD_PLATRAM is not set
-CONFIG_MTD_PICOHDP=y
+# CONFIG_MTD_PICOHDP is not set
 
 #
 # Self-contained MTD device drivers
 #
 # CONFIG_MTD_DATAFLASH is not set
 # CONFIG_MTD_M25P80 is not set
+# CONFIG_M25PXX_USE_FAST_READ is not set
 # CONFIG_MTD_SLRAM is not set
 # CONFIG_MTD_PHRAM is not set
 # CONFIG_MTD_MTDRAM is not set
@@ -472,14 +589,7 @@
 #
 # CONFIG_MTD_UBI is not set
 # CONFIG_PARPORT is not set
-CONFIG_BLK_DEV=y
-# CONFIG_BLK_DEV_COW_COMMON is not set
-CONFIG_BLK_DEV_LOOP=y
-# CONFIG_BLK_DEV_CRYPTOLOOP is not set
-# CONFIG_BLK_DEV_NBD is not set
-# CONFIG_BLK_DEV_RAM is not set
-# CONFIG_CDROM_PKTCDVD is not set
-# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_BLK_DEV is not set
 CONFIG_MISC_DEVICES=y
 # CONFIG_EEPROM_93CX6 is not set
 # CONFIG_ICS932S401 is not set
@@ -513,7 +623,7 @@
 # CONFIG_MARVELL_PHY is not set
 # CONFIG_DAVICOM_PHY is not set
 # CONFIG_QSEMI_PHY is not set
-# CONFIG_LXT_PHY is not set
+CONFIG_LXT_PHY=y
 # CONFIG_CICADA_PHY is not set
 # CONFIG_VITESSE_PHY is not set
 # CONFIG_SMSC_PHY is not set
@@ -572,14 +682,7 @@
 #
 # Input Device Drivers
 #
-CONFIG_INPUT_KEYBOARD=y
-CONFIG_KEYBOARD_ATKBD=y
-# CONFIG_KEYBOARD_SUNKBD is not set
-# CONFIG_KEYBOARD_LKKBD is not set
-# CONFIG_KEYBOARD_XTKBD is not set
-# CONFIG_KEYBOARD_NEWTON is not set
-# CONFIG_KEYBOARD_STOWAWAY is not set
-# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_INPUT_KEYBOARD is not set
 # CONFIG_INPUT_MOUSE is not set
 # CONFIG_INPUT_JOYSTICK is not set
 # CONFIG_INPUT_TABLET is not set
@@ -589,18 +692,14 @@
 #
 # Hardware I/O ports
 #
-CONFIG_SERIO=y
-# CONFIG_SERIO_SERPORT is not set
-# CONFIG_SERIO_AMBAKMI is not set
-CONFIG_SERIO_LIBPS2=y
-# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO is not set
 # CONFIG_GAMEPORT is not set
 
 #
 # Character devices
 #
 CONFIG_VT=y
-CONFIG_CONSOLE_TRANSLATIONS=y
+# CONFIG_CONSOLE_TRANSLATIONS is not set
 CONFIG_VT_CONSOLE=y
 CONFIG_HW_CONSOLE=y
 # CONFIG_VT_HW_CONSOLE_BINDING is not set
@@ -633,67 +732,8 @@
 # CONFIG_R3964 is not set
 # CONFIG_RAW_DRIVER is not set
 # CONFIG_TCG_TPM is not set
-CONFIG_I2C=y
-CONFIG_I2C_BOARDINFO=y
-CONFIG_I2C_CHARDEV=y
-CONFIG_I2C_HELPER_AUTO=y
-CONFIG_I2C_ALGOBIT=m
-
-#
-# I2C Hardware Bus support
-#
-
-#
-# I2C system bus drivers (mostly embedded / system-on-chip)
-#
-CONFIG_I2C_GPIO=m
-# CONFIG_I2C_OCORES is not set
-# CONFIG_I2C_SIMTEC is not set
-
-#
-# External I2C/SMBus adapter drivers
-#
-# CONFIG_I2C_PARPORT_LIGHT is not set
-# CONFIG_I2C_TAOS_EVM is not set
-
-#
-# Other I2C/SMBus bus drivers
-#
-# CONFIG_I2C_PCA_PLATFORM is not set
-# CONFIG_I2C_STUB is not set
-
-#
-# Miscellaneous I2C Chip support
-#
-# CONFIG_DS1682 is not set
-# CONFIG_AT24 is not set
-# CONFIG_SENSORS_EEPROM is not set
-# CONFIG_SENSORS_PCF8574 is not set
-# CONFIG_PCF8575 is not set
-# CONFIG_SENSORS_PCA9539 is not set
-# CONFIG_SENSORS_PCF8591 is not set
-# CONFIG_SENSORS_MAX6875 is not set
-# CONFIG_SENSORS_TSL2550 is not set
-# CONFIG_I2C_DEBUG_CORE is not set
-# CONFIG_I2C_DEBUG_ALGO is not set
-# CONFIG_I2C_DEBUG_BUS is not set
-# CONFIG_I2C_DEBUG_CHIP is not set
-CONFIG_SPI=y
-# CONFIG_SPI_DEBUG is not set
-CONFIG_SPI_MASTER=y
-
-#
-# SPI Master Controller Drivers
-#
-CONFIG_SPI_BITBANG=y
-CONFIG_SPI_FIRECRACKER=m
-
-#
-# SPI Protocol Masters
-#
-# CONFIG_SPI_AT25 is not set
-# CONFIG_SPI_SPIDEV is not set
-# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_I2C is not set
+# CONFIG_SPI is not set
 # CONFIG_W1 is not set
 # CONFIG_POWER_SUPPLY is not set
 # CONFIG_HWMON is not set
@@ -770,12 +810,23 @@
 #
 CONFIG_PICOCPE20X_FPGA=m
 CONFIG_PICOIF=m
+CONFIG_PICOIF_DMAPOOL=y
 CONFIG_PICOIF_PC202=y
 CONFIG_PICOIF_DEFAULT_DEBUG_LEVEL=1
 # CONFIG_PICOIF_DEBUG_TO_CONSOLE is not set
 # CONFIG_PERFCOUNTERS is not set
 
 #
+# IP Access Drivers
+#
+CONFIG_IPACCESS=m
+CONFIG_IPACCESS_CPETD=m
+CONFIG_IPACCESS_DEBUG=m
+CONFIG_IPACCESS_LED=m
+CONFIG_IPACCESS_CRYPTO=m
+CONFIG_IPACCESS_FPGA_DEBUG=y
+
+#
 # File systems
 #
 # CONFIG_EXT2_FS is not set
@@ -831,8 +882,7 @@
 # CONFIG_EFS_FS is not set
 CONFIG_JFFS2_FS=y
 CONFIG_JFFS2_FS_DEBUG=0
-CONFIG_JFFS2_FS_WRITEBUFFER=y
-# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_FS_WRITEBUFFER is not set
 # CONFIG_JFFS2_SUMMARY is not set
 # CONFIG_JFFS2_FS_XATTR is not set
 # CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
@@ -924,7 +974,7 @@
 CONFIG_ENABLE_WARN_DEPRECATED=y
 CONFIG_ENABLE_MUST_CHECK=y
 CONFIG_FRAME_WARN=1024
-CONFIG_MAGIC_SYSRQ=y
+# CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_UNUSED_SYMBOLS is not set
 CONFIG_DEBUG_FS=y
 # CONFIG_HEADERS_CHECK is not set
@@ -933,12 +983,12 @@
 CONFIG_DETECT_SOFTLOCKUP=y
 # CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
 CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
-CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHED_DEBUG is not set
 # CONFIG_SCHEDSTATS is not set
 # CONFIG_TIMER_STATS is not set
 # CONFIG_DEBUG_OBJECTS is not set
 # CONFIG_DEBUG_SLAB is not set
-CONFIG_DEBUG_PREEMPT=y
+# CONFIG_DEBUG_PREEMPT is not set
 # CONFIG_DEBUG_RT_MUTEXES is not set
 # CONFIG_RT_MUTEX_TESTER is not set
 # CONFIG_DEBUG_SPINLOCK is not set
@@ -949,13 +999,14 @@
 # CONFIG_DEBUG_SPINLOCK_SLEEP is not set
 # CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
 # CONFIG_DEBUG_KOBJECT is not set
-CONFIG_DEBUG_BUGVERBOSE=y
-CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_INFO is not set
 # CONFIG_DEBUG_VM is not set
 # CONFIG_DEBUG_WRITECOUNT is not set
 # CONFIG_DEBUG_MEMORY_INIT is not set
 # CONFIG_DEBUG_LIST is not set
 # CONFIG_DEBUG_SG is not set
+CONFIG_FRAME_POINTER=y
 # CONFIG_BOOT_PRINTK_DELAY is not set
 # CONFIG_RCU_TORTURE_TEST is not set
 # CONFIG_RCU_CPU_STALL_DETECTOR is not set
@@ -1010,9 +1061,9 @@
 CONFIG_CRYPTO_MANAGER=y
 CONFIG_CRYPTO_MANAGER2=y
 # CONFIG_CRYPTO_GF128MUL is not set
-# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_NULL=y
 # CONFIG_CRYPTO_CRYPTD is not set
-# CONFIG_CRYPTO_AUTHENC is not set
+CONFIG_CRYPTO_AUTHENC=y
 # CONFIG_CRYPTO_TEST is not set
 
 #
@@ -1025,7 +1076,7 @@
 #
 # Block modes
 #
-# CONFIG_CRYPTO_CBC is not set
+CONFIG_CRYPTO_CBC=y
 # CONFIG_CRYPTO_CTR is not set
 # CONFIG_CRYPTO_CTS is not set
 # CONFIG_CRYPTO_ECB is not set
@@ -1059,14 +1110,14 @@
 #
 # Ciphers
 #
-# CONFIG_CRYPTO_AES is not set
+CONFIG_CRYPTO_AES=y
 # CONFIG_CRYPTO_ANUBIS is not set
 # CONFIG_CRYPTO_ARC4 is not set
 # CONFIG_CRYPTO_BLOWFISH is not set
 # CONFIG_CRYPTO_CAMELLIA is not set
 # CONFIG_CRYPTO_CAST5 is not set
 # CONFIG_CRYPTO_CAST6 is not set
-# CONFIG_CRYPTO_DES is not set
+CONFIG_CRYPTO_DES=y
 # CONFIG_CRYPTO_FCRYPT is not set
 # CONFIG_CRYPTO_KHAZAD is not set
 # CONFIG_CRYPTO_SALSA20 is not set
@@ -1078,7 +1129,7 @@
 #
 # Compression
 #
-# CONFIG_CRYPTO_DEFLATE is not set
+CONFIG_CRYPTO_DEFLATE=y
 # CONFIG_CRYPTO_LZO is not set
 
 #
@@ -1086,7 +1137,8 @@
 #
 # CONFIG_CRYPTO_ANSI_CPRNG is not set
 # CONFIG_KEYSTREAM is not set
-# CONFIG_CRYPTO_HW is not set
+# CONFIG_IPA_KEYSTREAM is not set
+CONFIG_CRYPTO_HW=y
 
 #
 # Library routines
diff -Naur pico_2.6.28/arch/arm/configs/firecracker_xc ipa_2.6.28/arch/arm/configs/firecracker_xc
--- pico_2.6.28/arch/arm/configs/firecracker_xc	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/arch/arm/configs/firecracker_xc	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,1185 @@
+################################################################################
+# 
+# Copyright (c) 2009,2010 ip.access Ltd.
+#
+#  This program is free software; you can redistribute  it and/or modify it
+#  under  the terms of  the GNU General  Public License as published by the
+#  Free Software Foundation;  either version 2 of the  License, or (at your
+#  option) any later version.
+#
+# 22 Apr 2009 Created by Simon D Hughes.
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.28
+# Wed Jan 27 16:41:10 2010
+#
+##############################################################################
+# Filename: 
+##############################################################################
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+# CONFIG_GENERIC_TIME is not set
+# CONFIG_GENERIC_CLOCKEVENTS is not set
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION="-picochip-3.2.4"
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=17
+# CONFIG_CGROUPS is not set
+# CONFIG_GROUP_SCHED is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+CONFIG_RELAY=y
+# CONFIG_NAMESPACES is not set
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_PROFILING=y
+# CONFIG_MARKERS is not set
+CONFIG_OPROFILE=m
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+# CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS is not set
+# CONFIG_HAVE_IOREMAP_PROT is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+CONFIG_IOSCHED_DEADLINE=y
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_AS is not set
+CONFIG_DEFAULT_DEADLINE=y
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="deadline"
+CONFIG_CLASSIC_RCU=y
+
+#
+# IPAccess 3GAP Oyster Product Variant Options
+#
+CONFIG_IPACCESS_IP202FF=y
+# CONFIG_IPACCESS_IP202FF_686 is not set
+CONFIG_IPACCESS_IP202FF_XC=y
+# CONFIG_IPACCESS_IP202FF_XE is not set
+# CONFIG_IPACCESS_IP302FF is not set
+# CONFIG_IPACCESS_IP302FF_XC is not set
+# CONFIG_FREEZER is not set
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+CONFIG_ARCH_FIRECRACKER=y
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PC302 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_MSM is not set
+
+#
+# Firecracker platform type
+#
+CONFIG_MACH_PC72052_I10_REVB=y
+CONFIG_MACH_PC7802=y
+CONFIG_IP202FF_XC=y
+# CONFIG_FIRECRACKER_DMA_TEST is not set
+CONFIG_FIRECRACKER_DMA_DEBUG=0
+CONFIG_FIRECRACKER_EMAC_DEBUG=0
+CONFIG_FIRECRACKER_ASYNC_OPROF=y
+
+#
+# Boot options
+#
+
+#
+# Power management
+#
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+# CONFIG_OUTER_CACHE is not set
+CONFIG_ARM_VIC=y
+
+#
+# Bus support
+#
+CONFIG_ARM_AMBA=y
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_PREEMPT=y
+CONFIG_HZ=1000
+# CONFIG_ARM_ASM_UNIFIED is not set
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+CONFIG_ARCH_DISCONTIGMEM_ENABLE=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_NODES_SHIFT=2
+CONFIG_SELECT_MEMORY_MODEL=y
+# CONFIG_FLATMEM_MANUAL is not set
+CONFIG_DISCONTIGMEM_MANUAL=y
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_DISCONTIGMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_NEED_MULTIPLE_NODES=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_RESOURCES_64BIT is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_UNEVICTABLE_LRU=y
+# CONFIG_LEDS is not set
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="root=/dev/mtdblock1 rootfstype=jffs2 console=ttyS0,115200n8 noinitrd"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_XFRM_IPCOMP=y
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ASK_IP_FIB_HASH=y
+# CONFIG_IP_FIB_TRIE is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+# CONFIG_IP_ROUTE_VERBOSE is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+CONFIG_NET_IPIP=y
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+CONFIG_INET_IPCOMP=y
+CONFIG_INET_XFRM_TUNNEL=y
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+
+#
+# Core Netfilter Configuration
+#
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CT_ACCT=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+# CONFIG_NF_CT_PROTO_DCCP is not set
+# CONFIG_NF_CT_PROTO_SCTP is not set
+# CONFIG_NF_CT_PROTO_UDPLITE is not set
+# CONFIG_NF_CONNTRACK_AMANDA is not set
+# CONFIG_NF_CONNTRACK_FTP is not set
+# CONFIG_NF_CONNTRACK_H323 is not set
+# CONFIG_NF_CONNTRACK_IRC is not set
+# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
+# CONFIG_NF_CONNTRACK_PPTP is not set
+# CONFIG_NF_CONNTRACK_SANE is not set
+# CONFIG_NF_CONNTRACK_SIP is not set
+# CONFIG_NF_CONNTRACK_TFTP is not set
+# CONFIG_NF_CT_NETLINK is not set
+# CONFIG_NETFILTER_TPROXY is not set
+CONFIG_NETFILTER_XTABLES=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+# CONFIG_NETFILTER_XT_TARGET_CONNMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_TARGET_RATEEST=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+CONFIG_NETFILTER_XT_MATCH_DSCP=y
+CONFIG_NETFILTER_XT_MATCH_ESP=y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+CONFIG_NETFILTER_XT_MATCH_OWNER=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_RATEEST=y
+CONFIG_NETFILTER_XT_MATCH_REALM=y
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_ADDRTYPE=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_IP_NF_TARGET_ULOG=y
+# CONFIG_NF_NAT is not set
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+# CONFIG_IP_NF_TARGET_ECN is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+# CONFIG_IP_NF_RAW is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+# CONFIG_IP_DCCP is not set
+CONFIG_IP_SCTP=y
+# CONFIG_SCTP_DBG_MSG is not set
+# CONFIG_SCTP_DBG_OBJCNT is not set
+# CONFIG_SCTP_HMAC_NONE is not set
+# CONFIG_SCTP_HMAC_SHA1 is not set
+CONFIG_SCTP_HMAC_MD5=y
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+CONFIG_NET_CLS_ROUTE=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_PHONET is not set
+CONFIG_FIB_RULES=y
+# CONFIG_WIRELESS is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/mdev"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_GEOMETRY is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_OTP is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_PHYSMAP_START=0x20000000
+CONFIG_MTD_PHYSMAP_LEN=0x10000000
+CONFIG_MTD_PHYSMAP_BANKWIDTH=2
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_PLATRAM is not set
+# CONFIG_MTD_PICOHDP is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_M25PXX_USE_FAST_READ is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+# CONFIG_BLK_DEV is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+CONFIG_PC202_GPIO=y
+# CONFIG_C2PORT is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=y
+# CONFIG_VETH is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+CONFIG_LXT_PHY=y
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_ENC28J60 is not set
+# CONFIG_SMC911X is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_IWLWIFI_LEDS is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+# CONFIG_CONSOLE_TRANSLATIONS is not set
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+CONFIG_SERIAL_8250_FIRECRACKER=y
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+# CONFIG_SERIAL_AMBA_PL011 is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=16
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_I2C is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_PC302_GPIO is not set
+# CONFIG_SPI_PC302 is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_AT25 is not set
+# CONFIG_SPI_DAC7512 is not set
+# CONFIG_SPI_MAX6662 is not set
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_VIDEO_MEDIA is not set
+
+#
+# Multimedia drivers
+#
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_SOUND is not set
+# CONFIG_HID_SUPPORT is not set
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_UIO is not set
+
+#
+# picoChip Drivers
+#
+CONFIG_PICOIF=y
+CONFIG_PICOIF_DMAPOOL=y
+CONFIG_PICOIF_PC202=y
+CONFIG_PICOIF_DEFAULT_DEBUG_LEVEL=1
+# CONFIG_PICOIF_DEBUG_TO_CONSOLE is not set
+
+#
+# IP Access Drivers
+#
+CONFIG_IPACCESS=m
+CONFIG_IPACCESS_CPETD=m
+CONFIG_IPACCESS_DEBUG=m
+CONFIG_IPACCESS_LED=m
+CONFIG_IPACCESS_CRYPTO=m
+CONFIG_IPACCESS_FPGA_DEBUG=y
+# CONFIG_PERFCOUNTERS is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_FILE_LOCKING=y
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_CONFIGFS_FS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_WRITEBUFFER is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_REGISTER_V4 is not set
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+
+#
+# Tracers
+#
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_BOOT_TRACER is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_RVIDCC is not set
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+CONFIG_CRYPTO_NULL=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_KEYSTREAM is not set
+# CONFIG_IPA_KEYSTREAM is not set
+CONFIG_CRYPTO_HW=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=y
+CONFIG_TEXTSEARCH_BM=y
+CONFIG_TEXTSEARCH_FSM=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
diff -Naur pico_2.6.28/arch/arm/configs/pc302_226_xb ipa_2.6.28/arch/arm/configs/pc302_226_xb
--- pico_2.6.28/arch/arm/configs/pc302_226_xb	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/arch/arm/configs/pc302_226_xb	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,1261 @@
+################################################################################
+# 
+# Copyright (c) 2010 ip.access Ltd.
+#
+#  This program is free software; you can redistribute  it and/or modify it
+#  under  the terms of  the GNU General  Public License as published by the
+#  Free Software Foundation;  either version 2 of the  License, or (at your
+#  option) any later version.
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.28
+# Mon Feb 22 11:24:05 2010
+#
+##############################################################################
+# Filename: arch/arm/configs/pc302_226_xb
+##############################################################################
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_OPROFILE_ARMV6=y
+CONFIG_OPROFILE_ARM11_CORE=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION="-picochip-3.2.4"
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=17
+# CONFIG_CGROUPS is not set
+# CONFIG_GROUP_SCHED is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+CONFIG_RELAY=y
+# CONFIG_NAMESPACES is not set
+# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_COMPAT_BRK=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+CONFIG_PROFILING=y
+# CONFIG_MARKERS is not set
+CONFIG_OPROFILE=m
+CONFIG_HAVE_OPROFILE=y
+CONFIG_KPROBES=y
+CONFIG_KRETPROBES=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_KMOD=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+CONFIG_CLASSIC_RCU=y
+
+#
+# IPAccess 3GAP Oyster Product Variant Options
+#
+# CONFIG_IPACCESS_IP202FF is not set
+# CONFIG_IPACCESS_IP202FF_686 is not set
+# CONFIG_IPACCESS_IP202FF_XC is not set
+# CONFIG_IPACCESS_IP202FF_XE is not set
+CONFIG_IPACCESS_IP302FF=y
+CONFIG_IPACCESS_IP302FF_XC=y
+# CONFIG_FREEZER is not set
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FIRECRACKER is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PNX4008 is not set
+CONFIG_ARCH_PC302=y
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_MSM is not set
+
+#
+# PC302 platform type
+#
+CONFIG_MACH_PC7302=y
+CONFIG_PC302_ASYNC_OPROF=y
+CONFIG_IP302FF_XC=y
+
+#
+# Boot options
+#
+
+#
+# Power management
+#
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_V6=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v6=y
+CONFIG_CPU_ABRT_EV6=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_V6=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V6=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_HAS_TLS_REG=y
+# CONFIG_OUTER_CACHE is not set
+# CONFIG_ARM_ERRATA_364296 is not set
+CONFIG_ARM_ERRATA_411920=y
+
+#
+# Bus support
+#
+CONFIG_ARM_AMBA=y
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_PREEMPT=y
+CONFIG_HZ=1000
+# CONFIG_ARM_ASM_UNIFIED is not set
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_UNEVICTABLE_LRU=y
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE="ip=172.17.13.247:172.17.1.131:172.17.0.1:255.255.0.0:picopc7302-248#:eth0 mem=128M console=ttyS0,115200 loglevel=8"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_XFRM_IPCOMP=y
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ASK_IP_FIB_HASH=y
+# CONFIG_IP_FIB_TRIE is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+# CONFIG_IP_ROUTE_VERBOSE is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+CONFIG_NET_IPIP=y
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+CONFIG_INET_IPCOMP=y
+CONFIG_INET_XFRM_TUNNEL=y
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_NETLABEL is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+
+#
+# Core Netfilter Configuration
+#
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CT_ACCT=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+# CONFIG_NF_CT_PROTO_DCCP is not set
+# CONFIG_NF_CT_PROTO_SCTP is not set
+# CONFIG_NF_CT_PROTO_UDPLITE is not set
+# CONFIG_NF_CONNTRACK_AMANDA is not set
+# CONFIG_NF_CONNTRACK_FTP is not set
+# CONFIG_NF_CONNTRACK_H323 is not set
+# CONFIG_NF_CONNTRACK_IRC is not set
+# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
+# CONFIG_NF_CONNTRACK_PPTP is not set
+# CONFIG_NF_CONNTRACK_SANE is not set
+# CONFIG_NF_CONNTRACK_SIP is not set
+# CONFIG_NF_CONNTRACK_TFTP is not set
+# CONFIG_NF_CT_NETLINK is not set
+# CONFIG_NETFILTER_TPROXY is not set
+CONFIG_NETFILTER_XTABLES=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+# CONFIG_NETFILTER_XT_TARGET_CONNMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_TARGET_RATEEST=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+CONFIG_NETFILTER_XT_MATCH_DSCP=y
+CONFIG_NETFILTER_XT_MATCH_ESP=y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+CONFIG_NETFILTER_XT_MATCH_OWNER=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_RATEEST=y
+CONFIG_NETFILTER_XT_MATCH_REALM=y
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_ADDRTYPE=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_IP_NF_TARGET_ULOG=y
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+# CONFIG_IP_NF_TARGET_MASQUERADE is not set
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+# CONFIG_NF_NAT_SNMP_BASIC is not set
+# CONFIG_NF_NAT_FTP is not set
+# CONFIG_NF_NAT_IRC is not set
+# CONFIG_NF_NAT_TFTP is not set
+# CONFIG_NF_NAT_AMANDA is not set
+# CONFIG_NF_NAT_PPTP is not set
+# CONFIG_NF_NAT_H323 is not set
+# CONFIG_NF_NAT_SIP is not set
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+# CONFIG_IP_NF_TARGET_ECN is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+# CONFIG_IP_NF_RAW is not set
+# CONFIG_IP_NF_SECURITY is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+# CONFIG_IP_DCCP is not set
+CONFIG_IP_SCTP=y
+# CONFIG_SCTP_DBG_MSG is not set
+# CONFIG_SCTP_DBG_OBJCNT is not set
+# CONFIG_SCTP_HMAC_NONE is not set
+# CONFIG_SCTP_HMAC_SHA1 is not set
+CONFIG_SCTP_HMAC_MD5=y
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+CONFIG_VLAN_8021Q=y
+# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+CONFIG_NET_CLS_ROUTE=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_TCPPROBE is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_PHONET is not set
+CONFIG_FIB_RULES=y
+# CONFIG_WIRELESS is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/mdev"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_GEOMETRY is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_OTP is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_PHYSMAP_START=0x40000000
+CONFIG_MTD_PHYSMAP_LEN=0x8000000
+CONFIG_MTD_PHYSMAP_BANKWIDTH=1
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_IMPA7 is not set
+# CONFIG_MTD_PLATRAM is not set
+# CONFIG_MTD_PICOHDP is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_M25PXX_USE_FAST_READ is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+# CONFIG_BLK_DEV is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+CONFIG_PC302_FRACN=m
+CONFIG_PC302_FUSEBLOCK=m
+CONFIG_PC302_GPIO=y
+# CONFIG_C2PORT is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=y
+# CONFIG_VETH is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+CONFIG_FIXED_PHY=y
+CONFIG_MDIO_BITBANG=y
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_PC302_EMAC=y
+CONFIG_PC302_MICREL_VLAN_SWITCH=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_ENC28J60 is not set
+# CONFIG_SMC911X is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_IWLWIFI_LEDS is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=32
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+# CONFIG_SERIAL_8250_FIRECRACKER is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+# CONFIG_SERIAL_AMBA_PL011 is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+CONFIG_TCG_TPM=y
+# CONFIG_TCG_NSC is not set
+# CONFIG_TCG_ATMEL is not set
+CONFIG_TCG_ATMEL_TWI=m
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_HELPER_AUTO is not set
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+CONFIG_I2C_GPIO=y
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_AT24 is not set
+CONFIG_SENSORS_AD7995=m
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+CONFIG_SENSORS_MAX6635=m
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_PC302 is not set
+# CONFIG_SPI_PC302_GPIO is not set
+CONFIG_SPI_PC302_IPA=m
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_AT25 is not set
+CONFIG_SPI_DAC7512=m
+CONFIG_SPI_MAX6662=m
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_PC302_WATCHDOG=m
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_VIDEO_MEDIA is not set
+
+#
+# Multimedia drivers
+#
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_SOUND is not set
+# CONFIG_HID_SUPPORT is not set
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+CONFIG_DMADEVICES=y
+
+#
+# DMA Devices
+#
+CONFIG_PC302_DMA=y
+CONFIG_PC302_DMA_DEBUG_LEVEL=0
+CONFIG_DMA_ENGINE=y
+
+#
+# DMA Clients
+#
+# CONFIG_NET_DMA is not set
+# CONFIG_DMATEST is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_UIO is not set
+
+#
+# picoChip Drivers
+#
+CONFIG_PICOIF=y
+CONFIG_PICOIF_DMAPOOL=y
+CONFIG_PICOIF_PC302=y
+CONFIG_PICOIF_DEFAULT_DEBUG_LEVEL=1
+# CONFIG_PICOIF_DEBUG_TO_CONSOLE is not set
+CONFIG_PERFCOUNTERS=y
+CONFIG_ARMV6_PERFCOUNTER=m
+
+#
+# IP Access Drivers
+#
+CONFIG_IPACCESS=m
+CONFIG_IPACCESS_CPETD=m
+CONFIG_IPACCESS_DEBUG=m
+CONFIG_IPACCESS_LED=m
+CONFIG_IPACCESS_CRYPTO=m
+# CONFIG_IPACCESS_FPGA_DEBUG is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_CONFIGFS_FS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+CONFIG_JFFS2_SUMMARY=y
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_REGISTER_V4 is not set
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_NLS is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_KPROBES_SANITY_TEST is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_LKDTM is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+
+#
+# Tracers
+#
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_PREEMPT_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_BOOT_TRACER is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_ARM_UNWIND=y
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_RVIDCC is not set
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+CONFIG_KEYS_DEBUG_PROC_KEYS=y
+CONFIG_SECURITY=y
+# CONFIG_SECURITYFS is not set
+CONFIG_SECURITY_NETWORK=y
+# CONFIG_SECURITY_NETWORK_XFRM is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_SECURITY_DEFAULT_MMAP_MIN_ADDR=0
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+CONFIG_CRYPTO_NULL=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+CONFIG_CRYPTO_TEST=m
+
+#
+# Authenticated Encryption with Associated Data
+#
+CONFIG_CRYPTO_CCM=y
+# CONFIG_CRYPTO_GCM is not set
+CONFIG_CRYPTO_SEQIV=y
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_CTR=y
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_LZO=y
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_KEYSTREAM=m
+CONFIG_IPA_KEYSTREAM=m
+CONFIG_CRYPTO_HW=y
+CONFIG_CRYPTO_DEV_PC302=m
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=y
+CONFIG_TEXTSEARCH_BM=y
+CONFIG_TEXTSEARCH_FSM=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
diff -Naur pico_2.6.28/arch/arm/configs/pc302_defconfig ipa_2.6.28/arch/arm/configs/pc302_defconfig
--- pico_2.6.28/arch/arm/configs/pc302_defconfig	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/arch/arm/configs/pc302_defconfig	2011-04-26 14:51:35.000000000 +0100
@@ -170,6 +170,7 @@
 # PC302 platform type
 #
 CONFIG_MACH_PC7302=y
+CONFIG_PC302_ASYNC_OPROF=y
 
 #
 # Boot options
@@ -592,6 +593,7 @@
 CONFIG_NET_ETHERNET=y
 CONFIG_MII=y
 CONFIG_PC302_EMAC=y
+# CONFIG_PC302_MICREL_VLAN_SWITCH is not set
 # CONFIG_AX88796 is not set
 # CONFIG_SMC91X is not set
 # CONFIG_DM9000 is not set
@@ -699,11 +701,15 @@
 #
 # CONFIG_SPI_BITBANG is not set
 CONFIG_SPI_PC302=y
+# CONFIG_SPI_PC302_GPIO is not set
+# CONFIG_SPI_PC302_IPA is not set
 
 #
 # SPI Protocol Masters
 #
 # CONFIG_SPI_AT25 is not set
+# CONFIG_SPI_DAC7512 is not set
+# CONFIG_SPI_MAX6662 is not set
 # CONFIG_SPI_SPIDEV is not set
 # CONFIG_SPI_TLE62X0 is not set
 # CONFIG_W1 is not set
@@ -798,6 +804,7 @@
 # picoChip Drivers
 #
 CONFIG_PICOIF=y
+CONFIG_PICOIF_DMAPOOL=y
 CONFIG_PICOIF_PC302=y
 CONFIG_PICOIF_DEFAULT_DEBUG_LEVEL=1
 # CONFIG_PICOIF_DEBUG_TO_CONSOLE is not set
@@ -1092,6 +1099,7 @@
 #
 # CONFIG_CRYPTO_ANSI_CPRNG is not set
 CONFIG_KEYSTREAM=m
+CONFIG_IPA_KEYSTREAM=m
 CONFIG_CRYPTO_HW=y
 CONFIG_CRYPTO_DEV_PC302=m
 
diff -Naur pico_2.6.28/arch/arm/configs/pc302_ipa ipa_2.6.28/arch/arm/configs/pc302_ipa
--- pico_2.6.28/arch/arm/configs/pc302_ipa	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/arch/arm/configs/pc302_ipa	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,1182 @@
+################################################################################
+# 
+# Copyright (c) 2009 ip.access Ltd.
+#
+#  This program is free software; you can redistribute  it and/or modify it
+#  under  the terms of  the GNU General  Public License as published by the
+#  Free Software Foundation;  either version 2 of the  License, or (at your
+#  option) any later version.
+#
+# 22 Apr 2009 Created by Simon D Hughes.
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.28
+# Thu Jun  4 12:19:10 2009
+#
+##############################################################################
+# Filename: 
+##############################################################################
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+# CONFIG_GENERIC_TIME is not set
+# CONFIG_GENERIC_CLOCKEVENTS is not set
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_OPROFILE_ARMV6=y
+CONFIG_OPROFILE_ARM11_CORE=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION="-picochip-3.2.4"
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=17
+# CONFIG_CGROUPS is not set
+# CONFIG_GROUP_SCHED is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+CONFIG_RELAY=y
+# CONFIG_NAMESPACES is not set
+# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_COMPAT_BRK=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+CONFIG_PROFILING=y
+# CONFIG_MARKERS is not set
+CONFIG_OPROFILE=m
+CONFIG_HAVE_OPROFILE=y
+CONFIG_KPROBES=y
+CONFIG_KRETPROBES=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_KMOD=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+CONFIG_CLASSIC_RCU=y
+
+#
+# IPAccess 3GAP Oyster Product Variant Options
+#
+# CONFIG_IPACCESS_IP202FF is not set
+# CONFIG_IPACCESS_IP202FF_686 is not set
+# CONFIG_IPACCESS_IP202FF_XC is not set
+# CONFIG_IPACCESS_IP202FF_XE is not set
+CONFIG_IPACCESS_IP302FF=y
+CONFIG_IPACCESS_IP302FF_XC=y
+# CONFIG_FREEZER is not set
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FIRECRACKER is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PNX4008 is not set
+CONFIG_ARCH_PC302=y
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_MSM is not set
+
+#
+# PC302 platform type
+#
+CONFIG_MACH_PC7302=y
+CONFIG_PC302_ASYNC_OPROF=y
+CONFIG_IP302FF_XC=y
+
+#
+# Boot options
+#
+
+#
+# Power management
+#
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_V6=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v6=y
+CONFIG_CPU_ABRT_EV6=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_V6=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V6=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_HAS_TLS_REG=y
+# CONFIG_OUTER_CACHE is not set
+# CONFIG_ARM_ERRATA_364296 is not set
+CONFIG_ARM_ERRATA_411920=y
+
+#
+# Bus support
+#
+CONFIG_ARM_AMBA=y
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_PREEMPT=y
+CONFIG_HZ=1000
+# CONFIG_ARM_ASM_UNIFIED is not set
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_UNEVICTABLE_LRU=y
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE="ip=172.17.13.247:172.17.1.131:172.17.0.1:255.255.0.0:picopc7302-248#:eth0 mem=128M console=ttyS0,115200 loglevel=8"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_XFRM_IPCOMP=y
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ASK_IP_FIB_HASH=y
+# CONFIG_IP_FIB_TRIE is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+# CONFIG_IP_ROUTE_VERBOSE is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+CONFIG_NET_IPIP=y
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+CONFIG_INET_IPCOMP=y
+CONFIG_INET_XFRM_TUNNEL=y
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_NETLABEL is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+
+#
+# Core Netfilter Configuration
+#
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CT_ACCT=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+# CONFIG_NF_CT_PROTO_DCCP is not set
+# CONFIG_NF_CT_PROTO_SCTP is not set
+# CONFIG_NF_CT_PROTO_UDPLITE is not set
+# CONFIG_NF_CONNTRACK_AMANDA is not set
+# CONFIG_NF_CONNTRACK_FTP is not set
+# CONFIG_NF_CONNTRACK_H323 is not set
+# CONFIG_NF_CONNTRACK_IRC is not set
+# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
+# CONFIG_NF_CONNTRACK_PPTP is not set
+# CONFIG_NF_CONNTRACK_SANE is not set
+# CONFIG_NF_CONNTRACK_SIP is not set
+# CONFIG_NF_CONNTRACK_TFTP is not set
+# CONFIG_NF_CT_NETLINK is not set
+# CONFIG_NETFILTER_TPROXY is not set
+CONFIG_NETFILTER_XTABLES=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+# CONFIG_NETFILTER_XT_TARGET_CONNMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_TARGET_RATEEST=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+CONFIG_NETFILTER_XT_MATCH_DSCP=y
+CONFIG_NETFILTER_XT_MATCH_ESP=y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+CONFIG_NETFILTER_XT_MATCH_OWNER=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_RATEEST=y
+CONFIG_NETFILTER_XT_MATCH_REALM=y
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_ADDRTYPE=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_IP_NF_TARGET_ULOG=y
+# CONFIG_NF_NAT is not set
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+# CONFIG_IP_NF_TARGET_ECN is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+# CONFIG_IP_NF_RAW is not set
+# CONFIG_IP_NF_SECURITY is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+# CONFIG_IP_DCCP is not set
+CONFIG_IP_SCTP=y
+# CONFIG_SCTP_DBG_MSG is not set
+# CONFIG_SCTP_DBG_OBJCNT is not set
+# CONFIG_SCTP_HMAC_NONE is not set
+# CONFIG_SCTP_HMAC_SHA1 is not set
+CONFIG_SCTP_HMAC_MD5=y
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+CONFIG_VLAN_8021Q=y
+# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+CONFIG_NET_CLS_ROUTE=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_TCPPROBE is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_PHONET is not set
+CONFIG_FIB_RULES=y
+# CONFIG_WIRELESS is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/mdev"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+CONFIG_MTD_JEDECPROBE=y
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_GEOMETRY is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_OTP is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_IMPA7 is not set
+# CONFIG_MTD_PLATRAM is not set
+CONFIG_MTD_PICOHDP=y
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_M25PXX_USE_FAST_READ is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+# CONFIG_BLK_DEV is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+CONFIG_PC302_FRACN=m
+CONFIG_PC302_FUSEBLOCK=m
+CONFIG_PC302_GPIO=m
+# CONFIG_C2PORT is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=y
+# CONFIG_VETH is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+CONFIG_FIXED_PHY=y
+CONFIG_MDIO_BITBANG=y
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_PC302_EMAC=y
+# CONFIG_PC302_MICREL_VLAN_SWITCH is not set
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_ENC28J60 is not set
+# CONFIG_SMC911X is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_IWLWIFI_LEDS is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=32
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+# CONFIG_SERIAL_8250_FIRECRACKER is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+# CONFIG_SERIAL_AMBA_PL011 is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_I2C is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_PC302 is not set
+# CONFIG_SPI_PC302_GPIO is not set
+CONFIG_SPI_PC302_IPA=m
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_AT25 is not set
+CONFIG_SPI_DAC7512=m
+CONFIG_SPI_MAX6662=m
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_PC302_WATCHDOG=m
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_VIDEO_MEDIA is not set
+
+#
+# Multimedia drivers
+#
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_SOUND is not set
+# CONFIG_HID_SUPPORT is not set
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+CONFIG_DMADEVICES=y
+
+#
+# DMA Devices
+#
+CONFIG_PC302_DMA=m
+CONFIG_PC302_DMA_DEBUG_LEVEL=0
+CONFIG_DMA_ENGINE=y
+
+#
+# DMA Clients
+#
+# CONFIG_NET_DMA is not set
+# CONFIG_DMATEST is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_UIO is not set
+
+#
+# picoChip Drivers
+#
+CONFIG_PICOIF=m
+CONFIG_PICOIF_DMAPOOL=y
+CONFIG_PICOIF_PC302=y
+CONFIG_PICOIF_DEFAULT_DEBUG_LEVEL=1
+# CONFIG_PICOIF_DEBUG_TO_CONSOLE is not set
+CONFIG_PERFCOUNTERS=y
+CONFIG_ARMV6_PERFCOUNTER=m
+
+#
+# IP Access Drivers
+#
+CONFIG_IPACCESS=m
+CONFIG_IPACCESS_CPETD=m
+CONFIG_IPACCESS_DEBUG=m
+CONFIG_IPACCESS_LED=m
+CONFIG_IPACCESS_CRYPTO=m
+# CONFIG_IPACCESS_FPGA_DEBUG is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_CONFIGFS_FS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+CONFIG_JFFS2_SUMMARY=y
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_REGISTER_V4 is not set
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_NLS is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_KPROBES_SANITY_TEST is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_LKDTM is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+
+#
+# Tracers
+#
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_BOOT_TRACER is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_ARM_UNWIND=y
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_RVIDCC is not set
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+CONFIG_KEYS_DEBUG_PROC_KEYS=y
+CONFIG_SECURITY=y
+# CONFIG_SECURITYFS is not set
+CONFIG_SECURITY_NETWORK=y
+# CONFIG_SECURITY_NETWORK_XFRM is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_SECURITY_DEFAULT_MMAP_MIN_ADDR=0
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+CONFIG_CRYPTO_NULL=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+CONFIG_CRYPTO_TEST=m
+
+#
+# Authenticated Encryption with Associated Data
+#
+CONFIG_CRYPTO_CCM=y
+# CONFIG_CRYPTO_GCM is not set
+CONFIG_CRYPTO_SEQIV=y
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_CTR=y
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_KEYSTREAM=m
+CONFIG_IPA_KEYSTREAM=m
+CONFIG_CRYPTO_HW=y
+CONFIG_CRYPTO_DEV_PC302=m
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=y
+CONFIG_TEXTSEARCH_BM=y
+CONFIG_TEXTSEARCH_FSM=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
diff -Naur pico_2.6.28/arch/arm/configs/pc302_xa ipa_2.6.28/arch/arm/configs/pc302_xa
--- pico_2.6.28/arch/arm/configs/pc302_xa	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/arch/arm/configs/pc302_xa	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,1251 @@
+################################################################################
+# 
+# Copyright (c) 2009 ip.access Ltd.
+#
+#  This program is free software; you can redistribute  it and/or modify it
+#  under  the terms of  the GNU General  Public License as published by the
+#  Free Software Foundation;  either version 2 of the  License, or (at your
+#  option) any later version.
+#
+# 22 Apr 2009 Created by Simon D Hughes.
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.28
+# Wed Nov 18 13:25:38 2009
+#
+##############################################################################
+# Filename: 
+##############################################################################
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_OPROFILE_ARMV6=y
+CONFIG_OPROFILE_ARM11_CORE=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION="-picochip-3.2.4"
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=17
+# CONFIG_CGROUPS is not set
+# CONFIG_GROUP_SCHED is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+CONFIG_RELAY=y
+# CONFIG_NAMESPACES is not set
+# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_COMPAT_BRK=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+CONFIG_PROFILING=y
+# CONFIG_MARKERS is not set
+CONFIG_OPROFILE=m
+CONFIG_HAVE_OPROFILE=y
+CONFIG_KPROBES=y
+CONFIG_KRETPROBES=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_KMOD=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+CONFIG_CLASSIC_RCU=y
+
+#
+# IPAccess 3GAP Oyster Product Variant Options
+#
+# CONFIG_IPACCESS_IP202FF is not set
+# CONFIG_IPACCESS_IP202FF_686 is not set
+# CONFIG_IPACCESS_IP202FF_XC is not set
+# CONFIG_IPACCESS_IP202FF_XE is not set
+CONFIG_IPACCESS_IP302FF=y
+CONFIG_IPACCESS_IP302FF_XC=y
+# CONFIG_FREEZER is not set
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FIRECRACKER is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PNX4008 is not set
+CONFIG_ARCH_PC302=y
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_MSM is not set
+
+#
+# PC302 platform type
+#
+CONFIG_MACH_PC7302=y
+CONFIG_PC302_ASYNC_OPROF=y
+CONFIG_IP302FF_XC=y
+
+#
+# Boot options
+#
+
+#
+# Power management
+#
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_V6=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v6=y
+CONFIG_CPU_ABRT_EV6=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_V6=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V6=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_HAS_TLS_REG=y
+# CONFIG_OUTER_CACHE is not set
+# CONFIG_ARM_ERRATA_364296 is not set
+CONFIG_ARM_ERRATA_411920=y
+
+#
+# Bus support
+#
+CONFIG_ARM_AMBA=y
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_PREEMPT=y
+CONFIG_HZ=1000
+# CONFIG_ARM_ASM_UNIFIED is not set
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_UNEVICTABLE_LRU=y
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE="ip=172.17.13.247:172.17.1.131:172.17.0.1:255.255.0.0:picopc7302-248#:eth0 mem=128M console=ttyS0,115200 loglevel=8"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_XFRM_IPCOMP=y
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ASK_IP_FIB_HASH=y
+# CONFIG_IP_FIB_TRIE is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+# CONFIG_IP_ROUTE_VERBOSE is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+CONFIG_NET_IPIP=y
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+CONFIG_INET_IPCOMP=y
+CONFIG_INET_XFRM_TUNNEL=y
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_NETLABEL is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+
+#
+# Core Netfilter Configuration
+#
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CT_ACCT=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+# CONFIG_NF_CT_PROTO_DCCP is not set
+# CONFIG_NF_CT_PROTO_SCTP is not set
+# CONFIG_NF_CT_PROTO_UDPLITE is not set
+# CONFIG_NF_CONNTRACK_AMANDA is not set
+# CONFIG_NF_CONNTRACK_FTP is not set
+# CONFIG_NF_CONNTRACK_H323 is not set
+# CONFIG_NF_CONNTRACK_IRC is not set
+# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
+# CONFIG_NF_CONNTRACK_PPTP is not set
+# CONFIG_NF_CONNTRACK_SANE is not set
+# CONFIG_NF_CONNTRACK_SIP is not set
+# CONFIG_NF_CONNTRACK_TFTP is not set
+# CONFIG_NF_CT_NETLINK is not set
+# CONFIG_NETFILTER_TPROXY is not set
+CONFIG_NETFILTER_XTABLES=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+# CONFIG_NETFILTER_XT_TARGET_CONNMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_TARGET_RATEEST=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+CONFIG_NETFILTER_XT_MATCH_DSCP=y
+CONFIG_NETFILTER_XT_MATCH_ESP=y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+CONFIG_NETFILTER_XT_MATCH_OWNER=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_RATEEST=y
+CONFIG_NETFILTER_XT_MATCH_REALM=y
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_ADDRTYPE=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_IP_NF_TARGET_ULOG=y
+# CONFIG_NF_NAT is not set
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+# CONFIG_IP_NF_TARGET_ECN is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+# CONFIG_IP_NF_RAW is not set
+# CONFIG_IP_NF_SECURITY is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+# CONFIG_IP_DCCP is not set
+CONFIG_IP_SCTP=y
+# CONFIG_SCTP_DBG_MSG is not set
+# CONFIG_SCTP_DBG_OBJCNT is not set
+# CONFIG_SCTP_HMAC_NONE is not set
+# CONFIG_SCTP_HMAC_SHA1 is not set
+CONFIG_SCTP_HMAC_MD5=y
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+CONFIG_VLAN_8021Q=y
+# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+CONFIG_NET_CLS_ROUTE=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_TCPPROBE is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_PHONET is not set
+CONFIG_FIB_RULES=y
+# CONFIG_WIRELESS is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/mdev"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_GEOMETRY is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_OTP is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_PHYSMAP_START=0x40000000
+CONFIG_MTD_PHYSMAP_LEN=0x8000000
+CONFIG_MTD_PHYSMAP_BANKWIDTH=1
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_IMPA7 is not set
+# CONFIG_MTD_PLATRAM is not set
+# CONFIG_MTD_PICOHDP is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_M25PXX_USE_FAST_READ is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+# CONFIG_BLK_DEV is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+CONFIG_PC302_FRACN=m
+CONFIG_PC302_FUSEBLOCK=m
+CONFIG_PC302_GPIO=y
+# CONFIG_C2PORT is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=y
+# CONFIG_VETH is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+CONFIG_FIXED_PHY=y
+CONFIG_MDIO_BITBANG=y
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_PC302_EMAC=y
+# CONFIG_PC302_MICREL_VLAN_SWITCH is not set
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_ENC28J60 is not set
+# CONFIG_SMC911X is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_IWLWIFI_LEDS is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=32
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+# CONFIG_SERIAL_8250_FIRECRACKER is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+# CONFIG_SERIAL_AMBA_PL011 is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+CONFIG_TCG_TPM=y
+# CONFIG_TCG_NSC is not set
+# CONFIG_TCG_ATMEL is not set
+CONFIG_TCG_ATMEL_TWI=m
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_HELPER_AUTO is not set
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+CONFIG_I2C_GPIO=y
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_AT24 is not set
+CONFIG_SENSORS_AD7995=m
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+CONFIG_SENSORS_MAX6635=m
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_PC302 is not set
+# CONFIG_SPI_PC302_GPIO is not set
+CONFIG_SPI_PC302_IPA=m
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_AT25 is not set
+CONFIG_SPI_DAC7512=m
+CONFIG_SPI_MAX6662=m
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_PC302_WATCHDOG=m
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_VIDEO_MEDIA is not set
+
+#
+# Multimedia drivers
+#
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_SOUND is not set
+# CONFIG_HID_SUPPORT is not set
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+CONFIG_DMADEVICES=y
+
+#
+# DMA Devices
+#
+CONFIG_PC302_DMA=y
+CONFIG_PC302_DMA_DEBUG_LEVEL=0
+CONFIG_DMA_ENGINE=y
+
+#
+# DMA Clients
+#
+# CONFIG_NET_DMA is not set
+# CONFIG_DMATEST is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_UIO is not set
+
+#
+# picoChip Drivers
+#
+CONFIG_PICOIF=y
+CONFIG_PICOIF_DMAPOOL=y
+CONFIG_PICOIF_PC302=y
+CONFIG_PICOIF_DEFAULT_DEBUG_LEVEL=1
+# CONFIG_PICOIF_DEBUG_TO_CONSOLE is not set
+CONFIG_PERFCOUNTERS=y
+CONFIG_ARMV6_PERFCOUNTER=m
+
+#
+# IP Access Drivers
+#
+CONFIG_IPACCESS=m
+CONFIG_IPACCESS_CPETD=m
+CONFIG_IPACCESS_DEBUG=m
+CONFIG_IPACCESS_LED=m
+CONFIG_IPACCESS_CRYPTO=m
+# CONFIG_IPACCESS_FPGA_DEBUG is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_CONFIGFS_FS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+CONFIG_JFFS2_SUMMARY=y
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_REGISTER_V4 is not set
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_NLS is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_KPROBES_SANITY_TEST is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_LKDTM is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+
+#
+# Tracers
+#
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_PREEMPT_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_BOOT_TRACER is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_ARM_UNWIND=y
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_RVIDCC is not set
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+CONFIG_KEYS_DEBUG_PROC_KEYS=y
+CONFIG_SECURITY=y
+# CONFIG_SECURITYFS is not set
+CONFIG_SECURITY_NETWORK=y
+# CONFIG_SECURITY_NETWORK_XFRM is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_SECURITY_DEFAULT_MMAP_MIN_ADDR=0
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+CONFIG_CRYPTO_NULL=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+CONFIG_CRYPTO_TEST=m
+
+#
+# Authenticated Encryption with Associated Data
+#
+CONFIG_CRYPTO_CCM=y
+# CONFIG_CRYPTO_GCM is not set
+CONFIG_CRYPTO_SEQIV=y
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_CTR=y
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_LZO=y
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_KEYSTREAM=m
+CONFIG_IPA_KEYSTREAM=m
+CONFIG_CRYPTO_HW=y
+CONFIG_CRYPTO_DEV_PC302=m
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=y
+CONFIG_TEXTSEARCH_BM=y
+CONFIG_TEXTSEARCH_FSM=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
diff -Naur pico_2.6.28/arch/arm/include/asm/page.h ipa_2.6.28/arch/arm/include/asm/page.h
--- pico_2.6.28/arch/arm/include/asm/page.h	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/arch/arm/include/asm/page.h	2011-04-26 14:51:35.000000000 +0100
@@ -108,30 +108,37 @@
 #error Unknown user operations model
 #endif
 
+struct page;
+struct vm_area_struct;
+
 struct cpu_user_fns {
-	void (*cpu_clear_user_page)(void *p, unsigned long user);
-	void (*cpu_copy_user_page)(void *to, const void *from,
-				   unsigned long user);
+	void (*cpu_clear_user_highpage)(struct page *page, unsigned long vaddr);
+	void (*cpu_copy_user_highpage)(struct page *to, struct page *from,
+			unsigned long vaddr, struct vm_area_struct *vma);
 };
 
 #ifdef MULTI_USER
 extern struct cpu_user_fns cpu_user;
 
-#define __cpu_clear_user_page	cpu_user.cpu_clear_user_page
-#define __cpu_copy_user_page	cpu_user.cpu_copy_user_page
+#define __cpu_clear_user_highpage	cpu_user.cpu_clear_user_highpage
+#define __cpu_copy_user_highpage	cpu_user.cpu_copy_user_highpage
 
 #else
 
-#define __cpu_clear_user_page	__glue(_USER,_clear_user_page)
-#define __cpu_copy_user_page	__glue(_USER,_copy_user_page)
+#define __cpu_clear_user_highpage	__glue(_USER,_clear_user_highpage)
+#define __cpu_copy_user_highpage	__glue(_USER,_copy_user_highpage)
 
-extern void __cpu_clear_user_page(void *p, unsigned long user);
-extern void __cpu_copy_user_page(void *to, const void *from,
-				 unsigned long user);
+extern void __cpu_clear_user_highpage(struct page *page, unsigned long vaddr);
+extern void __cpu_copy_user_highpage(struct page *to, struct page *from,
+			unsigned long vaddr, struct vm_area_struct *vma);
 #endif
 
-#define clear_user_page(addr,vaddr,pg)	 __cpu_clear_user_page(addr, vaddr)
-#define copy_user_page(to,from,vaddr,pg) __cpu_copy_user_page(to, from, vaddr)
+#define clear_user_highpage(page,vaddr)		\
+	 __cpu_clear_user_highpage(page, vaddr)
+
+#define __HAVE_ARCH_COPY_USER_HIGHPAGE
+#define copy_user_highpage(to,from,vaddr,vma)	\
+	__cpu_copy_user_highpage(to, from, vaddr, vma)
 
 #define clear_page(page)	memzero((void *)(page), PAGE_SIZE)
 extern void copy_page(void *to, const void *from);
diff -Naur pico_2.6.28/arch/arm/Kconfig ipa_2.6.28/arch/arm/Kconfig
--- pico_2.6.28/arch/arm/Kconfig	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/arch/arm/Kconfig	2011-04-26 14:51:35.000000000 +0100
@@ -1,3 +1,20 @@
+################################################################################
+# 
+# Copyright (c) 2009 ip.access Ltd.
+#
+#  This program is free software; you can redistribute  it and/or modify it
+#  under  the terms of  the GNU General  Public License as published by the
+#  Free Software Foundation;  either version 2 of the  License, or (at your
+#  option) any later version.
+#
+# 22 Apr 2009 Created by Simon D Hughes.
+#
+# For a description of the syntax of this configuration file,
+# see Documentation/kbuild/kconfig-language.txt.
+#
+##############################################################################
+# Filename: 
+##############################################################################
 #
 # For a description of the syntax of this configuration file,
 # see Documentation/kbuild/kconfig-language.txt.
@@ -1431,6 +1448,8 @@
 
 source "drivers/picochip/Kconfig"
 
+source "drivers/ipa/Kconfig"
+
 source "drivers/perfcounters/Kconfig"
 
 endmenu
diff -Naur pico_2.6.28/arch/arm/mach-firecracker/firecracker_core.c ipa_2.6.28/arch/arm/mach-firecracker/firecracker_core.c
--- pico_2.6.28/arch/arm/mach-firecracker/firecracker_core.c	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/arch/arm/mach-firecracker/firecracker_core.c	2011-04-26 14:51:35.000000000 +0100
@@ -31,9 +31,22 @@
 #include <linux/sched.h>	/* just for sched_clock() - funny that */
 #include <linux/bug.h>
 
+#if defined(CONFIG_IPACCESS_FPGA_DEBUG)
+#include <mach/fpga_debug.h>
+#endif /* defined(CONFIG_IPACCESS_FPGA_DEBUG) */
+
 #include "core.h"
 
 
+#if defined(CONFIG_IPACCESS_FPGA_DEBUG)
+IPA_FPGA_DEBUG_0 ipaFpgaDebug0Ptr = NULL;
+IPA_FPGA_DEBUG_1 ipaFpgaDebug1Ptr = NULL;
+IPA_FPGA_DEBUG_2 ipaFpgaDebug2Ptr = NULL;
+IPA_FPGA_DEBUG_3 ipaFpgaDebug3Ptr = NULL;
+IPA_FPGA_DEBUG_4 ipaFpgaDebug4Ptr = NULL;
+IPA_HIRES_TIMER  ipaHiresTimerPtr = NULL;
+#endif /* defined(CONFIG_IPACCESS_FPGA_DEBUG) */
+
 /* Converts a physical address number into a pointer to the virtual location */
 #define _ioa(n)     __io(IO_ADDRESS(n))
 
@@ -159,7 +172,7 @@
 
 static struct platform_device mii_device = {
     .name       = "pc20x-mii",
-    .id         = -1,
+    .id         = 0,
 };
 
 
@@ -325,6 +338,16 @@
     .num_resources = ARRAY_SIZE( pc202gpio_resources ),
 };
 
+/*
+ * Added by MontaVista for platform support of the PicoArray Crypto for IPsec.
+ */
+#if defined(CONFIG_IPACCESS_CRYPTO) || defined(CONFIG_IPACCESS_CRYPTO_MODULE)
+static struct platform_device picoarray_ipsec_device = {
+    .name       = "pico-crypto-ipsec",
+    .id         = 0,
+};
+#endif
+
 void __init firecracker_init(void)
 {
     platform_device_register(&serial_device);
@@ -334,19 +357,32 @@
     platform_device_register(&dmac_device1);
     platform_device_register(&pc202gpio_device);
     platform_device_register(&pa0);
-
+    
 #ifdef CONFIG_FIRECRACKER_DMA_TEST
     platform_device_register(&dmac_test_device);
 #endif
+
+#if defined(CONFIG_IPACCESS_CRYPTO) || defined(CONFIG_IPACCESS_CRYPTO_MODULE)
+    platform_device_register(&picoarray_ipsec_device);
+#endif
 }
 
 /* TIMERS: */
 
 /* clock_tick_rate is the tick rate set at runtime. RT_LATCH is the derived timer reload
  * latch value.
+ * 
+ * PC202-PC205_ARM_Subsystem_Appendix_F-K_v1_3.pdf Section I.4 documents that the arm 
+ * timers generate an interrupt when the counter (having reached 0) is decremented 
+ * again. This operation automatically reloads the register with the TimerNLoadCount 
+ * value. This being the case, the TimerNLoadCount should be 1 less than RT_LATCH as 
+ * defined in the original 
+ *  <kernel_root> /arch/arm/mach-firecracker/firecracker_core.c.
+ * that is : #define RT_LATCH() ((clock_tick_rate + HZ/2) / HZ)
+ * This error has been corrected below (sh4 20070903)
  */
-static unsigned long clock_tick_rate = PC72052_I10_REVB_TIMER_FREQ;
-#define RT_LATCH() ((clock_tick_rate + HZ/2) / HZ)
+static const unsigned long clock_tick_rate = PC72052_I10_REVB_TIMER_FREQ;
+#define RT_LATCH() ( ((clock_tick_rate + HZ/2) / HZ) - 1)
 
 /* Use timer 0 for the linux tick */
 #define TICK_TIMER 0
@@ -358,8 +394,8 @@
 /* the <<1 gets rid of the cnt_32_to_63 top bit saving on a bic insn
  * in the sched_clock function
  */
-static unsigned long sched_clock_rtc_multiplier = 50<<1;
-static unsigned long sched_clock_rtc_divisor = 7<<1;
+static const unsigned long sched_clock_rtc_multiplier = 50<<1;
+static const unsigned long sched_clock_rtc_divisor = 7<<1;
 
 /*
  * This is the Firecracker sched_clock implementation.  
@@ -385,43 +421,77 @@
 }
 
 /*
+ * The system tick timer is critical since it is used to determine the clock
+ * frequency for NTP and for scheduling periodic RT tasks.  Unfortunately we
+ * could miss ticks if drivers disable interrupts for extended periods (e.g.,
+ * picoif and vprintk).  We'll use the free running RTC counter to detect when
+ * ticks were missed and we'll recover by calling timer_tick() multiple times.
+ * 
+ * When the timer first starts we'll record the current RTC count in the static
+ * variable startOfTick.  This is nominally the value of the RTC when the
+ * previous tick was raised.  When the tick handler is called we can use this
+ * to calculate how many tick intervals have elapsed and then increment the
+ * value of startOfTick by RTC_TICK_INCREMENT for each tick.  Initially, the
+ * delay in calling the handler will mean that startOfTick is actually a bit
+ * later than it should be.  As more interrupts arrive some may be slightly
+ * earlier than expected if they weren't delayed by as much.  We have to
+ * detect that and adjust the startOfTick to reflect the better information
+ * we now have about when the ticks are due.  As a sanity check we don't allow
+ * corrections if they are too big (>10%), if the total drift since start up
+ * gets too big (more than a tick) or if we've just processed multiple ticks.
+ * The last check is in case we detect multiple ticks and process them but
+ * still manage to get an interrupt for the last one.
+ *
+ * Operating separately from the startOfTick is refTimerTick.  This is used by
+ * the firecracker_gettimeoffset function to tell the timekeeping code how long
+ * it's been since the last tick.  This is incremented by RTC_TICK_INCREMENT for
+ * every tick.  It's not allowed to drift with the delay jitter, so the RTC count
+ * always provides an absolute time reference.  However, the reference is set so
+ * that it's nominally a couple of ticks in the past.  This is so that the value
+ * returned by firecracker_gettimeoffset is always positive, even if the working
+ * value of startOfTick does drift earlier than the initial snapshot.  To ensure
+ * this, we don't allow the startOfTick to drift closer than RTC_TICK_INCREMENT
+ * to refTimerTick.
+ *
+ */
+#undef DEBUG_TIMER_ADJUSTMENT
+
+/* How many RTC counts there are per ms tick interrupt */
+#define RTC_TICK_INCREMENT     ((PC72052_I10_REVB_TIMER_FREQ + HZ/2)/HZ)
+    
+/* How many counts we allow the tick to drift back in one go.
+ * Experiments showed that the initial delays at startup were fairly small
+ * and any adjustments needed were also small.  10% should be enough.
+ */
+#define MAX_TICK_ADJUSTMENT     (RTC_TICK_INCREMENT/10)
+
+/* Reference clock for firecracker_gettimeofffset.  Used to give sub tick
+ * resolution for the current time, based on the RTC counter.  The combination
+ * of this and the jiffies count should be locked to the CPU clock cycles.
+ */
+static u32 refTimerTick  = 0;
+
+/*
  * Returns number of microseconds since last clock interrupt.  Note that interrupts
  * will have been disabled by do_gettimeoffset().
  *
  */
 static unsigned long firecracker_gettimeoffset(void)
 {
-    u32 cur_ticks, last_ticks, status;
-
-    /*
-     * Get the current number of ticks since the reload.  
-     * Note that there is a race condition between us reading the timer and checking for
-     * an interrupt.  We get around this by ensuring that the counter has not reloaded
-     * between our two reads.
-     */
-    cur_ticks = RT_LATCH() - ioread32(
-            _ioa(PC20X_TIMERS_BASE + TIMER_N_CURRENT_VALUE_REG_OFFSET(TICK_TIMER)));
-    do {
-        last_ticks = cur_ticks;
-
-        status = ioread32(
-                _ioa(PC20X_TIMERS_BASE + TIMER_N_INTERRUPT_STATUS_REG_OFFSET(TICK_TIMER)));
-
-        cur_ticks = RT_LATCH() - ioread32(
-                _ioa(PC20X_TIMERS_BASE + TIMER_N_CURRENT_VALUE_REG_OFFSET(TICK_TIMER)));
-
-    } while (last_ticks > cur_ticks);
-
-    /* We should have the number of ticks since the last interrupt in cur_ticks.
-     * Adjust the value if a roll-over occurred while interrupts have been disabled.
-     * Return the resultant time since the last tick.
+    /* Convert from RTC counts to microseconds, i.e., divide by number of counts
+     * per microsecond.  Division is expensive and the divisor is a constant, so
+     * we can multiply by its reciprocal expressed as a 32.32 fixed point number.
+     * Since the RTC is runnning faster than 1MHz this will be less than 1.0 and
+     * we can discard the top 32 bits of the multiplier since they're 0.  The
+     * operation then reduces to 32*32 => 64 and keep only the top 32, which gcc
+     * optimises nicely.
      */
-    if (status)
-    {
-        cur_ticks += RT_LATCH();
-    }
+    static const u32 divisor    = (PC72052_I10_REVB_TIMER_FREQ + 500000) / 1000000;
+    static const u32 multiplier = ( ((1ULL << 32) + (divisor/2)) / divisor );
+
+    u32 cur_ticks = ipaHiresTimer() - refTimerTick;
 
-    return (cur_ticks / (clock_tick_rate / 1000000));
+    return ((unsigned long long)cur_ticks * multiplier) >> 32;
 }
 
 /*
@@ -429,10 +499,131 @@
  */
 static irqreturn_t firecracker_timer_interrupt(int irq, void *dev_id)
 {
+    static int       firstCall        = 1;
+
+    /* The RTC count corresponding to the last time round this function */
+    static u32       startOfTick      = 0;
+    
+    /* We have two choices.  We can clear the interrupt before reading the
+     * RTC.  In between, the RTC might have crossed another tick boundary
+     * and we might have another waiting interrupt.  We would process both
+     * ticks here, and on completion we'd get another, apparently spurious,
+     * interrupt right away.
+     *
+     * Alternatively, we can read the RTC and then clear the interrupt.  In
+     * that case the RTC might be read just before a second, overflow, interrupt
+     * is raised.  Both interrupts would be cleared and we would only process
+     * one of them.  It would be on the next interrupt that we detected that
+     * two ticks had actually passed.
+     *
+     * Neither is likely.  The first option should reduce the delays in
+     * handling ticks.  We have to ensure that such a case can't be used
+     * to adjust the startOfTick on a spurious interrupt.  We can do that
+     * by preventing adjustment for a certain number of ticks after we
+     * have processed a multi-tick interrupt.
+     */
+    static int       noAdjust         = 2;
+  
+    u32              now;
+
     // ...clear the interrupt
     ioread32(_ioa(PC20X_TIMERS_BASE + TIMER_N_EOI_REG_OFFSET(TICK_TIMER)));
 
-    timer_tick();
+    now = ipaHiresTimer();
+
+    if (firstCall)
+    {
+        /* First interrupt */
+        firstCall = 0;
+
+        startOfTick = now;
+        
+        /* A baseline for firecracker_gettimeoffset.  This is in the past to
+         * ensure that the value returned by that function will always be +ve,
+         * even after we allow some correction to the startOfTick for delays.
+         */
+        refTimerTick  = now - 2*RTC_TICK_INCREMENT;
+        
+        /* Process tick */
+        timer_tick();
+    }
+    else
+    {
+        /* How long since the previous tick? */
+        s32 interval = (s32)(now - startOfTick);
+        
+        if (interval < RTC_TICK_INCREMENT)
+        {
+            /* This tick is early.  How much earlier than expected? */
+            s32 earlierBy = RTC_TICK_INCREMENT - interval;
+            
+            /* If we were to adjust the startOfTick, how far ahead of
+             * refTickTimer would we be?  We always want to stay at least
+             * one tick ahead of the reference time.  (If we ever drifted
+             * anywhere close to that much then something would be
+             * seriously wrong.) */
+            s32 headRoom = (s32)(startOfTick - refTimerTick) - earlierBy;
+            
+            if (noAdjust)
+            {
+                /* Adjustment is currently disabled */
+#if defined (DEBUG_TIMER_ADJUSTMENT) && defined(CONFIG_IPACCESS_FPGA_DEBUG)
+                ipaFpgaDebug0("Ignore tick (too soon after multi)");
+#endif
+            }
+            else if (earlierBy > MAX_TICK_ADJUSTMENT)
+            {
+                /* Adjustment is more than we allow in a single correction */
+#if defined (DEBUG_TIMER_ADJUSTMENT) && defined(CONFIG_IPACCESS_FPGA_DEBUG)
+                ipaFpgaDebug1("Ignore tick (big adjust = %d)", earlierBy);
+#endif
+            }
+            else if (headRoom < RTC_TICK_INCREMENT)
+            {
+                /* Adjustment would mean we'd compensated by too much in total */
+#if defined (DEBUG_TIMER_ADJUSTMENT) && defined(CONFIG_IPACCESS_FPGA_DEBUG)
+                ipaFpgaDebug1("Ignore tick (drifted too far %d)", headRoom);
+#endif
+            }
+            else
+            {
+                /* This tick had less delay than previous ones.  Use this as
+                 * the new baseline for startOfTick and handle the tick. */
+#if defined (DEBUG_TIMER_ADJUSTMENT) && defined(CONFIG_IPACCESS_FPGA_DEBUG)
+                ipaFpgaDebug1("Adjust tick %d", earlierBy);
+#endif
+                startOfTick -= earlierBy;
+                interval     = RTC_TICK_INCREMENT;
+            }
+        }
+        
+        if (interval >= 2*RTC_TICK_INCREMENT)
+        {
+            /* We must have missed a tick interrupt.  We're playing
+             * catch up.  Prevent adjustments on the next few interrupts
+             * to be safe.
+             */
+#if defined (DEBUG_TIMER_ADJUSTMENT) && defined(CONFIG_IPACCESS_FPGA_DEBUG)
+            struct pt_regs* const regs = get_irq_regs();
+            ipaFpgaDebug2("Multi tick %d after instruction %p", interval, profile_pc(regs));
+#endif
+            noAdjust = 2;
+        }
+        else if (noAdjust)
+        {
+            noAdjust--;
+        }
+        
+        /* Handle all the ticks we've had since the last one */
+        while (interval >= RTC_TICK_INCREMENT)
+        {
+            startOfTick  += RTC_TICK_INCREMENT;
+            refTimerTick += RTC_TICK_INCREMENT;
+            interval     -= RTC_TICK_INCREMENT;
+            
+            timer_tick();
+        }
+    }
 
     return IRQ_HANDLED;
 }
@@ -448,10 +639,6 @@
  */
 static void __init firecracker_timer_init(void)
 {
-    clock_tick_rate = PC72052_I10_REVB_TIMER_FREQ;
-    sched_clock_rtc_multiplier = 50<<1;
-    sched_clock_rtc_divisor = 7<<1;
-
     /* Start with the timer disabled */
     iowrite32(0, 
             _ioa(PC20X_TIMERS_BASE + TIMER_N_CONTROL_REG_OFFSET(TICK_TIMER)));
@@ -563,3 +750,70 @@
                            
 }
 
+#if defined(CONFIG_IPACCESS_FPGA_DEBUG)
+void ipaFpgaDebug0(const char* text)
+{
+    if (ipaFpgaDebug0Ptr)
+    {
+        ipaFpgaDebug0Ptr(text);
+    }
+}
+
+EXPORT_SYMBOL(ipaFpgaDebug0Ptr);
+EXPORT_SYMBOL(ipaFpgaDebug0);
+
+void ipaFpgaDebug1(const char* text, int num1)
+{
+    if (ipaFpgaDebug1Ptr)
+    {
+        ipaFpgaDebug1Ptr(text, num1);
+    }
+}
+
+EXPORT_SYMBOL(ipaFpgaDebug1Ptr);
+EXPORT_SYMBOL(ipaFpgaDebug1);
+
+void ipaFpgaDebug2(const char* text, int num1, int num2)
+{
+    if (ipaFpgaDebug2Ptr)
+    {
+        ipaFpgaDebug2Ptr(text, num1, num2);
+    }
+}
+
+EXPORT_SYMBOL(ipaFpgaDebug2Ptr);
+EXPORT_SYMBOL(ipaFpgaDebug2);
+
+void ipaFpgaDebug3(const char* text, int num1, int num2, int num3)
+{
+    if (ipaFpgaDebug3Ptr)
+    {
+        ipaFpgaDebug3Ptr(text, num1, num2, num3);
+    }
+}
+
+EXPORT_SYMBOL(ipaFpgaDebug3Ptr);
+EXPORT_SYMBOL(ipaFpgaDebug3);
+
+void ipaFpgaDebug4(const char* text, int num1, int num2, int num3, int num4)
+{
+    if (ipaFpgaDebug4Ptr)
+    {
+        ipaFpgaDebug4Ptr(text, num1, num2, num3, num4);
+    }
+}
+
+EXPORT_SYMBOL(ipaFpgaDebug4Ptr);
+EXPORT_SYMBOL(ipaFpgaDebug4);
+
+unsigned long ipaHiresTimer(void)
+{
+    /* We were using cpetd's hires timer here, but the RTC is always running so
+     * we'll use that instead.
+     */
+    return ioread32(_ioa(PC20X_RTC_CLK_BASE + RTC_CURRECT_COUNTER_VALUE_REG_OFFSET));
+}
+
+EXPORT_SYMBOL(ipaHiresTimerPtr);
+EXPORT_SYMBOL(ipaHiresTimer);
+#endif /* defined(CONFIG_IPACCESS_FPGA_DEBUG) */
diff -Naur pico_2.6.28/arch/arm/mach-firecracker/firecracker_cpe.c ipa_2.6.28/arch/arm/mach-firecracker/firecracker_cpe.c
--- pico_2.6.28/arch/arm/mach-firecracker/firecracker_cpe.c	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/arch/arm/mach-firecracker/firecracker_cpe.c	2011-04-26 14:51:35.000000000 +0100
@@ -111,6 +111,7 @@
 	},
 };
 
+
 static int __init firecracker_cpe_init(void)
 {
     if ( machine_is_pc72052_i10_revb() || machine_is_pc7802() ) {
diff -Naur pico_2.6.28/arch/arm/mach-firecracker/firecracker_emac.c ipa_2.6.28/arch/arm/mach-firecracker/firecracker_emac.c
--- pico_2.6.28/arch/arm/mach-firecracker/firecracker_emac.c	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/arch/arm/mach-firecracker/firecracker_emac.c	2011-04-26 14:51:35.000000000 +0100
@@ -226,6 +226,8 @@
 
     struct napi_struct napi;
 
+    struct platform_device  *pdev;
+
     /* Used to indicate whether hw timestamping
        of received packets is required or not */
     unsigned int hw_timestamp_flag;
@@ -332,6 +334,9 @@
 /* The maximum packet size that can be handled by this driver */
 #define EMAC_MAX_PACKET_LENGTH      (EMAC_MAX_DMA_LENGTH * 2)
 
+/* Size of receive buffers */
+#define RX_BUFFER_SIZE		(2048)
+
 /* The length mask to be applied to the receive descriptors */
 #define EMAC_RX_LENGTH_MASK         (0xf)
 #define EMAC_RX_LENGTH_ALLIGN       (16)
@@ -979,6 +984,18 @@
 
         /* Check for time out */
         if (time_after(jiffies, timeout_jiffies)) {
+        
+            /* Check for the busy bit again before we leave.  If we were suspended
+               by a higher priority process just before checking the time, then
+               when control gets back here, the timer may have already expired, but
+               the busy bit might have been cleared in the meantime.  The longer we
+               are delayed, the more likely it is that we will return a timeout in
+               error.  That then causes a reset of the ethernet interface. */
+            addr_reg = EMAC_READ(EMAC_MAC_GMII_ADDR_REG_OFFSET);
+            if ((addr_reg & EMAC_GMII_BUSY) == 0) {
+                break;
+            }
+            
             DB((LVL_ERR, "Timed out waiting for MII\n"));
             res = -ETIMEDOUT;
             break;
@@ -1422,19 +1439,9 @@
 *emac_allocate_skb(struct net_device *dev)
 {
     struct sk_buff *skb;
-    unsigned int length;
-
-    /* The length of the skb needs to hold all data delivered by the
-     * hardware. This includes:
-     * MTU size, 2 bytes for IP alignment, ethernet header, VLAN header,
-     * checksum added by the hardware and extra bytes for DMA length
-     * alignment.
-     */
-    length = dev->mtu + 2 + ETH_HLEN + VLAN_ETH_HLEN +
-        EMAC_CHECKSUM_LENGTH + EMAC_RX_LENGTH_ALLIGN;
 
     /* Allocate the socket buffer. Always allocate maximum size */
-    skb = dev_alloc_skb(length);
+    skb = dev_alloc_skb(RX_BUFFER_SIZE);
     if (skb == NULL) {
         DB((LVL_WARNING, "emac: dev_alloc_skb failed\n"));
         goto out;
@@ -3051,7 +3058,7 @@
          */
         wake_up_interruptible(&ring->pending_waitq);
 
-        return 0;
+        return npackets;
     }
 
     DB((LVL_DEBUG, "Rx poll unfinished, pending count = %u\n",
@@ -3063,7 +3070,7 @@
     emac_hw_rx_resume(dev);
 
     /* We couldn't process everything. */
-    return 1;
+    return npackets;
 }
 
 /*
@@ -3268,6 +3275,58 @@
 }
 
 /*
+ * Support for ethtool PHY operations
+ */
+static int
+emac_get_settings(struct net_device *dev,
+                       struct ethtool_cmd *cmd)
+{
+    struct emac_priv *priv = netdev_priv(dev);
+    struct phy_device *phydev = priv->phydev;
+
+    if (!phydev)
+    {
+	return -ENODEV;
+    }
+
+    return phy_ethtool_gset(phydev, cmd);
+}
+
+static int
+emac_set_settings(struct net_device *dev,
+                       struct ethtool_cmd *cmd)
+{
+    struct emac_priv *priv = netdev_priv(dev);
+    struct phy_device *phydev = priv->phydev;
+
+    if (!phydev)
+    {
+        return -ENODEV;
+    }
+
+    return phy_ethtool_sset(phydev, cmd);
+}
+
+static void
+emac_get_drvinfo(struct net_device *dev,
+	              struct ethtool_drvinfo *info)
+{
+    struct emac_priv *priv = netdev_priv(dev);
+
+    strcpy(info->driver, priv->pdev->dev.driver->name);
+    strcpy(info->bus_info, priv->pdev->dev.bus_id);
+}
+
+static struct
+ethtool_ops emac_ethtool_ops =
+{
+    .get_settings   = emac_get_settings,
+    .set_settings   = emac_set_settings,
+    .get_drvinfo    = emac_get_drvinfo,
+    .get_link	    = ethtool_op_get_link,
+};
+
+/*
  * Ioctl commands
  */
 int
@@ -3621,8 +3680,11 @@
 
     netif_napi_add(dev, &priv->napi, emac_poll, napi_poll_weight);
 
+    dev->ethtool_ops = &emac_ethtool_ops;
+
     /* Get a pointer to the struct device for mapping operations */
     priv->device = &pdev->dev;
+    priv->pdev = pdev;
     priv->self = dev;
 
     /* Setup the thread lock for mirrored registers */
diff -Naur pico_2.6.28/arch/arm/mach-firecracker/include/mach/fpga_debug.h ipa_2.6.28/arch/arm/mach-firecracker/include/mach/fpga_debug.h
--- pico_2.6.28/arch/arm/mach-firecracker/include/mach/fpga_debug.h	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/arch/arm/mach-firecracker/include/mach/fpga_debug.h	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,34 @@
+/* linux/include/asm-arm/arch-firecracker/fpga_debug.h
+ *
+ * Copyright (c) 2006 ip.access Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_FPGA_DEBUG_H
+#define __ASM_ARCH_FPGA_DEBUG_H __FILE__
+
+typedef void          (* IPA_FPGA_DEBUG_0) (const char* text);
+typedef void          (* IPA_FPGA_DEBUG_1) (const char* text, int num1);
+typedef void          (* IPA_FPGA_DEBUG_2) (const char* text, int num1, int num2);
+typedef void          (* IPA_FPGA_DEBUG_3) (const char* text, int num1, int num2, int num3);
+typedef void          (* IPA_FPGA_DEBUG_4) (const char* text, int num1, int num2, int num3, int num4);
+typedef unsigned long (* IPA_HIRES_TIMER)  (void);
+
+extern IPA_FPGA_DEBUG_0 ipaFpgaDebug0Ptr;
+extern IPA_FPGA_DEBUG_1 ipaFpgaDebug1Ptr;
+extern IPA_FPGA_DEBUG_2 ipaFpgaDebug2Ptr;
+extern IPA_FPGA_DEBUG_3 ipaFpgaDebug3Ptr;
+extern IPA_FPGA_DEBUG_4 ipaFpgaDebug4Ptr;
+extern IPA_HIRES_TIMER  ipaHiresTimerPtr;
+
+void           ipaFpgaDebug0(const char* text);
+void           ipaFpgaDebug1(const char* text, int num1);
+void           ipaFpgaDebug2(const char* text, int num1, int num2);
+void           ipaFpgaDebug3(const char* text, int num1, int num2, int num3);
+void           ipaFpgaDebug4(const char* text, int num1, int num2, int num3, int num4);
+unsigned long  ipaHiresTimer(void);
+
+#endif /* __ASM_ARCH_FPGA_DEBUG_H */
diff -Naur pico_2.6.28/arch/arm/mach-firecracker/include/mach/gpio_assignment.h ipa_2.6.28/arch/arm/mach-firecracker/include/mach/gpio_assignment.h
--- pico_2.6.28/arch/arm/mach-firecracker/include/mach/gpio_assignment.h	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/arch/arm/mach-firecracker/include/mach/gpio_assignment.h	2011-04-26 14:51:35.000000000 +0100
@@ -23,8 +23,9 @@
 #define ARM_GPIO_SPI_CS0    GPIO(3)
 #define ARM_GPIO_SPI_CS1    GPIO(4)
 
-/* SVB GPIOs */
-#define ARM_GPIO_CPU_LED    GPIO(6)
+/* IP202FF GPIOs */
+#define ARM_GPIO_HARD_RESET GPIO(1)
+#define ARM_GPIO_CPU_LED    GPIO(5)
 
 
 #endif /* __ASM_ARCH_GPIO_ASSIGNMENTS_H */
diff -Naur pico_2.6.28/arch/arm/mach-firecracker/include/mach/platform.h ipa_2.6.28/arch/arm/mach-firecracker/include/mach/platform.h
--- pico_2.6.28/arch/arm/mach-firecracker/include/mach/platform.h	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/arch/arm/mach-firecracker/include/mach/platform.h	2011-04-26 14:51:35.000000000 +0100
@@ -28,7 +28,12 @@
 /* Flash size and position */
 #define FIRECRACKER_FLASH_BASE          0x20000000
 #define FIRECRACKER_FLASH_SIZE          SZ_128M
+
+#if defined(CONFIG_IP202FF_XC)
+#define FIRECRACKER_FLASH_WIDTH         2
+#else
 #define FIRECRACKER_FLASH_WIDTH         4
+#endif
 
 /* SDRAM size and position - the ram in the firecracker is split into 4 banks.
  * 64M spread over 4 banks, starting at zero with 64M between each bank.
@@ -39,7 +44,13 @@
  */
 #define FIRECRACKER_RAM_START           0x00000000
 #define FIRECRACKER_RAM_SIZE            SZ_64M      /* Default */
+
+#if defined(CONFIG_IP202FF_XC)
+#define FIRECRACKER_RAM_BANKS           2
+#else
 #define FIRECRACKER_RAM_BANKS           4
+#endif
+
 #define FIRECRACKER_RAM_BANK_STRIDE     SZ_64M
 
 /* The clock frequency for the UARTs */
diff -Naur pico_2.6.28/arch/arm/mach-firecracker/include/mach/spi-gpio.h ipa_2.6.28/arch/arm/mach-firecracker/include/mach/spi-gpio.h
--- pico_2.6.28/arch/arm/mach-firecracker/include/mach/spi-gpio.h	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/arch/arm/mach-firecracker/include/mach/spi-gpio.h	2011-04-26 14:51:35.000000000 +0100
@@ -31,5 +31,15 @@
     struct spi_board_info *board_info;
 };
 
+struct pc302_spi_info {
+    u8 cs0_active;
+    u8 cs1_active;
+    u8 cs2_active;
+    u8 cs3_active;
+	
+    unsigned long board_size;
+    struct spi_board_info *board_info;
+};
+
 
 #endif /* __ASM_ARCH_SPIGPIO_H */
diff -Naur pico_2.6.28/arch/arm/mach-firecracker/include/mach/uncompress.h ipa_2.6.28/arch/arm/mach-firecracker/include/mach/uncompress.h
--- pico_2.6.28/arch/arm/mach-firecracker/include/mach/uncompress.h	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/arch/arm/mach-firecracker/include/mach/uncompress.h	2011-04-26 14:51:35.000000000 +0100
@@ -20,20 +20,11 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include <mach/hardware.h>
-#include <linux/serial_reg.h>
-
 /*
- * This does not append a newline
+ * These are stubs for AP Hardening
  */
 static inline void putc(int c)
 {
-	int shift = 2;
-	volatile u8 * uart = (volatile u8 *)(PC20X_UART1_BASE);
-
-	while (!(uart[UART_LSR << shift] & UART_LSR_THRE))
-		barrier();
-	uart[UART_TX << shift] = c;
 }
 
 static inline void flush(void)
diff -Naur pico_2.6.28/arch/arm/mach-firecracker/Kconfig ipa_2.6.28/arch/arm/mach-firecracker/Kconfig
--- pico_2.6.28/arch/arm/mach-firecracker/Kconfig	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/arch/arm/mach-firecracker/Kconfig	2011-04-26 14:51:35.000000000 +0100
@@ -1,3 +1,16 @@
+################################################################################
+# 
+# Copyright (c) 2009 ip.access Ltd.
+#
+#  This program is free software; you can redistribute  it and/or modify it
+#  under  the terms of  the GNU General  Public License as published by the
+#  Free Software Foundation;  either version 2 of the  License, or (at your
+#  option) any later version.
+#
+# 22 Apr 2009 Created by Simon D Hughes.
+##############################################################################
+# Filename: 
+##############################################################################
 # $picoChipHeaderSubst$
 
 menu "Firecracker platform type"
@@ -13,6 +26,11 @@
 	help
 	  Include support for the picoChip PC7802 Platform.
 
+config IP202FF_XC
+	bool "Support IPA changes to XC"
+	help
+	  Include support for custom changes to the IPA CPE XC Board based on Firecracker REVB.
+
 config FIRECRACKER_DMA_TEST
 	bool "Firecracker DMA driver test module (dma_test)"
 	help
@@ -34,4 +52,12 @@
 	  firecracker EMAC driver. A value of zero builds a driver without
 	  debug code.
 
+config FIRECRACKER_ASYNC_OPROF
+    bool "Support async oprofile sampling (Uses Timer 2)"
+	help
+	  This controls whether to use a separate hardware timer for oprofile
+	  sampling rather than the system tick timer.  If this is selected then
+	  the oprofile sample rate will eventually gather samples from a range
+	  of points within the system tick.
+
 endmenu
diff -Naur pico_2.6.28/arch/arm/mach-pc302/include/mach/spi-gpio.h ipa_2.6.28/arch/arm/mach-pc302/include/mach/spi-gpio.h
--- pico_2.6.28/arch/arm/mach-pc302/include/mach/spi-gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/arch/arm/mach-pc302/include/mach/spi-gpio.h	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,33 @@
+/* linux/include/asm-arm/arch-pc302/spi-gpio.h
+ *
+ * BSP Version: 3.1.2, RevisionID: c296f5c, Date: 20090731 10:20:02
+ *
+ * Taken from linux/include/asm-arm/arch-firecracker/spi.h
+ *
+ * Copyright (c) 2006 picoChip Designs Ltd.
+ *
+ * Firecracker - SPI Controller platform_device info
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_SPIGPIO_H
+#define __ASM_ARCH_SPIGPIO_H __FILE__
+
+#include <linux/spi/spi.h>
+
+struct pc302_spi_info {
+
+    u8 cs0_active;
+    u8 cs1_active;
+    u8 cs2_active;
+    u8 cs3_active;
+	
+    unsigned long board_size;
+    struct spi_board_info *board_info;
+};
+
+
+#endif /* __ASM_ARCH_SPIGPIO_H */
diff -Naur pico_2.6.28/arch/arm/mach-pc302/include/mach/uncompress.h ipa_2.6.28/arch/arm/mach-pc302/include/mach/uncompress.h
--- pico_2.6.28/arch/arm/mach-pc302/include/mach/uncompress.h	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/arch/arm/mach-pc302/include/mach/uncompress.h	2011-04-26 14:51:35.000000000 +0100
@@ -18,43 +18,19 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include <mach/hardware.h>
-#include <mach/pc302/uart.h>
-#include <linux/serial_reg.h>
-
 /*
- * This does not append a newline
+ * These are stubs for AP Hardening
  */
 static inline void putc(int c)
 {
-	volatile u32 * uart = (volatile u32 *)(PC302_UART1_BASE);
-
-	while (!(uart[UART_LSR] & UART_LSR_THRE))
-		barrier();
-	uart[UART_TX] = c & 0xFF;
 }
 
 static inline void flush(void)
 {
 }
 
-static inline void arch_decomp_setup(void)
-{
-        volatile u32 *uart = (volatile u32 *)(PC302_UART1_BASE);
-        /* Reset and enable the FIFO's. */
-        uart[UART_FCR] = 0x1;
-        /* Wait for the FIFO's to be enabled. */
-        while (!(uart[UART_FCR] & 0xc0))
-            continue;
-        /* Enable divisor access, set length to 8 bits. */
-        uart[UART_LCR] = 0x83;
-        /* Set for 115200 baud. */
-        uart[UART_DLL] = 0x2;
-        uart[UART_DLM] = 0x0;
-        uart[UART_LCR] = 0x3;
-}
-
 /*
  * nothing to do
  */
+#define arch_decomp_setup()
 #define arch_decomp_wdog()
diff -Naur pico_2.6.28/arch/arm/mach-pc302/Kconfig ipa_2.6.28/arch/arm/mach-pc302/Kconfig
--- pico_2.6.28/arch/arm/mach-pc302/Kconfig	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/arch/arm/mach-pc302/Kconfig	2011-04-26 14:51:35.000000000 +0100
@@ -1,3 +1,16 @@
+################################################################################
+# 
+# Copyright (c) 2009 ip.access Ltd.
+#
+#  This program is free software; you can redistribute  it and/or modify it
+#  under  the terms of  the GNU General  Public License as published by the
+#  Free Software Foundation;  either version 2 of the  License, or (at your
+#  option) any later version.
+#
+# 22 Apr 2009 Created by Simon D Hughes.
+##############################################################################
+# Filename: 
+##############################################################################
 # $picoChipHeaderSubst$
 
 menu "PC302 platform type"
@@ -8,4 +21,17 @@
 	help
           Include support for the picoChip PC7302 platform.
           
+config IP302FF_XC
+	bool "Support IPA changes to XC"
+	help
+          Include support for custom changes to the IPA CPE XC Board based on PC7302.
+
+config PC302_ASYNC_OPROF
+	bool "Support async oprofile sampling (Uses Timer 2)"
+	help
+	  This controls whether to use a separate hardware timer for oprofile
+	  sampling rather than the system tick timer.  If this is selected then
+	  the oprofile sample rate will eventually gather samples from a range
+	  of points within the system tick.
+
 endmenu
diff -Naur pico_2.6.28/arch/arm/mach-pc302/pc302_core.c ipa_2.6.28/arch/arm/mach-pc302/pc302_core.c
--- pico_2.6.28/arch/arm/mach-pc302/pc302_core.c	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/arch/arm/mach-pc302/pc302_core.c	2011-04-26 14:51:35.000000000 +0100
@@ -448,6 +448,7 @@
     .num_resources  = ARRAY_SIZE( l2_resources ),
 };
 
+#if defined(CONFIG_SPI_PC302) || defined(CONFIG_SPI_PC302_MODULE)
 /* SPI Master */
 static struct resource spi_resources[] = {
     {
@@ -466,6 +467,7 @@
     .resource       = spi_resources,
     .num_resources  = ARRAY_SIZE( spi_resources ),
 };
+#endif
 
 /* AXI2CFG System Configuration Register */
 static void __init
@@ -506,7 +508,9 @@
     platform_device_register(&pa0);
     platform_device_register(&ipsec_device);
     platform_device_register(&l2_device);
+#if defined(CONFIG_SPI_PC302) || defined(CONFIG_SPI_PC302_MODULE)
     platform_device_register(&spi_device);
+#endif
 
     map_syscfg();
     pc302_axi_bus_error_init();
@@ -517,7 +521,7 @@
 /* clock_tick_rate is the tick rate set at runtime. RT_LATCH is the derived
  * timer reload latch value. */
 static unsigned long clock_tick_rate = PC302_TIMER_FREQ;
-#define RT_LATCH() ((clock_tick_rate + HZ/2) / HZ)
+#define RT_LATCH() (((clock_tick_rate + HZ/2) / HZ) - 1)
 
 /* Use timer 0 for the linux tick */
 #define TICK_TIMER 0
diff -Naur pico_2.6.28/arch/arm/mach-pc302/pc302_cpe.c ipa_2.6.28/arch/arm/mach-pc302/pc302_cpe.c
--- pico_2.6.28/arch/arm/mach-pc302/pc302_cpe.c	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/arch/arm/mach-pc302/pc302_cpe.c	2011-04-26 14:51:35.000000000 +0100
@@ -18,10 +18,20 @@
 #include <linux/platform_device.h>
 #include <linux/sysdev.h>
 #include <linux/amba/bus.h>
+
+#ifndef CONFIG_IPACCESS_IP302FF
 #include <linux/picochip/fpga_cpe20x.h>
 #include <linux/mtd/physmap.h>
 #include <linux/spi/flash.h>
 #include <linux/spi/spi.h>
+#endif
+
+#ifdef CONFIG_IPACCESS_IP302FF
+#include <linux/i2c.h>
+#include <linux/i2c-gpio.h>
+#include <linux/gpio.h>
+#include <mach/spi-gpio.h>
+#endif
 
 #include <mach/hardware.h>
 #include <asm/io.h>
@@ -32,6 +42,115 @@
 
 #include "core.h"
 
+#if defined(CONFIG_IPACCESS_IP302FF) && (defined(CONFIG_I2C_GPIO) || defined(CONFIG_I2C_GPIO_MODULE))
+
+/* i2c */
+static struct i2c_gpio_platform_data pc302_i2c_bus_data = {
+	.sda_pin = PC302_GPIO_PIN_ARM_2,
+	.scl_pin = PC302_GPIO_PIN_ARM_0,
+	.udelay  = 2,  /* Between 100kHz and 400kHz, nominally 250kHz */
+	.timeout = 100,
+};
+
+static struct platform_device pc302_i2c_bus_device = {
+	.name		= "i2c-gpio",
+	.id		= 0,
+	.dev = {
+		.platform_data = &pc302_i2c_bus_data,
+	}
+};
+
+static struct i2c_board_info __initdata pc302_i2c_devices[] = {
+	{
+		I2C_BOARD_INFO("max6635",   0x4B),
+	},
+	{
+		I2C_BOARD_INFO("atmel_twi", 0x29),
+	},
+	{
+		I2C_BOARD_INFO("ad7995",    0x28),
+	},
+	{
+		I2C_BOARD_INFO("micrel",    0x5F),
+	},
+};
+
+#endif /* CONFIG_IPACCESS_IP302FF && (CONFIG_I2C_GPIO || CONFIG_I2C_GPIO_MODULE) */
+
+
+#if defined(CONFIG_IPACCESS_IP302FF) && (defined(CONFIG_SPI_PC302_IPA) || defined(CONFIG_SPI_PC302_IPA_MODULE))
+
+/* SPI:
+*/
+    
+/* According to internet, the Synopsys device will deselect the chip select between words
+ * in SPI modes 0 and 2, so we have to use modes 3 and 1 respectively instead.
+ */
+static struct spi_board_info ip302ff_spi_board_info[] = {
+    [0] = { /* Thermal Sensor */
+        .modalias       = "max6662",
+        .bus_num        = 0,
+        .chip_select    = 3,
+        .max_speed_hz   = 10000, /* 10kHz */
+        .mode           = SPI_3WIRE | SPI_MODE_3,  /* Idle clock is high.  Latch on rising edge (second edge) */
+        .platform_data  = NULL,
+    },
+    [1] = { /* Reference Clock Control DAC */
+        .modalias       = "dac7512",
+        .bus_num        = 0,
+        .chip_select    = 2,
+        .max_speed_hz   = 10000, /* 10kHz (not 20MHz, we'd get only 80 CPU cycles between writes) */
+        .mode           = SPI_MODE_1,  /* Idle clock is low.  Latch on falling edge (second edge) */
+        .platform_data  = NULL,
+    },
+};
+
+
+static void
+pc302spi_platform_release( struct device *dev )
+{
+    /* This function is intentionally left blank. */
+}
+
+static struct resource pc302spi_resources[] = {
+    {
+        .start = PC302_SSI_BASE,
+        .end   = PC302_SSI_BASE + 0xffff,
+        .flags = IORESOURCE_MEM,
+    },
+    {
+        .start = IRQ_SSI,
+        .end   = IRQ_SSI,
+        .flags = IORESOURCE_IRQ,
+    },
+};
+
+static struct pc302_spi_info pc302spi_platform_data = {
+    .cs0_active     = 0,  /* EBI: NOR Flash */
+    .cs1_active     = 0,  /* EBI: Debug interface */
+    .cs2_active     = 1,  /* SPI: Reference Clock Control DAC */
+    .cs3_active     = 1,  /* SPI: Thermal Sensor */
+    .board_size     = ARRAY_SIZE(ip302ff_spi_board_info),
+    .board_info     = ip302ff_spi_board_info,
+};
+
+
+static struct platform_device pc302spi_device = {
+    .name = "pc302-spi",
+    .id = 0,
+    .dev = {
+        .coherent_dma_mask = 0xffffffff,
+        .release = pc302spi_platform_release,
+        .platform_data = &pc302spi_platform_data,
+    },
+    .num_resources = ARRAY_SIZE( pc302spi_resources ),
+    .resource = pc302spi_resources,
+};
+
+#endif /* CONFIG_IPACCESS_IP302FF && (CONFIG_SPI_PC302_IPA || CONFIG_SPI_PC302_IPA_MODULE) */
+
+#if defined(CONFIG_SPI_PC302) || defined(CONFIG_SPI_PC302_MODULE)
+
 /* PC7302 platforms have had a variety of different SPI Flash devices fitted.
  *
  * Spansion S25FL128P (128 Mbit) devices
@@ -73,10 +192,24 @@
     }
 };
 
+#endif /* defined(CONFIG_SPI_PC302) || defined(CONFIG_SPI_PC302_MODULE) */
+
 static int __init pc7302_init(void)
 {
+#if defined(CONFIG_SPI_PC302) || defined(CONFIG_SPI_PC302_MODULE)
     spi_register_board_info(pc7302_spi_board_info,
                             ARRAY_SIZE(pc7302_spi_board_info));
+#endif
+
+#if defined(CONFIG_IPACCESS_IP302FF) && (defined(CONFIG_SPI_PC302_IPA) || defined(CONFIG_SPI_PC302_IPA_MODULE))
+    platform_device_register(&pc302spi_device);
+#endif
+    
+#if defined(CONFIG_IPACCESS_IP302FF) && (defined(CONFIG_I2C_GPIO) || defined(CONFIG_I2C_GPIO_MODULE))
+    platform_device_register(&pc302_i2c_bus_device);
+    i2c_register_board_info(0, pc302_i2c_devices, ARRAY_SIZE(pc302_i2c_devices));
+#endif
+    
     return 0;
 }
 arch_initcall(pc7302_init);
diff -Naur pico_2.6.28/arch/arm/mm/copypage-feroceon.c ipa_2.6.28/arch/arm/mm/copypage-feroceon.c
--- pico_2.6.28/arch/arm/mm/copypage-feroceon.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/arch/arm/mm/copypage-feroceon.c	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,112 @@
+/*
+ *  linux/arch/arm/mm/copypage-feroceon.S
+ *
+ *  Copyright (C) 2008 Marvell Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This handles copy_user_highpage and clear_user_page on Feroceon
+ * more optimally than the generic implementations.
+ */
+#include <linux/init.h>
+#include <linux/highmem.h>
+
+static void __attribute__((naked))
+feroceon_copy_user_page(void *kto, const void *kfrom)
+{
+	asm("\
+	stmfd	sp!, {r4-r9, lr}		\n\
+	mov	ip, %0				\n\
+1:	mov	lr, r1				\n\
+	ldmia	r1!, {r2 - r9}			\n\
+	pld	[lr, #32]			\n\
+	pld	[lr, #64]			\n\
+	pld	[lr, #96]			\n\
+	pld	[lr, #128]			\n\
+	pld	[lr, #160]			\n\
+	pld	[lr, #192]			\n\
+	pld	[lr, #224]			\n\
+	stmia	r0, {r2 - r9}			\n\
+	ldmia	r1!, {r2 - r9}			\n\
+	mcr	p15, 0, r0, c7, c14, 1		@ clean and invalidate D line\n\
+	add	r0, r0, #32			\n\
+	stmia	r0, {r2 - r9}			\n\
+	ldmia	r1!, {r2 - r9}			\n\
+	mcr	p15, 0, r0, c7, c14, 1		@ clean and invalidate D line\n\
+	add	r0, r0, #32			\n\
+	stmia	r0, {r2 - r9}			\n\
+	ldmia	r1!, {r2 - r9}			\n\
+	mcr	p15, 0, r0, c7, c14, 1		@ clean and invalidate D line\n\
+	add	r0, r0, #32			\n\
+	stmia	r0, {r2 - r9}			\n\
+	ldmia	r1!, {r2 - r9}			\n\
+	mcr	p15, 0, r0, c7, c14, 1		@ clean and invalidate D line\n\
+	add	r0, r0, #32			\n\
+	stmia	r0, {r2 - r9}			\n\
+	ldmia	r1!, {r2 - r9}			\n\
+	mcr	p15, 0, r0, c7, c14, 1		@ clean and invalidate D line\n\
+	add	r0, r0, #32			\n\
+	stmia	r0, {r2 - r9}			\n\
+	ldmia	r1!, {r2 - r9}			\n\
+	mcr	p15, 0, r0, c7, c14, 1		@ clean and invalidate D line\n\
+	add	r0, r0, #32			\n\
+	stmia	r0, {r2 - r9}			\n\
+	ldmia	r1!, {r2 - r9}			\n\
+	mcr	p15, 0, r0, c7, c14, 1		@ clean and invalidate D line\n\
+	add	r0, r0, #32			\n\
+	stmia	r0, {r2 - r9}			\n\
+	subs	ip, ip, #(32 * 8)		\n\
+	mcr	p15, 0, r0, c7, c14, 1		@ clean and invalidate D line\n\
+	add	r0, r0, #32			\n\
+	bne	1b				\n\
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB\n\
+	ldmfd	sp!, {r4-r9, pc}"
+	:
+	: "I" (PAGE_SIZE));
+}
+
+void feroceon_copy_user_highpage(struct page *to, struct page *from,
+	unsigned long vaddr, struct vm_area_struct *vma)
+{
+	void *kto, *kfrom;
+
+	kto = kmap_atomic(to, KM_USER0);
+	kfrom = kmap_atomic(from, KM_USER1);
+	flush_cache_page(vma, vaddr, page_to_pfn(from));
+	feroceon_copy_user_page(kto, kfrom);
+	kunmap_atomic(kfrom, KM_USER1);
+	kunmap_atomic(kto, KM_USER0);
+}
+
+void feroceon_clear_user_highpage(struct page *page, unsigned long vaddr)
+{
+	void *ptr, *kaddr = kmap_atomic(page, KM_USER0);
+	asm volatile ("\
+	mov	r1, %2				\n\
+	mov	r2, #0				\n\
+	mov	r3, #0				\n\
+	mov	r4, #0				\n\
+	mov	r5, #0				\n\
+	mov	r6, #0				\n\
+	mov	r7, #0				\n\
+	mov	ip, #0				\n\
+	mov	lr, #0				\n\
+1:	stmia	%0, {r2-r7, ip, lr}		\n\
+	subs	r1, r1, #1			\n\
+	mcr	p15, 0, %0, c7, c14, 1		@ clean and invalidate D line\n\
+	add	%0, %0, #32			\n\
+	bne	1b				\n\
+	mcr	p15, 0, r1, c7, c10, 4		@ drain WB"
+	: "=r" (ptr)
+	: "0" (kaddr), "I" (PAGE_SIZE / 32)
+	: "r1", "r2", "r3", "r4", "r5", "r6", "r7", "ip", "lr");
+	kunmap_atomic(kaddr, KM_USER0);
+}
+
+struct cpu_user_fns feroceon_user_fns __initdata = {
+	.cpu_clear_user_highpage = feroceon_clear_user_highpage,
+	.cpu_copy_user_highpage	= feroceon_copy_user_highpage,
+};
+
diff -Naur pico_2.6.28/arch/arm/mm/copypage-feroceon.S ipa_2.6.28/arch/arm/mm/copypage-feroceon.S
--- pico_2.6.28/arch/arm/mm/copypage-feroceon.S	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/arch/arm/mm/copypage-feroceon.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,95 +0,0 @@
-/*
- *  linux/arch/arm/lib/copypage-feroceon.S
- *
- *  Copyright (C) 2008 Marvell Semiconductors
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This handles copy_user_page and clear_user_page on Feroceon
- * more optimally than the generic implementations.
- */
-#include <linux/linkage.h>
-#include <linux/init.h>
-#include <asm/asm-offsets.h>
-
-	.text
-	.align	5
-
-ENTRY(feroceon_copy_user_page)
-	stmfd	sp!, {r4-r9, lr}
-	mov	ip, #PAGE_SZ
-1:	mov	lr, r1
-	ldmia	r1!, {r2 - r9}
-	pld	[lr, #32]
-	pld	[lr, #64]
-	pld	[lr, #96]
-	pld	[lr, #128]
-	pld	[lr, #160]
-	pld	[lr, #192]
-	pld	[lr, #224]
-	stmia	r0, {r2 - r9}
-	ldmia	r1!, {r2 - r9}
-	mcr	p15, 0, r0, c7, c14, 1		@ clean and invalidate D line
-	add	r0, r0, #32
-	stmia	r0, {r2 - r9}
-	ldmia	r1!, {r2 - r9}
-	mcr	p15, 0, r0, c7, c14, 1		@ clean and invalidate D line
-	add	r0, r0, #32
-	stmia	r0, {r2 - r9}
-	ldmia	r1!, {r2 - r9}
-	mcr	p15, 0, r0, c7, c14, 1		@ clean and invalidate D line
-	add	r0, r0, #32
-	stmia	r0, {r2 - r9}
-	ldmia	r1!, {r2 - r9}
-	mcr	p15, 0, r0, c7, c14, 1		@ clean and invalidate D line
-	add	r0, r0, #32
-	stmia	r0, {r2 - r9}
-	ldmia	r1!, {r2 - r9}
-	mcr	p15, 0, r0, c7, c14, 1		@ clean and invalidate D line
-	add	r0, r0, #32
-	stmia	r0, {r2 - r9}
-	ldmia	r1!, {r2 - r9}
-	mcr	p15, 0, r0, c7, c14, 1		@ clean and invalidate D line
-	add	r0, r0, #32
-	stmia	r0, {r2 - r9}
-	ldmia	r1!, {r2 - r9}
-	mcr	p15, 0, r0, c7, c14, 1		@ clean and invalidate D line
-	add	r0, r0, #32
-	stmia	r0, {r2 - r9}
-	subs	ip, ip, #(32 * 8)
-	mcr	p15, 0, r0, c7, c14, 1		@ clean and invalidate D line
-	add	r0, r0, #32
-	bne	1b
-	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
-	ldmfd	sp!, {r4-r9, pc}
-
-	.align	5
-
-ENTRY(feroceon_clear_user_page)
-	stmfd	sp!, {r4-r7, lr}
-	mov	r1, #PAGE_SZ/32
-	mov	r2, #0
-	mov	r3, #0
-	mov	r4, #0
-	mov	r5, #0
-	mov	r6, #0
-	mov	r7, #0
-	mov	ip, #0
-	mov	lr, #0
-1:	stmia	r0, {r2-r7, ip, lr}
-	subs	r1, r1, #1
-	mcr	p15, 0, r0, c7, c14, 1		@ clean and invalidate D line
-	add	r0, r0, #32
-	bne	1b
-	mcr	p15, 0, r1, c7, c10, 4		@ drain WB
-	ldmfd	sp!, {r4-r7, pc}
-
-	__INITDATA
-
-	.type	feroceon_user_fns, #object
-ENTRY(feroceon_user_fns)
-	.long	feroceon_clear_user_page
-	.long	feroceon_copy_user_page
-	.size	feroceon_user_fns, . - feroceon_user_fns
diff -Naur pico_2.6.28/arch/arm/mm/copypage-v3.c ipa_2.6.28/arch/arm/mm/copypage-v3.c
--- pico_2.6.28/arch/arm/mm/copypage-v3.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/arch/arm/mm/copypage-v3.c	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,82 @@
+/*
+ *  linux/arch/arm/mm/copypage-v3.c
+ *
+ *  Copyright (C) 1995-1999 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/init.h>
+#include <linux/highmem.h>
+
+/*
+ * ARMv3 optimised copy_user_highpage
+ *
+ * FIXME: do we need to handle cache stuff...
+ */
+static void __attribute__((naked))
+v3_copy_user_page(void *kto, const void *kfrom)
+{
+	asm("\n\
+	stmfd	sp!, {r4, lr}			@	2\n\
+	mov	r2, %2				@	1\n\
+	ldmia	%0!, {r3, r4, ip, lr}		@	4+1\n\
+1:	stmia	%1!, {r3, r4, ip, lr}		@	4\n\
+	ldmia	%0!, {r3, r4, ip, lr}		@	4+1\n\
+	stmia	%1!, {r3, r4, ip, lr}		@	4\n\
+	ldmia	%0!, {r3, r4, ip, lr}		@	4+1\n\
+	stmia	%1!, {r3, r4, ip, lr}		@	4\n\
+	ldmia	%0!, {r3, r4, ip, lr}		@	4\n\
+	subs	r2, r2, #1			@	1\n\
+	stmia	%1!, {r3, r4, ip, lr}		@	4\n\
+	ldmneia	%0!, {r3, r4, ip, lr}		@	4\n\
+	bne	1b				@	1\n\
+	ldmfd	sp!, {r4, pc}			@	3"
+	:
+	: "r" (kfrom), "r" (kto), "I" (PAGE_SIZE / 64));
+}
+
+void v3_copy_user_highpage(struct page *to, struct page *from,
+	unsigned long vaddr, struct vm_area_struct *vma)
+{
+	void *kto, *kfrom;
+
+	kto = kmap_atomic(to, KM_USER0);
+	kfrom = kmap_atomic(from, KM_USER1);
+	flush_cache_page(vma, vaddr, page_to_pfn(from));
+	v3_copy_user_page(kto, kfrom);
+	kunmap_atomic(kfrom, KM_USER1);
+	kunmap_atomic(kto, KM_USER0);
+}
+
+/*
+ * ARMv3 optimised clear_user_page
+ *
+ * FIXME: do we need to handle cache stuff...
+ */
+void v3_clear_user_highpage(struct page *page, unsigned long vaddr)
+{
+	void *ptr, *kaddr = kmap_atomic(page, KM_USER0);
+	asm volatile("\n\
+	mov	r1, %2				@ 1\n\
+	mov	r2, #0				@ 1\n\
+	mov	r3, #0				@ 1\n\
+	mov	ip, #0				@ 1\n\
+	mov	lr, #0				@ 1\n\
+1:	stmia	%0!, {r2, r3, ip, lr}		@ 4\n\
+	stmia	%0!, {r2, r3, ip, lr}		@ 4\n\
+	stmia	%0!, {r2, r3, ip, lr}		@ 4\n\
+	stmia	%0!, {r2, r3, ip, lr}		@ 4\n\
+	subs	r1, r1, #1			@ 1\n\
+	bne	1b				@ 1"
+	: "=r" (ptr)
+	: "0" (kaddr), "I" (PAGE_SIZE / 64)
+	: "r1", "r2", "r3", "ip", "lr");
+	kunmap_atomic(kaddr, KM_USER0);
+}
+
+struct cpu_user_fns v3_user_fns __initdata = {
+	.cpu_clear_user_highpage = v3_clear_user_highpage,
+	.cpu_copy_user_highpage	= v3_copy_user_highpage,
+};
diff -Naur pico_2.6.28/arch/arm/mm/copypage-v3.S ipa_2.6.28/arch/arm/mm/copypage-v3.S
--- pico_2.6.28/arch/arm/mm/copypage-v3.S	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/arch/arm/mm/copypage-v3.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,67 +0,0 @@
-/*
- *  linux/arch/arm/lib/copypage.S
- *
- *  Copyright (C) 1995-1999 Russell King
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- *  ASM optimised string functions
- */
-#include <linux/linkage.h>
-#include <linux/init.h>
-#include <asm/assembler.h>
-#include <asm/asm-offsets.h>
-
-		.text
-		.align	5
-/*
- * ARMv3 optimised copy_user_page
- *
- * FIXME: do we need to handle cache stuff...
- */
-ENTRY(v3_copy_user_page)
-	stmfd	sp!, {r4, lr}			@	2
-	mov	r2, #PAGE_SZ/64			@	1
-	ldmia	r1!, {r3, r4, ip, lr}		@	4+1
-1:	stmia	r0!, {r3, r4, ip, lr}		@	4
-	ldmia	r1!, {r3, r4, ip, lr}		@	4+1
-	stmia	r0!, {r3, r4, ip, lr}		@	4
-	ldmia	r1!, {r3, r4, ip, lr}		@	4+1
-	stmia	r0!, {r3, r4, ip, lr}		@	4
-	ldmia	r1!, {r3, r4, ip, lr}		@	4
-	subs	r2, r2, #1			@	1
-	stmia	r0!, {r3, r4, ip, lr}		@	4
-	ldmneia	r1!, {r3, r4, ip, lr}		@	4
-	bne	1b				@	1
-	ldmfd	sp!, {r4, pc}			@	3
-
-	.align	5
-/*
- * ARMv3 optimised clear_user_page
- *
- * FIXME: do we need to handle cache stuff...
- */
-ENTRY(v3_clear_user_page)
-	str	lr, [sp, #-4]!
-	mov	r1, #PAGE_SZ/64			@ 1
-	mov	r2, #0				@ 1
-	mov	r3, #0				@ 1
-	mov	ip, #0				@ 1
-	mov	lr, #0				@ 1
-1:	stmia	r0!, {r2, r3, ip, lr}		@ 4
-	stmia	r0!, {r2, r3, ip, lr}		@ 4
-	stmia	r0!, {r2, r3, ip, lr}		@ 4
-	stmia	r0!, {r2, r3, ip, lr}		@ 4
-	subs	r1, r1, #1			@ 1
-	bne	1b				@ 1
-	ldr	pc, [sp], #4
-
-	__INITDATA
-
-	.type	v3_user_fns, #object
-ENTRY(v3_user_fns)
-	.long	v3_clear_user_page
-	.long	v3_copy_user_page
-	.size	v3_user_fns, . - v3_user_fns
diff -Naur pico_2.6.28/arch/arm/mm/copypage-v4mc.c ipa_2.6.28/arch/arm/mm/copypage-v4mc.c
--- pico_2.6.28/arch/arm/mm/copypage-v4mc.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/arch/arm/mm/copypage-v4mc.c	2011-04-26 14:51:35.000000000 +0100
@@ -15,8 +15,8 @@
  */
 #include <linux/init.h>
 #include <linux/mm.h>
+#include <linux/highmem.h>
 
-#include <asm/page.h>
 #include <asm/pgtable.h>
 #include <asm/tlbflush.h>
 #include <asm/cacheflush.h>
@@ -33,7 +33,7 @@
 static DEFINE_SPINLOCK(minicache_lock);
 
 /*
- * ARMv4 mini-dcache optimised copy_user_page
+ * ARMv4 mini-dcache optimised copy_user_highpage
  *
  * We flush the destination cache lines just before we write the data into the
  * corresponding address.  Since the Dcache is read-allocate, this removes the
@@ -42,7 +42,7 @@
  *
  * Note: We rely on all ARMv4 processors implementing the "invalidate D line"
  * instruction.  If your processor does not supply this, you have to write your
- * own copy_user_page that does the right thing.
+ * own copy_user_highpage that does the right thing.
  */
 static void __attribute__((naked))
 mc_copy_user_page(void *from, void *to)
@@ -68,50 +68,53 @@
 	: "r" (from), "r" (to), "I" (PAGE_SIZE / 64));
 }
 
-void v4_mc_copy_user_page(void *kto, const void *kfrom, unsigned long vaddr)
+void v4_mc_copy_user_highpage(struct page *to, struct page *from,
+	unsigned long vaddr, struct vm_area_struct *vma)
 {
-	struct page *page = virt_to_page(kfrom);
+	void *kto = kmap_atomic(to, KM_USER1);
 
-	if (test_and_clear_bit(PG_dcache_dirty, &page->flags))
-		__flush_dcache_page(page_mapping(page), page);
+	if (test_and_clear_bit(PG_dcache_dirty, &from->flags))
+		__flush_dcache_page(page_mapping(from), from);
 
 	spin_lock(&minicache_lock);
 
-	set_pte_ext(TOP_PTE(0xffff8000), pfn_pte(__pa(kfrom) >> PAGE_SHIFT, minicache_pgprot), 0);
+	set_pte_ext(TOP_PTE(0xffff8000), pfn_pte(page_to_pfn(from), minicache_pgprot), 0);
 	flush_tlb_kernel_page(0xffff8000);
 
 	mc_copy_user_page((void *)0xffff8000, kto);
 
 	spin_unlock(&minicache_lock);
+
+	kunmap_atomic(kto, KM_USER1);
 }
 
 /*
  * ARMv4 optimised clear_user_page
  */
-void __attribute__((naked))
-v4_mc_clear_user_page(void *kaddr, unsigned long vaddr)
+void v4_mc_clear_user_highpage(struct page *page, unsigned long vaddr)
 {
-	asm volatile(
-	"str	lr, [sp, #-4]!\n\
-	mov	r1, %0				@ 1\n\
+	void *ptr, *kaddr = kmap_atomic(page, KM_USER0);
+	asm volatile("\
+	mov	r1, %2				@ 1\n\
 	mov	r2, #0				@ 1\n\
 	mov	r3, #0				@ 1\n\
 	mov	ip, #0				@ 1\n\
 	mov	lr, #0				@ 1\n\
-1:	mcr	p15, 0, r0, c7, c6, 1		@ 1   invalidate D line\n\
-	stmia	r0!, {r2, r3, ip, lr}		@ 4\n\
-	stmia	r0!, {r2, r3, ip, lr}		@ 4\n\
-	mcr	p15, 0, r0, c7, c6, 1		@ 1   invalidate D line\n\
-	stmia	r0!, {r2, r3, ip, lr}		@ 4\n\
-	stmia	r0!, {r2, r3, ip, lr}		@ 4\n\
+1:	mcr	p15, 0, %0, c7, c6, 1		@ 1   invalidate D line\n\
+	stmia	%0!, {r2, r3, ip, lr}		@ 4\n\
+	stmia	%0!, {r2, r3, ip, lr}		@ 4\n\
+	mcr	p15, 0, %0, c7, c6, 1		@ 1   invalidate D line\n\
+	stmia	%0!, {r2, r3, ip, lr}		@ 4\n\
+	stmia	%0!, {r2, r3, ip, lr}		@ 4\n\
 	subs	r1, r1, #1			@ 1\n\
-	bne	1b				@ 1\n\
-	ldr	pc, [sp], #4"
-	:
-	: "I" (PAGE_SIZE / 64));
+	bne	1b				@ 1"
+	: "=r" (ptr)
+	: "0" (kaddr), "I" (PAGE_SIZE / 64)
+	: "r1", "r2", "r3", "ip", "lr");
+	kunmap_atomic(kaddr, KM_USER0);
 }
 
 struct cpu_user_fns v4_mc_user_fns __initdata = {
-	.cpu_clear_user_page	= v4_mc_clear_user_page, 
-	.cpu_copy_user_page	= v4_mc_copy_user_page,
+	.cpu_clear_user_highpage = v4_mc_clear_user_highpage,
+	.cpu_copy_user_highpage	= v4_mc_copy_user_highpage,
 };
diff -Naur pico_2.6.28/arch/arm/mm/copypage-v4wb.c ipa_2.6.28/arch/arm/mm/copypage-v4wb.c
--- pico_2.6.28/arch/arm/mm/copypage-v4wb.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/arch/arm/mm/copypage-v4wb.c	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,95 @@
+/*
+ *  linux/arch/arm/mm/copypage-v4wb.c
+ *
+ *  Copyright (C) 1995-1999 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/init.h>
+#include <linux/highmem.h>
+
+/*
+ * ARMv4 optimised copy_user_highpage
+ *
+ * We flush the destination cache lines just before we write the data into the
+ * corresponding address.  Since the Dcache is read-allocate, this removes the
+ * Dcache aliasing issue.  The writes will be forwarded to the write buffer,
+ * and merged as appropriate.
+ *
+ * Note: We rely on all ARMv4 processors implementing the "invalidate D line"
+ * instruction.  If your processor does not supply this, you have to write your
+ * own copy_user_highpage that does the right thing.
+ */
+static void __attribute__((naked))
+v4wb_copy_user_page(void *kto, const void *kfrom)
+{
+	asm("\
+	stmfd	sp!, {r4, lr}			@ 2\n\
+	mov	r2, %0				@ 1\n\
+	ldmia	r1!, {r3, r4, ip, lr}		@ 4\n\
+1:	mcr	p15, 0, r0, c7, c6, 1		@ 1   invalidate D line\n\
+	stmia	r0!, {r3, r4, ip, lr}		@ 4\n\
+	ldmia	r1!, {r3, r4, ip, lr}		@ 4+1\n\
+	stmia	r0!, {r3, r4, ip, lr}		@ 4\n\
+	ldmia	r1!, {r3, r4, ip, lr}		@ 4\n\
+	mcr	p15, 0, r0, c7, c6, 1		@ 1   invalidate D line\n\
+	stmia	r0!, {r3, r4, ip, lr}		@ 4\n\
+	ldmia	r1!, {r3, r4, ip, lr}		@ 4\n\
+	subs	r2, r2, #1			@ 1\n\
+	stmia	r0!, {r3, r4, ip, lr}		@ 4\n\
+	ldmneia	r1!, {r3, r4, ip, lr}		@ 4\n\
+	bne	1b				@ 1\n\
+	mcr	p15, 0, r1, c7, c10, 4		@ 1   drain WB\n\
+	ldmfd	 sp!, {r4, pc}			@ 3"
+	:
+	: "I" (PAGE_SIZE / 64));
+}
+
+void v4wb_copy_user_highpage(struct page *to, struct page *from,
+	unsigned long vaddr, struct vm_area_struct *vma)
+{
+	void *kto, *kfrom;
+
+	kto = kmap_atomic(to, KM_USER0);
+	kfrom = kmap_atomic(from, KM_USER1);
+	flush_cache_page(vma, vaddr, page_to_pfn(from));
+	v4wb_copy_user_page(kto, kfrom);
+	kunmap_atomic(kfrom, KM_USER1);
+	kunmap_atomic(kto, KM_USER0);
+}
+
+/*
+ * ARMv4 optimised clear_user_page
+ *
+ * Same story as above.
+ */
+void v4wb_clear_user_highpage(struct page *page, unsigned long vaddr)
+{
+	void *ptr, *kaddr = kmap_atomic(page, KM_USER0);
+	asm volatile("\
+	mov	r1, %2				@ 1\n\
+	mov	r2, #0				@ 1\n\
+	mov	r3, #0				@ 1\n\
+	mov	ip, #0				@ 1\n\
+	mov	lr, #0				@ 1\n\
+1:	mcr	p15, 0, %0, c7, c6, 1		@ 1   invalidate D line\n\
+	stmia	%0!, {r2, r3, ip, lr}		@ 4\n\
+	stmia	%0!, {r2, r3, ip, lr}		@ 4\n\
+	mcr	p15, 0, %0, c7, c6, 1		@ 1   invalidate D line\n\
+	stmia	%0!, {r2, r3, ip, lr}		@ 4\n\
+	stmia	%0!, {r2, r3, ip, lr}		@ 4\n\
+	subs	r1, r1, #1			@ 1\n\
+	bne	1b				@ 1\n\
+	mcr	p15, 0, r1, c7, c10, 4		@ 1   drain WB"
+	: "=r" (ptr)
+	: "0" (kaddr), "I" (PAGE_SIZE / 64)
+	: "r1", "r2", "r3", "ip", "lr");
+	kunmap_atomic(kaddr, KM_USER0);
+}
+
+struct cpu_user_fns v4wb_user_fns __initdata = {
+	.cpu_clear_user_highpage = v4wb_clear_user_highpage,
+	.cpu_copy_user_highpage	= v4wb_copy_user_highpage,
+};
diff -Naur pico_2.6.28/arch/arm/mm/copypage-v4wb.S ipa_2.6.28/arch/arm/mm/copypage-v4wb.S
--- pico_2.6.28/arch/arm/mm/copypage-v4wb.S	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/arch/arm/mm/copypage-v4wb.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,79 +0,0 @@
-/*
- *  linux/arch/arm/lib/copypage.S
- *
- *  Copyright (C) 1995-1999 Russell King
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- *  ASM optimised string functions
- */
-#include <linux/linkage.h>
-#include <linux/init.h>
-#include <asm/asm-offsets.h>
-
-	.text
-	.align	5
-/*
- * ARMv4 optimised copy_user_page
- *
- * We flush the destination cache lines just before we write the data into the
- * corresponding address.  Since the Dcache is read-allocate, this removes the
- * Dcache aliasing issue.  The writes will be forwarded to the write buffer,
- * and merged as appropriate.
- *
- * Note: We rely on all ARMv4 processors implementing the "invalidate D line"
- * instruction.  If your processor does not supply this, you have to write your
- * own copy_user_page that does the right thing.
- */
-ENTRY(v4wb_copy_user_page)
-	stmfd	sp!, {r4, lr}			@ 2
-	mov	r2, #PAGE_SZ/64			@ 1
-	ldmia	r1!, {r3, r4, ip, lr}		@ 4
-1:	mcr	p15, 0, r0, c7, c6, 1		@ 1   invalidate D line
-	stmia	r0!, {r3, r4, ip, lr}		@ 4
-	ldmia	r1!, {r3, r4, ip, lr}		@ 4+1
-	stmia	r0!, {r3, r4, ip, lr}		@ 4
-	ldmia	r1!, {r3, r4, ip, lr}		@ 4
-	mcr	p15, 0, r0, c7, c6, 1		@ 1   invalidate D line
-	stmia	r0!, {r3, r4, ip, lr}		@ 4
-	ldmia	r1!, {r3, r4, ip, lr}		@ 4
-	subs	r2, r2, #1			@ 1
-	stmia	r0!, {r3, r4, ip, lr}		@ 4
-	ldmneia	r1!, {r3, r4, ip, lr}		@ 4
-	bne	1b				@ 1
-	mcr	p15, 0, r1, c7, c10, 4		@ 1   drain WB
-	ldmfd	 sp!, {r4, pc}			@ 3
-
-	.align	5
-/*
- * ARMv4 optimised clear_user_page
- *
- * Same story as above.
- */
-ENTRY(v4wb_clear_user_page)
-	str	lr, [sp, #-4]!
-	mov	r1, #PAGE_SZ/64			@ 1
-	mov	r2, #0				@ 1
-	mov	r3, #0				@ 1
-	mov	ip, #0				@ 1
-	mov	lr, #0				@ 1
-1:	mcr	p15, 0, r0, c7, c6, 1		@ 1   invalidate D line
-	stmia	r0!, {r2, r3, ip, lr}		@ 4
-	stmia	r0!, {r2, r3, ip, lr}		@ 4
-	mcr	p15, 0, r0, c7, c6, 1		@ 1   invalidate D line
-	stmia	r0!, {r2, r3, ip, lr}		@ 4
-	stmia	r0!, {r2, r3, ip, lr}		@ 4
-	subs	r1, r1, #1			@ 1
-	bne	1b				@ 1
-	mcr	p15, 0, r1, c7, c10, 4		@ 1   drain WB
-	ldr	pc, [sp], #4
-
-	__INITDATA
-
-	.type	v4wb_user_fns, #object
-ENTRY(v4wb_user_fns)
-	.long	v4wb_clear_user_page
-	.long	v4wb_copy_user_page
-	.size	v4wb_user_fns, . - v4wb_user_fns
diff -Naur pico_2.6.28/arch/arm/mm/copypage-v4wt.c ipa_2.6.28/arch/arm/mm/copypage-v4wt.c
--- pico_2.6.28/arch/arm/mm/copypage-v4wt.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/arch/arm/mm/copypage-v4wt.c	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,88 @@
+/*
+ *  linux/arch/arm/mm/copypage-v4wt.S
+ *
+ *  Copyright (C) 1995-1999 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  This is for CPUs with a writethrough cache and 'flush ID cache' is
+ *  the only supported cache operation.
+ */
+#include <linux/init.h>
+#include <linux/highmem.h>
+
+/*
+ * ARMv4 optimised copy_user_highpage
+ *
+ * Since we have writethrough caches, we don't have to worry about
+ * dirty data in the cache.  However, we do have to ensure that
+ * subsequent reads are up to date.
+ */
+static void __attribute__((naked))
+v4wt_copy_user_page(void *kto, const void *kfrom)
+{
+	asm("\
+	stmfd	sp!, {r4, lr}			@ 2\n\
+	mov	r2, %0				@ 1\n\
+	ldmia	r1!, {r3, r4, ip, lr}		@ 4\n\
+1:	stmia	r0!, {r3, r4, ip, lr}		@ 4\n\
+	ldmia	r1!, {r3, r4, ip, lr}		@ 4+1\n\
+	stmia	r0!, {r3, r4, ip, lr}		@ 4\n\
+	ldmia	r1!, {r3, r4, ip, lr}		@ 4\n\
+	stmia	r0!, {r3, r4, ip, lr}		@ 4\n\
+	ldmia	r1!, {r3, r4, ip, lr}		@ 4\n\
+	subs	r2, r2, #1			@ 1\n\
+	stmia	r0!, {r3, r4, ip, lr}		@ 4\n\
+	ldmneia	r1!, {r3, r4, ip, lr}		@ 4\n\
+	bne	1b				@ 1\n\
+	mcr	p15, 0, r2, c7, c7, 0		@ flush ID cache\n\
+	ldmfd	sp!, {r4, pc}			@ 3"
+	:
+	: "I" (PAGE_SIZE / 64));
+}
+
+void v4wt_copy_user_highpage(struct page *to, struct page *from,
+	unsigned long vaddr, struct vm_area_struct *vma)
+{
+	void *kto, *kfrom;
+
+	kto = kmap_atomic(to, KM_USER0);
+	kfrom = kmap_atomic(from, KM_USER1);
+	v4wt_copy_user_page(kto, kfrom);
+	kunmap_atomic(kfrom, KM_USER1);
+	kunmap_atomic(kto, KM_USER0);
+}
+
+/*
+ * ARMv4 optimised clear_user_page
+ *
+ * Same story as above.
+ */
+void v4wt_clear_user_highpage(struct page *page, unsigned long vaddr)
+{
+	void *ptr, *kaddr = kmap_atomic(page, KM_USER0);
+	asm volatile("\
+	mov	r1, %2				@ 1\n\
+	mov	r2, #0				@ 1\n\
+	mov	r3, #0				@ 1\n\
+	mov	ip, #0				@ 1\n\
+	mov	lr, #0				@ 1\n\
+1:	stmia	%0!, {r2, r3, ip, lr}		@ 4\n\
+	stmia	%0!, {r2, r3, ip, lr}		@ 4\n\
+	stmia	%0!, {r2, r3, ip, lr}		@ 4\n\
+	stmia	%0!, {r2, r3, ip, lr}		@ 4\n\
+	subs	r1, r1, #1			@ 1\n\
+	bne	1b				@ 1\n\
+	mcr	p15, 0, r2, c7, c7, 0		@ flush ID cache"
+	: "=r" (ptr)
+	: "0" (kaddr), "I" (PAGE_SIZE / 64)
+	: "r1", "r2", "r3", "ip", "lr");
+	kunmap_atomic(kaddr, KM_USER0);
+}
+
+struct cpu_user_fns v4wt_user_fns __initdata = {
+	.cpu_clear_user_highpage = v4wt_clear_user_highpage,
+	.cpu_copy_user_highpage	= v4wt_copy_user_highpage,
+};
diff -Naur pico_2.6.28/arch/arm/mm/copypage-v4wt.S ipa_2.6.28/arch/arm/mm/copypage-v4wt.S
--- pico_2.6.28/arch/arm/mm/copypage-v4wt.S	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/arch/arm/mm/copypage-v4wt.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,73 +0,0 @@
-/*
- *  linux/arch/arm/lib/copypage-v4.S
- *
- *  Copyright (C) 1995-1999 Russell King
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- *  ASM optimised string functions
- *
- *  This is for CPUs with a writethrough cache and 'flush ID cache' is
- *  the only supported cache operation.
- */
-#include <linux/linkage.h>
-#include <linux/init.h>
-#include <asm/asm-offsets.h>
-
-	.text
-	.align	5
-/*
- * ARMv4 optimised copy_user_page
- *
- * Since we have writethrough caches, we don't have to worry about
- * dirty data in the cache.  However, we do have to ensure that
- * subsequent reads are up to date.
- */
-ENTRY(v4wt_copy_user_page)
-	stmfd	sp!, {r4, lr}			@ 2
-	mov	r2, #PAGE_SZ/64			@ 1
-	ldmia	r1!, {r3, r4, ip, lr}		@ 4
-1:	stmia	r0!, {r3, r4, ip, lr}		@ 4
-	ldmia	r1!, {r3, r4, ip, lr}		@ 4+1
-	stmia	r0!, {r3, r4, ip, lr}		@ 4
-	ldmia	r1!, {r3, r4, ip, lr}		@ 4
-	stmia	r0!, {r3, r4, ip, lr}		@ 4
-	ldmia	r1!, {r3, r4, ip, lr}		@ 4
-	subs	r2, r2, #1			@ 1
-	stmia	r0!, {r3, r4, ip, lr}		@ 4
-	ldmneia	r1!, {r3, r4, ip, lr}		@ 4
-	bne	1b				@ 1
-	mcr	p15, 0, r2, c7, c7, 0		@ flush ID cache
-	ldmfd	sp!, {r4, pc}			@ 3
-
-	.align	5
-/*
- * ARMv4 optimised clear_user_page
- *
- * Same story as above.
- */
-ENTRY(v4wt_clear_user_page)
-	str	lr, [sp, #-4]!
-	mov	r1, #PAGE_SZ/64			@ 1
-	mov	r2, #0				@ 1
-	mov	r3, #0				@ 1
-	mov	ip, #0				@ 1
-	mov	lr, #0				@ 1
-1:	stmia	r0!, {r2, r3, ip, lr}		@ 4
-	stmia	r0!, {r2, r3, ip, lr}		@ 4
-	stmia	r0!, {r2, r3, ip, lr}		@ 4
-	stmia	r0!, {r2, r3, ip, lr}		@ 4
-	subs	r1, r1, #1			@ 1
-	bne	1b				@ 1
-	mcr	p15, 0, r2, c7, c7, 0		@ flush ID cache
-	ldr	pc, [sp], #4
-
-	__INITDATA
-
-	.type	v4wt_user_fns, #object
-ENTRY(v4wt_user_fns)
-	.long	v4wt_clear_user_page
-	.long	v4wt_copy_user_page
-	.size	v4wt_user_fns, . - v4wt_user_fns
diff -Naur pico_2.6.28/arch/arm/mm/copypage-v6.c ipa_2.6.28/arch/arm/mm/copypage-v6.c
--- pico_2.6.28/arch/arm/mm/copypage-v6.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/arch/arm/mm/copypage-v6.c	2011-04-26 14:51:35.000000000 +0100
@@ -10,8 +10,8 @@
 #include <linux/init.h>
 #include <linux/spinlock.h>
 #include <linux/mm.h>
+#include <linux/highmem.h>
 
-#include <asm/page.h>
 #include <asm/pgtable.h>
 #include <asm/shmparam.h>
 #include <asm/tlbflush.h>
@@ -33,41 +33,56 @@
  * Copy the user page.  No aliasing to deal with so we can just
  * attack the kernel's existing mapping of these pages.
  */
-static void v6_copy_user_page_nonaliasing(void *kto, const void *kfrom, unsigned long vaddr)
+static void v6_copy_user_highpage_nonaliasing(struct page *to,
+	struct page *from, unsigned long vaddr, struct vm_area_struct *vma)
 {
+	void *kto, *kfrom;
+
+	kfrom = kmap_atomic(from, KM_USER0);
+	kto = kmap_atomic(to, KM_USER1);
 	copy_page(kto, kfrom);
+	kunmap_atomic(kto, KM_USER1);
+	kunmap_atomic(kfrom, KM_USER0);
 }
 
 /*
  * Clear the user page.  No aliasing to deal with so we can just
  * attack the kernel's existing mapping of this page.
  */
-static void v6_clear_user_page_nonaliasing(void *kaddr, unsigned long vaddr)
+static void v6_clear_user_highpage_nonaliasing(struct page *page, unsigned long vaddr)
 {
+	void *kaddr = kmap_atomic(page, KM_USER0);
 	clear_page(kaddr);
+	kunmap_atomic(kaddr, KM_USER0);
 }
 
 /*
- * Copy the page, taking account of the cache colour.
+ * Discard data in the kernel mapping for the new page.
+ * FIXME: needs this MCRR to be supported.
  */
-static void v6_copy_user_page_aliasing(void *kto, const void *kfrom, unsigned long vaddr)
+static void discard_old_kernel_data(void *kto)
 {
-	unsigned int offset = CACHE_COLOUR(vaddr);
-	unsigned long from, to;
-	struct page *page = virt_to_page(kfrom);
-
-	if (test_and_clear_bit(PG_dcache_dirty, &page->flags))
-		__flush_dcache_page(page_mapping(page), page);
-
-	/*
-	 * Discard data in the kernel mapping for the new page.
-	 * FIXME: needs this MCRR to be supported.
-	 */
 	__asm__("mcrr	p15, 0, %1, %0, c6	@ 0xec401f06"
 	   :
 	   : "r" (kto),
 	     "r" ((unsigned long)kto + PAGE_SIZE - L1_CACHE_BYTES)
 	   : "cc");
+}
+
+/*
+ * Copy the page, taking account of the cache colour.
+ */
+static void v6_copy_user_highpage_aliasing(struct page *to,
+	struct page *from, unsigned long vaddr, struct vm_area_struct *vma)
+{
+	unsigned int offset = CACHE_COLOUR(vaddr);
+	unsigned long kfrom, kto;
+
+	if (test_and_clear_bit(PG_dcache_dirty, &from->flags))
+		__flush_dcache_page(page_mapping(from), from);
+
+	/* FIXME: not highmem safe */
+	discard_old_kernel_data(page_address(to));
 
 	/*
 	 * Now copy the page using the same cache colour as the
@@ -75,16 +90,16 @@
 	 */
 	spin_lock(&v6_lock);
 
-	set_pte_ext(TOP_PTE(from_address) + offset, pfn_pte(__pa(kfrom) >> PAGE_SHIFT, PAGE_KERNEL), 0);
-	set_pte_ext(TOP_PTE(to_address) + offset, pfn_pte(__pa(kto) >> PAGE_SHIFT, PAGE_KERNEL), 0);
+	set_pte_ext(TOP_PTE(from_address) + offset, pfn_pte(page_to_pfn(from), PAGE_KERNEL), 0);
+	set_pte_ext(TOP_PTE(to_address) + offset, pfn_pte(page_to_pfn(to), PAGE_KERNEL), 0);
 
-	from = from_address + (offset << PAGE_SHIFT);
-	to   = to_address + (offset << PAGE_SHIFT);
+	kfrom = from_address + (offset << PAGE_SHIFT);
+	kto   = to_address + (offset << PAGE_SHIFT);
 
-	flush_tlb_kernel_page(from);
-	flush_tlb_kernel_page(to);
+	flush_tlb_kernel_page(kfrom);
+	flush_tlb_kernel_page(kto);
 
-	copy_page((void *)to, (void *)from);
+	copy_page((void *)kto, (void *)kfrom);
 
 	spin_unlock(&v6_lock);
 }
@@ -94,20 +109,13 @@
  * so remap the kernel page into the same cache colour as the user
  * page.
  */
-static void v6_clear_user_page_aliasing(void *kaddr, unsigned long vaddr)
+static void v6_clear_user_highpage_aliasing(struct page *page, unsigned long vaddr)
 {
 	unsigned int offset = CACHE_COLOUR(vaddr);
 	unsigned long to = to_address + (offset << PAGE_SHIFT);
 
-	/*
-	 * Discard data in the kernel mapping for the new page
-	 * FIXME: needs this MCRR to be supported.
-	 */
-	__asm__("mcrr	p15, 0, %1, %0, c6	@ 0xec401f06"
-	   :
-	   : "r" (kaddr),
-	     "r" ((unsigned long)kaddr + PAGE_SIZE - L1_CACHE_BYTES)
-	   : "cc");
+	/* FIXME: not highmem safe */
+	discard_old_kernel_data(page_address(page));
 
 	/*
 	 * Now clear the page using the same cache colour as
@@ -115,7 +123,7 @@
 	 */
 	spin_lock(&v6_lock);
 
-	set_pte_ext(TOP_PTE(to_address) + offset, pfn_pte(__pa(kaddr) >> PAGE_SHIFT, PAGE_KERNEL), 0);
+	set_pte_ext(TOP_PTE(to_address) + offset, pfn_pte(page_to_pfn(page), PAGE_KERNEL), 0);
 	flush_tlb_kernel_page(to);
 	clear_page((void *)to);
 
@@ -123,15 +131,15 @@
 }
 
 struct cpu_user_fns v6_user_fns __initdata = {
-	.cpu_clear_user_page	= v6_clear_user_page_nonaliasing,
-	.cpu_copy_user_page	= v6_copy_user_page_nonaliasing,
+	.cpu_clear_user_highpage = v6_clear_user_highpage_nonaliasing,
+	.cpu_copy_user_highpage	= v6_copy_user_highpage_nonaliasing,
 };
 
 static int __init v6_userpage_init(void)
 {
 	if (cache_is_vipt_aliasing()) {
-		cpu_user.cpu_clear_user_page = v6_clear_user_page_aliasing;
-		cpu_user.cpu_copy_user_page = v6_copy_user_page_aliasing;
+		cpu_user.cpu_clear_user_highpage = v6_clear_user_highpage_aliasing;
+		cpu_user.cpu_copy_user_highpage = v6_copy_user_highpage_aliasing;
 	}
 
 	return 0;
diff -Naur pico_2.6.28/arch/arm/mm/copypage-xsc3.c ipa_2.6.28/arch/arm/mm/copypage-xsc3.c
--- pico_2.6.28/arch/arm/mm/copypage-xsc3.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/arch/arm/mm/copypage-xsc3.c	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,114 @@
+/*
+ *  linux/arch/arm/mm/copypage-xsc3.S
+ *
+ *  Copyright (C) 2004 Intel Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Adapted for 3rd gen XScale core, no more mini-dcache
+ * Author: Matt Gilbert (matthew.m.gilbert@intel.com)
+ */
+#include <linux/init.h>
+#include <linux/highmem.h>
+
+/*
+ * General note:
+ *  We don't really want write-allocate cache behaviour for these functions
+ *  since that will just eat through 8K of the cache.
+ */
+
+/*
+ * XSC3 optimised copy_user_highpage
+ *  r0 = destination
+ *  r1 = source
+ *
+ * The source page may have some clean entries in the cache already, but we
+ * can safely ignore them - break_cow() will flush them out of the cache
+ * if we eventually end up using our copied page.
+ *
+ */
+static void __attribute__((naked))
+xsc3_mc_copy_user_page(void *kto, const void *kfrom)
+{
+	asm("\
+	stmfd	sp!, {r4, r5, lr}		\n\
+	mov	lr, %0				\n\
+						\n\
+	pld	[r1, #0]			\n\
+	pld	[r1, #32]			\n\
+1:	pld	[r1, #64]			\n\
+	pld	[r1, #96]			\n\
+						\n\
+2:	ldrd	r2, [r1], #8			\n\
+	mov	ip, r0				\n\
+	ldrd	r4, [r1], #8			\n\
+	mcr	p15, 0, ip, c7, c6, 1		@ invalidate\n\
+	strd	r2, [r0], #8			\n\
+	ldrd	r2, [r1], #8			\n\
+	strd	r4, [r0], #8			\n\
+	ldrd	r4, [r1], #8			\n\
+	strd	r2, [r0], #8			\n\
+	strd	r4, [r0], #8			\n\
+	ldrd	r2, [r1], #8			\n\
+	mov	ip, r0				\n\
+	ldrd	r4, [r1], #8			\n\
+	mcr	p15, 0, ip, c7, c6, 1		@ invalidate\n\
+	strd	r2, [r0], #8			\n\
+	ldrd	r2, [r1], #8			\n\
+	subs	lr, lr, #1			\n\
+	strd	r4, [r0], #8			\n\
+	ldrd	r4, [r1], #8			\n\
+	strd	r2, [r0], #8			\n\
+	strd	r4, [r0], #8			\n\
+	bgt	1b				\n\
+	beq	2b				\n\
+						\n\
+	ldmfd	sp!, {r4, r5, pc}"
+	:
+	: "I" (PAGE_SIZE / 64 - 1));
+}
+
+void xsc3_mc_copy_user_highpage(struct page *to, struct page *from,
+	unsigned long vaddr, struct vm_area_struct *vma)
+{
+	void *kto, *kfrom;
+
+	kto = kmap_atomic(to, KM_USER0);
+	kfrom = kmap_atomic(from, KM_USER1);
+	flush_cache_page(vma, vaddr, page_to_pfn(from));
+	xsc3_mc_copy_user_page(kto, kfrom);
+	kunmap_atomic(kfrom, KM_USER1);
+	kunmap_atomic(kto, KM_USER0);
+}
+
+/*
+ * XScale optimised clear_user_page
+ *  r0 = destination
+ *  r1 = virtual user address of ultimate destination page
+ */
+void xsc3_mc_clear_user_highpage(struct page *page, unsigned long vaddr)
+{
+	void *ptr, *kaddr = kmap_atomic(page, KM_USER0);
+	asm volatile ("\
+	mov	r1, %2				\n\
+	mov	r2, #0				\n\
+	mov	r3, #0				\n\
+1:	mcr	p15, 0, %0, c7, c6, 1		@ invalidate line\n\
+	strd	r2, [%0], #8			\n\
+	strd	r2, [%0], #8			\n\
+	strd	r2, [%0], #8			\n\
+	strd	r2, [%0], #8			\n\
+	subs	r1, r1, #1			\n\
+	bne	1b"
+	: "=r" (ptr)
+	: "0" (kaddr), "I" (PAGE_SIZE / 32)
+	: "r1", "r2", "r3");
+	kunmap_atomic(kaddr, KM_USER0);
+}
+
+struct cpu_user_fns xsc3_mc_user_fns __initdata = {
+	.cpu_clear_user_highpage = xsc3_mc_clear_user_highpage,
+	.cpu_copy_user_highpage	= xsc3_mc_copy_user_highpage,
+};
diff -Naur pico_2.6.28/arch/arm/mm/copypage-xsc3.S ipa_2.6.28/arch/arm/mm/copypage-xsc3.S
--- pico_2.6.28/arch/arm/mm/copypage-xsc3.S	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/arch/arm/mm/copypage-xsc3.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,97 +0,0 @@
-/*
- *  linux/arch/arm/lib/copypage-xsc3.S
- *
- *  Copyright (C) 2004 Intel Corp.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * Adapted for 3rd gen XScale core, no more mini-dcache
- * Author: Matt Gilbert (matthew.m.gilbert@intel.com)
- */
-
-#include <linux/linkage.h>
-#include <linux/init.h>
-#include <asm/asm-offsets.h>
-
-/*
- * General note:
- *  We don't really want write-allocate cache behaviour for these functions
- *  since that will just eat through 8K of the cache.
- */
-
-	.text
-	.align	5
-/*
- * XSC3 optimised copy_user_page
- *  r0 = destination
- *  r1 = source
- *  r2 = virtual user address of ultimate destination page
- *
- * The source page may have some clean entries in the cache already, but we
- * can safely ignore them - break_cow() will flush them out of the cache
- * if we eventually end up using our copied page.
- *
- */
-ENTRY(xsc3_mc_copy_user_page)
-	stmfd	sp!, {r4, r5, lr}
-	mov	lr, #PAGE_SZ/64-1
-
-	pld	[r1, #0]
-	pld	[r1, #32]
-1:	pld	[r1, #64]
-	pld	[r1, #96]
-
-2:	ldrd	r2, [r1], #8
-	mov	ip, r0
-	ldrd	r4, [r1], #8
-	mcr	p15, 0, ip, c7, c6, 1		@ invalidate
-	strd	r2, [r0], #8
-	ldrd	r2, [r1], #8
-	strd	r4, [r0], #8
-	ldrd	r4, [r1], #8
-	strd	r2, [r0], #8
-	strd	r4, [r0], #8
-	ldrd	r2, [r1], #8
-	mov	ip, r0
-	ldrd	r4, [r1], #8
-	mcr	p15, 0, ip, c7, c6, 1		@ invalidate
-	strd	r2, [r0], #8
-	ldrd	r2, [r1], #8
-	subs	lr, lr, #1
-	strd	r4, [r0], #8
-	ldrd	r4, [r1], #8
-	strd	r2, [r0], #8
-	strd	r4, [r0], #8
-	bgt	1b
-	beq	2b
-
-	ldmfd	sp!, {r4, r5, pc}
-
-	.align	5
-/*
- * XScale optimised clear_user_page
- *  r0 = destination
- *  r1 = virtual user address of ultimate destination page
- */
-ENTRY(xsc3_mc_clear_user_page)
-	mov	r1, #PAGE_SZ/32
-	mov	r2, #0
-	mov	r3, #0
-1:	mcr	p15, 0, r0, c7, c6, 1		@ invalidate line
-	strd	r2, [r0], #8
-	strd	r2, [r0], #8
-	strd	r2, [r0], #8
-	strd	r2, [r0], #8
-	subs	r1, r1, #1
-	bne	1b
-	mov	pc, lr
-
-	__INITDATA
-
-	.type	xsc3_mc_user_fns, #object
-ENTRY(xsc3_mc_user_fns)
-	.long	xsc3_mc_clear_user_page
-	.long	xsc3_mc_copy_user_page
-	.size	xsc3_mc_user_fns, . - xsc3_mc_user_fns
diff -Naur pico_2.6.28/arch/arm/mm/copypage-xscale.c ipa_2.6.28/arch/arm/mm/copypage-xscale.c
--- pico_2.6.28/arch/arm/mm/copypage-xscale.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/arch/arm/mm/copypage-xscale.c	2011-04-26 14:51:35.000000000 +0100
@@ -15,8 +15,8 @@
  */
 #include <linux/init.h>
 #include <linux/mm.h>
+#include <linux/highmem.h>
 
-#include <asm/page.h>
 #include <asm/pgtable.h>
 #include <asm/tlbflush.h>
 #include <asm/cacheflush.h>
@@ -35,7 +35,7 @@
 static DEFINE_SPINLOCK(minicache_lock);
 
 /*
- * XScale mini-dcache optimised copy_user_page
+ * XScale mini-dcache optimised copy_user_highpage
  *
  * We flush the destination cache lines just before we write the data into the
  * corresponding address.  Since the Dcache is read-allocate, this removes the
@@ -90,48 +90,53 @@
 	: "r" (from), "r" (to), "I" (PAGE_SIZE / 64 - 1));
 }
 
-void xscale_mc_copy_user_page(void *kto, const void *kfrom, unsigned long vaddr)
+void xscale_mc_copy_user_highpage(struct page *to, struct page *from,
+	unsigned long vaddr, struct vm_area_struct *vma)
 {
-	struct page *page = virt_to_page(kfrom);
+	void *kto = kmap_atomic(to, KM_USER1);
 
-	if (test_and_clear_bit(PG_dcache_dirty, &page->flags))
-		__flush_dcache_page(page_mapping(page), page);
+	if (test_and_clear_bit(PG_dcache_dirty, &from->flags))
+		__flush_dcache_page(page_mapping(from), from);
 
 	spin_lock(&minicache_lock);
 
-	set_pte_ext(TOP_PTE(COPYPAGE_MINICACHE), pfn_pte(__pa(kfrom) >> PAGE_SHIFT, minicache_pgprot), 0);
+	set_pte_ext(TOP_PTE(COPYPAGE_MINICACHE), pfn_pte(page_to_pfn(from), minicache_pgprot), 0);
 	flush_tlb_kernel_page(COPYPAGE_MINICACHE);
 
 	mc_copy_user_page((void *)COPYPAGE_MINICACHE, kto);
 
 	spin_unlock(&minicache_lock);
+
+	kunmap_atomic(kto, KM_USER1);
 }
 
 /*
  * XScale optimised clear_user_page
  */
-void __attribute__((naked))
-xscale_mc_clear_user_page(void *kaddr, unsigned long vaddr)
+void
+xscale_mc_clear_user_highpage(struct page *page, unsigned long vaddr)
 {
+	void *ptr, *kaddr = kmap_atomic(page, KM_USER0);
 	asm volatile(
-	"mov	r1, %0				\n\
+	"mov	r1, %2				\n\
 	mov	r2, #0				\n\
 	mov	r3, #0				\n\
-1:	mov	ip, r0				\n\
-	strd	r2, [r0], #8			\n\
-	strd	r2, [r0], #8			\n\
-	strd	r2, [r0], #8			\n\
-	strd	r2, [r0], #8			\n\
+1:	mov	ip, %0				\n\
+	strd	r2, [%0], #8			\n\
+	strd	r2, [%0], #8			\n\
+	strd	r2, [%0], #8			\n\
+	strd	r2, [%0], #8			\n\
 	mcr	p15, 0, ip, c7, c10, 1		@ clean D line\n\
 	subs	r1, r1, #1			\n\
 	mcr	p15, 0, ip, c7, c6, 1		@ invalidate D line\n\
-	bne	1b				\n\
-	mov	pc, lr"
-	:
-	: "I" (PAGE_SIZE / 32));
+	bne	1b"
+	: "=r" (ptr)
+	: "0" (kaddr), "I" (PAGE_SIZE / 32)
+	: "r1", "r2", "r3", "ip");
+	kunmap_atomic(kaddr, KM_USER0);
 }
 
 struct cpu_user_fns xscale_mc_user_fns __initdata = {
-	.cpu_clear_user_page	= xscale_mc_clear_user_page, 
-	.cpu_copy_user_page	= xscale_mc_copy_user_page,
+	.cpu_clear_user_highpage = xscale_mc_clear_user_highpage,
+	.cpu_copy_user_highpage	= xscale_mc_copy_user_highpage,
 };
diff -Naur pico_2.6.28/arch/arm/mm/proc-syms.c ipa_2.6.28/arch/arm/mm/proc-syms.c
--- pico_2.6.28/arch/arm/mm/proc-syms.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/arch/arm/mm/proc-syms.c	2011-04-26 14:51:35.000000000 +0100
@@ -33,8 +33,8 @@
 
 #ifdef CONFIG_MMU
 #ifndef MULTI_USER
-EXPORT_SYMBOL(__cpu_clear_user_page);
-EXPORT_SYMBOL(__cpu_copy_user_page);
+EXPORT_SYMBOL(__cpu_clear_user_highpage);
+EXPORT_SYMBOL(__cpu_copy_user_highpage);
 #else
 EXPORT_SYMBOL(cpu_user);
 #endif
diff -Naur pico_2.6.28/arch/arm/oprofile/common.c ipa_2.6.28/arch/arm/oprofile/common.c
--- pico_2.6.28/arch/arm/oprofile/common.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/arch/arm/oprofile/common.c	2011-04-26 14:51:35.000000000 +0100
@@ -149,6 +149,30 @@
 	spec = &op_armv7_spec;
 #endif
 
+#ifdef CONFIG_FIRECRACKER_ASYNC_OPROF
+	printk(KERN_INFO "oprofile: using async timer\n");
+	spec = NULL;
+	ops->create_files = NULL;
+	ops->setup = NULL;
+	ops->shutdown = NULL;
+	ops->start = op_firecracker_spec.start;
+	ops->stop = op_firecracker_spec.stop;
+	ops->cpu_type = "timer";
+	ret = 0;
+#endif
+
+#ifdef CONFIG_PC302_ASYNC_OPROF
+	printk(KERN_INFO "oprofile: using async timer\n");
+	spec = NULL;
+	ops->create_files = NULL;
+	ops->setup = NULL;
+	ops->shutdown = NULL;
+	ops->start = op_pc302_spec.start;
+	ops->stop = op_pc302_spec.stop;
+	ops->cpu_type = "timer";
+	ret = 0;
+#endif
+
 	if (spec) {
 		ret = spec->init();
 		if (ret < 0)
diff -Naur pico_2.6.28/arch/arm/oprofile/Makefile ipa_2.6.28/arch/arm/oprofile/Makefile
--- pico_2.6.28/arch/arm/oprofile/Makefile	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/arch/arm/oprofile/Makefile	2011-04-26 14:51:35.000000000 +0100
@@ -1,3 +1,16 @@
+################################################################################
+# 
+# Copyright (c) 2009 ip.access Ltd.
+#
+#  This program is free software; you can redistribute  it and/or modify it
+#  under  the terms of  the GNU General  Public License as published by the
+#  Free Software Foundation;  either version 2 of the  License, or (at your
+#  option) any later version.
+#
+# 22 Apr 2009 Created by Simon D Hughes.
+##############################################################################
+# Filename: 
+##############################################################################
 obj-$(CONFIG_OPROFILE) += oprofile.o
 
 DRIVER_OBJS = $(addprefix ../../../drivers/oprofile/, \
@@ -12,3 +25,5 @@
 oprofile-$(CONFIG_OPROFILE_ARMV6)	+= op_model_v6.o
 oprofile-$(CONFIG_OPROFILE_MPCORE)	+= op_model_mpcore.o
 oprofile-$(CONFIG_OPROFILE_ARMV7)	+= op_model_v7.o
+oprofile-$(CONFIG_FIRECRACKER_ASYNC_OPROF)	+= op_model_firecracker.o
+oprofile-$(CONFIG_PC302_ASYNC_OPROF)	+= op_model_pc302.o
diff -Naur pico_2.6.28/arch/arm/oprofile/op_arm_model.h ipa_2.6.28/arch/arm/oprofile/op_arm_model.h
--- pico_2.6.28/arch/arm/oprofile/op_arm_model.h	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/arch/arm/oprofile/op_arm_model.h	2011-04-26 14:51:35.000000000 +0100
@@ -24,6 +24,14 @@
 extern struct op_arm_model_spec op_xscale_spec;
 #endif
 
+#ifdef CONFIG_FIRECRACKER_ASYNC_OPROF
+extern struct op_arm_model_spec op_firecracker_spec;
+#endif
+
+#ifdef CONFIG_PC302_ASYNC_OPROF
+extern struct op_arm_model_spec op_pc302_spec;
+#endif
+
 extern struct op_arm_model_spec op_armv6_spec;
 extern struct op_arm_model_spec op_mpcore_spec;
 extern struct op_arm_model_spec op_armv7_spec;
diff -Naur pico_2.6.28/arch/arm/oprofile/op_model_firecracker.c ipa_2.6.28/arch/arm/oprofile/op_model_firecracker.c
--- pico_2.6.28/arch/arm/oprofile/op_model_firecracker.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/arch/arm/oprofile/op_model_firecracker.c	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,149 @@
+/*
+ * FILE NAME op_model_firecracker.c
+ *
+ * Copyright (c) 2008 ip.access Ltd.
+ *
+ * BRIEF MODULE DESCRIPTION
+ *  Support for async hardware timer for oprofile
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+ 
+ 
+/****************************************************************************
+ * Standard Library Includes
+ ****************************************************************************/ 
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <linux/oprofile.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/smp.h>
+
+/****************************************************************************
+ * Kernel Includes
+ ****************************************************************************/ 
+#include "op_counter.h"
+#include "op_arm_model.h"
+
+/****************************************************************************
+  Private Definitions
+ ****************************************************************************/
+/* Converts a physical address number into a pointer to the virtual location */
+#define _ioa(n)     __io(IO_ADDRESS(n))
+
+/****************************************************************************
+  Private Types
+ ****************************************************************************/
+
+/****************************************************************************
+ * Private Function Prototypes
+ ****************************************************************************/
+static irqreturn_t firecracker_oprof_interrupt(int irq, void *dev_id);
+static int         firecracker_oprof_start(void);
+static void        firecracker_oprof_stop(void);
+static int         firecracker_oprof_dummy(void);
+
+/****************************************************************************
+ * Private Constants
+ ****************************************************************************/
+/* Use a relatively prime divisor to avoid syncing up to the tick timer */
+#define OPROF_RT_LATCH ((3*3*3*3*3*11*53) - 1)  /* Divisor of 141669 vs 140000 for tick */
+
+/* Use timer 2 for the oprofile sample clock */
+#define OPROF_TICK_TIMER 2
+#define OPROF_TICK_TIMER_IRQ IRQ_TIMER_2
+
+/****************************************************************************
+ * Exported Variables
+ ****************************************************************************/
+struct op_arm_model_spec op_firecracker_spec = {
+    .init           = firecracker_oprof_dummy,
+    .num_counters   = 1,
+    .setup_ctrs     = firecracker_oprof_dummy,
+    .start          = firecracker_oprof_start,
+    .stop           = firecracker_oprof_stop,
+    .name           = "timer",  /* The name must be timer to allow oprofile to analyse results */
+};
+
+/****************************************************************************
+ * Private Variables (Must be declared static)
+ ****************************************************************************/
+
+
+  
+/****************************************************************************
+ * Function Name  : firecracker_oprof_interrupt
+ * Description    : IRQ handler for the timer.
+ *                  Clears interrupt and takes a sample
+ ****************************************************************************/
+static irqreturn_t firecracker_oprof_interrupt(int irq, void *dev_id)
+{
+    struct pt_regs *regs = get_irq_regs();
+    
+    // ...clear the interrupt
+    ioread32(_ioa(PC20X_TIMERS_BASE + TIMER_N_EOI_REG_OFFSET(OPROF_TICK_TIMER)));
+
+    oprofile_add_sample(regs, 0);
+    
+    return IRQ_HANDLED;
+}
+
+/****************************************************************************
+ * Function Name  : firecracker_oprof_start
+ * Description    : Set up the timer and interrupt.
+ ****************************************************************************/
+static int firecracker_oprof_start(void)
+{
+    int            ret = 0;
+
+    /* Start with the timer disabled */
+    iowrite32(0, 
+            _ioa(PC20X_TIMERS_BASE + TIMER_N_CONTROL_REG_OFFSET(OPROF_TICK_TIMER)));
+
+    /* Set mode  */
+    iowrite32(TIMER_MODE, 
+            _ioa(PC20X_TIMERS_BASE + TIMER_N_CONTROL_REG_OFFSET(OPROF_TICK_TIMER)));
+
+    /* Set the reload count that gives us the desired interrupt frequency */
+    iowrite32(OPROF_RT_LATCH, 
+            _ioa(PC20X_TIMERS_BASE + TIMER_N_LOAD_COUNT_REG_OFFSET(OPROF_TICK_TIMER)));
+    
+    /* Register interrupt handler */
+    ret = request_irq(OPROF_TICK_TIMER_IRQ, firecracker_oprof_interrupt, IRQF_DISABLED, "OProf Tick", NULL);
+    
+    if (ret == 0)
+    {
+        /* Set user defined count mode, unmask interrupt and enable the timer */
+        iowrite32((TIMER_ENABLE | TIMER_MODE), 
+                _ioa(PC20X_TIMERS_BASE + TIMER_N_CONTROL_REG_OFFSET(OPROF_TICK_TIMER)));
+    }
+    
+    return ret;
+}
+
+/****************************************************************************
+ * Function Name  : firecracker_oprof_stop
+ * Description    : Stop the timer and interrupt.
+ ****************************************************************************/
+static void firecracker_oprof_stop(void)
+{
+    /* Disable the timer */
+    iowrite32(0, 
+            _ioa(PC20X_TIMERS_BASE + TIMER_N_CONTROL_REG_OFFSET(OPROF_TICK_TIMER)));
+
+    free_irq(OPROF_TICK_TIMER_IRQ, NULL);
+}
+
+/****************************************************************************
+ * Function Name  : firecracker_oprof_dummy
+ * Description    : Dummy init and setup function.
+ ****************************************************************************/
+static int firecracker_oprof_dummy(void)
+{
+    return 0;
+}
diff -Naur pico_2.6.28/arch/arm/oprofile/op_model_pc302.c ipa_2.6.28/arch/arm/oprofile/op_model_pc302.c
--- pico_2.6.28/arch/arm/oprofile/op_model_pc302.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/arch/arm/oprofile/op_model_pc302.c	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,150 @@
+/*
+ * FILE NAME op_model_pc302.c
+ *
+ * Copyright (c) 2008 ip.access Ltd.
+ *
+ * BRIEF MODULE DESCRIPTION
+ *  Support for async hardware timer for oprofile
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+
+/****************************************************************************
+ * Standard Library Includes
+ ****************************************************************************/
+#include <linux/types.h>
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <linux/oprofile.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/smp.h>
+
+/****************************************************************************
+ * Kernel Includes
+ ****************************************************************************/
+#include "op_counter.h"
+#include "op_arm_model.h"
+
+/****************************************************************************
+  Private Definitions
+ ****************************************************************************/
+/* Converts a physical address number into a pointer to the virtual location */
+#define _ioa(n)     __io(IO_ADDRESS(n))
+
+/****************************************************************************
+  Private Types
+ ****************************************************************************/
+
+/****************************************************************************
+ * Private Function Prototypes
+ ****************************************************************************/
+static irqreturn_t pc302_oprof_interrupt(int irq, void *dev_id);
+static int         pc302_oprof_start(void);
+static void        pc302_oprof_stop(void);
+static int         pc302_oprof_dummy(void);
+
+/****************************************************************************
+ * Private Constants
+ ****************************************************************************/
+/* Use a relatively prime divisor to avoid syncing up to the tick timer */
+#define OPROF_RT_LATCH ((11*19*19*53) - 1)  /* Divisor of 210463 vs 200000 for tick */
+
+/* Use timer 2 for the oprofile sample clock */
+#define OPROF_TICK_TIMER 2
+#define OPROF_TICK_TIMER_IRQ IRQ_TIMER2
+
+/****************************************************************************
+ * Exported Variables
+ ****************************************************************************/
+struct op_arm_model_spec op_pc302_spec = {
+    .init           = pc302_oprof_dummy,
+    .num_counters   = 1,
+    .setup_ctrs     = pc302_oprof_dummy,
+    .start          = pc302_oprof_start,
+    .stop           = pc302_oprof_stop,
+    .name           = "timer",  /* The name must be timer to allow oprofile to analyse results */
+};
+
+/****************************************************************************
+ * Private Variables (Must be declared static)
+ ****************************************************************************/
+
+
+
+/****************************************************************************
+ * Function Name  : pc302_oprof_interrupt
+ * Description    : IRQ handler for the timer.
+ *                  Clears interrupt and takes a sample
+ ****************************************************************************/
+static irqreturn_t pc302_oprof_interrupt(int irq, void *dev_id)
+{
+    struct pt_regs *regs = get_irq_regs();
+
+    // ...clear the interrupt
+    ioread32(_ioa(PC302_TIMER_BASE + TIMERNEOIREGOFFSET(OPROF_TICK_TIMER)));
+
+    oprofile_add_sample(regs, 0);
+
+    return IRQ_HANDLED;
+}
+
+/****************************************************************************
+ * Function Name  : pc302_oprof_start
+ * Description    : Set up the timer and interrupt.
+ ****************************************************************************/
+static int pc302_oprof_start(void)
+{
+    int            ret = 0;
+
+    /* Start with the timer disabled */
+    iowrite32(0,
+            _ioa(PC302_TIMER_BASE + TIMERNCONTROLREGOFFSET(OPROF_TICK_TIMER)));
+
+    /* Set mode  */
+    iowrite32(TIMERMODE,
+            _ioa(PC302_TIMER_BASE + TIMERNCONTROLREGOFFSET(OPROF_TICK_TIMER)));
+
+    /* Set the reload count that gives us the desired interrupt frequency */
+    iowrite32(OPROF_RT_LATCH,
+            _ioa(PC302_TIMER_BASE + TIMERNLOADCOUNTREGOFFSET(OPROF_TICK_TIMER)));
+
+    /* Register interrupt handler */
+    ret = request_irq(OPROF_TICK_TIMER_IRQ, pc302_oprof_interrupt, IRQF_DISABLED, "OProf Tick", NULL);
+
+    if (ret == 0)
+    {
+        /* Set user defined count mode, unmask interrupt and enable the timer */
+        iowrite32((TIMERENABLE | TIMERMODE),
+                _ioa(PC302_TIMER_BASE + TIMERNCONTROLREGOFFSET(OPROF_TICK_TIMER)));
+    }
+
+    return ret;
+}
+
+/****************************************************************************
+ * Function Name  : pc302_oprof_stop
+ * Description    : Stop the timer and interrupt.
+ ****************************************************************************/
+static void pc302_oprof_stop(void)
+{
+    /* Disable the timer */
+    iowrite32(0,
+            _ioa(PC302_TIMER_BASE + TIMERNCONTROLREGOFFSET(OPROF_TICK_TIMER)));
+
+    free_irq(OPROF_TICK_TIMER_IRQ, NULL);
+}
+
+/****************************************************************************
+ * Function Name  : pc302_oprof_dummy
+ * Description    : Dummy init and setup function.
+ ****************************************************************************/
+static int pc302_oprof_dummy(void)
+{
+    return 0;
+}
diff -Naur pico_2.6.28/crypto/authenc.c ipa_2.6.28/crypto/authenc.c
--- pico_2.6.28/crypto/authenc.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/crypto/authenc.c	2011-04-26 14:51:35.000000000 +0100
@@ -157,16 +157,19 @@
 	dstp = sg_page(dst);
 	vdst = PageHighMem(dstp) ? NULL : page_address(dstp) + dst->offset;
 
-	sg_init_table(cipher, 2);
-	sg_set_buf(cipher, iv, ivsize);
-	authenc_chain(cipher, dst, vdst == iv + ivsize);
+	if (ivsize) {
+		sg_init_table(cipher, 2);
+		sg_set_buf(cipher, iv, ivsize);
+		authenc_chain(cipher, dst, vdst == iv + ivsize);
+		dst = cipher;
+	}
 
 	cryptlen = req->cryptlen + ivsize;
-	hash = crypto_authenc_hash(req, flags, cipher, cryptlen);
+	hash = crypto_authenc_hash(req, flags, dst, cryptlen);
 	if (IS_ERR(hash))
 		return PTR_ERR(hash);
 
-	scatterwalk_map_and_copy(hash, cipher, cryptlen,
+	scatterwalk_map_and_copy(hash, dst, cryptlen,
 				 crypto_aead_authsize(authenc), 1);
 	return 0;
 }
@@ -284,11 +287,14 @@
 	srcp = sg_page(src);
 	vsrc = PageHighMem(srcp) ? NULL : page_address(srcp) + src->offset;
 
-	sg_init_table(cipher, 2);
-	sg_set_buf(cipher, iv, ivsize);
-	authenc_chain(cipher, src, vsrc == iv + ivsize);
+	if (ivsize) {
+		sg_init_table(cipher, 2);
+		sg_set_buf(cipher, iv, ivsize);
+		authenc_chain(cipher, src, vsrc == iv + ivsize);
+		src = cipher;
+	}
 
-	return crypto_authenc_verify(req, cipher, cryptlen + ivsize);
+	return crypto_authenc_verify(req, src, cryptlen + ivsize);
 }
 
 static int crypto_authenc_decrypt(struct aead_request *req)
diff -Naur pico_2.6.28/crypto/ipa_keystream.c ipa_2.6.28/crypto/ipa_keystream.c
--- pico_2.6.28/crypto/ipa_keystream.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/crypto/ipa_keystream.c	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,2004 @@
+/****************************************************************************
+ *
+ * IP.ACCESS -
+ *
+ * Copyright (c) 2010 ip.access Ltd.
+ *
+ ****************************************************************************
+ *
+ * $Id: PC202/kernel/kernel-2.6.28/linux-v2.6.28-ipa-3.2.4-patch 1.4.2.18.1.2 2011/11/29 21:21:59GMT Mark Powell (mp3) Exp  $
+ *
+ ****************************************************************************
+ *
+ * File Description : keystream driver using an mmap interface
+ *
+ * Control and status is via ioctl calls.  Keystream data and status is made
+ * available via mmap().  Crypto engine HW DMAs directly into the mmap area,
+ * so care must be taken to ensure that the CPU and DMA don't overwrite each
+ * other's output.
+ *
+ * The mmap area is a series of contiguous requests (wrapping when necessary).
+ * Each request starts with a header of 32 bytes (one cache line) that holds
+ * information to pass back to the caller (pduLength, contextId etc).  The
+ * header is then followed by a block of keystream data that's rounded up to
+ * a multiple of 32 bytes to ensure the next header is still cache aligned.
+ * When a request is made, the count values that are used to form the IV for
+ * the cipher are stored temporarily in the buffer that the result will be
+ * stored in (one per PDU, saved in each PDU's space).  The counts are read
+ * again just before the encryption is started.  This is the only time when
+ * the CPU should access the DMA area in the kernel.  We have to ensure that
+ * nothing we do will corrupt DMAed results.  When the counts are written
+ * we explicitly flush them to SDRAM.  Similarly after we read the count we
+ * invalidate the line we read to ensure that nothing will be tempted to
+ * clean the line.  This shouldn't be necessary if we don't write to the
+ * line in the meantime, but just in case something else is tempted to dirty
+ * the line...
+ *
+ ****************************************************************************/
+
+
+/****************************************************************************
+ * Standard Library Includes
+ ****************************************************************************/
+#include <linux/cdev.h>
+#include <linux/configfs.h>
+#include <linux/crypto.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/gfp.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/poll.h>
+#include <linux/scatterlist.h>
+#include <linux/sched.h>
+#include <linux/semaphore.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/sysfs.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmapool.h>
+#include <linux/mm.h>
+#include <asm/pgtable.h>
+#include <asm/cacheflush.h>
+
+
+/****************************************************************************
+ * Project Includes
+ ****************************************************************************/
+#include <linux/ipa/ipa_keystream.h>
+
+
+/****************************************************************************
+ * Private Definitions
+ ****************************************************************************/
+#define ALLOW_CACHED_USER_READS 
+
+#define IPAC_DEVICE_MAJOR  242
+
+/* We support on f8(kasumi) in this driver */
+#define IPAC_CIPHER_KEY_LENGTH_BITS   128
+#define IPAC_IV_LENGTH_BITS           64
+
+#define IPAC_KEY_BYTES  ((IPAC_CIPHER_KEY_LENGTH_BITS + 7) / 8)
+#define IPAC_IV_LENGTH_BYTES          ((IPAC_IV_LENGTH_BITS + 7) / 8)
+#define IPAC_IV_LENGTH_LONGS          ((IPAC_IV_LENGTH_BITS + 31) / 32)
+
+
+#define DEBUG_BASIC   ( DBG_ALWAYS | DBG_ERROR | DBG_WARN | DBG_NOTICE )
+#define DEBUG_MASK    ( DEBUG_BASIC )
+
+#define PRINTD( _mask, _fmt, ... ) \
+    ({ \
+        if ( _mask & DEBUG_MASK ) \
+            printk( "%s:%u: " _fmt "\n", __FILE__, __LINE__, ##__VA_ARGS__ ); \
+    })
+
+
+/****************************************************************************
+ * Private Types
+ ****************************************************************************/
+typedef enum   IpacDirectionTag     IpacDirection;
+
+typedef struct IpacDeviceTag        IpacDevice;
+typedef struct IpacDeviceNodeTag    IpacDeviceNode;
+typedef struct IpacContextTag       IpacContext;
+typedef struct IpacCipherRequestTag IpacCipherRequest;
+
+enum IpacDebugOptions
+{
+    DBG_ALWAYS     =  (1 <<  0),  /* Used for getting messages during development*/
+    DBG_ERROR      =  (1 <<  1),  /* Critical errors. */
+    DBG_WARN       =  (1 <<  2),  /* Warning messages. */
+    DBG_NOTICE     =  (1 <<  3),  /* Notices of abnormal conditions that the driver should handle. */
+    DBG_FUNC_CALLS =  (1 <<  4),  /* Tracing of function entry and exit. */
+    DBG_BUFFER     =  (1 <<  5),  /* Request buffer handling. */
+    DBG_MEM_CACHE  =  (1 <<  6),  /* Track requests use of the mem cache */
+    DBG_CIPHER     =  (1 <<  7),  /* Track creation and deletion of cipher contexts */
+    DBG_CIPHER_REQ =  (1 <<  8),  /* Track cipher requests */
+    DBG_MMAP       =  (1 <<  9),  /* Track mmap operations */
+    DBG_SCATTER    =  (1 << 10),  /* Track scatter-gather */
+    DBG_PDU_COUNT  =  (1 << 11),  /* Track counting of PDUs within a request */
+};
+
+enum IpacDirectionTag
+{
+    IPAC_UPLINK,
+    IPAC_DOWNLINK
+};
+
+/* We have an array of contexts */
+struct IpacContextTag
+{
+    struct crypto_ablkcipher   *cipher_p;                 /* Pointer to active cipher used for new requests */
+    u32                        cipherActiveRequests;      /* How many requests have been submitted with the current cipher */
+    u32                        ivFixedPart;               /* The combination of binding ID and direction */
+    
+    struct crypto_ablkcipher   *oldCipher_p;              /* Pointer to old cipher used for old requests when switching */
+    u32                        oldCipherActiveRequests;   /* How many requests have still to finish with the old cipher */
+};
+
+/* The driver supports a number of device nodes that are held in an array.
+ * Information specific to each node is held in the following structure.
+ */
+struct IpacDeviceNodeTag
+{
+    u8                 name[16];                    /* A name for the node */
+    spinlock_t         lock;                        /* Lock to allow callbacks and user space calls */
+    int                useCount;                    /* How many clients have opened this node (max one allowed) */
+    IpacDirection      direction;                   /* Whether this node is for uplink or downlink */
+    struct kmem_cache  *requestCache_p;             /* memory pool used for submitting requests */
+    struct device      *dev_p;                      /* Pointer to the device created for this node */
+    u8                 *vm_start;                   /* The start of the memory buffer as seen by the user */
+    u8                 *startOfPool_p;              /* The start of the memory buffer as seen by the kernel */
+    u8                 *endOfPool_p;                /* One past the end of the memory buffer */
+    u8                 *firstRequest_p;             /* Pointer to the first (oldest) request */
+    u8                 *lastRequest_p;              /* Pointer to a marker after the last (newest request) */
+    u32                requestsPending;             /* The number of requests that the user has waiting */
+    u8                 releasingNode;               /* Flag to indicate that the client is closing */
+    u8                 inIoctlCall;                 /* Flag to indicate that the client task is running IOCTL */
+    IpacContext        context[IPAC_NUM_CONTEXTS];  /* Cipher contexts for this node */
+};
+ 
+
+/* Have dynamically allocated requests */
+struct IpacCipherRequestTag
+{
+    struct ablkcipher_request  *areq_p;
+    u32                        iv[IPAC_IV_LENGTH_LONGS];
+    struct scatterlist         src;
+    struct scatterlist         dst[2]; /* dest buffer could be split across two pages */
+    struct list_head           list;
+    IpacRequest                *request_p;
+};
+  
+/* Info about the driver/device */
+struct IpacDeviceTag {
+    struct cdev     cdev;
+    dev_t           devno;
+    struct class    *sysfs_class;
+};
+
+/****************************************************************************
+ * Private Function Prototypes (Must be declared static)
+ ****************************************************************************/
+
+/* Callback functions for cipher */
+static void ipacCipherCallback( struct crypto_async_request *req_p, int err );
+static void ipacCipherComplete( struct crypto_async_request *req_p, int err );
+
+/* Module operations */
+static int ipacRelease( struct inode *inode, struct file *filp );
+static int ipacOpen( struct inode *inode, struct file *filp );
+static int ipacMmap( struct file *filp, struct vm_area_struct *vma );
+static int ipacIoctl( struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg );
+static ssize_t ipacRead( struct file *filp, char __user *buf, size_t buf_len, loff_t *offset );
+
+/* Mmap operations */
+static void ipacVmaOpen( struct vm_area_struct *vma );
+static void ipacVmaClose( struct vm_area_struct *vma );
+static int ipacVmaFault( struct vm_area_struct *vma, struct vm_fault *vmf );
+
+/****************************************************************************
+ * Private Constants (Must be declared static)
+ ****************************************************************************/
+
+
+/****************************************************************************
+ * Exported Variables
+ ****************************************************************************/
+
+ 
+/****************************************************************************
+ * Private Variables (Must be declared static)
+ ****************************************************************************/
+ 
+static struct file_operations ipacFileOps = {
+    .owner    = THIS_MODULE,
+    .open     = ipacOpen,
+    .release  = ipacRelease,
+    .ioctl    = ipacIoctl,
+    .read     = ipacRead,
+    .mmap     = ipacMmap,
+};
+
+static struct vm_operations_struct ipacNopageVmOps = {
+    .open     = ipacVmaOpen,
+    .close    = ipacVmaClose,
+    .fault    = ipacVmaFault,
+};
+
+
+/* Zeroed page used for generating keystreams. */
+static void           *ipacZeroedPage = NULL;
+static IpacDevice      ipacDevice;
+static IpacDeviceNode  ipacNodes[IPAC_MAX_DRIVER_NODES];
+
+
+/******************************************************************************
+ * Function Name : ipacFlushRequestInfo
+ * Inputs        : request_p - Pointer to request header to flush.
+ *
+ * Description   : This function will clean a single request header from the
+ *                 data cache to the SDRAM.  If the user space is accessing the
+ *                 request headers then this is necessary to ensure that any
+ *                 updates made in kernel space are seen in user space.
+ *
+ *****************************************************************************/
+static void ipacFlushRequestInfo(const IpacRequest  *request_p)
+{
+    u8  *start_p = (u8*)request_p;
+    u8  *end_p   = ((u8*)(request_p+1)) - 1;
+
+    PRINTD(DBG_FUNC_CALLS, "ipacFlushRequestInfo(%p)", request_p);
+ 
+    dmac_clean_range(start_p, end_p);
+    
+    PRINTD(DBG_FUNC_CALLS, "ipacFlushRequestInfo out");
+}
+
+#ifdef ALLOW_CACHED_USER_READS 
+/******************************************************************************
+ * Function Name : ipacInvalidateCipherData
+ * Inputs        : start_p - Pointer to first byte to invalidate
+ *                 end_p   - Pointer to last byte to invalidate
+ *
+ * Description   : This function will invalidate the cache line(s) holding a
+ *                 cipher stream.  That ensures that the user app can see new
+ *                 data, but still get the advantages of burst reads via the
+ *                 data cache.
+ *
+ *****************************************************************************/
+static void ipacInvalidateCipherData(u8* start_p, u8* end_p)
+{
+    PRINTD(DBG_FUNC_CALLS, "ipacInvalidateCipherData(%p, %p)", start_p, end_p);
+ 
+    dmac_inv_range(start_p, end_p);
+    
+    PRINTD(DBG_FUNC_CALLS, "ipacInvalidateCipherData out");
+}
+#endif
+
+/******************************************************************************
+ * Function Name : ipacCreateCipher
+ * Inputs        : request_p - Pointer to request header to flush.
+ *
+ * Description   : Create a block cipher and set the key
+ *
+ *****************************************************************************/
+static struct crypto_ablkcipher* ipacCreateCipher(const u8*  key_p,
+                                                  u32        keyLen)
+{
+    struct crypto_ablkcipher  *cipher = NULL;
+    int                       ret;
+    
+    PRINTD(DBG_FUNC_CALLS, "ipacCreateCipher(%p, %u)", key_p, keyLen);
+ 
+    if (IPAC_KEY_BYTES != keyLen)
+    {
+        PRINTD(DBG_NOTICE,
+               "Unexpected length for f8(kasumi) key.  Wanted %d, but got %d",
+               IPAC_KEY_BYTES, keyLen);
+               
+        cipher = NULL;
+    }
+    else
+    {
+        PRINTD(DBG_CIPHER, "Allocating cipher for f8(kasumi)");
+        cipher = crypto_alloc_ablkcipher( "f8(kasumi)", 0, 0);
+        if ( IS_ERR( cipher ) )
+        {
+            PRINTD(DBG_NOTICE, "Failed to allocate ablkcipher for f8(kasumi)");
+            cipher = NULL;
+        }
+        else
+        {
+            PRINTD(DBG_CIPHER, "Allocated cipher %p for f8(kasumi)", cipher);
+        
+            PRINTD(DBG_CIPHER, "Setting key (len=%d) for cipher %p",
+                                keyLen, cipher);
+                                
+            PRINTD(DBG_CIPHER, "%02X %02X %02X %02X %02X ...",
+                                key_p[0], key_p[1], key_p[2], key_p[3], key_p[4]);
+            
+            ret = crypto_ablkcipher_setkey( cipher, key_p, keyLen );
+            if (ret)
+            {
+                PRINTD(DBG_NOTICE,
+                       "Freeing ablkcipher %p for f8(kasumi); setkey failure",
+                        cipher);
+                        
+                crypto_free_ablkcipher( cipher );
+                cipher = NULL;
+            }
+            else
+            {
+                PRINTD(DBG_CIPHER, "Setkey for cipher %p OK", cipher);
+            }
+        }
+    }
+        
+    PRINTD(DBG_FUNC_CALLS, "ipacCreateCipher returned %p", cipher);
+ 
+    return cipher;
+}
+
+/******************************************************************************
+ * Function Name : ipacSetupContext
+ * Inputs        : context_p   - Pointer to the context to configure.
+ *                 ioctl_p     - Pointer to data passed by user request
+ *                 direction   - uplink/downlink 
+ *                 saveCurrent - whether to backup existing cipher info
+ *                 cipher_p    - Pointer to the cipher to associate with the
+ *                               context.
+ *
+ * Description   : Setup a context for a supplied cipher.  If necessary the
+ *                 existing cipher will be backed up so that requests that
+ *                 are already queued will be able to complete.
+ *
+ *****************************************************************************/
+static void ipacSetupContext(IpacContext              *context_p,
+                            IpacContextIoctl          *ioctl_p,
+                            u32                       direction,
+                            int                       saveCurrent,
+                            struct crypto_ablkcipher  *cipher_p)
+{
+    u32  bearerId  = ioctl_p->bearerId;
+   
+    PRINTD(DBG_FUNC_CALLS, "ipacSetupContext(%p, %p, %u, %d, %p)",
+                            context_p, ioctl_p, direction, saveCurrent, cipher_p);
+ 
+    context_p->ivFixedPart = htonl(((bearerId & 0x1F) << 27) | ((direction & 1) << 26));
+    
+    if (saveCurrent)
+    {
+        /* Keep the old cipher around for a while if there are requests that 
+         * still have to be actioned with the current cipher.
+         */
+        if (context_p->cipherActiveRequests)
+        {
+            PRINTD(DBG_CIPHER, "Backing up cipher %p to oldCipher", context_p->cipher_p);
+            context_p->oldCipher_p             = context_p->cipher_p;
+            context_p->oldCipherActiveRequests = context_p->cipherActiveRequests;
+        }
+        else
+        {
+            PRINTD(DBG_CIPHER, "Freeing cipher %p; update with no clients", context_p->cipher_p);
+            crypto_free_ablkcipher( context_p->cipher_p );
+            context_p->oldCipher_p             = NULL;
+            context_p->oldCipherActiveRequests = 0;
+        }
+    }
+    
+    context_p->cipher_p = cipher_p;
+    context_p->cipherActiveRequests = 0;
+    
+    PRINTD(DBG_FUNC_CALLS, "ipacSetupContext out");
+}
+
+/******************************************************************************
+ * Function Name : ipacAllocateContext
+ * Inputs        : filp    - file info associated with user's file descriptor
+ *                 ioctl_p - Pointer to the context info passed by the user.
+ *
+ * Description   : Look for a free context and allocate it to the user.
+ *                 Configure the context with the data passed by the user.
+ *
+ *****************************************************************************/
+static int ipacAllocateContext(struct file       *filp, 
+                               IpacContextIoctl  *ioctl_p)
+{
+    struct crypto_ablkcipher   *cipher_p = NULL;
+    u32                        keyLength = IPAC_KEY_BYTES;
+    IpacDeviceNode             *node_p   = filp->private_data;
+    int                        ret       = -EBUSY;
+    int                        contextId;
+    
+    PRINTD(DBG_FUNC_CALLS, "ipacAllocateContext(%p, %p)", filp, ioctl_p);
+
+    /* Create the cipher before we acquire the spin lock.  Once we have
+     * the spin lock, attempt to associate the cipher with an unused context.
+     * If that association fails, we must free the cipher after releasing
+     * the spin lock.
+     */ 
+    cipher_p = ipacCreateCipher(&ioctl_p->cipherKey[0], keyLength);
+    if (cipher_p == NULL)
+    {
+        PRINTD(DBG_NOTICE, "Unable to create cipher");
+        return -ENOMEM;
+    }
+    
+    spin_lock_bh( &node_p->lock );
+    
+    /* Search for an unused context (one that doesn't have an associated ciper) */
+    for (contextId=0; contextId<IPAC_NUM_CONTEXTS; ++contextId)
+    {
+        IpacContext *context_p = &node_p->context[contextId];
+        
+        if (context_p->cipher_p == NULL)
+        {
+            ipacSetupContext(context_p, ioctl_p, node_p->direction, 0, cipher_p);
+            ret = contextId;
+            break;
+        }
+    }
+
+    spin_unlock_bh( &node_p->lock );
+    
+    if (ret == -EBUSY)
+    {
+        /* Failed to find unused context.  Discard the new cipher */
+        crypto_free_ablkcipher( cipher_p );
+    }
+    
+    PRINTD(DBG_FUNC_CALLS, "ipacAllocateContext returned %d", ret);
+    
+    return ret;
+}
+
+/******************************************************************************
+ * Function Name : ipacDeallocateContext
+ * Inputs        : filp      - file info associated with user's file descriptor
+ *                 contextId - Index of the context to be freed
+ *
+ * Description   : Free a context previously allocated to the user.
+ *
+ *****************************************************************************/
+static int ipacDeallocateContext(struct file  *filp,
+                                 int          contextId)
+{
+    IpacDeviceNode *node_p    = filp->private_data;
+    IpacContext    *context_p = NULL;
+    int            ret        = 0;
+
+    PRINTD(DBG_FUNC_CALLS, "ipacDeallocateContext(%p, %d)", filp, contextId);
+ 
+    spin_lock_bh( &node_p->lock );
+    
+    if ((contextId < 0) || (contextId >= IPAC_NUM_CONTEXTS))
+    {
+        PRINTD(DBG_NOTICE, "Invalid contextId %d", contextId);
+        ret = -EINVAL;
+    }
+    else
+    {
+        context_p = &node_p->context[contextId];
+    
+        if (context_p->cipher_p == NULL)
+        {
+            PRINTD(DBG_NOTICE, "No cipher associated with context to be deallocated");
+            ret = -ENOENT;
+        }
+        else if ((context_p->oldCipher_p != NULL) && (context_p->cipherActiveRequests != 0))
+        {
+            PRINTD(DBG_NOTICE, "Already have two ciphers running, so deallocate can't be done yet");
+            ret = -EBUSY;
+        }
+        else
+        {
+            /* Deactivate current cipher, but watch for existing requests */
+            if (context_p->cipherActiveRequests)
+            {
+                PRINTD(DBG_CIPHER, "Saving cipher %p as oldCipher", context_p->cipher_p);
+                context_p->oldCipher_p             = context_p->cipher_p;
+                context_p->oldCipherActiveRequests = context_p->cipherActiveRequests;
+            }
+            else
+            {
+                PRINTD(DBG_CIPHER, "Releasing cipher %p ", context_p->cipher_p);
+                crypto_free_ablkcipher( context_p->cipher_p );
+            }
+        
+            context_p->cipher_p             = NULL;
+            context_p->cipherActiveRequests = 0;
+            
+            ret = 0;
+        }
+    }
+    
+    spin_unlock_bh( &node_p->lock );
+
+    PRINTD(DBG_FUNC_CALLS, "ipacDeallocateContext returned %d", ret);
+ 
+    return ret;
+}
+
+/******************************************************************************
+ * Function Name : ipacUpdateContext
+ * Inputs        : filp    - file info associated with user's file descriptor
+ *                 ioctl_p - Pointer to the context info passed by the user.
+ *
+ * Description   : Update a context with the information passed by the user.
+ *
+ *****************************************************************************/
+static int ipacUpdateContext(struct file       *filp,
+                             IpacContextIoctl  *ioctl_p)
+{
+    struct crypto_ablkcipher   *cipher_p  = NULL;
+    u32                        keyLength  = IPAC_KEY_BYTES;
+    IpacDeviceNode             *node_p    = filp->private_data;
+    int                        contextId  = ioctl_p->contextId;
+    IpacContext                *context_p = NULL;
+    int                        ret        = -EINVAL;
+    
+    PRINTD(DBG_FUNC_CALLS, "ipacUpdateContext(%p, %p)", filp, ioctl_p);
+ 
+    /* Create the cipher before we acquire the spin lock.    Once we have
+     * the spin lock, attempt to update the context with the new cipher.
+     * If that update fails, we must free the cipher after releasing
+     * the spin lock.
+     */ 
+    cipher_p = ipacCreateCipher(&ioctl_p->cipherKey[0], keyLength);
+    if (cipher_p == NULL)
+    {
+        PRINTD(DBG_NOTICE, "Unable to create cipher");
+        return -ENOMEM;
+    }
+    
+    spin_lock_bh( &node_p->lock );
+    
+    if ((contextId < 0) || (contextId >= IPAC_NUM_CONTEXTS))
+    {
+        PRINTD(DBG_NOTICE, "Invalid contextId %d", contextId);
+        ret = -EINVAL;
+    }
+    else
+    {
+        context_p = &(node_p->context[contextId]);
+    
+        if ((context_p->cipher_p != NULL) && (context_p->oldCipher_p != NULL))
+        {
+            /* Both in use */
+            PRINTD(DBG_NOTICE, "contextId %d is too busy", contextId);
+            ret = -EAGAIN;
+        }
+        else if (context_p->cipher_p != NULL)
+        {
+            /* Current is in use, move to old */
+            ipacSetupContext(context_p, ioctl_p, node_p->direction, 1, cipher_p);
+            ret = contextId;
+        }
+        else
+        {
+            /* Current is not in use, can't update */
+            PRINTD(DBG_NOTICE, "contextId %d is not in use", contextId);
+            ret = -ENOENT;
+        }
+    }
+    
+    spin_unlock_bh( &node_p->lock );
+    
+    if (ret < 0)
+    {
+        /* Failed to update context.  Discard the new cipher */
+        crypto_free_ablkcipher( cipher_p );
+    }
+    
+    PRINTD(DBG_FUNC_CALLS, "ipacUpdateContext returned %d", ret);
+ 
+    return ret;
+}
+
+/******************************************************************************
+ * Function Name : ipacSetRequestParameters
+ * Inputs        : request_p - Pointer to request structure to fill in
+ *                 needed    - Number of bytes to allow for keystream data
+ *                 filp      - file info associated with user's file descriptor
+ *                 start_p   - Pointer to start request info from user
+ *
+ * Description   : Setup a request structure with enough information to start
+ *                 the the request and to return the results to the user once
+ *                 the request has completed.
+ *
+ *****************************************************************************/
+static void ipacSetRequestParameters(IpacRequest     *request_p,
+                                     u32             needed,
+                                     struct file     *filp,
+                                     IpacStartIoctl  *start_p)
+{
+    IpacDeviceNode  *node_p    = filp->private_data;
+    IpacContext     *context_p = &node_p->context[start_p->contextId];
+
+    PRINTD(DBG_FUNC_CALLS, "ipacSetRequestParameters(%p, %u, %p, %p)",
+                            request_p, needed, filp, start_p);
+
+    /* This info has to be returned to the user */ 
+    request_p->transactionId = start_p->transactionId;
+    request_p->contextId     = start_p->contextId;
+    request_p->numberOfPdus  = start_p->numPdus;
+    request_p->pduLength     = start_p->pduLength;
+
+    /* This info is needed to submit the request and handle the completion */
+    request_p->channel       = node_p - ipacNodes;
+    request_p->cipher_p      = context_p->cipher_p;
+    request_p->ivFixedPart   = context_p->ivFixedPart;
+    request_p->reservedBytes = needed;
+    request_p->pdusCompleted = 0;
+    
+    /* Track use of each cipher so we know when it's safe to clean them up */
+    context_p->cipherActiveRequests += start_p->numPdus;
+    
+    PRINTD(DBG_FUNC_CALLS, "ipacSetRequestParameters out");
+}
+
+
+/******************************************************************************
+ * Function Name : ipacSubmitRequest
+ * Inputs        : node_p    - Pointer to device node
+ *                 request_p - Pointer to request header in memory buffer
+ *
+ * Description   : Takes the information for a cipher request from the
+ *                 memory pool and submits it to the cipher engine.
+ *
+ *****************************************************************************/
+static int ipacSubmitRequest(IpacDeviceNode  *node_p,
+                             IpacRequest     *request_p,
+                             IpacStartIoctl  *start_p)
+{
+    u8  *pduBuffer_p   = NULL;
+    u32 *counts_p      = start_p->counts;
+    int  ret           = 0;
+    u32  pdu;
+    
+    PRINTD(DBG_FUNC_CALLS, "ipacSubmitRequest(%p, %p, %p)", node_p, request_p, start_p);
+ 
+    if (request_p == NULL)
+    {
+        PRINTD(DBG_ERROR, "Invalid (null) request_p");
+        ret = -EINVAL;
+        goto out;
+    }
+    
+    pduBuffer_p = (u8*)(request_p+1);
+    
+    request_p->state = IPAC_REQUEST_CIPHERING;
+
+    for (pdu=0; pdu<request_p->numberOfPdus; ++pdu)
+    {
+        IpacCipherRequest  *cipherRequest_p = NULL;
+        u32                count            = 0;
+        int                clen             = request_p->pduLength;
+       
+        PRINTD(DBG_MEM_CACHE, "Allocating request from cache %s for count %u",
+                               node_p->name, count);
+                               
+        if (copy_from_user(&count, counts_p, sizeof(u32)))
+        {
+            PRINTD(DBG_NOTICE, "Unable to copy counts[%d/%d] from user space at %p",
+                                pdu, start_p->numPdus, start_p->counts);
+            ret = -EINVAL;
+            
+            /* Since we haven't submitted all the PDUs we will terminiate
+             * waiting for results early too */
+            request_p->numberOfPdus  = pdu;
+            
+            goto out;
+        }
+        counts_p++;
+                               
+        cipherRequest_p = kmem_cache_alloc( node_p->requestCache_p, GFP_ATOMIC );
+        if ( !cipherRequest_p )
+        {
+            PRINTD(DBG_NOTICE, "Unable to allocate cipherRequest_p");
+            ret = -ENOMEM;
+            
+            /* Since we haven't submitted all the PDUs we will terminiate
+             * waiting for results early too */
+            request_p->numberOfPdus  = pdu;
+            
+            goto out;
+        }
+        
+        PRINTD(DBG_MEM_CACHE, "Allocated %p from request cache %s for count %u",
+                               cipherRequest_p, node_p->name, count);
+        
+        cipherRequest_p->request_p = request_p;
+        
+        PRINTD(DBG_CIPHER_REQ, "Allocating cipher request for cipher %p",
+                                request_p->cipher_p);
+                                
+        cipherRequest_p->areq_p = ablkcipher_request_alloc( request_p->cipher_p, GFP_ATOMIC );
+        if ( !cipherRequest_p->areq_p )
+        {
+            PRINTD(DBG_NOTICE, "Unable to allocate cipher request for cipher %p", request_p->cipher_p);
+            ret = -ENOMEM;
+            
+            PRINTD(DBG_MEM_CACHE, "Freeing request %p to request cache %s", cipherRequest_p, node_p->name);
+            kmem_cache_free( node_p->requestCache_p, cipherRequest_p );
+            
+            
+            /* Since we haven't submitted all the PDUs we will terminiate
+             * waiting for results early too */
+            request_p->numberOfPdus  = pdu;
+            
+            goto out;
+        }
+        
+        PRINTD(DBG_CIPHER_REQ, "Allocated cipher request %p for cipher %p",
+                                cipherRequest_p->areq_p, request_p->cipher_p);
+
+        /* Create the IV for the request. */
+        cipherRequest_p->iv[0] = htonl(count);
+        cipherRequest_p->iv[1] = request_p->ivFixedPart;
+
+        /* Single memory page in use */
+        sg_init_table( &cipherRequest_p->dst[0], 1 );
+        sg_set_buf( &cipherRequest_p->dst[0], pduBuffer_p, clen );
+        
+        PRINTD(DBG_CIPHER_REQ, "Setting callback for cipher request %p", cipherRequest_p->areq_p);
+        
+        ablkcipher_request_set_callback( cipherRequest_p->areq_p, CRYPTO_TFM_REQ_MAY_BACKLOG,
+                                            ipacCipherCallback, request_p );
+                                            
+        PRINTD(DBG_CIPHER_REQ, "Setting crypt params for cipher request %p", cipherRequest_p->areq_p);
+        
+        ablkcipher_request_set_crypt( cipherRequest_p->areq_p, 0,
+                                      &cipherRequest_p->dst[0], clen, cipherRequest_p->iv );
+    
+        PRINTD(DBG_CIPHER_REQ, "Starting encrypt for cipher request %p", cipherRequest_p->areq_p);
+        
+        ret = crypto_ablkcipher_encrypt( cipherRequest_p->areq_p );
+        if ( !ret )
+        {
+            /* We have completed synchronously. Call the completion function.
+                * This will free the request for us. */
+            PRINTD(DBG_CIPHER_REQ, "Encrypt for cipher request %p finished synchronously",
+                                    cipherRequest_p->areq_p);
+                                    
+            ipacCipherComplete( &cipherRequest_p->areq_p->base, 0 );
+        }
+        else if ( -EINPROGRESS == ret )
+        {
+            PRINTD(DBG_CIPHER_REQ, "Encrypt for cipher request %p is in progress",
+                                    cipherRequest_p->areq_p);
+                                    
+            ret = 0;
+        }
+        else
+        {
+            PRINTD(DBG_NOTICE, "encryption failed with %d", ret );
+            
+            ret = -ENOMEM;
+            
+            /* Since we haven't submitted all the PDUs we will terminiate
+             * waiting for results early too */
+            request_p->numberOfPdus  = pdu;
+            
+            goto out;
+        }
+        
+        pduBuffer_p += request_p->pduLength;
+    }
+    
+out:
+    PRINTD(DBG_BUFFER, "After submit requestpool=%p, end=%p, first=%p, last=%p",
+                        node_p->startOfPool_p, node_p->endOfPool_p, node_p->firstRequest_p,
+                        node_p->lastRequest_p);
+    PRINTD(DBG_FUNC_CALLS, "ipacSubmitRequest returned %d", ret);
+ 
+    return 0;
+}
+
+/******************************************************************************
+ * Function Name : ipacCipherComplete
+ * Inputs        : req_p - Pointer to the cipher request that was submitted
+ *                 err   - Status of the cipher request
+ *
+ * Description   : Called when the cipher engine has completed a cipher
+ *                 request.  The request in the memory pool is updated.
+ *
+ *****************************************************************************/
+static void ipacCipherComplete(struct crypto_async_request  *req_p,
+                               int                          err)
+{
+    IpacRequest               *request_p       = req_p->data;
+    struct ablkcipher_request *ablk_req_p      = ablkcipher_request_cast( req_p );
+    IpacCipherRequest         *cipherRequest_p = container_of( ablk_req_p->dst, IpacCipherRequest, dst[0] );
+    IpacDeviceNode            *node_p          = &ipacNodes[request_p->channel];
+    
+    PRINTD(DBG_FUNC_CALLS, "ipacCipherComplete(%p, %d)", req_p, err);
+ 
+    if ( !err )
+    {
+        struct crypto_ablkcipher  *cipher_p     = request_p->cipher_p;
+        int                        contextId = request_p->contextId;
+        IpacContext         *context_p    = &(node_p->context[contextId]);
+        
+        if (cipher_p == context_p->cipher_p)
+        {
+            PRINTD(DBG_CIPHER_REQ, "Completed cipher request %p for current cipher %p", ablk_req_p, cipher_p);
+            
+            context_p->cipherActiveRequests--;
+        }
+        else if (cipher_p == context_p->oldCipher_p)
+        {
+            PRINTD(DBG_CIPHER_REQ, "Completed cipher request %p for old cipher %p", ablk_req_p, cipher_p);
+            
+            context_p->oldCipherActiveRequests--;
+            
+            if (context_p->oldCipherActiveRequests == 0)
+            {
+                /* This request will not be used any more */
+                PRINTD(DBG_CIPHER, "Freeing old cipher %p; no old clients left", cipher_p);
+                context_p->oldCipher_p = NULL;
+                crypto_free_ablkcipher( cipher_p );
+            }
+        }
+        
+        request_p->pdusCompleted++;
+        PRINTD(DBG_PDU_COUNT, "Completed %d pdus of %d", request_p->pdusCompleted, request_p->numberOfPdus);
+        if (request_p->pdusCompleted == request_p->numberOfPdus)
+        {
+            /* Entire request has been completed and can now be returned */
+            request_p->state = IPAC_REQUEST_COMPLETED;
+        }
+    }
+    else
+    {
+        PRINTD(DBG_NOTICE, "encryption on keystream channel %lu failed "
+                "with code %d", request_p->channel, err );
+    }
+    
+    PRINTD(DBG_CIPHER_REQ, "Freeing cipher request %p", cipherRequest_p->areq_p);
+    ablkcipher_request_free( cipherRequest_p->areq_p );
+    cipherRequest_p->areq_p = NULL;
+    
+    PRINTD(DBG_MEM_CACHE, "Freeing request %p to request cache %s", cipherRequest_p, node_p->name);
+    kmem_cache_free( node_p->requestCache_p, cipherRequest_p );
+    
+    PRINTD(DBG_FUNC_CALLS, "ipacCipherComplete out");
+}
+
+/******************************************************************************
+ * Function Name : ipaCipherCallback
+ * Inputs        : req_p - Pointer to the cipher request that was submitted
+ *                 err   - Status of the cipher request
+ *
+ * Description   : Cipher engine callback routine.  Calls completion function.
+ *
+ *****************************************************************************/
+static void ipacCipherCallback(struct crypto_async_request  *req_p,
+                               int                          err)
+{
+    IpacRequest     *request_p = req_p->data;
+    IpacDeviceNode  *node_p    = &ipacNodes[request_p->channel];
+   
+    PRINTD(DBG_FUNC_CALLS, "ipacCipherCallback(%p, %d)", req_p, err);
+ 
+    spin_lock_bh( &node_p->lock );
+    
+    ipacCipherComplete( req_p, err );
+    
+    spin_unlock_bh( &node_p->lock );
+    
+    PRINTD(DBG_FUNC_CALLS, "ipacCipherCallback out");
+}
+
+/******************************************************************************
+ * Function Name : ipacAllocateRequestBuffer
+ * Inputs        : filp      - file info for user's file descriptor
+ *                 start_p   - Pointer to the user's request information
+ *                 numPdus   - Number of PDUs to allocate
+ *                 pduLength - Size of each PDU in bytes
+ * Outputs       : buffer_pp - Pointer to allocated request header
+ *
+ * Description   : Checks for space for the PDUs.  If the caller has passed
+ *                 in a non-NULL buffer_pp then the buffer space will actually
+ *                 be reserved and the header of the reserved buffer will be
+ *                 returned in buffer_pp.
+ *
+ *****************************************************************************/
+static int ipacAllocateRequestBuffer(struct file     *filp,
+                                     IpacStartIoctl  *start_p,
+                                     u32             numPdus,
+                                     u32             pduLength,
+                                     IpacRequest     **buffer_pp)
+{
+    IpacDeviceNode  *node_p     = filp->private_data;
+    IpacRequest     *buffer     = NULL;
+    IpacRequest     *lastBuffer = NULL;
+    IpacRequest     *wrapBuffer = NULL;
+    static u32      align       = 0xFFFFFFFF;
+    int             needed      = numPdus * pduLength;
+    int             ret         = -ENOMEM;
+    
+    PRINTD(DBG_FUNC_CALLS, "ipacAllocateRequestBuffer(%p, %p, %u, %u, %p)",
+                            filp, start_p, numPdus, pduLength, buffer_pp);
+    
+    spin_lock_bh( &node_p->lock );
+    
+    if (align == 0xFFFFFFFF)
+    {
+        /* Determine the minimum alignment requirement for the IpacRequest - 1 */
+        align = offsetof(struct {u8 dummy; IpacRequest x; }, x) - 1;
+        if (align < 31)
+        {
+             align = 31;
+        }
+        PRINTD(DBG_BUFFER, "buffer alignment is %u", align+1);
+    }
+    
+    /* Round the needed bytes up to keep the headers correctly aligned. */
+    needed += align;
+    needed |= align;
+    needed -= align;
+
+    PRINTD(DBG_BUFFER, "Need %u bytes for %u of %u", needed, numPdus, pduLength);
+    
+    if (node_p->firstRequest_p > node_p->lastRequest_p)
+    {
+        /* Buffer has wrapped, so the available space lies between the last and first
+         *                |......L         F.....  |
+         */
+        int midSpace = node_p->firstRequest_p - node_p->lastRequest_p - 2*sizeof(IpacRequest);
+        
+        PRINTD(DBG_BUFFER, "MID space is %d bytes", midSpace);
+
+        if (midSpace > needed)
+        {
+            PRINTD(DBG_BUFFER, "Can use MID space");
+            if (buffer_pp)
+            {
+                buffer  = (IpacRequest *)node_p->lastRequest_p;
+                
+                node_p->lastRequest_p += needed + sizeof(IpacRequest);
+                lastBuffer = (IpacRequest *)node_p->lastRequest_p;
+                
+                PRINTD(DBG_BUFFER, "Inserting new=%p, last=%p", buffer, lastBuffer);
+                memset(lastBuffer, 0, sizeof(lastBuffer));
+                ipacSetRequestParameters(buffer, needed, filp, start_p);
+                
+                lastBuffer->state = IPAC_REQUEST_FINAL;
+                buffer->state = IPAC_REQUEST_WAITING;
+
+                *buffer_pp = buffer;
+            }
+            
+            ret = 0;
+        }
+    }
+    else
+    {
+        /* Buffer hasn't wrapped, so there's potentially space both after the last and
+         * before the first.
+         *           |    F.......L   |
+         */
+         int headSpace = node_p->firstRequest_p - node_p->startOfPool_p - 2*sizeof(IpacRequest);
+         int tailSpace = node_p->endOfPool_p    - node_p->lastRequest_p - 2*sizeof(IpacRequest);
+         
+         PRINTD(DBG_BUFFER, "HEAD space is %d bytes", headSpace);
+         PRINTD(DBG_BUFFER, "TAIL space is %d bytes", tailSpace);
+
+         if (tailSpace >= needed)
+         {
+            PRINTD(DBG_BUFFER, "Can use TAIL space");
+            if (buffer_pp)
+            {
+                buffer  = (IpacRequest *)node_p->lastRequest_p;
+                node_p->lastRequest_p += needed + sizeof(IpacRequest);
+                lastBuffer = (IpacRequest *)node_p->lastRequest_p;
+                
+                PRINTD(DBG_BUFFER, "Appending new=%p, last=%p", buffer, lastBuffer);
+                memset(lastBuffer, 0, sizeof(lastBuffer));
+                ipacSetRequestParameters(buffer, needed, filp, start_p);
+                
+                lastBuffer->state = IPAC_REQUEST_FINAL;
+                buffer->state = IPAC_REQUEST_WAITING;
+
+                *buffer_pp = buffer;
+            }
+            
+            ret = 0;
+         }
+         else if (headSpace >= needed)
+         {
+            PRINTD(DBG_BUFFER, "Can use HEAD space");
+            if (buffer_pp)
+            {
+                wrapBuffer = (IpacRequest *)node_p->lastRequest_p;
+                buffer = (IpacRequest *)node_p->startOfPool_p;
+                node_p->lastRequest_p = node_p->startOfPool_p + needed + sizeof(IpacRequest);
+                lastBuffer = (IpacRequest *)node_p->lastRequest_p;
+                
+                PRINTD(DBG_BUFFER, "Wrapping wrap=%p, new=%p, last=%p", wrapBuffer, buffer, lastBuffer);
+                ipacSetRequestParameters(buffer, needed, filp, start_p);
+                memset(lastBuffer, 0, sizeof(lastBuffer));
+                
+                lastBuffer->state = IPAC_REQUEST_FINAL;
+                wrapBuffer->state = IPAC_REQUEST_WRAPPED;
+                buffer->state = IPAC_REQUEST_WAITING;
+
+                *buffer_pp = buffer;
+            }
+            
+            ret = 0;
+         }
+    }
+    
+    PRINTD(DBG_BUFFER, "After alloc request pool=%p, end=%p, first=%p, last=%p",
+                        node_p->startOfPool_p, node_p->endOfPool_p, node_p->firstRequest_p,
+                        node_p->lastRequest_p);
+    
+    spin_unlock_bh( &node_p->lock );
+
+    if (lastBuffer)
+    {
+        ipacFlushRequestInfo(lastBuffer);
+    }
+    if (wrapBuffer)
+    {
+        ipacFlushRequestInfo(wrapBuffer);
+    }
+    if (buffer)
+    {
+        ipacFlushRequestInfo(buffer);
+    }
+
+    PRINTD(DBG_FUNC_CALLS, "ipacAllocateRequestBuffer returned %d", ret);
+    
+    return ret;
+}
+
+/******************************************************************************
+ * Function Name : ipacCheckSpace
+ * Inputs        : filp             - Info associated with user's file desc.
+ *                 maxSpaceRequired - Number of bytes needed.
+ *
+ * Description   : Ioctl handler function for determining if there is space
+ *                 available for a request.
+ *
+ *****************************************************************************/
+static int ipacCheckSpace(struct file  *filp,
+                          u32          maxSpaceRequired)
+{
+    IpacDeviceNode     *node_p = filp->private_data;
+    int                ret     = 0;
+    
+    PRINTD(DBG_FUNC_CALLS, "ipacCheckSpace(%p, %u)", filp, maxSpaceRequired);
+    
+    if (IPAC_MAX_NUM_BUFFERS_ALLOWED && (node_p->requestsPending >= IPAC_MAX_NUM_BUFFERS_ALLOWED))
+    {
+        PRINTD(DBG_NOTICE, "More than the maximum number of requests would be active");
+        ret = -EBUSY;
+        goto out;
+    }
+    
+    ret = ipacAllocateRequestBuffer(filp, NULL, 1, maxSpaceRequired, NULL);
+    
+    PRINTD(DBG_FUNC_CALLS, "ipacCheckSpace returned %d", ret);
+
+out:    
+    return ret;
+}
+
+/******************************************************************************
+ * Function Name : ipacStartCipher
+ * Inputs        : filp    - Info associated with user's file descriptor.
+ *                 start_p - Pointer to the user data passed in the ioctl
+ *
+ * Description   : Validate a user request for generating cipher data.  If
+ *                 it's OK then add the request to the buffer and mark it
+ *                 waiting.  If the request can then be submitted to the
+ *                 cipher engine then do that too.
+ *
+ *****************************************************************************/
+static int ipacStartCipher(struct file     *filp,
+                           IpacStartIoctl  *start_p)
+{
+    IpacDeviceNode  *node_p      = filp->private_data;
+    IpacRequest     *request_p   = NULL;
+    int             ret          = -ENOMEM;
+   
+    PRINTD(DBG_FUNC_CALLS, "ipacStartCipher(%p, %p)", filp, start_p);
+    
+    
+    /* Ensure we have a valid context */
+    if (!node_p->context[start_p->contextId].cipher_p)
+    {
+        PRINTD(DBG_NOTICE, "Context is not valid");
+        ret = -EINVAL;
+        goto out;
+    }
+   
+    /* Ensure the pduLength is a multiple of 4 */
+    if (start_p->pduLength % 4)
+    {
+        PRINTD(DBG_NOTICE, "PDU is not a mutiple of 4 bytes");
+        ret = -EINVAL;
+        goto out;
+    }
+    
+    if (IPAC_MAX_NUM_BUFFERS_ALLOWED && (node_p->requestsPending >= IPAC_MAX_NUM_BUFFERS_ALLOWED))
+    {
+        PRINTD(DBG_NOTICE, "More than the maximum number of requests would be active");
+        ret = -EBUSY;
+        goto out;
+    }
+    
+    PRINTD(DBG_PDU_COUNT, "Requesting %u pdus of %u bytes", start_p->numPdus, start_p->pduLength);
+    ret = ipacAllocateRequestBuffer(filp, start_p, start_p->numPdus, start_p->pduLength, &request_p);
+    if (ret)
+    {
+        PRINTD(DBG_NOTICE, "Request failed %d", ret);
+        goto out;
+    }
+    
+    node_p->requestsPending++;
+    
+    ret = ipacSubmitRequest(node_p, request_p, start_p);
+
+out:
+    
+    PRINTD(DBG_FUNC_CALLS, "ipacStartCipher returned %d", ret);
+    
+    return ret;
+}
+
+/******************************************************************************
+ * Function Name : ipaCheckCryptoReady
+ * Inputs        : filp - Info associated with user's file descriptor.
+ *
+ * Description   : Check whether there are any requests that have finished
+ *                 that can be returned to the user.
+ *
+ *****************************************************************************/
+static int ipacCheckCryptoReady(struct file  *filp)
+{
+    IpacDeviceNode     *node_p    = filp->private_data;
+    IpacRequest        *request_p = NULL;
+    IpacRequest        *flush_p   = NULL;
+    int                ret        = 0;
+   
+    PRINTD(DBG_FUNC_CALLS, "ipacCheckCryptoReady(%p)", filp);
+    
+    spin_lock_bh( &node_p->lock );
+    
+    request_p = (IpacRequest*)node_p->firstRequest_p;
+    
+    PRINTD(DBG_BUFFER, "CheckCryptoReady firstRequest_p is %p(%d)",
+                        node_p->firstRequest_p, request_p->state);
+ 
+    if (request_p->state == IPAC_REQUEST_WRAPPED)
+    {
+        PRINTD(DBG_BUFFER, "Reached end of the buffer.  Wrapping to start of buffer");
+        flush_p = request_p;
+        node_p->firstRequest_p = node_p->startOfPool_p;
+        request_p = (IpacRequest*)node_p->firstRequest_p;
+    }
+    
+    if (request_p->state == IPAC_REQUEST_COMPLETED)
+    {
+        PRINTD(DBG_BUFFER, "Marking returned buffer at %p", request_p);
+        request_p->state = IPAC_REQUEST_RETURNED;
+
+        ret = node_p->firstRequest_p - node_p->startOfPool_p;
+    }
+    else if (request_p->state == IPAC_REQUEST_RETURNED)
+    {
+        PRINTD(DBG_BUFFER, "Buffer is still marked as returned at %p", request_p);
+
+        ret = node_p->firstRequest_p - node_p->startOfPool_p;
+    }
+    else
+    {
+        ret = -EBUSY;
+    }
+    
+    spin_unlock_bh( &node_p->lock );
+
+    if (flush_p)
+    {
+        ipacFlushRequestInfo(flush_p);
+    }
+    
+    ipacFlushRequestInfo(request_p);
+    
+    PRINTD(DBG_FUNC_CALLS, "ipacCheckCryptoReady returned %d", ret);
+
+    return ret;    
+}
+
+/******************************************************************************
+ * Function Name : ipacRead
+ * Inputs        : filp    - Info associated with user's file descriptor
+ *                 buf     - User buffer to fill
+ *                 buf_len - Max number of bytes to return
+ *                 offset  - file offset (not used)
+ *
+ * Description   : This provides an alternative interface to the mmap().
+ *                 Using this it is possible to read the cipher data back
+ *                 with a read() system call.  This function was added for
+ *                 initial testing and is not intended for use under normal
+ *                 circumstances.
+ *
+ *****************************************************************************/
+static ssize_t ipacRead(struct file  *filp,
+                        char __user  *buf,
+                        size_t       buf_len,
+                        loff_t       *offset )
+{
+    IpacDeviceNode  *node_p    = filp->private_data;
+    IpacRequest     *request_p = NULL;
+    int             ret        = 0;
+   
+    PRINTD(DBG_FUNC_CALLS, "ipacRead(%p, %p, %d, %p)", filp, buf, buf_len, offset);
+    
+    spin_lock_bh( &node_p->lock );
+    
+    request_p = (IpacRequest*)node_p->firstRequest_p;
+    
+    PRINTD(DBG_BUFFER, "Read firstRequest_p is %p(%d)", node_p->firstRequest_p, request_p->state);
+ 
+    if (request_p->state == IPAC_REQUEST_WRAPPED)
+    {
+        PRINTD(DBG_BUFFER, "Reached end of the buffer.  Wrapping to start of buffer");
+        node_p->firstRequest_p = node_p->startOfPool_p;
+        request_p = (IpacRequest*)node_p->firstRequest_p;
+    }
+    
+    if ((request_p->state == IPAC_REQUEST_COMPLETED) || (request_p->state == IPAC_REQUEST_RETURNED))
+    {
+        size_t  bytes_to_copy = min( buf_len, sizeof(IpacRequest)+request_p->numberOfPdus*request_p->pduLength);
+
+        /* If an attempt at reading fails, the user space app is free to either try again,
+         * or discard the data by unloading it and continuing.
+         */
+        PRINTD(DBG_BUFFER, "Marking returned buffer at %p", request_p);
+        request_p->state = IPAC_REQUEST_RETURNED;
+        
+        spin_unlock_bh( &node_p->lock );
+    
+        ret = copy_to_user( buf, request_p, bytes_to_copy );
+        if ( ret )
+        {
+            PRINTD(DBG_NOTICE, "Unable to copy request_p to user space at %p", buf);
+            ret = -EFAULT;
+        }
+        else
+        {
+            ipacFlushRequestInfo(request_p);
+    
+            ret = bytes_to_copy;
+        }
+    }
+    else
+    {
+        spin_unlock_bh( &node_p->lock );
+        ret = -EBUSY;
+    }
+    
+    PRINTD(DBG_FUNC_CALLS, "ipacRead returned %d", ret);
+    
+    return ret;
+}
+
+
+/******************************************************************************
+ * Function Name : ipacBufferUnload
+ * Inputs        : filp - Info associated with user's file descriptor
+ *
+ * Description   : This function is called (via an ioctl) when the user has
+ *                 finished with the cipher data in a request buffer.  It
+ *                 allows the driver to reclaim the buffer space for further
+ *                 requests.
+ *
+ *****************************************************************************/
+static int ipacBufferUnload(struct file *filp)
+{
+    IpacDeviceNode  *node_p          = filp->private_data;
+    IpacRequest     *request_p       = NULL;
+    IpacRequest     *flushPreWrap_p  = NULL;
+    IpacRequest     *flushResult_p   = NULL;
+    IpacRequest     *flushPostWrap_p = NULL;
+    int             ret              = 0;
+   
+    PRINTD(DBG_FUNC_CALLS, "ipacBufferUnload(%p)", filp);
+    
+    PRINTD(DBG_BUFFER, "BufferUnload firstRequest_p is %p", node_p->firstRequest_p);
+ 
+    spin_lock_bh( &node_p->lock );
+    
+    request_p = (IpacRequest*)node_p->firstRequest_p;
+    
+    if (request_p->state == IPAC_REQUEST_WRAPPED)
+    {
+        PRINTD(DBG_BUFFER, "Reached end of the buffer.  Wrapping to start of buffer");
+        request_p->state = IPAC_REQUEST_UNUSED;
+        flushPreWrap_p = request_p;
+        node_p->firstRequest_p = node_p->startOfPool_p;
+        request_p = (IpacRequest*)node_p->firstRequest_p;
+    }
+    
+    if (request_p->state != IPAC_REQUEST_RETURNED)
+    {
+        spin_unlock_bh( &node_p->lock );
+        PRINTD(DBG_NOTICE, "Buffer being unloaded isn't completed");
+        ret = -EINVAL;
+    }
+    else
+    {
+#ifdef ALLOW_CACHED_USER_READS 
+        u8   *start_p = ((u8*)request_p - node_p->startOfPool_p) + node_p->vm_start;
+        u8   *end_p   = start_p + request_p->reservedBytes + sizeof(IpacRequest);
+#endif
+
+        PRINTD(DBG_BUFFER, "Moving past %d bytes of space", request_p->reservedBytes);
+    
+        flushResult_p = request_p;
+        
+        request_p->state = IPAC_REQUEST_UNUSED;
+        node_p->firstRequest_p += request_p->reservedBytes + sizeof(IpacRequest);
+    
+        request_p = (IpacRequest*)node_p->firstRequest_p;
+    
+        node_p->requestsPending--;
+
+        if (request_p->state == IPAC_REQUEST_WRAPPED)
+        {
+            PRINTD(DBG_BUFFER, "Reached end of the buffer.  Wrapping to start of buffer");
+            request_p->state = IPAC_REQUEST_UNUSED;
+            flushPostWrap_p = request_p;
+            node_p->firstRequest_p = node_p->startOfPool_p;
+        }
+        
+        spin_unlock_bh( &node_p->lock );
+
+#ifdef ALLOW_CACHED_USER_READS
+        ipacInvalidateCipherData(start_p, end_p);
+#endif
+        
+        ipacFlushRequestInfo(flushResult_p);
+        
+        if (flushPostWrap_p)
+        {
+            ipacFlushRequestInfo(flushPostWrap_p);
+        }
+        
+        PRINTD(DBG_BUFFER, "After buffer unload pool=%p, end=%p, first=%p, last=%p",
+                            node_p->startOfPool_p, node_p->endOfPool_p, node_p->firstRequest_p,
+                            node_p->lastRequest_p);
+    }
+
+    if (flushPreWrap_p)
+    {    
+        ipacFlushRequestInfo(flushPreWrap_p);
+    }
+    
+    PRINTD(DBG_FUNC_CALLS, "ipacBufferUnload returned %d", ret);
+    
+    return ret;
+}
+
+/******************************************************************************
+ * Function Name : ipacIoctl
+ * Inputs        : inode - inode associated with the dev node
+ *                 filp  - info associated with the user's file descriptor
+ *                 cmd   - the ioctl cmd
+ *                 arg   - the arg associated with the cmd
+ *
+ * Description   : This is the ioctl handler for the driver.  It passes any
+ *                 recognised commands to specific handler functions.
+ *
+ *****************************************************************************/
+static int ipacIoctl( struct inode   *inode,
+                      struct file    *filp,
+                      unsigned int    cmd,
+                      unsigned long   arg )
+{
+    IpacStartIoctl    startIoctl;
+    IpacContextIoctl  contextIoctl;
+    int               ret          = 0;
+
+    PRINTD(DBG_FUNC_CALLS, "ipacIoctl(%p, %p, %u, %lu)", inode, filp, cmd, arg);
+    
+    /* don't even decode wrong cmds: better returning  ENOTTY than EFAULT */
+    if (_IOC_TYPE(cmd) != IPAC_IOCTL_MAGIC){
+        PRINTD(DBG_NOTICE, "Invalid ioctl command 0x%x (arg=%lu)", cmd, arg );
+        ret = -ENOTTY;
+    }
+    else if (_IOC_NR(cmd) > IPAC_IOCTL_MAXNR)
+    {
+        PRINTD(DBG_NOTICE, "Invalid ioctl command 0x%x (arg=%lu)", cmd, arg );
+        ret = -ENOTTY;
+    }
+    else
+    {
+        IpacDeviceNode  *node_p       = filp->private_data;
+
+        /* Atomically check whether the file is closing and, if not, indicate
+         * to the ipacRelease function that we are busy processing an ioctl
+         * request.
+         */
+        spin_lock_bh( &node_p->lock );
+        if (node_p->releasingNode)
+        {
+            spin_unlock_bh( &node_p->lock );
+            ret = -EBUSY;
+        }
+        else
+        {
+            node_p->inIoctlCall++;
+            spin_unlock_bh( &node_p->lock );
+
+            switch (cmd)
+            {
+            case IPAC_IOCTL_ALLOC_CONTEXT:
+                if (copy_from_user( &contextIoctl, (void*)arg, sizeof(contextIoctl)))
+                {
+                    PRINTD(DBG_NOTICE, "Unable to copy ioctl data from user");
+                    ret = -EINVAL;
+                }
+                else if (contextIoctl.contextId < 0)
+                {
+                    ret = ipacAllocateContext(filp, &contextIoctl);
+                }
+                else
+                {
+                    ret = ipacUpdateContext(filp, &contextIoctl);
+                }
+                break;
+        
+            case IPAC_IOCTL_DEALLOC_CONTEXT:
+                ret = ipacDeallocateContext(filp, arg);
+                break;
+        
+            case IPAC_IOCTL_CHECK_SPACE:
+                ret = ipacCheckSpace(filp, arg);
+                break;
+        
+            case IPAC_IOCTL_START_CRYPTO:
+                if (copy_from_user( &startIoctl, (void*)arg, sizeof(startIoctl)))
+                {
+                    PRINTD(DBG_NOTICE, "Unable to copy ioctl data from user");
+                    ret = -EINVAL;
+                }
+                else
+                {
+                    ret = ipacStartCipher(filp, &startIoctl);
+                }
+                break;
+        
+            case IPAC_IOCTL_CHECK_CRYPTO_READY:
+                ret = ipacCheckCryptoReady(filp);
+                break;
+        
+            case IPAC_IOCTL_BUFFER_UNLOAD:
+                ret = ipacBufferUnload(filp);
+                break;
+        
+            default:
+                /* redundant, as cmd was checked against MAXNR */
+                ret = -ENOTTY;
+            }
+
+            /* No longer busy in ioctl */
+            spin_lock_bh( &node_p->lock );
+            if (node_p->inIoctlCall > 0)
+            {
+                node_p->inIoctlCall--;
+            }
+            spin_unlock_bh( &node_p->lock );
+        }
+    }
+
+    PRINTD(DBG_FUNC_CALLS, "ipacIoctl returned %d", ret);
+    
+    return ret;
+}
+
+/******************************************************************************
+ * Function Name : ipacVmaOpen
+ * Inputs        : vma - Pointer to the vma associated with the mmap
+ *
+ * Description   : Dummy function
+ *
+ *****************************************************************************/
+static void ipacVmaOpen(struct vm_area_struct *vma)
+{
+    PRINTD(DBG_FUNC_CALLS, "ipacVmaOpen(%p)", vma );
+    PRINTD(DBG_FUNC_CALLS, "ipacVmaOpen out");
+}
+
+/******************************************************************************
+ * Function Name : ipacVmaClose
+ * Inputs        : vma - Pointer to the vma associated with the mmap
+ *
+ * Description   : Dummy function
+ *
+ *****************************************************************************/
+static void ipacVmaClose(struct vm_area_struct *vma)
+{
+    PRINTD(DBG_FUNC_CALLS, "ipacVmaClose(%p)", vma );
+    PRINTD(DBG_FUNC_CALLS, "ipacVmaClose out");
+}
+
+/******************************************************************************
+ * Function Name : ipacVmaFault 
+ * Inputs        : vma - Pointer to the vma associated with the mmap
+ *                 vmf - Pointer to a structure for passing page fault info.
+ *
+ * Description   : This is the mmap page fault handler.  As the user space
+ *                 accesses pages in the mapped area, this is called to map
+ *                 the user space to the kernel pages used for the buffer.
+ *
+ *****************************************************************************/
+static int ipacVmaFault(struct vm_area_struct *vma, struct vm_fault *vmf)
+{
+    IpacDeviceNode     *node_p  = vma->vm_private_data;
+    struct page        *page    = NULL;
+    u8*                offset   = NULL;
+    int                ret      = 0;
+
+    PRINTD(DBG_FUNC_CALLS, "ipacVmaFault(%p, %p)", vma, vmf);
+    
+    PRINTD(DBG_MMAP, "Offsets %p %lx %p.", vmf->virtual_address, vma->vm_start, node_p->startOfPool_p );
+
+    offset = ((unsigned long)vmf->virtual_address - vma->vm_start) + node_p->startOfPool_p;
+    if (offset >= node_p->endOfPool_p)
+    {
+        PRINTD(DBG_NOTICE, "Address %p is beyond end of buffer %p.", offset, node_p->endOfPool_p );
+        ret = VM_FAULT_SIGBUS;
+    }
+    else
+    {
+        PRINTD(DBG_MMAP, "Offset is %p.", offset );
+        
+        page = virt_to_page(offset);
+        PRINTD(DBG_MMAP, "Page is %p.", page );
+        get_page(page);
+        vmf->page = page;
+    }
+
+    PRINTD(DBG_FUNC_CALLS, "ipacVmaFault returned %d", ret);
+    
+    return ret;
+}
+
+/******************************************************************************
+ * Function Name : ipacMmap
+ * Inputs        : filp - Info associated with the user's file descriptor.
+ *                 vma  - vma structure describing mapped area.
+ *
+ * Description   : Defines a non-cached mapping for the mmap()ed area requested
+ *                 by the user.
+ *
+ *****************************************************************************/
+static int ipacMmap( struct file *filp, struct vm_area_struct *vma )
+{
+    IpacDeviceNode     *node_p = filp->private_data;
+    int                ret     = 0;
+    
+    PRINTD(DBG_FUNC_CALLS, "ipacMmap(%p, %p)", filp, vma);
+    
+    vma->vm_ops = &ipacNopageVmOps;
+    vma->vm_flags |= VM_RESERVED | VM_IO;
+    vma->vm_private_data = node_p;
+#ifndef ALLOW_CACHED_USER_READS
+    vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+#endif
+    ipacVmaOpen(vma);
+
+    node_p->vm_start = (u8*)vma->vm_start;
+
+    PRINTD(DBG_FUNC_CALLS, "ipacMmap returned %d", ret);
+    
+    return ret;
+}
+
+/******************************************************************************
+ * Function Name : ipacOpen
+ * Inputs        : inode - inode associated with the device
+ *                 filp  - user's file descriptor info
+ *
+ * Description   : The open() call handler for the device.
+ *
+ *****************************************************************************/
+/*
+ * Open a keystream device node. This uses the minor number of the device node
+ * to find the channel to associate with. The device is marked as unconfigured
+ * until the client has set the direction using an ioctl call
+ */
+static int ipacOpen( struct inode *inode, struct file  *filp )
+{
+    int               minor      = iminor( inode );
+    unsigned          minor_base = MINOR( ipacDevice.devno );
+    unsigned          channel    = minor - minor_base;
+    IpacDeviceNode    *node_p    = NULL;
+    int               contextId  = 0;
+    IpacRequest       *buffer    = NULL;
+    int               ret        = 0;
+
+    PRINTD(DBG_FUNC_CALLS, "ipacOpen(%p, %p)", inode, filp);
+    
+    if ( channel >= IPAC_MAX_DRIVER_NODES )
+    {
+        PRINTD(DBG_NOTICE, "Invalid device number %d is > %d", channel, IPAC_MAX_DRIVER_NODES);
+        ret = -ENODEV;
+    }
+    else
+    {
+        node_p = &ipacNodes[ channel ];
+    
+        spin_lock_bh( &node_p->lock );
+    
+        if ( node_p->useCount != 0)
+        {
+            spin_unlock_bh( &node_p->lock );
+            PRINTD(DBG_NOTICE, "Device number %d is already in use", channel);
+            ret = -EBUSY;
+        }
+        else
+        {
+            node_p->useCount = 1;
+            
+            for (contextId=0; contextId<IPAC_NUM_CONTEXTS; ++contextId)
+            {
+                node_p->context[contextId].cipher_p    = NULL;
+                node_p->context[contextId].oldCipher_p = NULL;
+            }
+        
+            node_p->firstRequest_p = node_p->startOfPool_p;
+            node_p->lastRequest_p  = node_p->startOfPool_p;
+        
+            node_p->requestsPending = 0;
+
+            buffer = (IpacRequest*)(node_p->firstRequest_p);
+            buffer->state = IPAC_REQUEST_FINAL;
+        
+            /* Odd channels are for downlink, even for uplink */    
+            if (channel & 1)
+            {
+                node_p->direction = IPAC_DOWNLINK;
+            }
+            else
+            {
+                node_p->direction = IPAC_UPLINK;
+            }
+            
+            spin_unlock_bh( &node_p->lock );
+            
+            ipacFlushRequestInfo(buffer);
+            
+            filp->private_data = node_p;
+        }
+    }
+
+    PRINTD(DBG_FUNC_CALLS, "ipacOpen returned %d", ret);
+    
+    return ret;
+}
+
+/******************************************************************************
+ * Function Name : ipacRelease
+ * Inputs        : inode - inode associated with the device
+ *                 filp  - user's file descriptor info
+ *
+ * Description   : The close() call handler for the device. 
+ *
+ *****************************************************************************/
+static int ipacRelease(struct inode  *inode,
+                       struct file   *filp)
+{
+    IpacDeviceNode     *node_p   = filp->private_data;
+    int                contextId = 0;
+    int                ret       = 0;
+    int                busy      = 0;
+    int                retries   = 100; /* Allow at least 200 ms to complete */
+    
+    PRINTD(DBG_FUNC_CALLS, "ipacRelease(%p, %p)", inode, filp);
+    
+    spin_lock_bh( &node_p->lock );
+
+    /* Wait till any last active IOCTL call has been completed and all the
+     * active cipher requests for this node have completed.
+     */
+    node_p->releasingNode = 1;
+
+    do
+    {
+        busy = 0;
+
+        retries--;
+
+        if (node_p->inIoctlCall)
+        {
+            busy = 1;
+        }
+        else
+        {
+            for (contextId=0; contextId<IPAC_NUM_CONTEXTS; ++contextId)
+            {
+                IpacContext   *context_p = &(node_p->context[contextId]);
+                
+                if (context_p->oldCipherActiveRequests || context_p->cipherActiveRequests)
+                {
+                    /* Have to wait for at least one request to complete */
+                    busy = 1;
+                    break;
+                }
+            }
+        }
+
+        if (busy)
+        {
+            /* Wait for activity to stop.  This shouldn't take long. */
+            spin_unlock_bh( &node_p->lock );
+            msleep(2);
+            spin_lock_bh( &node_p->lock );
+        }
+        
+    } while (busy && (retries > 0));
+
+    if (busy)
+    {
+        ret = -EBUSY;
+    }
+    else
+    {
+        /* All requests are complete, and new IOCTL calls are being bounced,
+         * so there can be no more requests and it's safe to release all the
+         * cipher contexts.
+         */
+        for (contextId=0; contextId<IPAC_NUM_CONTEXTS; ++contextId)
+        {
+            IpacContext  *context_p = &(node_p->context[contextId]);
+        
+            if (context_p->cipher_p != NULL)
+            {
+                PRINTD(DBG_CIPHER, "Freeing current cipher %p in release", context_p->cipher_p);
+                crypto_free_ablkcipher( context_p->cipher_p );
+                context_p->cipher_p    = NULL;
+            }
+        
+            if (context_p->oldCipher_p != NULL)
+            {
+                PRINTD(DBG_CIPHER, "Freeing old cipher %p in release", context_p->oldCipher_p);
+                crypto_free_ablkcipher( context_p->oldCipher_p );
+                context_p->oldCipher_p = NULL;
+            }
+        }
+
+        /* Allow this node to be reopened. */
+        node_p->useCount = 0;
+    }
+
+    node_p->releasingNode = 0;
+    spin_unlock_bh( &node_p->lock );
+
+    PRINTD(DBG_FUNC_CALLS, "ipacRelease returned %d", ret);
+    
+    return ret;
+}
+
+/******************************************************************************
+ * Function Name : ipac_init
+ * Inputs        : -
+ *
+ * Description   : Called when the module is loaded.
+ *
+ *****************************************************************************/
+static int ipac_init( void )
+{
+    IpacDeviceNode  *node_p = NULL;
+    IpacRequest     *buffer = NULL;
+    int             ret     = -ENOMEM;
+    int             i;
+
+    PRINTD(DBG_FUNC_CALLS, "ipac_init()");
+
+    for (i=0; i<IPAC_MAX_DRIVER_NODES; ++i)
+    {
+        memset(&ipacNodes[i], 0, sizeof(IpacDeviceNode));
+
+        spin_lock_init( &ipacNodes[i].lock );
+        strcpy(ipacNodes[i].name, "reqx");
+        ipacNodes[i].name[3] = '0' + i;
+    }
+    
+    ipacZeroedPage = ( void * )get_zeroed_page( GFP_KERNEL );
+    if ( !ipacZeroedPage )
+    {
+        PRINTD(DBG_ERROR, KERN_INFO "failed to allocate zeroed page" );
+        goto out;
+    }
+
+    cdev_init( &ipacDevice.cdev, &ipacFileOps );
+    ipacDevice.cdev.owner = THIS_MODULE;
+    ipacDevice.cdev.ops   = &ipacFileOps;
+
+    ipacDevice.devno = MKDEV(IPAC_DEVICE_MAJOR, 0);
+
+    ret = register_chrdev_region( ipacDevice.devno, IPAC_MAX_DRIVER_NODES, "ipa_crypto" );
+    if ( ret )
+    {
+        PRINTD(DBG_ERROR, "failed to allocate dev node range" );
+        goto alloc_failed;
+    }
+
+    ipacDevice.sysfs_class = class_create( THIS_MODULE, "ipa_crypto" );
+    for ( i = 0; i < IPAC_MAX_DRIVER_NODES; ++i )
+    {
+        ipacNodes[i].dev_p =  device_create( ipacDevice.sysfs_class, NULL,
+                                             MKDEV( MAJOR( ipacDevice.devno ),
+                                             MINOR( ipacDevice.devno ) + i ), NULL,
+                                             "ipa_crypto%u", i );
+        if (ipacNodes[i].dev_p == NULL)
+        {
+            PRINTD(DBG_ERROR, "failed to create device %d", ret );
+            ret = -ENOMEM;
+            goto device_creation_failed;
+        }
+
+        ipacNodes[i].dev_p->coherent_dma_mask = 0xFFFFFFFF;
+        ipacNodes[i].dev_p->dma_mask = &(ipacNodes[i].dev_p->coherent_dma_mask);
+    }
+
+
+    /* Create a request cache for each node */
+    for ( i = 0; i < IPAC_MAX_DRIVER_NODES; ++i )
+    {
+        node_p = &ipacNodes[i];
+        
+        node_p->requestCache_p = kmem_cache_create( node_p->name, sizeof(IpacCipherRequest), 0, 0, NULL );
+        if (node_p->requestCache_p == NULL)
+        {
+            ret = -ENOMEM;
+            PRINTD(DBG_ERROR, "failed to allocate memory for pool" );
+            goto dma_cache_alloc_failed;
+        }
+    }
+    
+    ret = cdev_add( &ipacDevice.cdev, ipacDevice.devno, IPAC_MAX_DRIVER_NODES );
+    if ( ret )
+    {
+        PRINTD(DBG_ERROR, "failed to add cdev" );
+        goto cdev_add_failed;
+    }
+    
+    for ( i = 0; i < IPAC_MAX_DRIVER_NODES; ++i )
+    {
+        node_p = &ipacNodes[i];
+        
+        node_p->startOfPool_p = kmalloc(IPAC_KEYSTREAM_BUFFER_SIZE, GFP_KERNEL | __GFP_DMA);
+        if ( node_p->startOfPool_p == NULL )
+        {
+            ret = -ENOMEM;
+            PRINTD(DBG_ERROR, "failed to allocate memory for pool" );
+            goto dma_alloc_failed;
+        }
+
+        node_p->endOfPool_p    = node_p->startOfPool_p + IPAC_KEYSTREAM_BUFFER_SIZE;
+        node_p->firstRequest_p = node_p->startOfPool_p;
+        node_p->lastRequest_p  = node_p->startOfPool_p;
+        
+        node_p->requestsPending = 0;
+
+        buffer = (IpacRequest*)(node_p->firstRequest_p);
+        buffer->state = IPAC_REQUEST_FINAL;
+        ipacFlushRequestInfo(buffer);
+    }
+
+    ret = 0;    
+    goto out;
+
+dma_alloc_failed:
+    for ( i = 0; i < IPAC_MAX_DRIVER_NODES; ++i )
+    {
+        node_p = &ipacNodes[i];
+        
+        if (node_p->startOfPool_p)
+        {
+            kfree(node_p->startOfPool_p);
+            node_p->startOfPool_p = NULL;
+        }
+    }
+    cdev_del( &ipacDevice.cdev );
+dma_cache_alloc_failed:
+    for ( i = 0; i < IPAC_MAX_DRIVER_NODES; ++i )
+    {
+        node_p = &ipacNodes[i];
+        
+        if (node_p->requestCache_p)
+        {
+            kmem_cache_destroy( node_p->requestCache_p );
+            node_p->requestCache_p = NULL;
+        }
+    }
+device_creation_failed:
+    for ( i = 0; i < IPAC_MAX_DRIVER_NODES; ++i )
+    {
+        if (ipacNodes[i].dev_p)
+        {
+            device_destroy( ipacDevice.sysfs_class,
+                            MKDEV( MAJOR( ipacDevice.devno ),
+                            MINOR( ipacDevice.devno ) + i ) );
+        }
+    }
+    class_destroy( ipacDevice.sysfs_class );
+cdev_add_failed:
+    unregister_chrdev_region( ipacDevice.devno, IPAC_MAX_DRIVER_NODES );
+alloc_failed:
+    free_page( ( unsigned long )ipacZeroedPage );
+out:
+    
+    PRINTD(DBG_FUNC_CALLS, "ipac_init returned %d", ret);
+
+    return ret;
+}
+
+/******************************************************************************
+ * Function Name : ipac_exit
+ * Inputs        : -
+ *
+ * Description   : Cleanup when the module is unloaded
+ *
+ *****************************************************************************/
+static void ipac_exit( void )
+{
+    IpacDeviceNode    *node_p = NULL;
+    int               i;
+
+    PRINTD(DBG_FUNC_CALLS, "ipac_exit()");
+
+    /* TODO Will have to clean up all allocated memory before unloading the driver */
+
+    for ( i = 0; i < IPAC_MAX_DRIVER_NODES; ++i )
+    {
+        node_p = &ipacNodes[i];
+        
+        if (node_p->startOfPool_p)
+        {
+            kfree(node_p->startOfPool_p);
+            node_p->startOfPool_p = NULL;
+        }
+
+        if (node_p->requestCache_p)
+        {
+            kmem_cache_destroy( node_p->requestCache_p );
+            node_p->requestCache_p = NULL;
+        }
+    }
+    
+    cdev_del( &ipacDevice.cdev );
+    for ( i = 0; i < IPAC_MAX_DRIVER_NODES; ++i )
+    {
+        device_destroy( ipacDevice.sysfs_class,
+                        MKDEV( MAJOR( ipacDevice.devno ),
+                               MINOR( ipacDevice.devno ) + i ) );
+    }
+    class_destroy( ipacDevice.sysfs_class );
+
+    unregister_chrdev_region( ipacDevice.devno, IPAC_MAX_DRIVER_NODES );
+    free_page( ( unsigned long )ipacZeroedPage );
+    
+    PRINTD(DBG_FUNC_CALLS, "ipac_exit out");
+}
+
+module_init( ipac_init );
+module_exit( ipac_exit );
+
+MODULE_AUTHOR("ip.access");
+MODULE_DESCRIPTION("ipacrypto user interface driver for f8(kasumi)");
+MODULE_LICENSE( "GPL" );
diff -Naur pico_2.6.28/crypto/Kconfig ipa_2.6.28/crypto/Kconfig
--- pico_2.6.28/crypto/Kconfig	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/crypto/Kconfig	2011-04-26 14:51:35.000000000 +0100
@@ -744,6 +744,15 @@
           read into userspace applications and XOR'd with plaintext/ciphertext
           to perform encryption/decryption in a stream cipher mode.
 
+config IPA_KEYSTREAM
+        tristate "ioctl/mmap based keystream generator"
+        select CONFIGFS_FS
+        help
+          This option enables the keystream generator that provides an ioctl/mmap
+          based API to use block ciphers to generate a keystream that can be
+          read into userspace applications and XOR'd with plaintext/ciphertext
+          to perform encryption/decryption in a stream cipher mode.
+
 source "drivers/crypto/Kconfig"
 
 endif	# if CRYPTO
diff -Naur pico_2.6.28/crypto/keystream.c ipa_2.6.28/crypto/keystream.c
--- pico_2.6.28/crypto/keystream.c	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/crypto/keystream.c	2011-04-26 14:51:35.000000000 +0100
@@ -17,7 +17,7 @@
 #include <linux/sysfs.h>
 
 /*! The number of keystream generator device nodes to create. */
-#define MAX_KS_NODES    8
+#define MAX_KS_NODES    96
 
 #define MAX_IV_LEN      32
 
diff -Naur pico_2.6.28/crypto/Makefile ipa_2.6.28/crypto/Makefile
--- pico_2.6.28/crypto/Makefile	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/crypto/Makefile	2011-04-26 14:51:35.000000000 +0100
@@ -78,6 +78,7 @@
 obj-$(CONFIG_CRYPTO_ANSI_CPRNG) += ansi_cprng.o
 obj-$(CONFIG_CRYPTO_TEST) += tcrypt.o
 obj-$(CONFIG_KEYSTREAM) += keystream.o
+obj-$(CONFIG_IPA_KEYSTREAM) += ipa_keystream.o
 
 #
 # generic algorithms and the async_tx api
diff -Naur pico_2.6.28/drivers/char/tpm/Kconfig ipa_2.6.28/drivers/char/tpm/Kconfig
--- pico_2.6.28/drivers/char/tpm/Kconfig	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/drivers/char/tpm/Kconfig	2011-04-26 14:51:35.000000000 +0100
@@ -46,6 +46,15 @@
 	  will be accessible from within Linux.  To compile this driver 
 	  as a module, choose M here; the module will be called tpm_atmel.
 
+config TCG_ATMEL_TWI
+	tristate "Atmel TWI TPM Interface"
+	depends on I2C
+	---help---
+	  If you have a TPM security chip from Atmel that uses the Two Wire
+	  Interface say Yes and it will be accessible from within Linux.
+	  To compile this driver as a module, choose M here; the module
+	  will be called tpm_atmel_twi.
+
 config TCG_INFINEON
 	tristate "Infineon Technologies TPM Interface"
 	depends on PNP
diff -Naur pico_2.6.28/drivers/char/tpm/Makefile ipa_2.6.28/drivers/char/tpm/Makefile
--- pico_2.6.28/drivers/char/tpm/Makefile	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/drivers/char/tpm/Makefile	2011-04-26 14:51:35.000000000 +0100
@@ -8,4 +8,5 @@
 obj-$(CONFIG_TCG_TIS) += tpm_tis.o
 obj-$(CONFIG_TCG_NSC) += tpm_nsc.o
 obj-$(CONFIG_TCG_ATMEL) += tpm_atmel.o
+obj-$(CONFIG_TCG_ATMEL_TWI) += tpm_atmel_twi.o
 obj-$(CONFIG_TCG_INFINEON) += tpm_infineon.o
diff -Naur pico_2.6.28/drivers/char/tpm/tpm_atmel_twi.c ipa_2.6.28/drivers/char/tpm/tpm_atmel_twi.c
--- pico_2.6.28/drivers/char/tpm/tpm_atmel_twi.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/char/tpm/tpm_atmel_twi.c	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,303 @@
+/*
+ * Copyright (C) 2009 ip.access Ltd
+ *
+ * Authors:
+ *
+ * Device driver for TCG/TCPA TPM (trusted platform module).
+ * Specifications at www.trustedcomputinggroup.org	 
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation, version 2 of the
+ * License.
+ * 
+ */
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include "tpm.h"
+
+/* read status bits */
+enum tpm_atmel_twi_read_status {
+	TPM_ATMEL_TWI_STATUS_BUSY  = 0x01,
+	TPM_ATMEL_TWI_STATUS_READY = 0x02
+};
+
+enum tpm_atmel_twi_defaults {
+	TPM_ATMEL_TWI_SHORT_TIMEOUT = 750,	/* ms */
+	TPM_ATMEL_TWI_LONG_TIMEOUT  = 2000,	/* 2 sec */
+};
+
+/* Addresses to scan */
+static const unsigned short normal_i2c[] = { 0x29, I2C_CLIENT_END };
+
+/* Insmod parameters */
+I2C_CLIENT_INSMOD_1(atmel_twi);
+
+static const struct i2c_device_id atmel_twi_id[] = {
+	{ "atmel_twi", atmel_twi },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, atmel_twi_id);
+
+/* device specific function to read from the TPM using I2C */
+static int tpm_atmel_twi_recv(struct tpm_chip *chip, u8 *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(chip->dev);
+	u8 *hdr = buf + 2;
+	u32 size;
+	int len;
+	
+	dev_dbg(chip->dev, "recv %d bytes:\n", count);
+	
+	/* start reading the result header 2(tag)+4(length)+4(operation) */
+	if (count < 10) {
+		return -EIO;
+	}
+
+	len = i2c_master_recv(client, buf, 10);
+	if (len < 10) {
+		dev_err(chip->dev, "error reading header\n");
+		return -EIO;
+	}
+	
+	/* size of the data received */
+	size = *hdr++;
+	size <<= 8;
+	size |= *hdr++;
+	size <<= 8;
+	size |= *hdr++;
+	size <<= 8;
+	size |= *hdr;
+
+	dev_dbg(chip->dev, "reply is %d bytes\n", size);
+	
+	if (count < size) {
+		dev_err(chip->dev, "Recv size(%d) less than needed space(%d)\n", count, size);
+		return -EIO;
+	}
+
+	/* read all the data available, if we didn't get it all anyway. */
+	if (len != size)
+	{
+		len = i2c_master_recv(client, buf, size);
+		if (len < size) {
+			dev_err(chip->dev, "error reading data (%d)\n", len);
+			return -EIO;
+		}
+	}
+	
+	return len;
+}
+
+/* device specific function to write to the TPM using I2C */
+static int tpm_atmel_twi_send(struct tpm_chip *chip, u8 *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(chip->dev);
+	int len;
+
+	dev_dbg(chip->dev, "send %d bytes:\n", count);
+	
+	len = i2c_master_send(client, buf, count);
+	
+	dev_dbg(chip->dev, "send returned %d\n", len);
+	return len;
+}
+
+/* device specific function to cancel operations on the TPM */
+static void tpm_atmel_twi_cancel(struct tpm_chip *chip)
+{
+	/* There doesn't seem to be a way to cancel an operation on the
+	 * AT97SC3204T.
+	 */
+	dev_dbg(chip->dev, "cancel\n");
+}
+
+/* device specific function to poll for TPM status using I2C */
+static u8 tpm_atmel_twi_status(struct tpm_chip *chip)
+{
+	struct i2c_client *client = to_i2c_client(chip->dev);
+	struct i2c_adapter *adapter = client->adapter;
+	int ret;
+	
+	dev_dbg(chip->dev, "status\n");
+	
+	/* The AT97SC3204T will return a NACK in reponse to its address when
+	 * it is busy, so a quick read will give us BUSY/IDLE status.
+	 */
+	ret = i2c_smbus_xfer(adapter, client->addr, 0, I2C_SMBUS_READ, 0, I2C_SMBUS_QUICK, NULL);
+	if (ret < 0) {
+		dev_dbg(chip->dev, "busy\n");
+		return TPM_ATMEL_TWI_STATUS_BUSY;
+	} else {
+		dev_dbg(chip->dev, "idle\n");
+		return 0;
+	}
+}
+
+/* Check for the presence of a TPM on I2C.
+ * Return 0 if detection is successful, -ENODEV otherwise
+ */
+static int atmel_twi_detect(struct i2c_client *client, int kind,
+			  struct i2c_board_info *info)
+{
+	struct i2c_adapter *adapter = client->adapter;
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))
+		return -ENODEV;
+
+	if (kind <= 0) {
+		int ret;
+
+		/* Try to start a write to the device.  That should return an ACK
+		 * if the device is idle, which is the state a newly reset TPM should
+		 * be in.  We stop the write transaction immediately after getting the
+		 * ACK/NACK so no data is actually transferred.
+		 */
+		ret = i2c_smbus_xfer(adapter, client->addr, 0, 0, 0, I2C_SMBUS_QUICK, NULL);
+		if (ret < 0)
+		{
+			dev_dbg(&adapter->dev, "detection failed\n");
+			return -ENODEV;
+		}
+		
+	} else
+		dev_dbg(&adapter->dev, "detection forced\n");
+
+	strlcpy(info->type, "atmel_twi", I2C_NAME_SIZE);
+	
+	dev_dbg(&adapter->dev, "detection succeeded\n");
+
+	return 0;
+}
+
+/* We use the standard operations provided by the tpm module */
+static const struct file_operations atmel_twi_ops = {
+	.owner = THIS_MODULE,
+	.llseek = no_llseek,
+	.open = tpm_open,
+	.read = tpm_read,
+	.write = tpm_write,
+	.release = tpm_release,
+};
+
+/* We provide the standard sysfs files provided by the tpm module
+ * for version 1.2 
+ */
+static DEVICE_ATTR(pubek, S_IRUGO, tpm_show_pubek, NULL);
+static DEVICE_ATTR(pcrs, S_IRUGO, tpm_show_pcrs, NULL);
+static DEVICE_ATTR(enabled, S_IRUGO, tpm_show_enabled, NULL);
+static DEVICE_ATTR(active, S_IRUGO, tpm_show_active, NULL);
+static DEVICE_ATTR(owned, S_IRUGO, tpm_show_owned, NULL);
+static DEVICE_ATTR(temp_deactivated, S_IRUGO, tpm_show_temp_deactivated,
+		   NULL);
+static DEVICE_ATTR(caps, S_IRUGO, tpm_show_caps_1_2, NULL);
+static DEVICE_ATTR(cancel, S_IWUSR |S_IWGRP, NULL, tpm_store_cancel);
+
+static struct attribute* atmel_twi_attrs[] = {
+	&dev_attr_pubek.attr,
+	&dev_attr_pcrs.attr,
+	&dev_attr_enabled.attr,
+	&dev_attr_active.attr,
+	&dev_attr_owned.attr,
+	&dev_attr_temp_deactivated.attr,
+	&dev_attr_caps.attr,
+	&dev_attr_cancel.attr,
+	NULL,
+};
+
+static struct attribute_group atmel_twi_attr_grp = { .attrs = atmel_twi_attrs };
+
+/* Register the vendor specific functions with the TPM module */
+static const struct tpm_vendor_specific tpm_atmel_twi = {
+	.recv = tpm_atmel_twi_recv,
+	.send = tpm_atmel_twi_send,
+	.cancel = tpm_atmel_twi_cancel,
+	.status = tpm_atmel_twi_status,
+	.req_complete_mask = TPM_ATMEL_TWI_STATUS_BUSY,
+	.req_complete_val = 0,
+	.req_canceled = TPM_ATMEL_TWI_STATUS_READY,
+	.attr_group = &atmel_twi_attr_grp,
+	.miscdev = { .fops = &atmel_twi_ops, },
+};
+
+static int atmel_twi_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	struct  tpm_chip *chip;
+	int     err;
+
+	dev_info(&client->dev, "%s chip found\n", client->name);
+
+	if (!(chip = tpm_register_hardware(&client->dev, &tpm_atmel_twi))) {
+		err = -ENODEV;
+		goto exit;
+	}
+
+	chip->vendor.iobase = 0;
+	chip->vendor.base = 0;
+	chip->vendor.have_region = 0;
+	chip->vendor.region_size = 0;
+
+	/* Use defaults for the timeouts when performing initialisation operations */
+	chip->vendor.timeout_a = msecs_to_jiffies(TPM_ATMEL_TWI_SHORT_TIMEOUT);
+	chip->vendor.timeout_b = msecs_to_jiffies(TPM_ATMEL_TWI_LONG_TIMEOUT);
+	chip->vendor.timeout_c = msecs_to_jiffies(TPM_ATMEL_TWI_SHORT_TIMEOUT);
+	chip->vendor.timeout_d = msecs_to_jiffies(TPM_ATMEL_TWI_SHORT_TIMEOUT);
+	
+	/* On reset, the TPM is effectively initialised by a TPM_Init command.
+	 * The TPM is then in a state where it waits for a TPM_Startup command
+	 * to inform it which type of initialization is required (see TPM Main
+	 * Part 3 Commands, Section 3.1).  Neither the kernel module TPM driver
+	 * nor the trousers library normally send this TPM_Startup command,
+	 * presumably because the BIOS would normally be repsonsible for doing
+	 * it.  On the PC302 this has to be done somewhere, and since we need
+	 * to read the chip's timeouts before continuing, we do the TPM_Startup
+	 * here to wake the device.
+	 */
+	tpm_startup(chip);
+	tpm_get_timeouts(chip);
+	tpm_continue_selftest(chip);
+	
+	return 0;
+
+exit:
+	return err;
+}
+
+static int atmel_twi_remove(struct i2c_client *client)
+{
+	struct tpm_chip *chip = dev_get_drvdata(&client->dev);
+
+	tpm_remove_hardware(chip->dev);
+	return 0;
+}
+
+static struct i2c_driver atmel_twi_driver = {
+	.class		= I2C_CLASS_ALL,
+	.driver = {
+		.name	= "atmel_twi",
+	},
+	.probe		= atmel_twi_probe,
+	.remove		= atmel_twi_remove,
+	.id_table	= atmel_twi_id,
+	.detect		= atmel_twi_detect,
+	.address_data	= &addr_data,
+};
+
+static int __init atmel_twi_init(void)
+{
+	return i2c_add_driver(&atmel_twi_driver);
+}
+
+static void __exit atmel_twi_exit(void)
+{
+	i2c_del_driver(&atmel_twi_driver);
+}
+
+module_init(atmel_twi_init);
+module_exit(atmel_twi_exit);
+
+MODULE_AUTHOR("ip.access");
+MODULE_DESCRIPTION("TPM Driver for Atmel AT97SC3204T");
+MODULE_VERSION("2.0");
+MODULE_LICENSE("GPL");
diff -Naur pico_2.6.28/drivers/char/tpm/tpm.c ipa_2.6.28/drivers/char/tpm/tpm.c
--- pico_2.6.28/drivers/char/tpm/tpm.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/drivers/char/tpm/tpm.c	2011-04-26 14:51:35.000000000 +0100
@@ -320,6 +320,23 @@
 	TPM_MEDIUM,
 };
 
+/* The TPM code was written for PC platforms.  Those allow misaligned
+ * access to 32-bit numbers.  Other platforms, including the ARM, are
+ * not always so tolerant, so we need to extract the numbers byte by byte.
+ */
+static u32 tpm_getbe32(const void *buf)
+{
+    const u8 *p = (const u8*)buf;
+	u32 ret = *p++;
+	ret <<= 8;
+	ret |= *p++;
+	ret <<= 8;
+	ret |= *p++;
+	ret <<= 8;
+	ret |= *p;
+	return ret;
+}
+
 static void user_reader_timeout(unsigned long ptr)
 {
 	struct tpm_chip *chip = (struct tpm_chip *) ptr;
@@ -373,8 +390,8 @@
 	u32 count, ordinal;
 	unsigned long stop;
 
-	count = be32_to_cpu(*((__be32 *) (buf + 2)));
-	ordinal = be32_to_cpu(*((__be32 *) (buf + 6)));
+	count = tpm_getbe32(buf + 2);
+	ordinal = tpm_getbe32(buf + 6);
 	if (count == 0)
 		return -ENODATA;
 	if (count > bufsiz) {
@@ -481,7 +498,7 @@
 	if (len <  0)
 		return len;
 	if (len == TPM_ERROR_SIZE) {
-		err = be32_to_cpu(*((__be32 *) (data + TPM_RET_CODE_IDX)));
+		err = tpm_getbe32(data + TPM_RET_CODE_IDX);
 		dev_dbg(chip->dev, "A TPM error (%d) occurred %s\n", err, desc);
 		return err;
 	}
@@ -517,25 +534,21 @@
 	if (rc)
 		goto duration;
 
-	if (be32_to_cpu(*((__be32 *) (data + TPM_GET_CAP_RET_SIZE_IDX)))
+	if (tpm_getbe32(data + TPM_GET_CAP_RET_SIZE_IDX)
 	    != 4 * sizeof(u32))
 		goto duration;
 
 	/* Don't overwrite default if value is 0 */
-	timeout =
-	    be32_to_cpu(*((__be32 *) (data + TPM_GET_CAP_RET_UINT32_1_IDX)));
+	timeout = tpm_getbe32(data + TPM_GET_CAP_RET_UINT32_1_IDX);
 	if (timeout)
 		chip->vendor.timeout_a = usecs_to_jiffies(timeout);
-	timeout =
-	    be32_to_cpu(*((__be32 *) (data + TPM_GET_CAP_RET_UINT32_2_IDX)));
+	timeout = tpm_getbe32(data + TPM_GET_CAP_RET_UINT32_2_IDX);
 	if (timeout)
 		chip->vendor.timeout_b = usecs_to_jiffies(timeout);
-	timeout =
-	    be32_to_cpu(*((__be32 *) (data + TPM_GET_CAP_RET_UINT32_3_IDX)));
+	timeout = tpm_getbe32(data + TPM_GET_CAP_RET_UINT32_3_IDX);
 	if (timeout)
 		chip->vendor.timeout_c = usecs_to_jiffies(timeout);
-	timeout =
-	    be32_to_cpu(*((__be32 *) (data + TPM_GET_CAP_RET_UINT32_4_IDX)));
+	timeout = tpm_getbe32(data + TPM_GET_CAP_RET_UINT32_4_IDX);
 	if (timeout)
 		chip->vendor.timeout_d = usecs_to_jiffies(timeout);
 
@@ -549,14 +562,13 @@
 	if (rc)
 		return;
 
-	if (be32_to_cpu(*((__be32 *) (data + TPM_GET_CAP_RET_SIZE_IDX)))
+	if (tpm_getbe32(data + TPM_GET_CAP_RET_SIZE_IDX)
 	    != 3 * sizeof(u32))
 		return;
 
 	chip->vendor.duration[TPM_SHORT] =
-	    usecs_to_jiffies(be32_to_cpu
-			     (*((__be32 *) (data +
-					    TPM_GET_CAP_RET_UINT32_1_IDX))));
+	    usecs_to_jiffies(tpm_getbe32(data +
+					    TPM_GET_CAP_RET_UINT32_1_IDX));
 	/* The Broadcom BCM0102 chipset in a Dell Latitude D820 gets the above
 	 * value wrong and apparently reports msecs rather than usecs. So we
 	 * fix up the resulting too-small TPM_SHORT value to make things work.
@@ -565,13 +577,11 @@
 		chip->vendor.duration[TPM_SHORT] = HZ;
 
 	chip->vendor.duration[TPM_MEDIUM] =
-	    usecs_to_jiffies(be32_to_cpu
-			     (*((__be32 *) (data +
-					    TPM_GET_CAP_RET_UINT32_2_IDX))));
+	    usecs_to_jiffies(tpm_getbe32(data +
+					    TPM_GET_CAP_RET_UINT32_2_IDX));
 	chip->vendor.duration[TPM_LONG] =
-	    usecs_to_jiffies(be32_to_cpu
-			     (*((__be32 *) (data +
-					    TPM_GET_CAP_RET_UINT32_3_IDX))));
+	    usecs_to_jiffies(tpm_getbe32(data +
+					    TPM_GET_CAP_RET_UINT32_3_IDX));
 }
 EXPORT_SYMBOL_GPL(tpm_get_timeouts);
 
@@ -580,13 +590,28 @@
 	u8 data[] = {
 		0, 193,			/* TPM_TAG_RQU_COMMAND */
 		0, 0, 0, 10,		/* length */
-		0, 0, 0, 83,		/* TPM_ORD_GetCapability */
+		0, 0, 0, 83,		/* TPM_ORD_ContinueSelfTest */
 	};
 
 	tpm_transmit(chip, data, sizeof(data));
 }
 EXPORT_SYMBOL_GPL(tpm_continue_selftest);
 
+/* The BIOS should do this, but until it is capable of doing so, we
+ * will add the capability to do it from here */
+void tpm_startup(struct tpm_chip *chip)
+{
+	u8 data[] = {
+		0, 193,			/* TPM_TAG_RQU_COMMAND */
+		0, 0, 0, 12,		/* length */
+		0, 0, 0, 153,		/* TPM_ORD_Startup */
+		0, 1,			/* TPM_ST_CLEAR */
+	};
+
+	tpm_transmit(chip, data, sizeof(data));
+}
+EXPORT_SYMBOL_GPL(tpm_startup);
+
 #define  TPM_INTERNAL_RESULT_SIZE 200
 
 ssize_t tpm_show_enabled(struct device * dev, struct device_attribute * attr,
@@ -752,7 +777,7 @@
 		return 0;
 	}
 
-	num_pcrs = be32_to_cpu(*((__be32 *) (data + 14)));
+	num_pcrs = tpm_getbe32(data + 14);
 	for (i = 0; i < num_pcrs; i++) {
 		memcpy(data, pcrread, sizeof(pcrread));
 		index = cpu_to_be32(i);
@@ -823,7 +848,7 @@
 		    data[15], data[16], data[17], data[22], data[23],
 		    data[24], data[25], data[26], data[27], data[28],
 		    data[29], data[30], data[31], data[32], data[33],
-		    be32_to_cpu(*((__be32 *) (data + 34))));
+		    tpm_getbe32(data + 34));
 
 	for (i = 0; i < 256; i++) {
 		str += sprintf(str, "%02X ", data[i + 38]);
@@ -875,7 +900,7 @@
 	}
 
 	str += sprintf(str, "Manufacturer: 0x%x\n",
-		       be32_to_cpu(*((__be32 *) (data + TPM_GET_CAP_RET_UINT32_1_IDX))));
+		       tpm_getbe32(data + TPM_GET_CAP_RET_UINT32_1_IDX));
 
 	memcpy(data, cap_version, sizeof(cap_version));
 	data[CAP_VERSION_IDX] = CAP_VERSION_1_1;
@@ -918,13 +943,13 @@
 	if (len <= TPM_ERROR_SIZE) {
 		dev_dbg(chip->dev, "A TPM error (%d) occurred "
 			"attempting to determine the manufacturer\n",
-			be32_to_cpu(*((__be32 *) (data + TPM_RET_CODE_IDX))));
+			tpm_getbe32(data + TPM_RET_CODE_IDX));
 		kfree(data);
 		return 0;
 	}
 
 	str += sprintf(str, "Manufacturer: 0x%x\n",
-		       be32_to_cpu(*((__be32 *) (data + TPM_GET_CAP_RET_UINT32_1_IDX))));
+		       tpm_getbe32(data + TPM_GET_CAP_RET_UINT32_1_IDX));
 
 	memcpy(data, cap_version, sizeof(cap_version));
 	data[CAP_VERSION_IDX] = CAP_VERSION_1_2;
@@ -933,7 +958,7 @@
 	if (len <= TPM_ERROR_SIZE) {
 		dev_err(chip->dev, "A TPM error (%d) occurred "
 			"attempting to determine the 1.2 version\n",
-			be32_to_cpu(*((__be32 *) (data + TPM_RET_CODE_IDX))));
+			tpm_getbe32(data + TPM_RET_CODE_IDX));
 		goto out;
 	}
 	str += sprintf(str,
diff -Naur pico_2.6.28/drivers/char/tpm/tpm.h ipa_2.6.28/drivers/char/tpm/tpm.h
--- pico_2.6.28/drivers/char/tpm/tpm.h	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/drivers/char/tpm/tpm.h	2011-04-26 14:51:35.000000000 +0100
@@ -124,6 +124,7 @@
 	outb(value & 0xFF, base+1);
 }
 
+extern void tpm_startup(struct tpm_chip *);
 extern void tpm_get_timeouts(struct tpm_chip *);
 extern void tpm_gen_interrupt(struct tpm_chip *);
 extern void tpm_continue_selftest(struct tpm_chip *);
diff -Naur pico_2.6.28/drivers/crypto/pc302crypto.c ipa_2.6.28/drivers/crypto/pc302crypto.c
--- pico_2.6.28/drivers/crypto/pc302crypto.c	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/drivers/crypto/pc302crypto.c	2011-04-26 14:51:35.000000000 +0100
@@ -24,11 +24,15 @@
 
 #include <mach/pc302/pc302.h>
 #include <mach/pc302/spacc.h>
+#include <mach/hardware.h>
+
+#undef  PROFILE_PC302CRYPTO_USING_HIRES_TIMER
 
 /* The threshold for the number of packets that should complete in the SPAcc
  * before the STAT_CNT interrupt is raised. Incresing this value will reduce
  * the number of interrupts raised to the CPU. */
-#define STAT_IRQ_THRESHOLD   ( 1 )
+#define STAT_IRQ_THRESHOLD_IPSEC   ( 24 )
+#define STAT_IRQ_THRESHOLD_L2      ( 64 )
 
 /* The threshold for the number of entries in the CMD FIFO available before
  * the CMD0_CNT interrupt is raised. Incresing this value will reduce the
@@ -40,7 +44,7 @@
  * When there are packets in flight but lower than the threshold, we enable
  * the timer and at expiry, attempt to remove any processed packets from the
  * queue and if there are still packets left, schedule the timer again. */
-#define PACKET_TIMEOUT      ( 1 )
+#define PACKET_TIMEOUT      ( 2 )
 
 /*! The priority to register each algorithm with. */
 #define PC302_CRYPTO_ALG_PRIORITY       ( 10000 )
@@ -152,7 +156,11 @@
 {
     struct pc302crypt_ddt       __ddt_align src_ddt[MAX_DDT_LEN];
     struct pc302crypt_ddt       __ddt_align dst_ddt[MAX_DDT_LEN];
-    int                         in_use;
+};
+
+struct pc302crypt_ddt_info
+{
+    struct pc302crypt_ddt_info *next;
 };
 
 /*!
@@ -243,6 +251,12 @@
 
     /*! The DDT buffer. */
     struct pc302crypt_engine_ctx    *ddt_buf;
+    
+    struct pc302crypt_ddt_info    *ddt_info;
+    struct pc302crypt_ddt_info    *free_ddt_info;
+    void                          *zeroed_page;
+    dma_addr_t                    zeroed_src_addr;
+    struct scatterlist            zeroed_list;
 
     /*! The physical address of the DDT buffer. */
     dma_addr_t                  ddt_buf_phys;
@@ -283,6 +297,9 @@
     /*! The number of requests 'in flight'. */
     unsigned                    in_flight;
 
+    /*! The number of requests allowed before an interrupt. */
+    unsigned                    stat_irq_threshold;
+
     /*! The timer for packet timeouts. */
     struct timer_list           packet_timeout;
 };
@@ -843,6 +860,7 @@
     .fifo_sz            = PC302_CRYPTO_IPSEC_FIFO_SZ,
     .algs               = ipsec_engine_algs,
     .num_algs           = ARRAY_SIZE( ipsec_engine_algs ),
+    .stat_irq_threshold = STAT_IRQ_THRESHOLD_IPSEC,
 };
 
 /*! The layer 2 offload engine. */
@@ -855,6 +873,7 @@
     .fifo_sz            = PC302_CRYPTO_L2_FIFO_SZ,
     .algs               = l2_engine_algs,
     .num_algs           = ARRAY_SIZE( l2_engine_algs ),
+    .stat_irq_threshold = STAT_IRQ_THRESHOLD_L2,
 };
 
 /*!
@@ -871,6 +890,25 @@
         NULL;
 }
 
+#ifdef PROFILE_PC302CRYPTO_USING_HIRES_TIMER
+static u32 profileN = 0;
+static u32 profileTotalSum = 0;
+static u32 profileTotalSumSquares = 0;
+static u32 profileTestSum = 0;
+static u32 profileTestSumSquares = 0;
+static u32 profileDelaySum = 0;
+static u32 profileTotal=0;
+static u32 profileTotalStart=0;
+static u32 profileTest=0;
+static u32 profileTestStart=0;
+
+static inline u32
+pc302crypt_get_cycles(void)
+{
+    return ioread32(__io(IO_ADDRESS(PC302_RTCLK_BASE + RTCLK_CCV_REG_OFFSET)));
+}
+#endif
+
 /*!
  * From a generic context, get the AEAD cipher context containing it.
  *
@@ -1032,23 +1070,17 @@
                      size_t ivlen,
                      enum context_load_mode mode )
 {
-    unsigned i;
     unsigned indx;
 
-    indx = -1;
-    for ( i = 0; i < ctx->engine->max_ctxs; ++i )
-        if ( ( !ctx->engine->ddt_buf[ i ].in_use ) )
-        {
-            indx = i;
-            break;
-        }
-
     /* We failed to find a context slot. There are the same number of context
      * pages as there are slots in the FIFO so it should be impossible to get
      * a context slot. */
-    BUG_ON( -1 == indx );
+    BUG_ON( NULL == ctx->engine->free_ddt_info );
 
-    ctx->engine->ddt_buf[ i ].in_use = 1;
+    indx = ctx->engine->free_ddt_info - ctx->engine->ddt_info;
+    
+    ctx->engine->free_ddt_info = ctx->engine->ddt_info[ indx ].next;
+    ctx->engine->ddt_info[ indx ].next = NULL;
 
     if ( CTX_CIPHER == mode )
     {
@@ -1104,7 +1136,8 @@
 pc302crypt_unload_ctx( struct pc302crypt_generic_ctx *ctx,
                        unsigned indx )
 {
-    ctx->engine->ddt_buf[ indx ].in_use = 0;
+    ctx->engine->ddt_info[ indx ].next = ctx->engine->free_ddt_info;
+    ctx->engine->free_ddt_info = &ctx->engine->ddt_info[ indx ];
 }
 
 /*!
@@ -1435,10 +1468,13 @@
                      unsigned nbytes,
                      enum dma_data_direction dir )
 {
-    unsigned nents = sg_count( payload, nbytes );
-    struct pc302crypt_ablk_ctx *ablk_ctx = crypto_tfm_ctx( req->req->tfm );
-    struct pc302crypt_engine *engine = ablk_ctx->generic.engine;
-    dma_unmap_sg( engine->dev, payload, nents, dir );
+    if (payload)
+    {
+        unsigned nents = sg_count( payload, nbytes );
+        struct pc302crypt_ablk_ctx *ablk_ctx = crypto_tfm_ctx( req->req->tfm );
+        struct pc302crypt_engine *engine = ablk_ctx->generic.engine;
+        dma_unmap_sg( engine->dev, payload, nents, dir );
+    }
 }
 
 /*!
@@ -1811,12 +1847,13 @@
     /* If we are not over the IRQ threshold, then schedule a timeout. If we
      * are over the threshold then we can simply delete the timer as we'll get
      * an interrupt and reenable the timer when we pass below the threshold. */
-    if ( ++engine->in_flight < STAT_IRQ_THRESHOLD )
+    engine->in_flight++;
+    if ( engine->in_flight == 1 )
     {
         PRINTD( DBG_TRACE, "schedule timeout" );
         mod_timer( &engine->packet_timeout, jiffies + PACKET_TIMEOUT );
     }
-    else
+    else if ( engine->in_flight == engine->stat_irq_threshold )
     {
         PRINTD( DBG_TRACE, "over threshold, disable timer" );
         del_timer( &engine->packet_timeout );
@@ -2227,16 +2264,35 @@
                                        alg->cra_ablkcipher.ivsize,
                                        CTX_CIPHER );
 
-    if ( !pc302crypt_sg_to_ddt( req, ablk_req->src, ablk_req->nbytes,
-                               DMA_TO_DEVICE ) )
-        return -ENOMEM;
+    if (ablk_req->src)
+    {
+#ifdef PROFILE_PC302CRYPTO_USING_HIRES_TIMER
+    profileTestStart = pc302crypt_get_cycles();
+#endif
+
+        if ( !pc302crypt_sg_to_ddt( req, ablk_req->src, ablk_req->nbytes,
+                                DMA_TO_DEVICE ) )
+            return -ENOMEM;
+    }
+                
     if ( !pc302crypt_sg_to_ddt( req, ablk_req->dst, ablk_req->nbytes,
                                 DMA_FROM_DEVICE ) )
         return -ENOMEM;
 
-    req->src_addr = engine->ddt_buf_phys +
-        ( req->ctx_id * sizeof( struct pc302crypt_engine_ctx ) ) +
-        offsetof( struct pc302crypt_engine_ctx, src_ddt );
+    if (ablk_req->src)
+    {
+        req->src_addr = engine->ddt_buf_phys +
+            ( req->ctx_id * sizeof( struct pc302crypt_engine_ctx ) ) +
+            offsetof( struct pc302crypt_engine_ctx, src_ddt );
+#ifdef PROFILE_PC302CRYPTO_USING_HIRES_TIMER
+    profileTest = pc302crypt_get_cycles() - profileTestStart;
+#endif
+    }
+    else
+    {
+        req->src_addr = engine->zeroed_src_addr;
+    }
+    
     req->dst_addr = engine->ddt_buf_phys +
         ( req->ctx_id * sizeof( struct pc302crypt_engine_ctx ) ) +
         offsetof( struct pc302crypt_engine_ctx, dst_ddt );
@@ -2301,12 +2357,13 @@
     /* If we are not over the IRQ threshold, then schedule a timeout. If we
      * are over the threshold then we can simply delete the timer as we'll get
      * an interrupt and reenable the timer when we pass below the threshold. */
-    if ( ++engine->in_flight < STAT_IRQ_THRESHOLD )
+    engine->in_flight++;
+    if ( engine->in_flight == 1 )
     {
         PRINTD( DBG_TRACE, "schedule timeout" );
         mod_timer( &engine->packet_timeout, jiffies + PACKET_TIMEOUT );
     }
-    else
+    else if ( engine->in_flight == engine->stat_irq_threshold )
     {
         PRINTD( DBG_TRACE, "over threshold, disable timer" );
         del_timer( &engine->packet_timeout );
@@ -2354,6 +2411,12 @@
     unsigned long flags;
     int err = -EINPROGRESS;
 
+#ifdef PROFILE_PC302CRYPTO_USING_HIRES_TIMER
+    profileTotal=0;
+    profileTest=0;
+    profileTestStart=0;
+#endif
+
     if ( !dev_req )
         return -ENOMEM;
 
@@ -2372,6 +2435,9 @@
     }
 
     spin_lock_irqsave( &engine->hw_lock, flags );
+#ifdef PROFILE_PC302CRYPTO_USING_HIRES_TIMER
+    profileTotalStart = pc302crypt_get_cycles();
+#endif
     err = pc302crypt_queue_req( &engine->pending, dev_req );
 
     /* If we were unable to put the request in because the transform can't
@@ -2392,7 +2458,38 @@
         err = -EINPROGRESS;
     }
 
+#ifdef PROFILE_PC302CRYPTO_USING_HIRES_TIMER
+    profileTotal = pc302crypt_get_cycles() - profileTotalStart;
+#endif
+
     spin_unlock_irqrestore( &engine->hw_lock, flags );
+    
+#ifdef PROFILE_PC302CRYPTO_USING_HIRES_TIMER
+    if (profileTest)
+    {
+        profileN++;
+        profileTotalSum += profileTotal;
+//        profileTotalSumSquares += profileTotal*profileTotal;
+        profileTestSum += profileTest;
+//        profileTestSumSquares += profileTest*profileTest;
+        if (profileTestStart)
+        {
+            profileDelaySum += profileTestStart-profileTotalStart;
+        }
+    }
+    
+    if (profileN == 100000)
+    {
+        printk("N=%u S=%u S2=%u ST=%u ST2=%u DLY=%u\n",
+                profileN, profileTotalSum, profileTotalSumSquares, profileTestSum, profileTestSumSquares, profileDelaySum);
+        profileN = 0;
+        profileTotalSum = 0;
+        profileTotalSumSquares = 0;
+        profileTestSum = 0;
+        profileTestSumSquares = 0;
+        profileDelaySum = 0;
+    }
+#endif
 out:
     return err;
 }
@@ -2683,7 +2780,7 @@
 
     /* If we have less packets in flight than the threshold, kick the
      * timer. */
-    if ( engine->in_flight && engine->in_flight < STAT_IRQ_THRESHOLD )
+    if ( engine->in_flight && engine->in_flight < engine->stat_irq_threshold )
     {
         PRINTD( DBG_TRACE, "below threshold, kick timer" );
         mod_timer( &engine->packet_timeout, jiffies + PACKET_TIMEOUT );
@@ -2763,6 +2860,13 @@
 
     engine->dev = &pdev->dev;
 
+    engine->zeroed_page = ( void * )get_zeroed_page( GFP_KERNEL );
+    if ( !engine->zeroed_page )
+    {
+        printk( KERN_INFO "failed to allocate a zeroed page (%s)\n", pdev->name );
+        goto out;
+    }
+
     engine->regs =
         pc302crypt_request_and_map( mem_resource, engine->name );
     if ( !engine->regs )
@@ -2815,25 +2919,62 @@
      * submit a new packet for processing when we complete another in the
      * queue. This minimizes time spent in the interrupt handler. */
     pc302crypt_reg_write( engine, SPA_IRQ_CTRL_REG_OFFSET,
-                          STAT_IRQ_THRESHOLD << SPA_IRQ_CTRL_STAT_CNT_OFFSET );
+                          engine->stat_irq_threshold << SPA_IRQ_CTRL_STAT_CNT_OFFSET );
     pc302crypt_reg_write( engine, SPA_IRQ_EN_REG_OFFSET,
                           SPA_IRQ_EN_STAT_EN | SPA_IRQ_EN_GLBL_EN );
 
     setup_timer( &engine->packet_timeout, pc302crypt_packet_timeout,
                  ( unsigned long )engine );
 
-    engine->ddt_buf = dma_alloc_coherent( engine->dev, engine->max_ctxs *
+    engine->ddt_buf = dma_alloc_coherent( engine->dev, (engine->max_ctxs + 1) *
             sizeof( struct pc302crypt_engine_ctx ), &engine->ddt_buf_phys,
             GFP_KERNEL );
     if ( !engine->ddt_buf )
     {
         ret = -ENOMEM;
-        goto ddt_failed;
+        goto ddt_buf_failed;
     }
+    
+    memset(engine->ddt_buf, 0, (engine->max_ctxs + 1) * sizeof( struct pc302crypt_engine_ctx ));
+    
+    engine->ddt_info = kmalloc( (engine->max_ctxs + 1) * 
+              sizeof( struct pc302crypt_ddt_info ), GFP_KERNEL );
+    if ( !engine->ddt_info )
+    {
+        ret = -ENOMEM;
+        goto ddt_info_failed;
+    }
+    
+    memset(engine->ddt_info, 0, (engine->max_ctxs + 1) * sizeof( struct pc302crypt_ddt_info ));
+    
+    engine->free_ddt_info = engine->ddt_info;
+    for ( i = 0; i < engine->max_ctxs - 1; ++i )
+    {
+        engine->ddt_info[i].next = &engine->ddt_info[i+1];
+    }
+    engine->ddt_info[engine->max_ctxs - 1].next = 0;
 
+    sg_init_table( &engine->zeroed_list, 1 );
+    sg_set_buf( &engine->zeroed_list, engine->zeroed_page, 4096 );
+    dma_map_sg( engine->dev, &engine->zeroed_list, 1, DMA_TO_DEVICE );
+
+    engine->ddt_buf[ engine->max_ctxs ].src_ddt[ 0 ].p   = sg_dma_address( &engine->zeroed_list );
+    engine->ddt_buf[ engine->max_ctxs ].src_ddt[ 0 ].len = sg_dma_len( &engine->zeroed_list );
+    engine->ddt_buf[ engine->max_ctxs ].src_ddt[ 1 ].p   = 0;
+    engine->ddt_buf[ engine->max_ctxs ].src_ddt[ 1 ].len = 0;
+    
+    engine->zeroed_src_addr = engine->ddt_buf_phys + 
+            ( engine->max_ctxs * sizeof( struct pc302crypt_engine_ctx ) ) +
+            offsetof( struct pc302crypt_engine_ctx, src_ddt );
+            
     return ret;
 
-ddt_failed:
+ddt_info_failed:
+    dma_free_coherent( engine->dev, engine->max_ctxs *
+            sizeof( struct pc302crypt_engine_ctx ), engine->ddt_buf,
+            engine->ddt_buf_phys );
+
+ddt_buf_failed:
     del_timer( &engine->packet_timeout );
 
     list_for_each_entry_safe( alg, next, &engine->registered_algs,
@@ -2845,8 +2986,10 @@
 
 map_fail:
 irq_fail:
+    free_page(( unsigned long )engine->zeroed_page);
 out:
 
+
     return ret;
 }
 
@@ -2874,7 +3017,9 @@
     pc302crypt_release_and_unmap( mem_resource, engine->regs );
     free_irq( irq->start, engine );
 
-    dma_free_coherent( engine->dev, engine->max_ctxs *
+    kfree(engine->ddt_info);
+    
+    dma_free_coherent( engine->dev, (engine->max_ctxs + 1) *
             sizeof( struct pc302crypt_engine_ctx ), engine->ddt_buf,
             engine->ddt_buf_phys );
 
@@ -2885,6 +3030,9 @@
         crypto_unregister_alg( &alg->alg );
     }
 
+    dma_unmap_sg(engine->dev, &engine->zeroed_list, 1, DMA_TO_DEVICE );
+    free_page(( unsigned long )engine->zeroed_page);
+    
     return 0;
 }
 
diff -Naur pico_2.6.28/drivers/i2c/chips/ad7995.c ipa_2.6.28/drivers/i2c/chips/ad7995.c
--- pico_2.6.28/drivers/i2c/chips/ad7995.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/i2c/chips/ad7995.c	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,503 @@
+/*
+    ad7995.c - driver for AD7995
+
+    Copyright (C) 2009 ip.access Ltd
+
+    Based on i2c/chips/max6875.c
+*/
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/mutex.h>
+#include <linux/fs.h>
+#include <linux/ctype.h>
+#include <linux/miscdevice.h>
+#include <asm/uaccess.h>
+
+#include <linux/ipa/ad7995.h>
+
+/* Addresses to scan */
+static const unsigned short normal_i2c[] = { 0x28, I2C_CLIENT_END };
+
+/* Insmod parameters */
+I2C_CLIENT_INSMOD_1(ad7995);
+
+static const struct i2c_device_id ad7995_id[] = {
+	{ "ad7995", ad7995 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ad7995_id);
+
+struct ad7995_data {
+	struct i2c_client     *client;
+	struct miscdevice      miscdev;
+	struct mutex           lock;                       /* Required for read-modify-write of config reg */
+	u8                     config;
+	u8                     buf[8];
+};
+
+
+static struct ad7995_data  *ad7995_device = NULL;
+
+/* Conversion register.  Read only. */
+static ssize_t ad7995_show_sample( struct device            *dev, 
+                                   struct device_attribute  *attr,
+                                   char                     *buf )
+{
+	struct ad7995_data  *ad7995 = NULL;
+	int                  written = 0;
+	int                  len;
+	int                  i;
+	
+	ad7995 = dev_get_drvdata(dev);
+	
+	if (ad7995)
+	{
+		int  numChannels = 0;
+		
+		mutex_lock(&ad7995->lock);
+
+		/* Try to read up to 4 samples (8 bytes) in the case where multiple
+		 * channels are enabled.
+		 */
+		if (ad7995->config & 0x80)
+		{
+			numChannels++;
+		}
+		if (ad7995->config & 0x40)
+		{
+			numChannels++;
+		}
+		if (ad7995->config & 0x20)
+		{
+			numChannels++;
+		}
+		if (ad7995->config & 0x10)
+		{
+			numChannels++;
+		}
+		
+		len = i2c_master_recv(ad7995->client, ad7995->buf, 2*numChannels);
+		
+		if (len < 0)
+		{
+			mutex_unlock(&ad7995->lock);
+			written = scnprintf( buf, PAGE_SIZE, "Failed to convert (%d)\n", len);
+		}
+		else
+		{
+			int  sample[4] = {-1, -1, -1, -1};
+			
+			for (i=0; i<len-1; i+=2)
+			{
+				int value;
+				int channel = (ad7995->buf[i] >> 4) & 3;
+				value = ad7995->buf[i] & 0x0F;
+				value <<= 8;
+				value |= ad7995->buf[i+1];
+				sample[channel] = value;
+			}
+			
+			mutex_unlock(&ad7995->lock);
+			
+			written = scnprintf( buf, PAGE_SIZE, "adc[0]=%d, adc[1]=%d, adc[2]=%d, adc[3]=%d\n",
+			                                      sample[0], sample[1], sample[2], sample[3]);
+		}
+	}
+	
+	return written;
+}
+
+static ssize_t ad7995_store_sample( struct device            *dev, 
+                                    struct device_attribute  *attr,
+                                    const char               *buf,
+                                    size_t                    count )
+{
+	return -EIO;
+}
+
+static DEVICE_ATTR( ad7995_sample, S_IRUGO | S_IWUSR, ad7995_show_sample, ad7995_store_sample );
+
+
+
+/* Configuration register */
+static ssize_t ad7995_show_config( struct device            *dev, 
+                                   struct device_attribute  *attr, 
+                                   char                     *buf )
+{
+	struct ad7995_data  *ad7995 = NULL;
+	int                  written = 0;
+	
+	ad7995 = dev_get_drvdata(dev);
+	
+	if (ad7995)
+	{
+		u8  config = ad7995->config;
+		
+		written = scnprintf( buf, PAGE_SIZE, "config=%c%c%c%c%c%c%c%c\n",
+		                                      (config & 0x80) ? '3' : '-',
+		                                      (config & 0x40) ? '2' : '-',
+		                                      (config & 0x20) ? '1' : '-',
+		                                      (config & 0x10) ? '0' : '-',
+		                                      (config & 0x08) ? 'R' : 'r',
+		                                      (config & 0x04) ? 'F' : 'f',
+		                                      (config & 0x02) ? 'B' : 'b',
+		                                      (config & 0x01) ? 'S' : 's');
+	}
+	
+	return written;
+}
+
+static ssize_t ad7995_store_config( struct device            *dev, 
+                                    struct device_attribute  *attr, 
+                                    const char               *buf,
+                                    size_t                    count)
+{
+    struct ad7995_data  *ad7995 = NULL;
+    u8                   value  = 0;
+    int                  i;
+	
+	for (i=0; i<count; ++i)
+	{
+		char c = buf[i];
+				
+		if (c == 0)
+		{
+			break;
+		}
+	
+		/* Accept lower case to clear a flag and upper case to set it */        
+		switch (c)
+		{
+		case '3':
+			value |= 0x80;
+			break;
+		case '2':
+			value |= 0x40;
+			break;
+		case '1':
+			value |= 0x20;
+			break;
+		case '0':
+			value |= 0x10;
+			break;
+		case 'R':
+			value |= 0x08;
+			break;
+		case 'F':
+			value |= 0x04;
+			break;
+		case 'B':
+			value |= 0x02;
+			break;
+		case 'S':
+			value |= 0x01;
+			break;
+		case 'r':
+			value &= ~0x08;
+			break;
+		case 'f':
+			value &= ~0x04;
+			break;
+		case 'b':
+			value &= ~0x02;
+			break;
+		case 's':
+			value &= ~0x01;
+			break;
+		}
+	}
+	
+	ad7995 = dev_get_drvdata(dev);
+	
+	if (ad7995)
+	{
+		mutex_lock(&ad7995->lock);
+	
+		ad7995->config = value;
+		i2c_smbus_write_byte(ad7995->client, ad7995->config);
+		
+		mutex_unlock(&ad7995->lock);
+	}
+	
+	return count;
+}
+
+static DEVICE_ATTR( ad7995_config, S_IRUGO | S_IWUSR, ad7995_show_config, ad7995_store_config );
+
+
+static int ad7995_open(struct inode  *inode,
+                       struct file   *filp)
+{
+	int                   result = 0;
+	
+	filp->private_data  = ad7995_device;
+	
+	return result;
+}
+
+static int ad7995_release(struct inode  *inode,
+                          struct file   *filp)
+{
+	if (filp->private_data)
+	{
+		filp->private_data = 0;
+	}
+	
+	return 0;
+}
+
+static int ad7995_ioctl(struct inode   *inode_p,
+                        struct file    *filp,
+                        unsigned int    cmd,
+                        unsigned long   arg)
+{
+	struct ad7995_data  *ad7995 = NULL;
+	int                   ret     = 0;
+	
+	/* don't even decode wrong cmds: better returning  ENOTTY than EFAULT */
+	if (_IOC_TYPE(cmd) != AD7995_IOCTL_MAGIC) return -ENOTTY;
+	if (_IOC_NR(cmd)    > AD7995_IOCTL_MAXNR) return -ENOTTY;
+	
+	ad7995 = filp->private_data;
+	
+	switch (cmd)
+	{
+	case AD7995_IOCTL_READ_ADC:
+		{
+			int            numChannels = 0;
+			Ad7995Samples  samples;
+			int            len;
+			int            i;
+			
+			samples.adc[0] = -1;
+			samples.adc[1] = -1;
+			samples.adc[2] = -1;
+			samples.adc[3] = -1;
+			
+			mutex_lock(&ad7995->lock);
+	
+			if (ad7995->config & 0x80)
+			{
+				numChannels++;
+			}
+			if (ad7995->config & 0x40)
+			{
+				numChannels++;
+			}
+			if (ad7995->config & 0x20)
+			{
+				numChannels++;
+			}
+			if (ad7995->config & 0x10)
+			{
+				numChannels++;
+			}
+			
+			/* Try to read up to 4 samples (8 bytes) in the case where multiple
+			 * channels are enabled.
+			 */
+			len = i2c_master_recv(ad7995->client, ad7995->buf, 2*numChannels);
+			
+			if (len < 0)
+			{
+				mutex_unlock(&ad7995->lock);
+				
+				ret = -EIO;
+			}
+			else
+			{
+				for (i=0; i<len-1; i+=2)
+				{
+					int  value;
+					int  channel;
+					
+					channel = (ad7995->buf[i] >> 4) & 3;
+					
+					value = ad7995->buf[i] & 0x0F;
+					value <<= 8;
+					value |= ad7995->buf[i+1];
+					
+					samples.adc[channel] = value;
+				}
+				
+				mutex_unlock(&ad7995->lock);
+			
+				if (copy_to_user((void*)arg, &samples, sizeof(samples)))
+				{
+					ret = -EFAULT;
+				}
+			}
+		}
+		break;
+	
+	case AD7995_IOCTL_WRITE_CONFIG:
+		{
+			Ad7995Config  config;
+			
+			if (copy_from_user(&config, (void*)arg, sizeof(config)))
+			{
+				ret = -EFAULT;
+				break;
+			}
+		
+			mutex_lock(&ad7995->lock);
+			
+			ad7995->config = config.flags;
+			ret = i2c_smbus_write_byte(ad7995->client, ad7995->config);
+			
+			mutex_unlock(&ad7995->lock);
+		}
+		break;
+		
+	case AD7995_IOCTL_READ_CONFIG:
+		{
+			Ad7995Config  config;
+			
+			config.flags = ad7995->config;
+			
+			if (copy_to_user((void*)arg, &config, sizeof(config)))
+			{
+				ret = -EFAULT;
+			}
+		}
+		break;
+		
+	default:  /* redundant, as cmd was checked against MAXNR */
+		ret = -ENOTTY;
+	}
+	
+	return ret;
+}
+
+static struct file_operations ad7995_fops = {
+	.owner      = THIS_MODULE,
+	.open       = ad7995_open,
+	.release    = ad7995_release,
+	.ioctl      = ad7995_ioctl,
+};
+
+
+/* Return 0 if detection is successful, -ENODEV otherwise */
+static int ad7995_detect(struct i2c_client      *client,
+                         int                     kind,
+                         struct i2c_board_info  *info)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WRITE_BYTE_DATA
+						| I2C_FUNC_SMBUS_READ_BYTE))
+		return -ENODEV;
+	
+	strlcpy(info->type, "ad7995", I2C_NAME_SIZE);
+	
+	return 0;
+}
+
+static int ad7995_probe(struct i2c_client           *client,
+                        const struct i2c_device_id  *id)
+{
+	struct device       *dev      = &client->dev;
+	struct ad7995_data  *ad7995  = NULL;
+	int                  err;
+	
+	ad7995 = kzalloc(sizeof(struct ad7995_data), GFP_KERNEL);
+	if (ad7995 == NULL)
+	{
+		err = -ENOMEM;
+		goto err_no_mem;
+	}
+	
+	ad7995->client = client;
+	
+	ad7995->miscdev.fops   = &ad7995_fops;
+	ad7995->miscdev.name   = "ad7995";
+	ad7995->miscdev.minor  =  AD7995_MINOR;  /* Our /dev is read only, so use a fixed value */
+	
+	err = misc_register( &ad7995->miscdev );
+	if ( err )
+	{
+		printk( KERN_INFO "failed to register ad7995 misc device\n" );
+		goto err_no_misc_device;
+	}
+	
+	/* Init i2c_client */
+	i2c_set_clientdata(client, ad7995);
+	mutex_init(&ad7995->lock);
+
+	/* Default to a single channel */	
+	ad7995->config = 0x10;
+	i2c_smbus_write_byte(client, ad7995->config);
+	
+	err = device_create_file(dev, &dev_attr_ad7995_config);
+	if (err)
+	{
+		goto err_no_sysfs_config;
+	}
+	
+	err = device_create_file(dev, &dev_attr_ad7995_sample);
+	if (err)
+	{
+		goto err_no_sysfs_sample;
+	}
+	
+	ad7995_device = ad7995;
+	
+	return 0;
+
+err_no_sysfs_sample:
+	device_remove_file( dev, &dev_attr_ad7995_config);
+err_no_sysfs_config:
+	misc_deregister( &ad7995->miscdev );
+err_no_misc_device:
+	kfree(ad7995);
+err_no_mem:
+	return err;
+}
+
+static int ad7995_remove(struct i2c_client *client)
+{
+	struct ad7995_data  *ad7995 = i2c_get_clientdata(client);
+	struct device       *dev    = &client->dev;
+	
+	ad7995_device = NULL;
+	device_remove_file( dev, &dev_attr_ad7995_sample);
+	device_remove_file( dev, &dev_attr_ad7995_config);
+	misc_deregister( &ad7995->miscdev );
+	kfree(ad7995);
+	
+	return 0;
+}
+
+static struct i2c_driver ad7995_driver = {
+	.class		= I2C_CLASS_ALL,
+	.driver = {
+		.name	= "ad7995",
+	},
+	.probe		= ad7995_probe,
+	.remove		= ad7995_remove,
+	.id_table	= ad7995_id,
+	.detect		= ad7995_detect,
+	.address_data	= &addr_data,
+};
+
+static int __init ad7995_init(void)
+{
+	return i2c_add_driver(&ad7995_driver);
+}
+
+static void __exit ad7995_exit(void)
+{
+	i2c_del_driver(&ad7995_driver);
+}
+
+
+MODULE_DESCRIPTION("Driver for AD7995 ADC");
+MODULE_AUTHOR("ip.access Ltd");
+MODULE_LICENSE("GPL");
+
+module_init(ad7995_init);
+module_exit(ad7995_exit);
diff -Naur pico_2.6.28/drivers/i2c/chips/Kconfig ipa_2.6.28/drivers/i2c/chips/Kconfig
--- pico_2.6.28/drivers/i2c/chips/Kconfig	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/drivers/i2c/chips/Kconfig	2011-04-26 14:51:35.000000000 +0100
@@ -42,6 +42,16 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called at24.
 
+config SENSORS_AD7995
+	tristate "Analog Devices AD7995 four channel ADC"
+	depends on EXPERIMENTAL
+	help
+	  If you say yes here you get support for the Analog AD7995
+	  ADC.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called ad7995.
+
 config SENSORS_EEPROM
 	tristate "EEPROM reader"
 	depends on EXPERIMENTAL
@@ -139,6 +149,16 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called tps65010.
 
+config SENSORS_MAX6635
+	tristate "Maxim MAX6635 Temperature sensor"
+	depends on EXPERIMENTAL
+	help
+	  If you say yes here you get support for the Maxim MAX6635
+	  temperature sensor.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called max6635.
+
 config SENSORS_MAX6875
 	tristate "Maxim MAX6875 Power supply supervisor"
 	depends on EXPERIMENTAL
diff -Naur pico_2.6.28/drivers/i2c/chips/Makefile ipa_2.6.28/drivers/i2c/chips/Makefile
--- pico_2.6.28/drivers/i2c/chips/Makefile	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/drivers/i2c/chips/Makefile	2011-04-26 14:51:35.000000000 +0100
@@ -12,8 +12,10 @@
 
 obj-$(CONFIG_DS1682)		+= ds1682.o
 obj-$(CONFIG_AT24)		+= at24.o
+obj-$(CONFIG_SENSORS_AD7995)	+= ad7995.o
 obj-$(CONFIG_SENSORS_EEPROM)	+= eeprom.o
 obj-$(CONFIG_SENSORS_MAX6875)	+= max6875.o
+obj-$(CONFIG_SENSORS_MAX6635)	+= max6635.o
 obj-$(CONFIG_SENSORS_PCA9539)	+= pca9539.o
 obj-$(CONFIG_SENSORS_PCF8574)	+= pcf8574.o
 obj-$(CONFIG_PCF8575)		+= pcf8575.o
diff -Naur pico_2.6.28/drivers/i2c/chips/max6635.c ipa_2.6.28/drivers/i2c/chips/max6635.c
--- pico_2.6.28/drivers/i2c/chips/max6635.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/i2c/chips/max6635.c	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,880 @@
+/*
+    max6635.c - driver for MAX6635
+
+    Copyright (C) 2009 ip.access Ltd
+
+    Based on i2c/chips/max6875.c
+*/
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/mutex.h>
+#include <linux/fs.h>
+#include <linux/ctype.h>
+#include <linux/miscdevice.h>
+#include <asm/uaccess.h>
+
+#include <linux/ipa/max6635.h>
+
+#define  MAX6635_TRANSFER_SIZE               (8)
+
+#define  MAX6635_LIMIT_REG_MIN               (-256)
+#define  MAX6635_LIMIT_REG_MAX               (255)
+
+#define  MAX6635_TEMP_REG                    (0x00)
+#define  MAX6635_CONFIG_REG                  (0x01)
+#define  MAX6635_THYST_REG                   (0x02)
+#define  MAX6635_TMAX_REG                    (0x03)
+#define  MAX6635_TLOW_REG                    (0x04)
+#define  MAX6635_THIGH_REG                   (0x05)
+
+#define  MAX6635_CONFIG_SHUTDOWN_MODE        (1 << 0)
+#define  MAX6635_CONFIG_INTERRUPT_MODE       (1 << 1)
+#define  MAX6635_CONFIG_OVER_TEMP_POLARITY   (1 << 2)
+#define  MAX6635_CONFIG_ALERT_POLARITY       (1 << 3)
+#define  MAX6635_CONFIG_FAULT_QUEUE          (1 << 4)
+#define  MAX6635_CONFIG_SMB_TIMEOUT_DISABLE  (1 << 5)
+
+#define  MAX6635_STATUS_TLOW                 (1 <<  0)
+#define  MAX6635_STATUS_THIGH                (1 <<  1)
+#define  MAX6635_STATUS_TOVER                (1 <<  2)
+
+/* Do not scan - the MAX6875 access method will write to some EEPROM chips */
+static const unsigned short normal_i2c[] = { I2C_CLIENT_END };
+
+/* Insmod parameters */
+I2C_CLIENT_INSMOD_1(max6635);
+
+
+struct max6635_data {
+    struct i2c_client     *client;
+    struct miscdevice      miscdev;
+    struct mutex           lock;                        /* Required for read-modify-write of config reg */
+    u8                     buf[MAX6635_TRANSFER_SIZE];  /* DMA safe buffer for SPI transfers */
+};
+
+
+static struct max6635_data  *max6635_device = NULL;
+
+
+
+/* Temperature register.  Read only. */
+static ssize_t max6635_show_temp( struct device *dev, struct device_attribute *attr, char *buf )
+{
+    struct max6635_data  *max6635 = NULL;
+    s32                   value;
+    int                   written = 0;
+    
+    max6635 = dev_get_drvdata(dev);
+    
+    if (max6635)
+    {
+        mutex_lock(&max6635->lock);
+        
+        value = i2c_smbus_read_word_data(max6635->client, MAX6635_TEMP_REG);
+        
+        mutex_unlock(&max6635->lock);
+        
+        if (value < 0)
+        {
+            written = scnprintf( buf, PAGE_SIZE, "read failure %d\n", value );
+        }
+        else
+        {
+            int units     = (value >> 3) & 0x1FFF;
+            int fract     = 0;
+            int negative  = 0;
+            
+            /* Convert -ve to +ve and hold a sign flag */
+            if (units & 0x1000)
+            {
+                units = 0x2000 - units;
+                negative  = 1;
+            }
+    
+            /* Each code corresponds to 0.0625 degrees C */
+            units *= 625;
+            
+            /* Round from 4 decimal places to 2 decimal places */
+            units += 50;
+            units /= 100;
+    
+            /* Split whole and fractional parts */
+            fract = units % 100;
+            units /= 100;
+            
+            written = scnprintf( buf, PAGE_SIZE, "%s%d.%02d Tover=%d Thigh=%d Tlow=%d\n",
+                                 negative ? "-" : "", units, fract,
+                                 !!(value & MAX6635_STATUS_TOVER),
+                                 !!(value & MAX6635_STATUS_THIGH),
+                                 !!(value & MAX6635_STATUS_TLOW)
+                               );
+        }
+    }
+    
+    return written;
+}
+
+static ssize_t max6635_store_temp( struct device *dev, struct device_attribute *attr, const char *buf, size_t count )
+{
+    return -EIO;
+}
+
+static DEVICE_ATTR( max6635_temp, S_IRUGO | S_IWUSR, max6635_show_temp, max6635_store_temp   );
+
+
+
+/* Configuration register */
+static ssize_t max6635_show_config( struct device *dev, struct device_attribute *attr, char *buf )
+{
+    struct max6635_data  *max6635 = NULL;
+    s32                   value;
+    int                   written = 0;
+    char                  a;
+    char                  f;
+    char                  i;
+    char                  o;
+    char                  s;
+    
+    max6635 = dev_get_drvdata(dev);
+    
+    if (max6635)
+    {
+        mutex_lock(&max6635->lock);
+        
+        value = i2c_smbus_read_byte_data(max6635->client, MAX6635_CONFIG_REG);
+        
+        mutex_unlock(&max6635->lock);
+    
+        if (value < 0)
+        {
+            written = scnprintf( buf, PAGE_SIZE, "read failure %d\n", value );
+        }
+        else
+        {
+            a = (value & MAX6635_CONFIG_ALERT_POLARITY)     ? 'A' : 'a';
+            f = (value & MAX6635_CONFIG_FAULT_QUEUE)        ? 'F' : 'f';
+            i = (value & MAX6635_CONFIG_INTERRUPT_MODE)     ? 'I' : 'i';
+            o = (value & MAX6635_CONFIG_OVER_TEMP_POLARITY) ? 'O' : 'o';
+            s = (value & MAX6635_CONFIG_SHUTDOWN_MODE)      ? 'S' : 's';
+            
+            written = scnprintf( buf, PAGE_SIZE,
+                    "%c:alert polarity %s\n"
+                    "%c:fault queue %s\n"
+                    "%c:interrupt mode %s\n"
+                    "%c:over temperature polarity %s\n"
+                    "%c:shutdown mode %s\n",
+                    a, isupper(a)?"ON":"OFF",
+                    f, isupper(f)?"ON":"OFF",
+                    i, isupper(i)?"ON":"OFF",
+                    o, isupper(o)?"ON":"OFF",
+                    s, isupper(s)?"ON":"OFF"
+                );
+        }
+    }
+    
+    return written;
+}
+
+static ssize_t max6635_store_config( struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct max6635_data  *max6635     = NULL;
+    int                   ret         = 0;
+    u16                   configMask  = 0;
+    u16                   configValue = 0;
+    s32                   value;
+    int                   i;
+    
+    for (i=0; i<count; ++i)
+    {
+        char c = buf[i];
+                
+        if (c == 0)
+        {
+            break;
+        }
+    
+        /* Accept lower case to clear a flag and upper case to set it */        
+        switch (c)
+        {
+        case 'A':
+            configMask  |=  MAX6635_CONFIG_ALERT_POLARITY;
+            configValue |=  MAX6635_CONFIG_ALERT_POLARITY;
+            break;
+            
+        case 'a':
+            configMask  |=  MAX6635_CONFIG_ALERT_POLARITY;
+            configValue &= ~MAX6635_CONFIG_ALERT_POLARITY;
+            break;
+            
+        case 'F':
+            configMask  |=  MAX6635_CONFIG_FAULT_QUEUE;
+            configValue |=  MAX6635_CONFIG_FAULT_QUEUE;
+            break;
+            
+        case 'f':
+            configMask  |=  MAX6635_CONFIG_FAULT_QUEUE;
+            configValue &= ~MAX6635_CONFIG_FAULT_QUEUE;
+            break;
+            
+        case 'I':
+            configMask  |=  MAX6635_CONFIG_INTERRUPT_MODE;
+            configValue |=  MAX6635_CONFIG_INTERRUPT_MODE;
+            break;
+            
+        case 'i':
+            configMask  |=  MAX6635_CONFIG_INTERRUPT_MODE;
+            configValue &= ~MAX6635_CONFIG_INTERRUPT_MODE;
+            break;
+            
+        case 'O':
+            configMask  |=  MAX6635_CONFIG_OVER_TEMP_POLARITY;
+            configValue |=  MAX6635_CONFIG_OVER_TEMP_POLARITY;
+            break;
+            
+        case 'o':
+            configMask  |=  MAX6635_CONFIG_OVER_TEMP_POLARITY;
+            configValue &= ~MAX6635_CONFIG_OVER_TEMP_POLARITY;
+            break;
+            
+        case 'S':
+            configMask  |=  MAX6635_CONFIG_SHUTDOWN_MODE;
+            configValue |=  MAX6635_CONFIG_SHUTDOWN_MODE;
+            break;
+            
+        case 's':
+            configMask  |=  MAX6635_CONFIG_SHUTDOWN_MODE;
+            configValue &= ~MAX6635_CONFIG_SHUTDOWN_MODE;
+            break;
+            
+        case ' ':
+        case '\t':
+        case '\n':
+        case '\r':
+            break;
+            
+        default:
+            printk("max6635 config invalid char[%d]=%d\n", i, c);
+            return -EINVAL;
+        }
+    }
+    
+    max6635 = dev_get_drvdata(dev);
+    
+    if (max6635)
+    {
+        mutex_lock(&max6635->lock);
+    
+        value = i2c_smbus_read_byte_data(max6635->client, MAX6635_CONFIG_REG);
+        if (value < 0)
+        {
+            printk("max6635:config failed to read %d\n", value);
+            return -EIO;
+        }
+        else
+        {
+            value &= ~configMask;
+            value |= configValue;
+            
+            ret = i2c_smbus_write_byte_data(max6635->client, MAX6635_CONFIG_REG, value);
+            if (ret)
+            {
+                printk("max6635:config failed to write %d\n", ret);
+                return -EIO;
+            }
+        }
+    
+        mutex_unlock(&max6635->lock);
+    }
+    
+    return count;
+}
+
+static DEVICE_ATTR( max6635_config, S_IRUGO | S_IWUSR, max6635_show_config, max6635_store_config );
+
+
+static int max6635_extractLimitValue(u16 value)
+{
+    int temp = (value >> 7) & 0x1FF;
+    
+    if (value & 0x8000)
+    {
+        temp -= 0x200;
+    }
+    
+    return temp;
+}
+
+/* The limit registers are 9-bit twos-complement in the MSBs.  The 7 LSBs are not used.
+* The value is in degrees C.
+*/
+static ssize_t max6635_show_limit_register( struct device *dev, char *buf, u8 regReadCmd )
+{
+    struct max6635_data  *max6635 = NULL;
+    s32                   value;
+    int                   written = 0;
+    
+    max6635 = dev_get_drvdata(dev);
+    
+    if (max6635)
+    {
+        mutex_lock(&max6635->lock);
+    
+        value = i2c_smbus_read_word_data(max6635->client, regReadCmd);
+        
+        mutex_unlock(&max6635->lock);
+        
+        if (value < 0)
+        {
+            written = scnprintf( buf, PAGE_SIZE, "read failure %d\n", value );
+        }
+        else
+        {
+            int temp = max6635_extractLimitValue(value);
+            
+            written = scnprintf( buf, PAGE_SIZE, "%d\n", temp );
+        }
+    }
+    
+    return written;
+}
+    
+/* The limit registers are 9-bit twos-complement in the MSBs.  The 7 LSBs are not used.
+* The value is in degrees C.
+*/
+static ssize_t max6635_store_limit_register( struct device *dev, const char *buf,
+                                            size_t count, u8 regWriteCmd )
+{
+    u16  t        = 0;
+    int  valid    = 0;
+    int  negative = 0;
+    int  remain   = count;
+    u16  limit    = MAX6635_LIMIT_REG_MAX;
+    
+    /* Skip initial space. */
+    while (remain && isspace(*buf))
+    {
+        buf++;
+        remain--;
+    }
+    
+    /* Check for sign */    
+    if (remain && (*buf == '-'))
+    {
+        negative  = 1;
+        limit = -MAX6635_LIMIT_REG_MIN;
+        
+        buf++;
+        remain--;
+    }
+    
+    /* Read digits. */
+    while (remain && isdigit(*buf))
+    {
+        if (t < 0x1000)
+        {
+            t *= 10;
+            t += *buf - '0';
+            
+            /* Saw at least one digit */
+            valid = 1;
+        }
+        else
+        {
+            /* Saw too many digits, result will be too big. */
+            valid = 0;
+        }
+        
+        buf++;
+        remain--;
+    }
+    
+    /* Check that trailing characters are all space. */
+    while (remain && isspace(*buf))
+    {
+        buf++;
+        remain--;
+    }
+    
+    if (valid && (remain == 0) && (t <= limit))
+    {
+        struct max6635_data  *max6635 = NULL;
+    
+        if (negative)
+        {
+            t = 0x200 - t;
+        }
+        
+        t <<= 7;
+                
+        max6635 = dev_get_drvdata(dev);
+    
+        if (max6635)
+        {
+            int  ret;
+            
+            mutex_lock(&max6635->lock);
+    
+            ret = i2c_smbus_write_word_data(max6635->client, regWriteCmd, t);
+            
+            mutex_unlock(&max6635->lock);
+            
+            if (ret < 0)
+            {
+                printk("max6635:store limit, failed to write %d\n", ret);
+                return -EIO;
+            }
+        }
+    }
+    else
+    {
+        printk("max6635:store limit, invalid value\n");
+        return -EINVAL;
+    }
+    
+    return count;
+}
+
+
+/* Hyst limit register */
+static ssize_t max6635_show_thyst( struct device *dev, struct device_attribute *attr, char *buf )
+{
+    return max6635_show_limit_register( dev, buf, MAX6635_THYST_REG );
+}
+
+static ssize_t max6635_store_thyst( struct device *dev, struct device_attribute *attr, const char *buf, size_t count )
+{
+    return max6635_store_limit_register( dev, buf, count, MAX6635_THYST_REG );
+}
+
+static DEVICE_ATTR( max6635_thyst, S_IRUGO | S_IWUSR, max6635_show_thyst, max6635_store_thyst  );
+
+
+
+/* Max limit register */
+static ssize_t max6635_show_tmax( struct device *dev, struct device_attribute *attr, char *buf )
+{
+    return max6635_show_limit_register( dev, buf, MAX6635_TMAX_REG );
+}
+
+static ssize_t max6635_store_tmax( struct device *dev, struct device_attribute *attr, const char *buf, size_t count )
+{
+    return max6635_store_limit_register( dev, buf, count, MAX6635_TMAX_REG );
+}
+
+static DEVICE_ATTR( max6635_tmax, S_IRUGO | S_IWUSR, max6635_show_tmax, max6635_store_tmax   );
+
+
+
+/* Low limit register */
+static ssize_t max6635_show_tlow( struct device *dev, struct device_attribute *attr, char *buf )
+{
+    return max6635_show_limit_register( dev, buf, MAX6635_TLOW_REG );
+}
+
+static ssize_t max6635_store_tlow( struct device *dev, struct device_attribute *attr, const char *buf, size_t count )
+{
+    return max6635_store_limit_register( dev, buf, count, MAX6635_TLOW_REG );
+}
+
+static DEVICE_ATTR( max6635_tlow, S_IRUGO | S_IWUSR, max6635_show_tlow, max6635_store_tlow   );
+
+
+
+/* High limit register */
+static ssize_t max6635_show_thigh( struct device *dev, struct device_attribute *attr, char *buf )
+{
+    return max6635_show_limit_register( dev, buf, MAX6635_THIGH_REG );
+}
+
+static ssize_t max6635_store_thigh( struct device *dev, struct device_attribute *attr, const char *buf, size_t count )
+{
+    return max6635_store_limit_register( dev, buf, count, MAX6635_THIGH_REG );
+}
+
+static DEVICE_ATTR( max6635_thigh, S_IRUGO | S_IWUSR, max6635_show_thigh, max6635_store_thigh  );
+
+
+static int max6635_open(struct inode *inode, struct file *filp)
+{
+    int                   result = 0;
+    
+    filp->private_data  = max6635_device;
+    
+    return result;
+}
+
+static int max6635_release(struct inode *inode, struct file *filp)
+{
+    if (filp->private_data)
+    {
+        filp->private_data = 0;
+    }
+    
+    return 0;
+}
+
+static int max6635_writeLimitRegister(struct max6635_data *max6635, u8 cmd, int temp)
+{
+    int  ret = 0;
+    
+    if (temp != MAX6635_DONT_UPDATE_LIMIT)
+    {
+        if ((temp < MAX6635_LIMIT_REG_MIN) || (temp > MAX6635_LIMIT_REG_MAX))
+        {
+            ret = -EINVAL;
+        }
+        else
+        {
+            u16 regVal;
+             
+            if (temp < 0)
+            {
+                regVal = 0x200 + temp;
+            }
+            else
+            {
+                regVal = temp;
+            }
+             
+            regVal <<= 7;
+            
+            ret = i2c_smbus_write_word_data(max6635->client, cmd, regVal);
+        }
+    }
+    
+    return ret;
+}
+
+static int max6635_readLimitRegister(struct max6635_data *max6635, u8 cmd, int* temp)
+{
+    s32  value;
+    
+    value = i2c_smbus_read_word_data(max6635->client, cmd);
+    if (value < 0)
+    {
+        return value;
+    }
+    
+    *temp = max6635_extractLimitValue(value);
+    
+    return 0;
+}
+
+static int max6635_ioctl(struct inode   *inode_p,
+                struct file    *filp,
+                unsigned int   cmd,
+                unsigned long  arg)
+{
+    struct max6635_data  *max6635 = NULL;
+    int                   ret     = 0;
+
+    /* don't even decode wrong cmds: better returning  ENOTTY than EFAULT */
+    if (_IOC_TYPE(cmd) != MAX6635_IOCTL_MAGIC) return -ENOTTY;
+    if (_IOC_NR(cmd)    > MAX6635_IOCTL_MAXNR) return -ENOTTY;
+    
+    max6635 = filp->private_data;
+    
+    switch (cmd)
+    {
+    case MAX6635_IOCTL_READ_TEMP:
+        {
+            Max6635Status  status;
+            s32            value;
+            
+            value = i2c_smbus_read_word_data(max6635->client, MAX6635_TEMP_REG);
+            if (value < 0)
+            {
+                ret = value;
+                break;
+            }
+            
+            status.flags   = value & 7;
+            
+            status.scaledCelcius = (value >> 3) & 0x1FFF;
+            if (status.scaledCelcius & 0x1000)
+            {
+                status.scaledCelcius = 0x2000 - status.scaledCelcius;
+            }
+            
+            if (copy_to_user((void*)arg, &status, sizeof(status)))
+            {
+                ret = -EFAULT;
+            }
+        }
+        break;
+    
+    case MAX6635_IOCTL_WRITE_CONFIG:
+        {
+            Max6635Config  config;
+            
+            if (copy_from_user(&config, (void*)arg, sizeof(config)))
+            {
+                ret = -EFAULT;
+                break;
+            }
+        
+            ret = i2c_smbus_write_byte_data(max6635->client, MAX6635_CONFIG_REG, config.flags);
+        }
+        break;
+        
+    case MAX6635_IOCTL_READ_CONFIG:
+        {
+            Max6635Config  config;
+            s32            value;
+            
+            value = i2c_smbus_read_byte_data(max6635->client, MAX6635_CONFIG_REG);
+            if (value < 0)
+            {
+                ret = value;
+                break;
+            }
+            
+            config.flags = value;
+            
+            if (copy_to_user((void*)arg, &config, sizeof(config)))
+            {
+                ret = -EFAULT;
+            }
+        }
+        break;
+        
+    case MAX6635_IOCTL_WRITE_LIMITS:
+        {
+            Max6635Limits  limits;
+            
+            if (copy_from_user(&limits, (void*)arg, sizeof(limits)))
+            {
+                ret = -EFAULT;
+                break;
+            }
+            
+            ret = max6635_writeLimitRegister(max6635, MAX6635_THIGH_REG, limits.thigh);
+            if (ret)
+            {
+                break;
+            }
+            
+            ret = max6635_writeLimitRegister(max6635, MAX6635_TLOW_REG, limits.tlow);
+            if (ret)
+            {
+                break;
+            }
+            
+            ret = max6635_writeLimitRegister(max6635, MAX6635_TMAX_REG, limits.tmax);
+            if (ret)
+            {
+                break;
+            }
+            
+            ret = max6635_writeLimitRegister(max6635, MAX6635_THYST_REG, limits.thyst);
+        }
+        break;
+        
+    case MAX6635_IOCTL_READ_LIMITS:
+        {
+            Max6635Limits  limits;
+            
+            ret = max6635_readLimitRegister(max6635, MAX6635_THIGH_REG, &limits.thigh);
+            if (ret)
+            {
+                break;
+            }
+            
+            ret = max6635_readLimitRegister(max6635, MAX6635_TLOW_REG, &limits.tlow);
+            if (ret)
+            {
+                break;
+            }
+            
+            ret = max6635_readLimitRegister(max6635, MAX6635_TMAX_REG, &limits.tmax);
+            if (ret)
+            {
+                break;
+            }
+            
+            ret = max6635_readLimitRegister(max6635, MAX6635_THYST_REG, &limits.thyst);
+            if (ret)
+            {
+                break;
+            }
+            
+            if (copy_to_user((void*)arg, &limits, sizeof(limits)))
+            {
+                ret = -EFAULT;
+            }
+        }
+        break;
+        
+    default:  /* redundant, as cmd was checked against MAXNR */
+        ret = -ENOTTY;
+    }
+    
+    return ret;
+}
+
+static struct file_operations max6635_fops = {
+    .owner      = THIS_MODULE,
+    .open       = max6635_open,
+    .release    = max6635_release,
+    .ioctl      = max6635_ioctl,
+};
+
+
+/* Return 0 if detection is successful, -ENODEV otherwise */
+static int max6635_detect(struct i2c_client *client, int kind,
+			  struct i2c_board_info *info)
+{
+	struct i2c_adapter *adapter = client->adapter;
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WRITE_BYTE_DATA
+				     | I2C_FUNC_SMBUS_READ_BYTE))
+		return -ENODEV;
+
+	strlcpy(info->type, "max6635", I2C_NAME_SIZE);
+
+	return 0;
+}
+
+static int max6635_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+    struct device        *dev      = &client->dev;
+    struct max6635_data  *max6635  = NULL;
+    int                   err;
+
+    max6635 = kzalloc(sizeof(struct max6635_data), GFP_KERNEL);
+    if (max6635 == NULL)
+    {
+        err = -ENOMEM;
+        goto err_no_mem;
+    }
+
+    max6635->client = client;
+
+    max6635->miscdev.fops   = &max6635_fops;
+    max6635->miscdev.name   = "max6635";
+    max6635->miscdev.minor  =  MAX6635_MINOR;  /* Our /dev is read only, so use a fixed value */
+    
+    err = misc_register( &max6635->miscdev );
+    if ( err )
+    {
+        printk( KERN_INFO "failed to register max6635 misc device\n" );
+        goto err_no_misc_device;
+    }
+    
+    /* Init i2c_client */
+    i2c_set_clientdata(client, max6635);
+    mutex_init(&max6635->lock);
+
+    err = device_create_file(dev, &dev_attr_max6635_temp);
+    if (err)
+    {
+        goto err_no_sysfs_temp;
+    }
+    err = device_create_file(dev, &dev_attr_max6635_config);
+    if (err)
+    {
+        goto err_no_sysfs_config;
+    }
+    err = device_create_file(dev, &dev_attr_max6635_thyst);
+    if (err)
+    {
+        goto err_no_sysfs_thyst;
+    }
+    err = device_create_file(dev, &dev_attr_max6635_tmax);
+    if (err)
+    {
+        goto err_no_sysfs_tmax;
+    }
+    err = device_create_file(dev, &dev_attr_max6635_tlow);
+    if (err)
+    {
+        goto err_no_sysfs_tlow;
+    }
+    err = device_create_file(dev, &dev_attr_max6635_thigh);
+    if (err)
+    {
+        goto err_no_sysfs_thigh;
+    }
+    
+    max6635_device = max6635;
+	
+    return 0;
+
+err_no_sysfs_thigh:
+    device_remove_file( dev, &dev_attr_max6635_tlow);
+err_no_sysfs_tlow:
+    device_remove_file( dev, &dev_attr_max6635_tmax);
+err_no_sysfs_tmax:
+    device_remove_file( dev, &dev_attr_max6635_thyst);
+err_no_sysfs_thyst:
+    device_remove_file( dev, &dev_attr_max6635_config);
+err_no_sysfs_config:
+    device_remove_file( dev, &dev_attr_max6635_temp);
+err_no_sysfs_temp:
+    misc_deregister( &max6635->miscdev );
+err_no_misc_device:
+	kfree(max6635);
+err_no_mem:
+	return err;
+}
+
+static int max6635_remove(struct i2c_client *client)
+{
+	struct max6635_data *max6635 = i2c_get_clientdata(client);
+    struct device       *dev     = &client->dev;
+
+    max6635_device = NULL;
+    
+    device_remove_file( dev, &dev_attr_max6635_thigh);
+    device_remove_file( dev, &dev_attr_max6635_tlow);
+    device_remove_file( dev, &dev_attr_max6635_tmax);
+    device_remove_file( dev, &dev_attr_max6635_thyst);
+    device_remove_file( dev, &dev_attr_max6635_config);
+    device_remove_file( dev, &dev_attr_max6635_temp);
+    
+    misc_deregister( &max6635->miscdev );
+    
+	kfree(max6635);
+
+	return 0;
+}
+
+static const struct i2c_device_id max6635_id[] = {
+	{ "max6635", 0 },
+	{ }
+};
+
+static struct i2c_driver max6635_driver = {
+	.driver = {
+		.name	= "max6635",
+	},
+	.probe		= max6635_probe,
+	.remove		= max6635_remove,
+	.id_table	= max6635_id,
+
+	.detect		= max6635_detect,
+	.address_data	= &addr_data,
+};
+
+static int __init max6635_init(void)
+{
+	return i2c_add_driver(&max6635_driver);
+}
+
+static void __exit max6635_exit(void)
+{
+	i2c_del_driver(&max6635_driver);
+}
+
+
+MODULE_DESCRIPTION("Driver for Maxim 6635");
+MODULE_AUTHOR("ip.access Ltd");
+MODULE_LICENSE("GPL");
+
+module_init(max6635_init);
+module_exit(max6635_exit);
diff -Naur pico_2.6.28/drivers/ipa/cpetd/cpetd_def.h ipa_2.6.28/drivers/ipa/cpetd/cpetd_def.h
--- pico_2.6.28/drivers/ipa/cpetd/cpetd_def.h	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/ipa/cpetd/cpetd_def.h	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,36 @@
+/******************************************************************************
+ *
+ * Copyright (c) 2009 ip.access Ltd.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ * 22 Apr 2009 Created by Simon D Hughes.
+ *
+ * header for remainder table
+ *****************************************************************************
+ * Filename: 
+ *****************************************************************************/
+
+/* remainder_table
+ *  lookup table of jiffies (32 bit word) remainders
+ *  table of remainders of 2^32 % period for 1 < period < 63
+ *  using a table allows us to avoid using a spin lock for ioctls that 
+ *  change the period and hence need the remainder recalculating (as this 
+ *  would cause a race condition between the ioctl syscall and the timer 
+ *  callback which needs to access period and remainder). 
+ *  generated using code in cpetd_test.c
+ *
+ *  defined in header file so can be shared between module and test app.
+ */
+#define CPETD_MAX_PERIOD        63  /* 2^32 for computing remainder. jiffies is 32bit number */
+
+#define CPTED_DECLARE_REMAINDER_TABLE(__varname)                                    \
+    static unsigned char __varname[] = {                                            \
+   -1,   0,   0,   1,   0,   1,   4,   4,   0,   4,   6,   4,   4,   9,   4,   1,   \
+    0,   1,   4,   6,  16,   4,   4,  12,  16,  21,  22,  22,   4,  16,  16,   4,   \
+    0,   4,  18,  11,   4,   7,   6,  22,  16,  37,   4,  16,   4,  31,  12,  42,   \
+    16,  39,  46,   1,  48,  42,  22,  26,  32,  25,  16,  51,  16,  57,   4,   4   \
+    }
diff -Naur pico_2.6.28/drivers/ipa/cpetd/cpetd_load ipa_2.6.28/drivers/ipa/cpetd/cpetd_load
--- pico_2.6.28/drivers/ipa/cpetd/cpetd_load	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/ipa/cpetd/cpetd_load	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,58 @@
+#!/bin/sh
+
+################################################################################
+# 
+# Copyright (c) 2009 ip.access Ltd.
+#
+#  This program is free software; you can redistribute  it and/or modify it
+#  under  the terms of  the GNU General  Public License as published by the
+#  Free Software Foundation;  either version 2 of the  License, or (at your
+#  option) any later version.
+#
+# 22 Apr 2009 Created by Simon D Hughes.
+##############################################################################
+# Filename: 
+##############################################################################
+
+# User can supply the number of devices to create - defautls to 1
+if test $1
+then
+    numDevs=$1
+    if [ ${numDevs} -eq 0 ]
+    then
+        numDevs=1
+    fi
+else
+    numDevs=1
+fi
+
+module="cpetd"
+device="cpetd"
+group="root"
+mode="664"
+
+# remove stale nodes
+rm -f /dev/${device}[0-9] /dev/${device}
+
+# invoke insmod with all arguments we got
+# and use a pathname, as newer modutils don't look in . by default
+/sbin/insmod -f ./$module.ko cpetdNumDevs=${numDevs} || exit 1
+
+major=`cat /proc/devices | awk "\\$2==\"$module\" {print \\$1}"`
+
+dnum=0
+while [ ${dnum} -lt ${numDevs} ]
+do
+    if test ${dnum} -lt ${numDevs}
+    then
+        mknod /dev/${device}${dnum} c $major ${dnum}
+
+        # give appropriate group/permissions
+        chgrp $group /dev/${device}${dnum}
+        chmod $mode  /dev/${device}${dnum}
+    fi
+    let dnum++
+done
+
+ln -sf ${device}0  /dev/${device}
+
diff -Naur pico_2.6.28/drivers/ipa/cpetd/cpetd_main.c ipa_2.6.28/drivers/ipa/cpetd/cpetd_main.c
--- pico_2.6.28/drivers/ipa/cpetd/cpetd_main.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/ipa/cpetd/cpetd_main.c	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,989 @@
+/* -*- C -*-
+ * cpetd_main.c -- the CPE Timebase Device driver module
+ *
+ * Document refence list:
+ * 1. 3GAP_CPE_HLD_0013_Timebase_Device_V00_03.doc
+ *    the design document.
+ *
+ * Copyright (C) 2007 ip.access Ltd
+ *
+ * $Id: PC202/kernel/kernel-2.6.28/linux-v2.6.28-ipa-3.2.4-patch 1.4.2.18.1.2 2011/11/29 21:21:59GMT Mark Powell (mp3) Exp  $
+ */
+
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/kernel.h>   /* printk() */
+#include <linux/slab.h>     /* kmalloc() */
+#include <linux/fs.h>       /* everything... */
+#include <linux/errno.h>    /* error codes */
+#include <linux/types.h>    /* size_t */
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+#include <linux/jiffies.h>
+#include <linux/timer.h>
+#include <linux/cdev.h>
+#include <linux/spinlock.h>
+#if defined(CPETD_ON_ARM)
+#include <asm/io.h>
+#include <mach/hardware.h>
+
+#if defined(CONFIG_ARCH_FIRECRACKER)
+#  include <mach/pc20x/pc20x.h>
+#  include <mach/pc20x/timer.h>
+#elif defined(CONFIG_ARCH_PC302)
+#  include <mach/pc302/pc302.h>
+#  include <mach/pc302/timer.h>
+#else  /* CONFIG_ARCH_... */
+#  error "Unknown architecture"
+#endif /* CONFIG_ARCH_... */
+
+#include <mach/platform.h>
+#endif  /* defined(CPETD_ON_ARM) */
+#include <linux/ipa/cpetd.h>          /* driver interface header file */
+
+#if defined(CONFIG_IPACCESS_FPGA_DEBUG)
+#include <mach/fpga_debug.h>
+#endif /* defined(CONFIG_IPACCESS_FPGA_DEBUG) */
+
+/*
+ * Configuration definitions
+ */
+#define USE_KERNEL_TIMER        1
+#define CPETD_USE_PROC          1
+
+
+/*
+ * Macros to help debugging
+ */
+
+#undef PDEBUG             /* undef it, just in case */
+#if defined(CPETD_DEBUG)
+#   define PDEBUG(fmt, args...) printk( KERN_DEBUG "cpetd: " fmt, ## args)
+#else
+#   define PDEBUG(fmt, args...) /* not debugging: nothing */
+#endif
+
+
+
+#ifdef CONFIG_IPACCESS_CPETD_MODULE
+#define CPETD_MAJOR             0           /* dynamic major by default */
+#else
+#define CPETD_MAJOR           240           /* Fixed major when working with RO filesys and driver in kernel */
+#endif
+#define CPETD_NUM_DEVS          1           /* only one device by default */
+
+#define CPETD_BASE_INTERVAL     CPETD_PERIOD    /* timebase interrupt period (ms) */
+#define CPETD_TIMEBASE_INIT     ((unsigned long)(unsigned int) (-250))  /* start value for the timebase tick
+                                                                        * (check wrapping behaviour early!)
+                                                                        * (-300*1000) == 5mins before wrap
+                                                                        */
+
+
+#if defined(CPETD_ON_ARM)
+/* use PIT4 for free running timer */
+#define TIMER_NUM       3
+
+#if defined(CONFIG_ARCH_FIRECRACKER)
+
+#  define TIMER_REG_BASE   PC20X_TIMERS_BASE
+#  define TIMER_REG_OFFSET TIMER_N_CURRENT_VALUE_REG_OFFSET(TIMER_NUM)
+
+#  define TIMER_VAL_REG (IO_ADDRESS(PC20X_TIMERS_BASE + TIMER_N_CURRENT_VALUE_REG_OFFSET(TIMER_NUM)))
+#  define TIMER_CTL_REG (IO_ADDRESS(PC20X_TIMERS_BASE + TIMER_N_CONTROL_REG_OFFSET(TIMER_NUM)))
+#  define TIMER_CNT_REG (IO_ADDRESS(PC20X_TIMERS_BASE + TIMER_N_LOAD_COUNT_REG_OFFSET(TIMER_NUM)))
+
+#  define TIMER_CTL_REG_ENABLE_BIT (TIMER_ENABLE)
+
+#elif defined(CONFIG_ARCH_PC302)
+
+#  define TIMER_REG_BASE   PC302_TIMER_BASE
+#  define TIMER_REG_OFFSET TIMERNCURRENTVALUEREGOFFSET(TIMER_NUM)
+
+#  define TIMER_VAL_REG (IO_ADDRESS(PC302_TIMER_BASE + TIMERNCURRENTVALUEREGOFFSET(TIMER_NUM)))
+#  define TIMER_CTL_REG (IO_ADDRESS(PC302_TIMER_BASE + TIMERNCONTROLREGOFFSET(TIMER_NUM)))
+#  define TIMER_CNT_REG (IO_ADDRESS(PC302_TIMER_BASE + TIMERNLOADCOUNTREGOFFSET(TIMER_NUM)))
+
+#  define TIMER_CTL_REG_ENABLE_BIT (TIMERENABLE)
+
+#else  /* CONFIG_ARCH_... */
+
+#  error "Unknown architecture"
+
+#endif /* CONFIG_ARCH_... */
+
+#endif  /* defined(CPETD_ON_ARM) */
+
+
+
+/*---------------------------------------------------------------------------*/
+
+/* STRUCTURE: CpetdDev
+ *  Device structure
+ * MEMBERS:
+ * period
+ *   timebase interval in jiffies (must be r/w as an atomic operation)
+ * cdev
+ *   char dev struct
+ */
+typedef struct CpetdDevTag
+{
+    unsigned short  period;
+    struct cdev     cdev;
+} CpetdDev;
+
+
+/* STRUCTURE: CpetdFileCtxTag
+ *  file structure
+ * MEMBERS:
+ * dev_p        pointer to associated device
+ * info         read info
+ * lastReadEnd  time of last return (jiffies). F in ref 1.
+ * lastBeat     time (in jiffies) of last beat user woke up on
+ * noReadYet    =1 initially, set to 0 after 1st user process read. Used to
+ *              stop lastBeat being used until after the first read. This is
+ *              done to allow for arbitrarily long delay between opening and reading.
+ * offset       used for debug & test. offset is added to jiffies so that the
+ *              test application can simulate jiffies wrapping.
+ */
+typedef struct CpetdFileCtxTag
+{
+    CpetdDev*           dev_p;
+    CpetdReadInfoV1     info;
+    unsigned int        lastReadEnd;
+    unsigned int        lastBeat;
+    unsigned int        flags;
+    int                 noReadYet;
+    /* debug and test members follow */
+#ifdef CPETD_TEST
+    unsigned int        offset;
+#endif /* CPETD_TEST */
+} CpetdFileCtx;
+
+#define CPETD_FIILECTX_F_FAST_RETURN    (1<<0)
+
+/* helper macro to see if wrapped*/
+#define CPETD_FIILECTX_FAST_RETURN(ctx_p)   ((ctx_p)->flags & CPETD_FIILECTX_F_FAST_RETURN)
+#define CPETD_INFO_FAST_RETURN(ctx_p)       ((ctx_p)->info.flags & CPETD_INFO_F_FAST_RETURN)
+
+/*---------------------------------------------------------------------------*/
+
+/*
+ * The different configurable parameters (i.e. can be overridden when driver is installed)
+ */
+int     cpetdMajor              = CPETD_MAJOR;
+int     cpetdNumDevs            = CPETD_NUM_DEVS;   /* number of cpetd devices */
+short   cpetdPeriod             = CPETD_PERIOD;
+
+
+/*
+ * tick count used for timebase (1 tick = CPETD_BASE_INTERVAL ms)
+ * this MUST be volatile to ensure atomic access.
+ * NB timebase instants are now calculated usign jiffies rather than this value. It has been
+ *    left in for clarity in debugging, but in theory could be removed.
+ */
+static volatile unsigned long   cpetdTimebaseTick = CPETD_TIMEBASE_INIT;
+
+/*
+ * Value of free-running PIT4 at the last (underlying) timebase instant
+ */
+static volatile int             cpetdHiresInstant = 0;
+
+/* number of ticks of the high resolution timer per second - default to jiffies rate */
+static int                      cpetdHiresResolution = HZ;
+
+#if defined(USE_KERNEL_TIMER)
+/*
+ * kernel timer used to provide the timebase
+ */
+struct timer_list   cpetdTimebaseTimer;
+#   if defined(CPETD_DEBUG)
+unsigned long       cpetdTimerAdded;                /* jiffies value when timer was added */
+unsigned long       cpetdTimerNumLate = 0;          /* # times kernel timer was late by >= 1 jiffies value (1 ms) */
+unsigned long       cpetdTimerMaxLate = 0;          /* max lateness (in jiffies) observed */
+unsigned long       cpetdTimerNumExpired = 0;       /* # times kernel timer has expired when we start it */
+unsigned long       cpetdTimerMaxExpired = 0;       /* max time by which timer has already expired */
+unsigned long       cpetdTimerNumExpired2 = 0;      /* # times kernel timer has expired when we start it (early calc) */
+unsigned long       cpetdTimerMaxExpired2 = 0;      /* max time by which timer has already expired (early calc) */
+unsigned long       cpetdTimerNumSlowExec = 0;      /* # times kernel expiry function ran for more than 2 ms */
+unsigned long       cpetdTimerMaxExecTime = 0;      /* max time the timer expiry function runs for */
+unsigned long       cpetdTimerMaxAddTime = 0;       /* max time the add_timer function runs for */
+unsigned long       cpetdTimerMaxWakeupTime = 0;    /* max time the wake_up_interruptible function runs for */
+#   endif  /* defined(CPETD_DEBUG) */
+
+#else
+#error No mechanismm for counting off the timebase!
+#endif
+
+/*
+ * Context structures allocated per device (in cpetd_init())
+ */
+CpetdDev            *cpetdDevices_p = NULL;
+
+
+/*
+ * all processes will block on this queue when they read()
+ */
+DECLARE_WAIT_QUEUE_HEAD (cpetd_wait_q);
+
+
+/*---------------------------------------------------------------------------*/
+
+/*
+ * export symbols to the kernel
+ */
+module_param (cpetdMajor, int, 0);
+module_param (cpetdNumDevs, int, 0);
+module_param (cpetdPeriod, short, 0);
+
+MODULE_AUTHOR ("ip.access");
+MODULE_LICENSE ("Dual BSD/GPL");
+
+
+
+/*---------------------------------------------------------------------------*/
+#ifdef CPETD_USE_PROC /* don't waste space if unused */
+/*
+ * The proc filesystem: function to read an entry
+ */
+
+int cpetd_read_procmem (char    *buf_p,
+                        char    **start_p,
+                        off_t   offset,
+                        int     count,
+                        int     *eof_p,
+                        void    *data_p)
+{
+    int                 devNum;
+    int                 len = 0;
+    int                 limit = count - 80; /* Don't print more than this */
+    unsigned short      period;
+    CpetdDev            *dev_p;
+
+    len += sprintf (buf_p + len,"\nVersion=0x%08x\n", CPETD_INFO_F_VERSION_1_0);
+    len += sprintf (buf_p + len,"TimebaseNow=%ld\n", cpetdTimebaseTick);
+    len += sprintf (buf_p + len,"HiresInstant=0x%08x\n", cpetdHiresInstant);
+    len += sprintf (buf_p + len,"Hires ticks per second=%d\n", cpetdHiresResolution);
+#if defined(USE_KERNEL_TIMER) && defined(CPETD_DEBUG)
+    len += sprintf (buf_p + len,"  Num times late=%ld,  max lateness=%ld ms\n",
+                    cpetdTimerNumLate, cpetdTimerMaxLate);
+    len += sprintf (buf_p + len,"  Num times expired=%ld,  max expired time=%ld ms\n",
+                    cpetdTimerNumExpired, cpetdTimerMaxExpired);
+    len += sprintf (buf_p + len,"  Num times expired2=%ld,  max expired time2=%ld ms\n",
+                    cpetdTimerNumExpired2, cpetdTimerMaxExpired2);
+    len += sprintf (buf_p + len,"  Max expiry handler execution time=%ld ms   (Slow %ld times out of %ld)\n",
+                    cpetdTimerMaxExecTime, cpetdTimerNumSlowExec, (cpetdTimebaseTick - CPETD_TIMEBASE_INIT));
+    len += sprintf (buf_p + len,"  Max add_timer execution time=%ld ms\n",
+                    cpetdTimerMaxAddTime);
+    len += sprintf (buf_p + len,"  Max wake_up_interruptible execution time=%ld ms\n",
+                    cpetdTimerMaxWakeupTime);
+#endif  /* defined(USE_KERNEL_TIMER) && defined(CPETD_DEBUG) */
+
+    dev_p = &cpetdDevices_p [0];
+    for (devNum = 0; devNum < cpetdNumDevs; devNum++)
+    {
+        /* retrieve the period of each device and use remainder_table[] for atomicity*/
+        period = dev_p->period;
+        len += sprintf (buf_p + len,"\nDevice %i: Period %i ms\n", devNum, period);
+        if (len > limit)
+        {
+            break;
+        }
+
+        dev_p++;
+    }
+
+    *eof_p = 1;
+    return len;
+}
+#endif /* CPETD_USE_PROC */
+
+
+/*---------------------------------------------------------------------------*/
+#if defined(USE_KERNEL_TIMER)
+void cpetdTimebaseTimerExpired (unsigned long data)
+{
+#   if defined(CPETD_DEBUG)
+    unsigned long   t0 = jiffies;
+    unsigned long   t1;
+    unsigned long   t2;
+    unsigned long   t3;
+    unsigned long   expectedJiffies = cpetdTimerAdded + msecs_to_jiffies(CPETD_BASE_INTERVAL);
+
+    if (time_after (expectedJiffies, t0))
+    {
+        cpetdTimerNumLate++;
+        if (cpetdTimerMaxLate < (expectedJiffies - t0))
+        {
+            cpetdTimerMaxLate = expectedJiffies - t0;
+        }
+    }
+    if (time_after (t0, cpetdTimebaseTimer.expires))
+    {
+        cpetdTimerNumExpired2++;
+        if (cpetdTimerMaxExpired2 < (t0 - cpetdTimebaseTimer.expires))
+        {
+            cpetdTimerMaxExpired2 = t0 - cpetdTimebaseTimer.expires;
+        }
+    }
+#   endif  /* defined(CPETD_DEBUG) */
+
+#if defined(CPETD_ON_ARM)
+    /* read free-running timer for high resolution value at the time of the instant */
+    cpetdHiresInstant = ioread32(__io(TIMER_VAL_REG));
+#else
+    cpetdHiresInstant = jiffies;
+#endif  /* defined(CPETD_ON_ARM) */
+
+    /* this is the next timebase instant! */
+    cpetdTimebaseTick++;
+
+    /* restart the timer */
+#   if defined(CPETD_DEBUG)
+    cpetdTimerAdded = jiffies;                                        /* re-read in case chanegs as this function executes */
+    t1 = jiffies;
+#   endif   /* defined(CPETD_DEBUG) */
+    cpetdTimebaseTimer.expires += msecs_to_jiffies(CPETD_BASE_INTERVAL);
+    add_timer (&cpetdTimebaseTimer);
+
+#   if defined(CPETD_DEBUG)
+    t2 = jiffies;
+    if (time_after (t2, cpetdTimebaseTimer.expires))
+    {
+        cpetdTimerNumExpired++;
+        if (cpetdTimerMaxExpired < (t2 - cpetdTimebaseTimer.expires))
+        {
+            cpetdTimerMaxExpired = t2 - cpetdTimebaseTimer.expires;
+        }
+    }
+#   endif  /* defined(CPETD_DEBUG) */
+
+    /* kick off all the processes waiting on the timebase */
+    wake_up_interruptible (&cpetd_wait_q);
+
+#   if defined(CPETD_DEBUG)
+    t3 = jiffies;
+    if (cpetdTimerMaxAddTime < (t2 - t1))
+    {
+        cpetdTimerMaxAddTime = t2 - t1;
+    }
+    if (cpetdTimerMaxWakeupTime < (t3 - t2))
+    {
+        cpetdTimerMaxWakeupTime = t3 - t2;
+    }
+    if (cpetdTimerMaxExecTime < (t3 - t0))
+    {
+        cpetdTimerMaxExecTime = t3 - t0;
+    }
+    if (t3 - t0 > msecs_to_jiffies(CPETD_BASE_INTERVAL))
+    {
+        cpetdTimerNumSlowExec++;
+    }
+#   endif  /* defined(CPETD_DEBUG) */
+}
+#endif
+
+
+/*---------------------------------------------------------------------------*/
+/*
+ * invoked when user process issues an open() call (or equivalent) on device file
+ */
+int cpetd_open (struct inode *inode, struct file *filp)
+{
+    int             result = 0;
+    CpetdFileCtx*   ctx_p;      /* file private context */
+    CpetdDev*       dev_p;      /* device information */
+
+    /*  Find the device */
+    dev_p = container_of (inode->i_cdev, CpetdDev, cdev);
+
+    ctx_p = kmalloc(sizeof(CpetdFileCtx), GFP_KERNEL);
+    if(!ctx_p)
+    {
+        result = -ENOMEM;
+    }
+    else
+    {
+        memset(ctx_p , 0, sizeof (CpetdFileCtx));
+        ctx_p->lastBeat     = cpetdTimebaseTimer.expires - dev_p->period;
+        ctx_p->noReadYet    = 1;
+        ctx_p->lastReadEnd  = ctx_p->lastBeat;
+        ctx_p->dev_p        = dev_p;
+        filp->private_data  = ctx_p;
+    }
+    return result;
+}
+
+
+/*---------------------------------------------------------------------------*/
+/*
+ * invoked when user process issues a close() call (or equivalent) on device file
+ */
+int cpetd_release (struct inode *inode, struct file *filp)
+{
+    if (filp->private_data)
+    {
+        kfree (filp->private_data);
+        filp->private_data = 0;
+    }
+
+    return 0;
+}
+
+
+/*---------------------------------------------------------------------------*/
+/* offset used to induce wrap*/
+static inline unsigned long get_jiffies(CpetdFileCtx* ctx_p)
+{
+#ifdef CPETD_TEST
+    return jiffies + ctx_p->offset;
+#else
+    return jiffies;
+#endif /* CPETD_TEST */
+
+}
+
+
+/*---------------------------------------------------------------------------*/
+/*
+ * invoked when user process issues a read() call (or equivalent) on device file
+ */
+ssize_t cpetd_read (struct file *filp,
+                    char __user *buf_p,
+                    size_t      count,
+                    loff_t      *f_pos_p)
+{
+    CpetdFileCtx*       ctx_p = (CpetdFileCtx*) filp->private_data;
+    CpetdDev            *dev_p = ctx_p->dev_p;
+    unsigned long       readStartTime = get_jiffies(ctx_p);
+    unsigned long       readEndTime;
+    unsigned long       predictedNextBeat;          /* beat app expected to hit */
+    unsigned long       actualNextBeat;             /* beat that app will actual be reactivated on */
+    unsigned long       result;
+    short               period = dev_p->period;     /* reading period ensure atomicity */
+    int                 index, index1 = 0;
+    unsigned long num_running;
+
+
+    /* setup calculation of return data */
+    ctx_p->info.flags &= ~CPETD_READINFO_F_FAST_RETURN;
+
+    /* determine if beats have been missed*/
+    predictedNextBeat = ctx_p->lastBeat + dev_p->period;
+    if (   CPETD_FIILECTX_FAST_RETURN(ctx_p)
+        && (ctx_p->noReadYet == 0)
+        && time_before_eq (predictedNextBeat, readStartTime)
+       )
+    {   /* fast return enabled AND user is late for the next beat */
+        PDEBUG("cpetd: fast return\n");
+        ctx_p->info.flags |= CPETD_READINFO_F_FAST_RETURN;
+
+        /* force user to resync though multiple fast erturns i.e. irrespective of the   */
+        /* amount by which user is late, we only increment the beat by one period.      */
+        /* The idea is that the user is strictly locked to the absolute timebase.       */
+        actualNextBeat = predictedNextBeat;
+/*SHH old code - skips beats, not good!        actualNextBeat = readStartTime - ((readStartTime - ctx_p->lastBeat) % period);*/
+    }
+    else
+    {
+        /* calculate next timebase instant (in jiffies) for the period we are using,    */
+        /* and update timebaseAlignment if wrap                                         */
+        actualNextBeat = readStartTime + (period - ((readStartTime - ctx_p->lastBeat) % period));
+
+        /* sleep until the end time is reached */
+        while (time_before (get_jiffies(ctx_p), actualNextBeat))
+        {
+            DEFINE_WAIT (wait);
+
+            if (filp->f_flags & O_NONBLOCK)
+            {
+                return -EAGAIN;
+            }
+
+            prepare_to_wait (&cpetd_wait_q, &wait, TASK_INTERRUPTIBLE);
+            if (time_before (get_jiffies(ctx_p), actualNextBeat))
+            {   /* didn't reach timer while preparing for wait - so really go to sleep */
+                schedule ();
+            }
+            finish_wait (&cpetd_wait_q, &wait);
+            if (signal_pending (current))
+            {
+                return -ERESTARTSYS;
+            }
+        }
+    }
+
+    ctx_p->noReadYet = 0;
+
+    /* set info.jiffies to now */
+    readEndTime         = get_jiffies(ctx_p);
+    ctx_p->info.jiffies = readEndTime;
+
+    /* update userProc */
+    result = jiffies_to_msecs(readStartTime - ctx_p->lastReadEnd);
+    if (result > 255)
+    {
+        result = 255;
+    }
+    ctx_p->info.userProc = result;
+
+    /* update kernelDelay */
+    result = jiffies_to_msecs(readEndTime - actualNextBeat);
+    if (result > 255)
+    {
+        result = 255;
+    }
+    ctx_p->info.kernelDelay = result;
+
+    /* update missed beats */
+    result = jiffies_to_msecs(actualNextBeat - predictedNextBeat);
+    if (result > 255)
+    {
+        result = 255;
+    }
+    ctx_p->info.missedBeats = result;
+
+#ifdef CPETD_TEST
+    ctx_p->info.actualBeat = actualNextBeat;
+#endif /* CPETD_TEST */
+
+    ctx_p->lastReadEnd  = readEndTime;
+    ctx_p->lastBeat     = actualNextBeat;
+    num_running = ret_nr_running();
+    ctx_p->info.numRunning = num_running;
+    ctx_p->info.globPreemptFlag = 0;
+
+    for(index = 0; index < MAX_NUM_OF_PROCESSES; ++index)
+    {
+		for(index1 = 0; index1 < ctx_p->info.processInfo[index].numThreads; ++index1)
+		{
+			struct task_struct *task_p = find_task_struct_by_pid(ctx_p->info.processInfo[index].threadInfo[index1].tid);
+			if(task_p)
+			{
+				if (task_p->state == TASK_RUNNING)
+				{
+					/* The thread had more work to do the last time that it ran or it has just woken up.
+					 * Update how long this thread has been waiting to run to completion. */
+					task_p->incompleteTicks++;
+				}
+				ctx_p->info.processInfo[index].threadInfo[index1].incompleteTicks = task_p->incompleteTicks;
+				ctx_p->info.processInfo[index].threadInfo[index1].state = task_p->state;
+				ctx_p->info.processInfo[index].threadInfo[index1].preemptFlag = task_p->preempt_flag;
+				ctx_p->info.processInfo[index].threadInfo[index1].preemptPid = task_p->preempt_pid;
+				ctx_p->info.globPreemptFlag |= ctx_p->info.processInfo[index].threadInfo[index1].preemptFlag;
+			}
+		}
+    }
+    /* return data */
+    result = min(count, sizeof(CpetdReadInfoV1));
+    if (copy_to_user (buf_p, &ctx_p->info, result))
+    {
+        return -EFAULT;
+    }
+    return result;
+}
+
+
+/*---------------------------------------------------------------------------*/
+/*
+ * The ioctl() implementation
+ */
+
+static int cpetd_ioctl_setinfo(CpetdFileCtx* ctx_p, CpetdInfo* info_p)
+{
+    int ret = 0;
+
+    /* process fast return bit*/
+    if (info_p->flags & CPETD_INFO_F_FAST_RETURN)
+    {
+        /* set fast return mode*/
+        ctx_p->flags |= CPETD_FIILECTX_F_FAST_RETURN;
+    }
+    else
+    {
+        /* clear fast return mode*/
+        ctx_p->flags &= ~CPETD_FIILECTX_F_FAST_RETURN;
+    }
+
+#ifdef CPETD_TEST
+    /* process debug offset stop*/
+    if (info_p->flags & CPETD_INFO_F_DEBUG_OFFSET_STEP)
+    {
+        /* set offset to cause jiffies + offset to wrap in 10 seconds - ensure multiple of interval */
+        ctx_p->offset = ((CPETD_TIMEBASE_INIT - jiffies)/CPETD_BASE_INTERVAL)*CPETD_BASE_INTERVAL;
+    }
+    /* process debug offset reset*/
+    if (info_p->flags & CPETD_INFO_F_DEBUG_OFFSET_RESET)
+    {
+        /* set offset to cause jiffies + offset to wrap in 10 seconds */
+        ctx_p->offset = 0;
+    }
+#endif /* CPETD_TEST */
+
+    return ret;
+}
+
+
+int cpetd_ioctl (struct inode   *inode_p,
+                 struct file    *filp,
+                 unsigned int   cmd,
+                 unsigned long  arg)
+{
+    int             ret = 0;
+    CpetdDev*       dev_p;
+    CpetdFileCtx*   ctx_p;
+    int index, index1 = 0;
+    int i, j = 0;
+
+    /* don't even decode wrong cmds: better returning  ENOTTY than EFAULT */
+    if (_IOC_TYPE(cmd) != CPETD_IOC_MAGIC) return -ENOTTY;
+    if (_IOC_NR(cmd) > CPETD_IOC_MAXNR) return -ENOTTY;
+
+    ctx_p = filp->private_data;
+    dev_p = ctx_p->dev_p;
+
+    switch (cmd)
+    {
+    case CPETD_IOCTPERIOD: /* Tell: arg is the value */
+        if ((arg < CPETD_BASE_INTERVAL) || (arg > CPETD_MAX_INTERVAL))
+        {
+            ret = -EINVAL;
+        }
+        else
+        {
+            dev_p->period = msecs_to_jiffies((unsigned int) arg);
+        }
+        break;
+
+    case CPETD_IOCQPERIOD: /* Query: return it (it's positive) */
+        ret = jiffies_to_msecs(dev_p->period);
+        break;
+
+    case CPETD_IOCSETINFO:
+    {
+        CpetdInfo       info;
+
+        if (copy_from_user(&info, (void*) arg, sizeof(info)))
+        {
+            ret = -EFAULT;
+        }
+        else
+        {
+            ret = cpetd_ioctl_setinfo(ctx_p, &info);
+        }
+        break;
+    }
+
+    case CPETD_IOCGETINFO:
+    {
+        CpetdInfo       info;
+
+        memset(&info, 0, sizeof(info));
+
+        if(ctx_p->flags & CPETD_FIILECTX_F_FAST_RETURN)
+        {
+            info.flags |= CPETD_INFO_F_FAST_RETURN;
+        }
+        else
+        {
+            info.flags &= ~CPETD_INFO_F_FAST_RETURN;
+        }
+        info.flags |= CPETD_INFO_F_VERSION_1_0;
+        if(copy_to_user((void*) arg, &info, sizeof(info)))
+        {
+            ret = -EFAULT;
+        }
+        break;
+    }
+
+    case CPETD_IOCGETHIRESINFO:
+    {
+        CpetdHiresInfo  hiresInfo;
+
+        memset(&hiresInfo, 0, sizeof(hiresInfo));
+
+        hiresInfo.lastBeatHiresTime     = cpetdHiresInstant;
+        hiresInfo.hiresTicksPerSecond   = cpetdHiresResolution;
+        if(copy_to_user((void*) arg, &hiresInfo, sizeof(hiresInfo)))
+        {
+            ret = -EFAULT;
+        }
+        break;
+    }
+
+    case CPETD_IOCGETPHYSREGINFO:
+    {
+        CpetdPhysRegInfo  physRegInfo;
+
+        memset(&physRegInfo, 0, sizeof(physRegInfo));
+
+        physRegInfo.timerRegisters   = TIMER_REG_BASE;
+        physRegInfo.timerCountRegOff = TIMER_REG_OFFSET;
+        if(copy_to_user((void*) arg, &physRegInfo, sizeof(physRegInfo)))
+        {
+            ret = -EFAULT;
+        }
+        break;
+    }
+    case CPETD_IOCPROCESSIDINFO:
+    {
+	CpetdProcessInfo procInfo[MAX_NUM_OF_PROCESSES];
+
+	memset(&procInfo, 0, (MAX_NUM_OF_PROCESSES * sizeof(CpetdProcessInfo)));
+
+	if(copy_from_user(&procInfo, (void*) arg, (MAX_NUM_OF_PROCESSES * sizeof(CpetdProcessInfo))))
+	{
+            ret = -EFAULT;
+	}
+
+	for(index = 0; index < MAX_NUM_OF_PROCESSES; ++index)
+	{
+		ctx_p->info.processInfo[index].numThreads = procInfo[index].numThreads;
+
+		for(index1 = 0; index1 < ctx_p->info.processInfo[index].numThreads; ++index1)
+		{
+			ctx_p->info.processInfo[index].threadInfo[index1].tid = procInfo[index].threadInfo[index1].tid;
+		}
+	}
+
+	for(i=0; i < MAX_NUM_OF_PROCESSES; ++i)
+        {
+		printk(KERN_NOTICE "\nNumber of threads are: %d\n", ctx_p->info.processInfo[i].numThreads);
+		for(j = 0; j < ctx_p->info.processInfo[i].numThreads; ++j)
+		{
+			struct task_struct *task_p = NULL;
+			
+			printk(KERN_NOTICE "\nThe tID is %d\n", ctx_p->info.processInfo[i].threadInfo[j].tid);
+			
+			task_p = find_task_struct_by_pid(ctx_p->info.processInfo[i].threadInfo[j].tid);
+			if(task_p)
+			{
+				task_p->incompleteTicks = 0;
+			}
+		}
+    	}
+	
+	break;
+    }
+
+    default:  /* redundant, as cmd was checked against MAXNR */
+        ret = -ENOTTY;
+    }
+
+    return ret;
+}
+
+
+/*---------------------------------------------------------------------------*/
+/*
+ * The fops - this structure tells the kernel which functiosn to invoke to
+ * handle user process access to the device file
+ */
+struct file_operations cpetdFops =
+{
+    .owner =     THIS_MODULE,
+    .read =      cpetd_read,
+    .ioctl =     cpetd_ioctl,
+    .open =      cpetd_open,
+    .release =   cpetd_release,
+};
+
+
+/*---------------------------------------------------------------------------*/
+/*
+ * Initialise a character device kernel structure
+ */
+static void cpetd_setup_cdev (CpetdDev *dev_p, int index)
+{
+    int     err;
+    int     devno = MKDEV (cpetdMajor, index);
+
+    cdev_init (&dev_p->cdev, &cpetdFops);
+    dev_p->cdev.owner = THIS_MODULE;
+    dev_p->cdev.ops = &cpetdFops;
+    err = cdev_add (&dev_p->cdev, devno, 1);
+    /* Fail gracefully if need be */
+    if (err)
+    {
+        PDEBUG("Error %d adding cpetd%d", err, index);
+    }
+}
+
+#if defined(CONFIG_IPACCESS_FPGA_DEBUG)
+static unsigned long cpetd_timestamp(void)
+{
+    return ioread32(__io(TIMER_VAL_REG));
+}
+#endif /* defined(CONFIG_IPACCESS_FPGA_DEBUG) */
+
+/*---------------------------------------------------------------------------*/
+/*
+ * Invoked by the kernel when the device driver is loaded (insmod)
+ */
+int cpetd_init (void)
+{
+    int         result;
+    int         devNum;
+    dev_t       dev = MKDEV (cpetdMajor, 0);
+    CpetdDev    *dev_p;
+
+
+    PDEBUG("initialising\n");
+
+    /*
+     * check the parameters exported by the module for some sort of sanity
+     */
+    if ((cpetdPeriod < CPETD_BASE_INTERVAL) || (cpetdPeriod > CPETD_MAX_INTERVAL))
+    {
+        printk (KERN_NOTICE "cpetd: Period is out of range %d to %d (%d)",
+                            CPETD_BASE_INTERVAL, CPETD_MAX_INTERVAL, cpetdPeriod);
+        return -EINVAL;
+    }
+    /* check load module param cpetdPeriod is multiple of baseline period */
+    if (cpetdPeriod % CPETD_BASE_INTERVAL != 0)
+    {
+        printk (KERN_NOTICE "cpetd: load module param for period (%d) is not multiple of baseline period (%d)",
+                            cpetdPeriod, CPETD_BASE_INTERVAL);
+        return -EINVAL;
+    }
+
+    if ((cpetdNumDevs < 1) || (cpetdNumDevs > CPETD_MAX_NUM_DEVICES))
+    {
+        printk (KERN_NOTICE "cpetd: Num devices is out of range 1 to %d (%d)",
+                            CPETD_MAX_NUM_DEVICES, cpetdNumDevs);
+        return -EINVAL;
+    }
+
+    /*
+     * Register our major device number, and accept a dynamic number.
+     */
+    if (cpetdMajor)
+    {
+        result = register_chrdev_region (dev, cpetdNumDevs, "cpetd");
+    }
+    else
+    {
+        result = alloc_chrdev_region (&dev, 0, cpetdNumDevs, "cpetd");
+        cpetdMajor = MAJOR (dev);
+    }
+    if (result < 0)
+    {
+        return result;
+    }
+
+    /*
+     * allocate the devices -- we can't have them static, as the number
+     * can be specified at load time
+     */
+    cpetdDevices_p = kmalloc (cpetdNumDevs*sizeof (CpetdDev), GFP_KERNEL);
+    if (!cpetdDevices_p)
+    {
+        result = -ENOMEM;
+        goto fail_malloc;
+    }
+    memset (cpetdDevices_p, 0, cpetdNumDevs*sizeof (CpetdDev));
+
+    cpetdTimebaseTick = CPETD_TIMEBASE_INIT;
+#if defined(USE_KERNEL_TIMER)
+    init_timer (&cpetdTimebaseTimer);
+
+#   if defined(CPETD_DEBUG)
+    cpetdTimerAdded = jiffies;
+#   endif   /* defined(CPETD_DEBUG) */
+    cpetdTimebaseTimer.data = 0;
+    cpetdTimebaseTimer.function = cpetdTimebaseTimerExpired;
+    cpetdTimebaseTimer.expires = jiffies + msecs_to_jiffies(CPETD_BASE_INTERVAL);
+    add_timer (&cpetdTimebaseTimer);
+#endif
+
+    dev_p = &cpetdDevices_p [0];
+    for (devNum = 0; devNum < cpetdNumDevs; devNum++)
+    {
+        dev_p->period = msecs_to_jiffies((unsigned int) cpetdPeriod);
+
+        cpetd_setup_cdev (dev_p, devNum);
+
+        dev_p++;
+    }
+
+#if defined(CPETD_ON_ARM)
+#if defined(CONFIG_MACH_PC72052_I10_REVA)
+        cpetdHiresResolution = PC72052_I10_REVA_TIMER_FREQ;
+#elif defined(CONFIG_MACH_PC72052_I10_REVB)
+        cpetdHiresResolution = PC72052_I10_REVB_TIMER_FREQ;
+#elif defined(CONFIG_MACH_PC7302)
+        cpetdHiresResolution = PC302_TIMER_FREQ;
+#else
+#  error "Unknown architecture"
+#endif
+
+#else
+        cpetdHiresResolution = HZ;
+#endif  /* defined(CPETD_ON_ARM) */
+
+#if defined(CPETD_ON_ARM)
+    /*-----------------------------------------------------------------------*/
+    /* stop the timer */
+    iowrite32(0x0, __io(TIMER_CTL_REG));
+
+    /* load the count */
+    iowrite32(0xffffffff, __io(TIMER_CNT_REG));
+
+    /* start the timer in free-running mode */
+    iowrite32(TIMER_CTL_REG_ENABLE_BIT, __io(TIMER_CTL_REG));
+    /*-----------------------------------------------------------------------*/
+#endif  /* defined(CPETD_ON_ARM) */
+
+
+#ifdef CPETD_USE_PROC /* only when available */
+    create_proc_read_entry ("cpetdmem", 0, NULL, cpetd_read_procmem, NULL);
+#endif
+
+#if defined(CONFIG_IPACCESS_FPGA_DEBUG)
+    ipaHiresTimerPtr = cpetd_timestamp;
+#endif /* defined(CONFIG_IPACCESS_FPGA_DEBUG) */
+
+    return 0; /* succeed */
+
+fail_malloc:
+    unregister_chrdev_region (dev, cpetdNumDevs);
+    return result;
+}
+
+
+/*---------------------------------------------------------------------------*/
+/*
+ * Invoked by the kernel when the device driver is unloaded (rmmod)
+ */
+void cpetd_cleanup (void)
+{
+    int     devNum;
+
+#if defined(CONFIG_IPACCESS_FPGA_DEBUG)
+    ipaHiresTimerPtr = NULL;
+#endif /* defined(CONFIG_IPACCESS_FPGA_DEBUG) */
+
+#ifdef CPETD_USE_PROC
+    remove_proc_entry ("cpetdmem", NULL);
+#endif
+
+    del_timer (&cpetdTimebaseTimer);
+
+    for (devNum = 0; devNum < cpetdNumDevs; devNum++)
+    {
+        cdev_del (&cpetdDevices_p [devNum].cdev);
+    }
+
+    kfree (cpetdDevices_p);
+
+    unregister_chrdev_region (MKDEV (cpetdMajor, 0), cpetdNumDevs);
+}
+
+
+/*---------------------------------------------------------------------------*/
+/*
+ * Export device driver main entry points.
+ */
+module_init (cpetd_init);
+module_exit (cpetd_cleanup);
diff -Naur pico_2.6.28/drivers/ipa/cpetd/cpetd_test.c ipa_2.6.28/drivers/ipa/cpetd/cpetd_test.c
--- pico_2.6.28/drivers/ipa/cpetd/cpetd_test.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/ipa/cpetd/cpetd_test.c	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,179 @@
+/******************************************************************************
+ *
+ * Copyright (c) 2009 ip.access Ltd.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ * 22 Apr 2009 Created by Simon D Hughes.
+ *
+ * test application for cpetd
+ *
+ * This test application was run on x86 to verify the behaviour of the driver. These results
+ * are recorded in cpetd_test_log_i386.txt for periods 5ms < period < 62ms.
+ *****************************************************************************
+ * Filename: 
+ *****************************************************************************/
+
+
+#include <stdio.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <linux/ipa/cpetd.h>          /* driver interface header file */
+
+static char* read_mode[] = { "non fast return", "fast return"};
+
+
+
+int main(int argc, char* argv[])
+{
+    char*                       mode = NULL;
+    int                         verbose = 0;
+    int                         fd = -1;
+    int                         ret = 0;
+    int                         limit = 0;
+    int                         i = 0;
+    int                         version = 0;
+    unsigned long               lastjiffies = 0;
+    unsigned int                period;
+    CpetdReadInfoV1             info;
+    CpetdInfo                   ioctl_info;
+    CpetdHiresInfo              ioctl_hires_info;
+
+    /* debug & test parameters at end of structure */
+    unsigned int                readEnd = 0;
+    unsigned int                readEndPrev = 0;
+
+    memset(&info, 0, sizeof(info));
+    memset(&ioctl_info, 0, sizeof(ioctl_info));
+
+    fd = open("/dev/cpetd0", O_SYNC | O_RDONLY);
+    if(fd < 0) {
+        printf("error: failed to open device.\n");
+        goto out0;
+    }
+
+    ret = ioctl(fd, CPETD_IOCGETINFO, &ioctl_info);
+    if(ret < 0) {
+        printf("error: CPETD_IOCGETINFO ioctl failed.\n");
+        goto out1;
+    }
+    version = (ioctl_info.flags & CPETD_INFO_F_VERSION_MASK) == CPETD_INFO_F_VERSION_1_0 ? 1: -1;
+    printf("version=%d\n", version);
+
+    ret = ioctl(fd, CPETD_IOCGETHIRESINFO, &ioctl_hires_info);
+    if(ret < 0) {
+        printf("error: CPETD_IOCGETHIRESINFO hires ioctl failed.\n");
+        goto out1;
+    }
+    printf("hires resolution=%d ticks per sec, last beat @ 0x%08x\n",
+           ioctl_hires_info.hiresTicksPerSecond,
+           ioctl_hires_info.lastBeatHiresTime);
+
+    for(period = CPETD_PERIOD; period <= CPETD_MAX_INTERVAL; period += CPETD_PERIOD)
+    {
+        /* set the period */
+        ret = ioctl(fd, CPETD_IOCTPERIOD, period);
+        if(ret < 0) {
+            printf("error: CPETD_IOCTPERIOD ioctl failed.\n");
+            goto out1;
+        }
+
+        /* step the offset for inducing wrap */
+        memset(&ioctl_info, 0, sizeof(ioctl_info));
+        ioctl_info.flags = CPETD_INFO_F_DEBUG_OFFSET_STEP;
+        ret = ioctl(fd, CPETD_IOCSETINFO, &ioctl_info);
+        if(ret < 0)
+        {
+            printf("error: CPETD_IOCSETINFO ioctl failed.\n");
+            goto out1;
+        }
+
+        printf("=================================================================================\n");
+        printf("Period=%d ms\n", period);
+        printf("readEnd     jiffies     kDelay      missedBeat  userProc    flag        delta_jiff  readEnd dt  \n");
+        printf("=======     =======     ======      ==========  ========    ====        ==========  ==========  \n");
+
+        /* loop on timebase */
+        for(i=0;i< (500/CPETD_PERIOD);i++)
+        {
+            /* test blocking mode */
+            ret = read(fd, (void*) &info, sizeof(info));
+            if(ret < 0)
+            {
+                printf("error: to read device.\n");
+                goto out1;
+            }
+            if(ret != sizeof(info))
+            {
+                printf("error: to read correct number of bytes (%d).\n", sizeof(info));
+                goto out1;
+            }
+            /* report once a second */
+#ifdef CPETD_TEST
+            /* debug & test parameters at end of structure */
+            readEnd = info.actualBeat;
+#endif /* CPETD_TEST */
+            printf("0x%8x  0x%8x  0x%8x  0x%8x  0x%8x  0x%8x  0x%8x  0x%8x\n",
+                readEnd, info.jiffies, info.kernelDelay, info.missedBeats, info.userProc,
+                info.flags, info.jiffies - lastjiffies, readEnd-readEndPrev);
+            lastjiffies = info.jiffies;
+
+            readEndPrev = readEnd;
+        }
+    }
+    /* now perform fast return test */
+    period = 5;
+    printf("=================================================================================\n");
+    printf("==== Fast Return Test ===========================================================\n");
+    printf("Period=%d ms\n", period);
+    printf("jiffies     kDelay      missedBeat  userProc    flag        delta_jiff\n");
+    printf("=======     ======      ==========  ========    ====        ==========\n");
+    /* set the period */
+    ret = ioctl(fd, CPETD_IOCTPERIOD, period);
+    if(ret < 0) {
+        printf("error: CPETD_IOCTPERIOD ioctl failed.\n");
+        goto out1;
+    }
+    memset(&ioctl_info, 0, sizeof(ioctl_info));
+    ioctl_info.flags = CPETD_INFO_F_FAST_RETURN;
+    ret = ioctl(fd, CPETD_IOCSETINFO, &ioctl_info);
+    if(ret < 0) {
+        printf("error: CPETD_IOCSETINFO ioctl failed.\n");
+        goto out1;
+    }
+    for(i=0; i < 100; i++)
+    {
+        /* test fast return mode mode */
+        ret = read(fd, (void*) &info, sizeof(info));
+        if(ret < 0)
+        {
+            printf("error: to read device.\n");
+            goto out1;
+        }
+        if(ret != sizeof(info))
+        {
+            printf("error: to read correct number of bytes (%d).\n", sizeof(info));
+            goto out1;
+        }
+
+        mode = info.userProc > period ? read_mode[1] : read_mode[0];
+        /* report once a second */
+        printf("0x%8x  0x%8x  0x%8x  0x%8x  0x%8x  0x%8x  %s\n",
+            info.jiffies, info.kernelDelay, info.missedBeats, info.userProc,
+            info.flags, info.jiffies - lastjiffies, mode);
+
+        /* induce a sleep longer than the period */
+        if(i % 2 == 0) usleep((period*1000) + (period*500));
+    }
+
+out1:
+    if(fd) close(fd);
+out0:
+    return 0;
+}
diff -Naur pico_2.6.28/drivers/ipa/cpetd/cpetd_unload ipa_2.6.28/drivers/ipa/cpetd/cpetd_unload
--- pico_2.6.28/drivers/ipa/cpetd/cpetd_unload	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/ipa/cpetd/cpetd_unload	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,25 @@
+#!/bin/sh
+
+################################################################################
+# 
+# Copyright (c) 2009 ip.access Ltd.
+#
+#  This program is free software; you can redistribute  it and/or modify it
+#  under  the terms of  the GNU General  Public License as published by the
+#  Free Software Foundation;  either version 2 of the  License, or (at your
+#  option) any later version.
+#
+# 22 Apr 2009 Created by Simon D Hughes.
+##############################################################################
+# Filename: 
+##############################################################################
+module="cpetd"
+device="cpetd"
+
+# invoke rmmod with all arguments we got
+/sbin/rmmod $module $* || exit 1
+
+# remove nodes
+rm -f /dev/${device}[0-9] /dev/${device}
+
+exit 0
diff -Naur pico_2.6.28/drivers/ipa/cpetd/Makefile ipa_2.6.28/drivers/ipa/cpetd/Makefile
--- pico_2.6.28/drivers/ipa/cpetd/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/ipa/cpetd/Makefile	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,88 @@
+################################################################################
+# 
+# Copyright (c) 2009 ip.access Ltd.
+#
+#  This program is free software; you can redistribute  it and/or modify it
+#  under  the terms of  the GNU General  Public License as published by the
+#  Free Software Foundation;  either version 2 of the  License, or (at your
+#  option) any later version.
+#
+# 9 Apr 2008 Created by Simon D Hughes.
+#
+# CPE Timer Driver
+#  x86 support should be built with 3gap_setup.sh i386-redhat-linux environment
+##############################################################################
+# Filename: 
+##############################################################################
+
+#
+# main kernel makefile requirments
+#
+obj-$(CONFIG_IPACCESS_CPETD) += cpetd.o
+cpetd-objs := cpetd_main.o
+
+
+# 
+# development support
+#
+
+APP=cpetd_test
+BOARD_VARIANTS?=xbplus xc
+
+# Comment/uncomment the following line to enable/disable debugging
+#DEBUG = y
+
+ifeq ($(DEBUG),y)
+  DEBFLAGS = -O -g -DCPETD_DEBUG # "-O" is needed to expand inlines
+else
+  DEBFLAGS = -O2
+endif
+
+EXTRA_CFLAGS += $(DEBFLAGS)
+#CFLAGS += -DCPETD_TEST
+
+ifeq ($(ARCH),arm)
+  EXTRA_CFLAGS += -DCPETD_ON_ARM
+endif
+
+ifeq ($(ARCH),i386)
+  export CONFIG_IPACCESS_CPETD=m
+  KSRC?= /lib/modules/$(shell uname -r)/build
+  CPPFLAGS += -I$(KERNEL_SRC)/include
+  EXTRA_CFLAGS += -D$(ARCH) 
+endif
+
+
+PWD    := $(shell pwd)
+
+all: all_$(ARCH)
+	@echo " Making $@..."
+
+all_arm: 
+	@echo " Making $@"
+	@echo " module is built from top level kernel make file using make modules"
+
+all_i386: test cpetd_i386
+	@echo " Making $@"
+
+clean:
+	rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions *.symvers
+	rm -f $(APP)
+
+
+##############################################################################
+### target for building x86 module for local host.
+# IPAcess IT supported redhat EL machines have kernel sources installed as detailed below
+cpetd_i386:
+	@echo " Making $@..."
+	$(MAKE) -C $(KSRC) V=1 KSRC=$(KSRC) SUBDIRS=$(PWD) modules
+
+test:
+	$(CROSS_COMPILE)gcc cpetd_test.c $(CFLAGS) -L. -I. -I$(KERNEL_SRC)/include -o $(APP)
+
+
+
+
+
+
+
diff -Naur pico_2.6.28/drivers/ipa/cpetd/Makefile.ipkg ipa_2.6.28/drivers/ipa/cpetd/Makefile.ipkg
--- pico_2.6.28/drivers/ipa/cpetd/Makefile.ipkg	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/ipa/cpetd/Makefile.ipkg	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,62 @@
+################################################################################
+# 
+# Copyright (c) 2009 ip.access Ltd.
+#
+#  This program is free software; you can redistribute  it and/or modify it
+#  under  the terms of  the GNU General  Public License as published by the
+#  Free Software Foundation;  either version 2 of the  License, or (at your
+#  option) any later version.
+#
+# 22 Apr 2009 Created by Simon D Hughes.
+##############################################################################
+# Filename: 
+##############################################################################
+
+THIS = cpetd
+
+###
+# N.B: Must not strip kernel modules!!!
+###
+IPKG_STRIP_EXECUTABLES=false
+
+###
+# Directory definitions
+###
+DIR_IPKG              = ipkg
+
+###
+# iPackage
+###
+IPACKAGE = $(DIR_IPKG)/cpetd.ipk
+
+DIR_IPKG_DEST = opt/ipaccess/drivers
+
+IPKG_COMPONENTS = cpetd_load \
+                  cpetd_unload \
+                  cpetd.ko
+
+.PHONY:all
+all: $(IPACKAGE)
+
+.PHONY:clean
+clean:
+	make -f Makefile.pc clean
+	$(RM) $(IPACKAGE)
+
+
+cpetd.ko:
+	@make -f Makefile.pc
+
+                  
+        
+
+###
+# Rule Makefiles
+###
+include $(DIR_MAKEFILES)/tools_ipackage.mak
+
+
+
+
+
+
diff -Naur pico_2.6.28/drivers/ipa/cpetd/Makefile.pc ipa_2.6.28/drivers/ipa/cpetd/Makefile.pc
--- pico_2.6.28/drivers/ipa/cpetd/Makefile.pc	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/ipa/cpetd/Makefile.pc	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,49 @@
+#-------------------------------------------------------------------
+# CPE Timebase Device Driver makefile
+# Copyright (c) 2007 ip.access Ltd
+#-------------------------------------------------------------------
+
+# Comment/uncomment the following line to enable/disable debugging
+DEBUG = y
+
+ifeq ($(DEBUG),y)
+  DEBFLAGS = -O -g -DCPETD_DEBUG # "-O" is needed to expand inlines
+else
+  DEBFLAGS = -O2
+endif
+
+CFLAGS += $(DEBFLAGS) -I$(LDDINC)
+
+TARGET = cpetd
+
+        
+ifneq ($(KERNELRELEASE),)
+
+cpetd-objs := cpetd_main.o
+
+obj-m	:= cpetd.o
+
+else
+
+KERNELDIR ?= /lib/modules/$(shell uname -r)/build
+PWD       := $(shell pwd)
+
+modules:
+	$(MAKE) -C $(KERNELDIR) ARCH=i386 M=$(PWD) LDDINC=$(PWD) modules
+endif
+
+
+install:
+	install -d $(INSTALLDIR)
+	install -c $(TARGET).o $(INSTALLDIR)
+
+clean:
+	rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions
+
+
+depend .depend dep:
+	$(CC) $(CFLAGS) -M *.c > .depend
+
+ifeq (.depend,$(wildcard .depend))
+include .depend
+endif
diff -Naur pico_2.6.28/drivers/ipa/crypto/CHANGE_NOTES.txt ipa_2.6.28/drivers/ipa/crypto/CHANGE_NOTES.txt
--- pico_2.6.28/drivers/ipa/crypto/CHANGE_NOTES.txt	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/ipa/crypto/CHANGE_NOTES.txt	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,310 @@
+Copyright MontaVista Software Ltd.
+Author: Dean Jenkins
+
+Linux PicoArray Crypto driver change notes
+
+Codedrop 20090129
+-----------------
+
+This codedrop supports Software and Hardware based Encryption/Decryption
+and/or Authentication.
+
+The picoArray firmware IPsecFull_v3.pa has been used to test the driver.
+
+A new function called check_for_free_bd() was added. This checks whether a
+given BDR contains any free BDs. check_for_free_bd() is called from inside
+picocrypto_add_to_bdr() to test that a BD is available before allocating a
+PDU. This avoids unnecessary PDU allocations when the BDR is full so reducing
+the probability of running out of PDUs.
+
+
+Codedrop 20090121
+-----------------
+
+This codedrop supports Software and Hardware based Encryption/Decryption
+and/or Authentication.
+
+The picoArray firmware IPsecFull_v1.pa has been used to test the driver.
+This pa firmware supports encryption/decryption and/or authenication.
+Note that encryption/decryption with non authenication does not work
+because the firmware erroneously includes the "empty" 16 bytes of the IV field.
+
+A bug was found in picocrypto_add_to_bdr() that calculated the wrong length
+of the encryption/decryption length variable in the BD. The calculation used
+cryptlen supplied from the Kernel's AEAD request. It appears that the
+meanining of cryptlen depends on whether the request is for encryption or
+decryption. For encryption cryptlen does not include the length of the
+authentication field/tag but in decryption it does. The private crypto
+context structure was modified to indicate the enc/dec direction allowing
+other functions to use the correct calculation. This also affected the
+reading out of the completed data from SRAM because the authentication field
+has to be copied out only for encryption.
+
+A bug was found in that mark_bd_sram_free() was never called during freeing
+of a BD. The only side effect of this missing call relates to any human
+analysis of the SRAM BD contents because the status always remained at
+completed after the BD had been freed.
+
+A bug was found in alloc_sram_pdu() that caused the function to incorrectly
+indicate that there was no room left in the PDU pool for a PDU allocation.
+This was due to the check for the "DEAD band" at the end of the pool not
+allowing for the next PDU pointer to be ahead of the oldest PDU pointer.
+Consequently on rare occasions when the oldest PDU pointer was inside the
+dead band and the next PDU pointer was also in the dead band then the request
+could sometimes be erroneously rejected. The error occurs when the number of
+allocated PDUs is low eg. < 5
+
+Added #define USE_TWO_BDRS to select between using 1 or 2 BDRs. The default
+is that USE_TWO_BDRS is defined.
+
+Added #define ENABLE_BDR_PROCESSING_AFTER_ENC_DEC to attempt to process
+completed BDs at the end of each enc/dec request. This still resulted in
+running out of PDUs and/or BDs under load testing using bw_tcp.
+The default is that ENABLE_BDR_PROCESSING_AFTER_ENC_DEC is not defined.
+This implementation does not check that it is processing the results
+of the current enc/dec request so effectively is a synchronous call.
+A modification could be to try BD processing before actioning the
+enc/dec request to avoid that complication.
+
+Under heavy load it appears that the driver runs out of either PDUs or BDs.
+Doing an SRAM dump shows that all in use PDUs are associated with
+completed BDs, however, the memory snapshot does not halt the picoArray
+so there is time for the picoArray to complete all jobs during the dump.
+This makes analysis tricky.
+
+Fixed the double generation of sysfs output. This was due to a regression
+in the sysfs return values.
+
+
+Codedrop 20090119
+-----------------
+
+This codedrop supports Software Based Encryption/Decryption and/or
+Authentication. All 4 combinations tested using IPsec.
+
+#define APPLICATION_NOT_AVAILABLE is now undefined so upon loading the driver
+it does not try to OPEN the picoArray. The sysfs open_pico must be used to
+OPEN the picoArray. The driver will load itself into the Kernel regardless
+of the presence of the picoArray firmware. If the open_pico fails then the
+driver continues in Software Fallback mode for the crypto.
+
+The picoArray firmware NULL/NON ipsec_dev4.pa picoArray has been used to test
+the driver.
+
+A bug was found in write_sram_context_keys() that prevented the keys being
+written to the SRAM when in ENC/DEC-NON or NULL-AUTH modes. Now fixed.
+
+Added a sysfs file call show_mode to show the current operating mode
+eg. "HW mode", "HW mode (switching)", "SW mode (switching)" or "SW mode".
+
+REMINDER: A kernel patch in kernel_changes/patches/crypto_no_iv_hash_crash.patch 
+needs to be applied to the Kernel to avoid a crash when using NULL encryption
+with authentication enabled. See the kernel_changes/patches/README.txt for
+details.
+
+Modified the tpicocrypto test mode to add unit tests for
+ENC/DEC-AUTH. Therefore, all 4 combinations are now supported
+eg. NULL-NON, NULL-AUTH, ENC/DEC-NON and ENC/DEC-AUTH.
+
+Some code tidy-ups have been made.
+
+By agreement with ip.access, ESN is not supported due to Kernel and IKEv2
+limitations.
+
+
+Codedrop 20090114
+-----------------
+
+This codedrop supports Software Based Encryption/Decryption and/or
+Authentication. All 4 combinations tested using IPsec.
+
+As the driver starts up, it probes for the presence of the picoArray firmware.
+If suitable firmware is found then the driver switches to Hardware mode,
+otherwise the driver uses Software Fallback mode. This test can be removed
+by undef the #define APPLICATION_NOT_AVAILABLE. Default: APPLICATION_NOT_AVAILABLE
+is defined.
+
+The picoArray firmware NULL/NON ipsec_dev4.pa picoArray has been used to test
+the driver.
+
+A kernel patch in kernel_changes/patches/crypto_no_iv_hash_crash.patch needs to be
+applied to the Kernel to avoid a crash when using NULL encryption with 
+authentication enabled. See the kernel_changes/patches/README.txt for details.
+
+Note that Sofware based encryption/decryption uses synchronous mode because it is
+not offloaded. There is no flow control so high through-put over Ethernet will
+cause an overload of the system.
+
+Note that when IPsec is used, the driver generates random data for the IV field
+contents for encryption, both HW and SW.
+
+The freeing of the SW AEAD request has been resolved and 1,000,000 pings were
+tested ( some pings lost, reasons unknown ) over IPsec using Encryption and 
+Authentication. There was no sign of a memory leak.
+
+Open and Close has been tested while pinging over IPsec using NULL encryption
+and NON authentication. No packets lost during transition phase. Also loaded
+the magic_Dev0.pa firmware and that did not seem to corrupt the SRAM.
+
+Modified the tpicocrypto test mode to add unit tests for
+NULL-NON, NULL-AUTH, ENC/DEC-NON
+
+Note that tpicocrypto specifies IV field data and so calls non-giv encrypt
+functions. Therefore, this does not test fully the encryption routines used by
+ESP in IPsec operation.
+
+
+Codedrop 20090106
+-----------------
+
+This codedrop requires some picoArray firmware to be available. The driver
+has been tested against the NULL/NON ipsec_dev4.pa picoArray firmware.
+
+Improved the OPEN/CLOSE mechanism as described below:
+
+Added a mutex between accesses to the SRAM state variables to prevent clashes
+between driver instigated accesses and sysfs accesses.
+
+For OPEN_REQ, if the picoArray is already OPENED then the OPEN_REQ is not sent
+and nothing is done, otherwise the OPEN_REQ is sent eg. for READY and CLOSED
+confirmed states.
+
+For CLOSE_REQ, if the picoArray is currently in the OPENED state then the
+CLOSE_REQ is sent otherwise nothing is done.
+
+During driver start-up there is a check to make sure that the picoArray is
+not in the OPENED state. This is an unlikely error condition but ensures that
+the picoArray is either in the READY or CLOSED confirmed states to allow the
+SRAM to be (re-)initialised.
+  
+There is test code at the end of the driver's start-up to force the piocArray to
+be placed in the OPENED state. This can be compiled-in using the #define
+APPLICATION_NOT_AVAILABLE. Normally the application will request the picoArray
+to be opened. Default: #define APPLICATION_NOT_AVAILABLE is defined.
+
+The sysfs file "close_pico" now checks that no BDs are active before calling
+the CLOSE_REQ function. If any BDs remain active after a time-out then the
+"close_pico" is aborted. Also the BDRs are re-initialised after successfully
+changing the picoArray to the CLOSED state. This ensures that the current BD
+pointers within the driver are now pointing to the start of each BDR
+matching the picoArray's pointers after the CLOSE_REQ.
+
+Limitation: Make sure no IP traffic is flowing before requesting a "close_pico"
+because there is insufficient locking protection within the "close_pico"
+function to stop new BDs being inserted by the kernel during the CLOSE_REQ
+procedure. As a consequence of resetting the BDRs it is possible that
+orphan PDUs can occur and AEAD reqs being lost thus resulting in corruption.
+This limitation will disappear when software fallback is implemented as it
+will stop new BDs from being inserted during the "close_pico" operation.
+
+A new #define ENABLE_NO_BD_NO_PDU_PROCESSING has been added to enable recovery
+processing when no BDs or PDUs are available for a new encryption/decryption
+job. This recovery mechansim was added in codedrop 20081216. Default: 
+ENABLE_NO_BD_NO_PDU_PROCESSING is not defined so recovery processing is
+disabled in this codedrop therefore expect to see some dropped packets under
+heavy loads.
+
+
+Codedrop 20081216
+-----------------
+
+Added code in picocrypto_add_to_bdr() to handle the situation where no PDUs
+and/or BDs are available. If no PDUs are available then an attempt is made
+to try to process the BDR that contains the oldest PDU therefore freeing a
+PDU. If no BDs are avaiable then the current BD of the current BDR has attempt
+made on it to try to process the BD and hence free up a BD.  
+
+Different locking mechanisms have been investigated and it has been determined
+that the encrypt and decrypt calls from the Kernel are in an Interrupt context
+(ATOMIC) eg. tasklet or ISR. This means that these threads cannot sleep and
+must proceed to completion. Therefore turning interrupts off and on is the only
+way to prevent these threads interrupting the async event code. spin_locks have
+no effect on a single core processor although some documents says they do inhibit
+preemption. This means that the spin_lock_irqsave() and spin_unlock_irqrestore()
+are used. Note that this disables interrupts and that might be not be desirable
+for doing all SRAM processing.
+
+Found a re-cursion / re-entrancy issue. Sometimes the Kernel callback for
+completing a crypto work item causes a decrypt or encrypt to be fired off
+and this results in re-cursion / re-entrancy of the decrypt or encrypt 
+functions. This occurs despite the interrupts being off. In others, it is
+the all same thread. This issue was observed under heavy processor load
+with a ping -f running and a bw_tcp running on the gateway. It was observed that
+various Kernel warnings on bw_tcp were generated saying sleeping whilst atomic
+and that is not allowed.
+
+Code has been added to handle the re-cursion / re-entrancy issue but everything
+runs with interrupts off so may not be desireable.
+
+Basic handling of the open / close picoArray mechanism has been added and can be
+controlled via the sysfs interface eg.
+
+To request open
+echo 1 > /sys/bus/platform/drivers/pico-crypto-ipsec/open_pico
+
+To request close
+ echo 1 > /sys/bus/platform/drivers/pico-crypto-ipsec/close_pico
+
+To get the confirmed status
+cat /sys/bus/platform/drivers/pico-crypto-ipsec/pico_status
+
+Note that the driver has no locking for this interface and all are blocking.
+Also the driver tries to close and open the picoArray at install time. But
+the sysfs interface is ignored by the rest of the driver and will assume that
+the picoArray is running. In other words, close does not currently make
+sure that all BDs have been processed before closing the picoArray.
+
+Other sysfs debug options
+
+To force all BDs (AEAD Reqs) to be processed
+echo 1 > /sys/bus/platform/drivers/pico-crypto-ipsec/clear_aead_reqs
+
+To dump the SRAM contents
+echo 1 > /sys/bus/platform/drivers/pico-crypto-ipsec/dump_sram
+
+Note the dump is not protected against SRAM changes from Kernel theads and is
+therefore not a true snapshot.
+
+
+Codedrop 20081211
+-----------------
+
+Copying Crypto data to and from the PDU is now done 4 bytes at time and a check
+has been added to make sure that the scatterlist pointers are 4 bytes aligned.
+
+The WRAP_BIT value is derived from the BD allocation function to avoid a
+read-modify-write of the Control Flags register. Note that on freeing
+a BD, a read-modify-write of the Control Flags register is still required
+because the free function cannot know whether it is the end BD of the pool.
+
+Added support for freeing PDUs and allowing PDUs to be freed randomly.
+Note that the freed memory is not reuseable until the oldest PDU pointer
+reaches this position within the PDU pool. The PDU now has an 8 byte header
+(for ARM only) prepended to the PDU structure to manage a next PDU pointer
+and a free/in_use flag.
+
+Improved the dropped packet debug to show lack of PDUs or BDs.
+
+Using 2 BDRs; BDR #1 is used for encrypt and BDR #2 is used for decrypt.
+Both BDR #1 and #2 contain 40 BDs.
+
+Added picoArray OPEN and CLOSE access functions as per Paul's version 0.5 SRAM
+API doc. The driver will attempt to close and open the picoArray at install
+time but the error code will be inhibited to allow the driver to operate.
+
+Added #define PICO_FIRMWARE_NOT_AVAILABLE to run the driver without
+the picoArray firmware being present. If undefined then firmware will
+need to support the OPEN and CLOSE mechanism plus the PDU completed
+flag update.
+
+Added spin_locking and irq off/on protection between encrypt, decrypt and async_test
+threads. This means that the async polling work queue will process all completed BDs
+before allowing encrypt or decrypt to insert a new BD. This mechanism helps provide
+CPU cycles to the polling thread but it needs reviewing as mutex's may be more
+appropriate at the expense of context switching.
+
+
+Codedrop 20081204
+-----------------
+
+Original prototype driver
diff -Naur pico_2.6.28/drivers/ipa/crypto/Makefile ipa_2.6.28/drivers/ipa/crypto/Makefile
--- pico_2.6.28/drivers/ipa/crypto/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/ipa/crypto/Makefile	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,20 @@
+################################################################################
+# 
+# Copyright (c) 2009 ip.access Ltd.
+#
+#  This program is free software; you can redistribute  it and/or modify it
+#  under  the terms of  the GNU General  Public License as published by the
+#  Free Software Foundation;  either version 2 of the  License, or (at your
+#  option) any later version.
+#
+# 22 Apr 2009 Created by Simon D Hughes.
+##############################################################################
+# Filename: 
+##############################################################################
+
+picocrypto-objs := picodriver.o
+picocrypto-objs += picosram.o swcrypto.o
+obj-m += picocrypto.o
+obj-m += tpicocrypto.o
+
+
diff -Naur pico_2.6.28/drivers/ipa/crypto/picocrypto.h ipa_2.6.28/drivers/ipa/crypto/picocrypto.h
--- pico_2.6.28/drivers/ipa/crypto/picocrypto.h	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/ipa/crypto/picocrypto.h	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,349 @@
+/*
+ * This file contains the PicoArray Crypto driver #defines, types and prototypes.
+ *
+ * File: picocrypto.h
+ * Author: Dean Jenkins <djenkins@mvista.com>
+ *
+ * 2008 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+/*******************
+ * common #defines *
+ *******************/
+
+#undef PICO_FIRMWARE_NOT_AVAILABLE 
+/* If the IPsec picoArray firmware becomes available them comment out this #define */
+/* #define PICO_FIRMWARE_NOT_AVAILABLE	1	*/
+
+#undef ENABLE_BDR_PROCESSING_AFTER_ENC_DEC
+/* If it is desired to process the BDRs after the end of an enc/dec then define this #define */
+#define ENABLE_BDR_PROCESSING_AFTER_ENC_DEC	1
+
+#undef APPLICATION_NOT_AVAILABLE
+/* If the Linux Application becomes available then comment out this #define */
+/* #define APPLICATION_NOT_AVAILABLE	1	*/
+
+/* We want to use a single BDR as there are issues with PDU memory pool fragmentation when
+   two BDRs are used */
+#undef USE_TWO_BDRS
+/* define to use 2 BDRs; 1 for encryption and 1 for decryption else use only 1 BDR for both functions */
+/* #define USE_TWO_BDRS	1 */
+
+/* driver locking type */
+#define LOCK_NONE		(0)
+#define	LOCK_SPINLOCK_IRQ	(2)
+
+#define DRIVER_LOCKING	LOCK_SPINLOCK_IRQ 
+#define SRAM_LOCKING	LOCK_NONE 
+
+
+#define MAX_AUTHKEY_LEN		(20)
+#define MAX_ENCKEY_LEN		(16)
+#define MAX_RAWKEY_LEN		( sizeof( struct rtattr ) + MAX_AUTHKEY_LEN + MAX_ENCKEY_LEN + 12 )	/* TODO: Check length */
+
+#define CTX_FLAGS_UNKNOWN	(0)	/* context crypto flags are unknown */
+#define CTX_FLAGS_SET		(1)	/* context crypto flags have been set */
+
+#define CNF_STATE_TIMEOUT	(100)	/* Confirmed State change time-out in ms */
+#define BD_PROCESS_TIMEOUT	(100)	/* Processing of an active BD time-out in ms */
+
+#define PICO_MAX_ENC_LENGTH	(1600)	/* max PicoArray encryption/decryption length */
+ 
+/* SRAM header offsets */
+#define SRAM_HEADER_REQ_STATE_OFFSET	(0x00)
+#define HEADER_REQ_STATE_CLOSE_REQ	(0xDEADBEEF)
+#define HEADER_REQ_STATE_OPEN_REQ	(0x36B9A2F1)
+#define HEADER_REQ_STATE_NO_REQ		(0x00000000)
+
+#define SRAM_HEADER_CNF_STATE_OFFSET	(0x04)
+#define HEADER_CNF_STATE_READY		(0xC4E70D85)
+#define HEADER_CNF_STATE_CLOSED		(0xDEADDEAD)
+#define HEADER_CNF_STATE_OPENED		(0xD28C379A)
+
+#define SRAM_HEADER_VERSION_OFFSET	(0x08)
+#define SRAM_HEADER_BDR_PTR1_OFFSET	(0x0C)
+#define SRAM_HEADER_BDR_PTR2_OFFSET	(0x10)
+#define SRAM_HEADER_BDR_PTR3_OFFSET	(0x14)
+#define SRAM_HEADER_BDR_PTR4_OFFSET	(0x18)
+#define SRAM_HEADER_SIZE		(0x40)	/* total size of header block (multiple of 4 bytes) */
+
+/* SRAM context offsets */
+#define SRAM_CTX_AUTHKEY_OFFSET		(0x00)
+#define SRAM_CTX_ENCKEY_OFFSET		(0x14)
+#define SRAM_CTX_SEQH_OFFSET		(0x24)
+#define SRAM_CTX_FLAGS_OFFSET		(0x28)	/* 1 byte */
+#define CTX_FLAG_ENC_DIR		(0x00)
+#define CTX_FLAG_DEC_DIR		(0x80)
+#define CTX_FLAG_ESN_ON			(0x40)	/* Enhanced seq number */
+#define CTX_FLAG_ESN_OFF		(0x00)	/* Normal seq number */
+#define CTX_FLAG_AUTH_ON		(0x20)
+#define CTX_FLAG_NON_AUTH		(0x00)
+#define CTX_FLAG_ENC_ON			(0x10)
+#define CTX_FLAG_NULL_ENC		(0x00)
+
+#define SRAM_CTX_FREE_STATUS_OFFSET	(0x2C)	/* MV ADDED: context status */
+#define CTX_FREE			(0xDEADDEAD)	/* Free status */
+#define CTX_IN_USE			(0xBEEFBEEF)	/* In use status */
+
+#define SRAM_CTX_SIZE			(0x30)	/* total size of each crypto context structure (multiple of 4 bytes) */
+
+#define SRAM_CTX_MAX_NUMBER		(10)	/* maximum number of contexts */
+
+/* SRAM buffer descriptor BD offsets */
+#define SRAM_BD_CONTROL_FLAGS_OFFSET	(0x00)	/* 1 byte */
+#define	BD_WRAP_BIT			(0x80)
+#define BD_STATUS_FREE			(0x00)	/* 2 bits */
+#define BD_STATUS_READY			(0x01)	/* 2 bits */
+#define BD_STATUS_PROCESSING		(0x02)	/* 2 bits */
+#define BD_STATUS_PROCESSED		(0x03)	/* 2 bits */
+#define BD_STATUS_MASK			(0x03)
+
+#define SRAM_BD_ERROR_FLAGS_OFFSET	(0x01)	/* 1 byte */
+#define SRAM_BD_ENC_DEC_LENGTH_OFFSET	(0x02)	/* 2 bytes */
+#define SRAM_BD_CTX_PTR_OFFSET		(0x04)	/* 2 bytes */
+#define SRAM_BD_PDU_PTR_OFFSET		(0x06)	/* 2 bytes */
+#define SRAM_BD_AEAD_REQ_PTR_OFFSET	(0x08)	/* MV ADDED: AEAD request pointer */
+#define SRAM_BD_SIZE			(0x10)	/* total size of each buffer descriptor (multiple of 4 bytes) */
+
+#ifdef USE_TWO_BDRS
+#define SRAM_BD_RING1_NUMBER		(40)	/* number of BDs in ring #1 */	/* encrypt */
+#define SRAM_BD_RING2_NUMBER		(40)	/* number of BDs in ring #2 */	/* decrypt */
+#else
+#define SRAM_BD_RING1_NUMBER		(80)	/* number of BDs in ring #1 */	/* encrypt and decrypt */
+#define SRAM_BD_RING2_NUMBER		(1)	/* number of BDs in ring #2 */	/* not used */
+#endif
+#define SRAM_BD_RING3_NUMBER		(1)	/* number of BDs in ring #3 */
+#define SRAM_BD_RING4_NUMBER		(1)	/* number of BDs in ring #4 */
+
+/* PDU */
+#define SRAM_PDU_HEADER_SIZE		(8)	/* Reserve 8 bytes for a PDU header for the ARM's usage */
+#define SRAM_PDU_HDR_PTR_OFFSET		(0)	/* Header field contains an ARM pointer to the next PDU */
+#define SRAM_PDU_HDR_STATE_OFFSET	(4)  	/* Header field containing state flag */
+#define PDU_HDR_STATE_FREE		(0xDEADDED0)	/* lowest nibble resevered for holding the BDR num */
+#define PDU_HDR_STATE_IN_USE		(0xBEEFF0D0)	/* lowest nibble resevered for holding the BDR num */
+#define PDU_HDR_STATE_POOL_WRAP		(0xD0BACED0)	/* lowest nibble resevered for holding the BDR num */
+#define PDU_HDR_STATE_MASK		(0xFFFFFFF0)	/* lowest nibble resevered for holding the BDR num */
+#define PDU_HDR_STATE_BDR_MASK		(0x0000000F)
+/* offsets relative to PDU body after the PDU header */
+#define SRAM_PDU_ASSOC_OFFSET		(0)	/* ASSOC data offset in the PDU eg. ESP header*/
+#define SRAM_PDU_IV_OFFSET		(8)	/* IV data offset in the PDU */
+#define SRAM_PDU_AUTHENC_OFFSET 	(8+16)	/* AUTHENC data offset in the PDU */
+#define PDU_ASSOC_IV_LENGTH		(8+16)	/* associated field + IV field lengths in PDU */
+#define PDU_AUTH_FIELD_LENGTH		(12)	/* length of the authentication field in the PDU */
+
+/* max PDU size in bytes */
+#define PDU_MAX_SIZE		( PDU_ASSOC_IV_LENGTH + PICO_MAX_ENC_LENGTH + PDU_AUTH_FIELD_LENGTH )
+
+/* driver transit states, used in atomic variable */
+#define	DRIVER_ALL_SW		(0)	/* ( input is SW, output is SW ) All activity is using SW based encryption/decryption */
+#define DRIVER_SWITCH_TO_HW	(1) 	/* ( input is HW, output is SW ) Switching over to HW based encryption/decryption */
+#define	DRIVER_ALL_HW		(2)	/* ( input is HW, output is HW ) All activity is using HW based encryption/decryption */
+#define DRIVER_SWITCH_TO_SW	(3) 	/* ( input is SW, output is HW ) Switching over to SW based encryption/decryption */
+
+
+/* This is probably overkill, but we allow all the BDs to complete at once. */
+#define MAX_COMPLETED_AEADS (SRAM_BD_RING1_NUMBER+SRAM_BD_RING2_NUMBER+SRAM_BD_RING3_NUMBER+SRAM_BD_RING4_NUMBER)
+//#define MAX_COMPLETED_AEADS 4
+
+/********************
+ * enum definitions *
+ ********************/
+enum bd_status {
+	BD_DATA_PROCESSED,	/* by PicoArray */
+	BD_NO_PROCESSED_DATA,
+	BD_DATA_PENDING,
+	BD_ERROR_OCCURRED
+};
+
+enum bdr_number {
+	BDR_NUM_1 = 0,
+	BDR_NUM_2,
+	BDR_NUM_3,
+	BDR_NUM_4,
+	BDR_TOTAL_NUM	/* Total number of Buffer Descriptor Rings */
+};
+
+/* select 1 or 2 Buffer Descriptor Rings */ 
+#ifdef USE_TWO_BDRS
+#define BDR_NUM_FOR_ENC		BDR_NUM_1	/* BDR used for encryption */ 
+#define BDR_NUM_FOR_DEC		BDR_NUM_2	/* BDR used for decryption */ 
+#else
+#define BDR_NUM_FOR_ENC		BDR_NUM_1	/* BDR used for encryption */ 
+#define BDR_NUM_FOR_DEC		BDR_NUM_1	/* BDR used for decryption */ 
+#endif
+
+/*************************
+ * structure definitions *
+ *************************/
+
+struct ctx_data {
+	u32 auth_key[5];
+	u32 aes_key[4];
+	u32 seqh;
+	u8 flags;
+	u8 unused1;
+	u8 unused2;
+	u8 unused3;
+	u32 state;
+};
+
+/*
+ * Context management structure
+ */
+struct ctx_management {
+	u32 context_base_address;	/* base address of the context structure block */
+	u32 total_num_ctxs;		/* total number of contexts */
+	u32 num_ctx_in_use;		/* number of active contexts */
+	u32 last_free_ctx;		/* address of the last free context */ 
+	struct ctx_data shadow[SRAM_CTX_MAX_NUMBER];
+};
+
+
+/*
+ * Buffer Descriptor Ring management structure
+ */
+struct bdr_management {
+	u32 bdr_base_address;		/* base address of the buffer descriptor ring */
+	u32 total_num_bds;		/* total number of buffer descriptors in this ring */
+	u32 num_bds_in_use;		/* number of active buffer descriptors */
+	u32 last_free_bd;		/* address of the last free buffer descriptor */ 
+	u32 current_bd_processed;	/* address of the current db to be processed */
+
+	spinlock_t bdr_lock;		/* spinlock to lock async events */
+	unsigned long bdr_flags;	/* irq flags for spinlock */
+};
+
+
+/*
+ * PDU management structure
+ */
+struct pdu_management {
+	u32 pdu_pool_base_address;	/* base address of the PDU pool */
+	u32 pdu_pool_end_address;	/* end address of the PDU pool */
+	u32 pdu_pool_size;		/* size of the PDU pool */
+	u32 next_alloc_pdu;		/* address of the next free PDU to be allocated */ 
+	u32 oldest_pdu;			/* address of the oldest PDU in the pool not yet freed */	
+	u32 num_pdus_in_use;		/* metric to see how many PDUs are in use */
+	u32 num_pdus_alloced;		/* metric to see how many PDUs have been allocated (some maybe marked free) */
+
+	spinlock_t pdu_lock;		/* spinlock to lock async events */
+	unsigned long pdu_flags;	/* irq flags for spinlock */
+};
+
+
+/*
+ * When we recover AEAD requests from the picoArray we can read a few of them
+ * with interrupts off, before we pass them back to the kernel with interrupts on.
+ * We only need to have the pointer to the request and the status.
+ */
+struct picocrypto_aead_completion {
+	u32 sram_pdu;
+	struct aead_request *req;
+	int err;
+};
+
+
+/*
+ * Private driver data structure
+ */
+struct private_driver_data {
+	u32 sram_size;						/* multiple of 4 bytes */	
+	u32 phys_sram_base_address;				/* multiple of 4 bytes */
+	void *vert_sram_base_address;				/* multiple of 4 bytes */
+	u32 header_address;					/* multiple of 4 bytes */
+	struct ctx_management context_info;			/* Context management */
+	struct bdr_management bdr_info[ BDR_TOTAL_NUM ];	/* BDR rings */
+	struct pdu_management pdu_info;				/* PDU management */
+
+	struct list_head alg_list;	/* list of registered algorithms */
+
+	spinlock_t driver_lock;		/* spinlock to lock async events */
+	
+	atomic_t number_of_pdus;
+	atomic_t number_of_pdu_drops;
+	atomic_t number_of_bd_1_pre_drops;
+	atomic_t number_of_bd_2_pre_drops;
+	atomic_t number_of_bd_1_drops;
+	atomic_t number_of_bd_2_drops;
+	atomic_t number_of_dec_size_drops;
+	atomic_t number_of_enc_size_drops;
+	atomic_t largest_dec_dropped;
+	atomic_t largest_enc_dropped;
+	u32 max_irq_off_time;	/* max ticks of HW clock that irqs are disabled */
+	u32 max_test_time_1;	/* test timer 1 */
+	u32 max_test_time_2;	/* test timer 2 */
+	u32 max_test_time_3;	/* test timer 3 */
+	u32 max_test_time_4;	/* test timer 4 */
+	const char* culprit;
+
+	struct picocrypto_aead_completion completed[MAX_COMPLETED_AEADS];
+	int completed_head;
+	int completed_tail;
+	struct tasklet_struct	tasklet;
+	
+	struct mutex pico_state_mutex;	/* mutex for accessing the picoArray state variables */
+
+	atomic_t driver_transit_state;		/* atomic state variable to inidicate transit state between */
+						/* hw and sw encryption/decryption */
+};
+
+
+/* 
+ * Private ctx data stored in the Kernel tfm structure.
+ * Memory is alloced by __crypto_alloc_tfm() in crypto/apic.c
+ */
+struct private_ctx_data {
+	struct private_driver_data *driver_info;
+	u32 authsize;		/* size of the authentication field */
+	u32 context_addr;	/* allocated SRAM context structure address */
+	u8 authkey[ MAX_AUTHKEY_LEN ];	/* authentication key */
+	u8 authkey_len;			/* authentication key length in bytes */
+	u8 enckey[ MAX_ENCKEY_LEN ];	/* encryption key */
+	u8 enckey_len;			/* encryption key length in bytes */
+	char rawkey[ MAX_RAWKEY_LEN ];	/* TODO: check size. raw key for SW encrytion */
+	int rawkey_len;			/* length of rawkey encoded for struct rtattr */ 
+	u8 flags_set;			/* CTX_FLAGS_UNKNOWN = not set, CTX_FLAGS_SET = set */
+	u8 enc_dec_dir;			/* CTX_FLAG_ENC_DIR for encryption, CTX_FLAG_DEC_DIR for decryption */
+};
+
+
+/***********************
+ * function prototypes *
+ ***********************/
+
+extern void dump_sram_structures( struct private_driver_data *pdata );
+
+extern u32 alloc_sram_context_structure( struct private_driver_data *pdata );
+extern u32 free_sram_context_structure( struct private_driver_data *pdata, u32 allocated_ctx );
+extern void write_sram_context_keys( struct private_driver_data *pdata, u32 allocated_ctx, const u8 *pall_keys, u8 authkeylen, u8 enckeylen );
+extern void write_sram_context_seqh( struct private_driver_data *pdata, u32 allocated_ctx, u32 seqh );
+extern void write_sram_context_flags( struct private_driver_data *pdata, u32 allocated_ctx, u8 flags );
+extern u8 init_sram_structures( struct private_driver_data *pdata );
+extern u32 alloc_sram_buffer_descriptor( struct bdr_management *pbdr_info, u16 *pwrap_bit_flag );
+extern u32 finished_sram_buffer_descriptor( struct bdr_management *pbdr_info );
+extern u32 get_current_sram_buffer_descriptor( struct bdr_management *pbdr_info );
+extern void insert_bd_sram_aead_request( u32 allocated_bd, struct aead_request *req );
+extern struct aead_request *get_bd_sram_aead_request( u32 allocated_bd );
+extern void insert_bd_sram_enc_dec_len( u32 allocated_bd, u32 enc_dec_len );
+extern void insert_bd_sram_context_address( u32 allocated_bd, u16 context_address );
+extern void insert_bd_sram_pdu_address( u32 allocated_bd, u16 pdu_address );
+extern u32 get_bd_sram_pdu_address( struct private_driver_data *pdata, u32 allocated_bd );
+extern void mark_bd_sram_free( u32 allocated_bd );
+extern void mark_bd_sram_ready( u32 allocated_bd, u16 wrap_bit_flag );
+extern enum bd_status get_bd_sram_status( u32 allocated_bd );
+extern u32 alloc_sram_pdu( struct pdu_management *ppdu_info, u32 pdu_size, enum bdr_number bdr_num );
+extern u8 get_bdr_num_of_oldest_pdu( struct pdu_management *ppdu_info, enum bdr_number *pbdr_num );
+extern u8 free_sram_pdu( struct pdu_management *ppdu_info, u32 allocated_pdu );
+extern void copy_crypto_to_pdu_sram( u32 pdu_address, u8 *pcrypto, u32 length );
+extern void copy_crypto_from_pdu_sram( u32 pdu_address, u8 *pcrypto, u32 length );
+extern u8 cmp_crypto_from_pdu_sram( u32 pdu_address, u8 *pcrypto, u32 length );
+extern u8 request_sram_pico_close( struct private_driver_data *pdata );
+extern u8 request_sram_pico_open( struct private_driver_data *pdata );
+extern u32 read_sram_confirmed_state( struct private_driver_data *pdata );
+extern u8 read_pico_active_state( struct private_driver_data *pdata );
+extern void init_sram_bdrs( struct private_driver_data *pdata );
+extern void init_context_structure_block( struct private_driver_data *pdata, u8 number_contexts );
+
diff -Naur pico_2.6.28/drivers/ipa/crypto/picodriver.c ipa_2.6.28/drivers/ipa/crypto/picodriver.c
--- pico_2.6.28/drivers/ipa/crypto/picodriver.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/ipa/crypto/picodriver.c	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,2951 @@
+/*
+ * This file contains the PicoArray Crypto driver to facilitate IPsec crypto.
+ *
+ * File: picodriver.c
+ * Author: Dean Jenkins <djenkins@mvista.com>
+ *
+ * 2008 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+/*
+ * Ancestry acknowledgements (all GPL code):
+ * talitos - Freescale Integrated Security Engine (SEC) device driver
+ * Copyright (c) 2008 Freescale Semiconductor, Inc.
+ *
+ * Scatterlist Crypto API glue code copied from files with the following:
+ * Copyright (c) 2006-2007 Herbert Xu <herbert@gondor.apana.org.au>
+ */
+
+/* kernel related headers */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/rtnetlink.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/hw_random.h>
+
+/* Kernel crypto related headers */
+#include <linux/crypto.h>
+#include <crypto/algapi.h>
+#include <crypto/aead.h>
+#include <crypto/authenc.h>
+#include <crypto/aes.h>
+#include <crypto/sha.h>
+
+#include <asm/io.h>
+
+#if defined(CONFIG_ARCH_FIRECRACKER)
+#  include <mach/pc20x/pc20x.h>
+#  include <mach/pc20x/timer.h>
+#elif defined(CONFIG_ARCH_PC302)
+#  include <mach/pc302/pc302.h>
+#  include <mach/pc302/timer.h>
+#else  /* CONFIG_ARCH_... */
+#  error "Unknown architecture"
+#endif /* CONFIG_ARCH_... */
+
+#include <mach/platform.h>
+#include <mach/hardware.h>
+
+#include "picocrypto.h"
+#include "swcrypto.h"
+
+/******************
+ * local #defines *
+ ******************/
+#define CPETD_TIMER_NUM 3
+
+#define DRVNAME	"pico-crypto-ipsec"
+#define DRVVERS	"20091020"
+
+#if defined(CONFIG_ARCH_FIRECRACKER)
+#  define SRAM_PHYS_ADDRESS	(0x10000000)
+#elif defined(CONFIG_ARCH_PC302)
+#  define SRAM_PHYS_ADDRESS	(0x20000000)
+#else  /* CONFIG_ARCH_... */
+#  error "Unknown architecture"
+#endif /* CONFIG_ARCH_... */
+
+#define SRAM_LENGTH		(0x00010000)	/* 64KB */
+
+#undef PDU_SRAM_CMP
+/* #define PDU_SRAM_CMP	1	*/	/* TEST CODE: Compare src with pdu, NULL/NON only */
+
+#undef DEBUG_DRIVER
+/* #define DEBUG_DRIVER	1   */
+
+#ifdef DEBUG_DRIVER
+#define DRIVER_DEBUG(fmt,args...)	printk( fmt ,##args )
+#else
+#define DRIVER_DEBUG(fmt,args...)
+#endif
+
+#define DRIVER_INFO(fmt,args...)	printk( fmt ,##args )
+#define DRIVER_ERROR(fmt,args...)	printk( fmt ,##args )
+
+#if defined(CONFIG_ARCH_FIRECRACKER)
+#  define TIMER_VAL_REG (IO_ADDRESS(PC20X_TIMERS_BASE + TIMER_N_CURRENT_VALUE_REG_OFFSET(CPETD_TIMER_NUM)))
+#  define TIMER_CTL_REG (IO_ADDRESS(PC20X_TIMERS_BASE + TIMER_N_CONTROL_REG_OFFSET(CPETD_TIMER_NUM)))
+#  define TIMER_CNT_REG (IO_ADDRESS(PC20X_TIMERS_BASE + TIMER_N_LOAD_COUNT_REG_OFFSET(CPETD_TIMER_NUM)))
+#  define TIMER_CTL_REG_ENABLE_BIT (TIMER_ENABLE)
+#elif defined(CONFIG_ARCH_PC302)
+#  define TIMER_VAL_REG (IO_ADDRESS(PC302_TIMER_BASE + TIMERNCURRENTVALUEREGOFFSET(CPETD_TIMER_NUM)))
+#  define TIMER_CTL_REG (IO_ADDRESS(PC302_TIMER_BASE + TIMERNCONTROLREGOFFSET(CPETD_TIMER_NUM)))
+#  define TIMER_CNT_REG (IO_ADDRESS(PC302_TIMER_BASE + TIMERNLOADCOUNTREGOFFSET(CPETD_TIMER_NUM)))
+#  define TIMER_CTL_REG_ENABLE_BIT (TIMERENABLE)
+#else  /* CONFIG_ARCH_... */
+#  error "Unknown architecture"
+#endif /* CONFIG_ARCH_... */
+/*******************************
+ * local structure definitions *
+ *******************************/
+
+/*
+ * structure that holds info about a driver algorithm
+ */
+struct picocrypto_alg_template {
+	char name[ CRYPTO_MAX_ALG_NAME ];
+	char driver_name[ CRYPTO_MAX_ALG_NAME ];
+	u32 priority;
+	u32 blocksize;
+	struct aead_alg aead;
+};
+
+
+/*
+ * an algorithm record structure for registration list
+ * also allow driver info to be retrieved
+ */
+struct picocrypto_alg_record {
+	struct list_head entry;		/* allow records to be linked together */
+	struct crypto_alg crypto_alg;	/* Kernel API algorithm structure contain our alg info */
+	struct private_driver_data *driver_info;	/* driver information */
+};
+
+/****************************
+ * Local forward prototypes *
+ ****************************/
+static struct picocrypto_alg_record *picocrypto_alg_alloc( struct private_driver_data *pdata,
+	struct picocrypto_alg_template *template );
+
+static int init_private_ctx_data(struct crypto_tfm *tfm);
+static void release_private_ctx_data(struct crypto_tfm *tfm);
+
+static int picocrypto_setkey( struct crypto_aead *authenc, const u8 *key,
+	unsigned int keylen );
+static int picocrypto_setauthsize( struct crypto_aead *authenc,
+	unsigned int authsize );
+
+static int picocrypto_encrypt( struct aead_request *req );
+static int picocrypto_decrypt( struct aead_request *req );
+static int picocrypto_givencrypt( struct aead_givcrypt_request *req );
+static int picocrypto_encrypt_non( struct aead_request *req );
+static int picocrypto_decrypt_non( struct aead_request *req );
+static int picocrypto_givencrypt_non( struct aead_givcrypt_request *req );
+static int picocrypto_encrypt_null( struct aead_request *req );
+static int picocrypto_decrypt_null( struct aead_request *req );
+static int picocrypto_givencrypt_null( struct aead_givcrypt_request *req );
+static int picocrypto_encrypt_null_non( struct aead_request *req );
+static int picocrypto_decrypt_null_non( struct aead_request *req );
+static int picocrypto_givencrypt_null_non( struct aead_givcrypt_request *req );
+
+
+/*********************************
+ * Scatterlist support functions *
+ *********************************/
+
+/*
+ * derive number of elements in scatterlist
+ */
+static int sg_count(struct scatterlist *sg_list, int nbytes)
+{
+	struct scatterlist *sg = sg_list;
+	int sg_nents = 0;
+
+	/* MV fixed bug, nbytes can go negative if whole segment length not used */
+	while ( ( nbytes > 0 ) && ( sg != NULL ) ) {
+		sg_nents++;
+		nbytes -= sg->length;
+		sg = sg_next( sg );
+	}
+
+	if( nbytes > 0 ) {
+		DRIVER_ERROR( KERN_ERR "ERROR: sg_count(), total scatterlist length too short\n" );
+	}
+
+	return ( sg_nents );
+}
+
+
+/*********************************
+ * Crypto AEAD API to the kernel *
+ *********************************/
+
+/*
+ * Array that holds info about all the driver/PicoArray algorithms
+ */
+static struct picocrypto_alg_template crypto_driver_algs[] = {
+	/*
+	 * NORMAL MODE
+	 * added for supporting CBC-AES-128 enc and HMAC-SHA-1-96 auth 
+	 */
+	{
+		.name = "authenc(hmac(sha1),cbc(aes))",
+		.driver_name = "authenc-hmac-sha1-cbc-aes-picocrypto",
+		.priority = 2000,
+		.blocksize = AES_BLOCK_SIZE,
+		.aead = {
+			.setkey = picocrypto_setkey,
+			.setauthsize = picocrypto_setauthsize,
+			.encrypt = picocrypto_encrypt,
+			.decrypt = picocrypto_decrypt,
+			.givencrypt = picocrypto_givencrypt,
+			.geniv = "<built-in>",
+			.ivsize = AES_BLOCK_SIZE,
+			.maxauthsize = SHA1_DIGEST_SIZE,
+			},
+	},
+	/*
+	 * TEST MODE
+	 * added for supporting CBC-AES-128 enc and NON auth 
+	 */
+	{
+		.name = "authenc(digest_null,cbc(aes))",
+		.driver_name = "authenc-digest-null-cbc-aes-picocrypto",
+		.priority = 2000,
+		.blocksize = AES_BLOCK_SIZE,
+		.aead = {
+			.setkey = picocrypto_setkey,
+			.setauthsize = picocrypto_setauthsize,
+			.encrypt = picocrypto_encrypt_non,
+			.decrypt = picocrypto_decrypt_non,
+			.givencrypt = picocrypto_givencrypt_non,
+			.geniv = "<built-in>",
+			.ivsize = AES_BLOCK_SIZE,
+			.maxauthsize = 0,	/* NON Authentication */
+		},
+	},
+	/*
+	 * TEST MODE
+	 * added for supporting NULL enc and HMAC-SHA-1-96 auth 
+	 */
+	{
+		.name = "authenc(hmac(sha1),ecb(cipher_null))",
+		.driver_name = "authenc-hmac-sha1-ecb-null-picocrypto",
+		.priority = 2000,
+		.blocksize = 1,	/* NULL_BLOCK_SIZE */
+		.aead = {
+			.setkey = picocrypto_setkey,
+			.setauthsize = picocrypto_setauthsize,
+			.encrypt = picocrypto_encrypt_null,
+			.decrypt = picocrypto_decrypt_null,
+			.givencrypt = picocrypto_givencrypt_null,
+			.geniv = "<built-in>",
+			.ivsize = 0,		/* NULL Encryption */
+			.maxauthsize = SHA1_DIGEST_SIZE,
+		},
+	},
+	/*
+	 * TEST MODE
+	 * added for supporting NULL enc and NON auth 
+	 */
+	{
+		.name = "authenc(digest_null,ecb(cipher_null))",
+		.driver_name = "authenc-digest-null-ecb-null-picocrypto",
+		.priority = 2000,
+		.blocksize = 1,	/* NULL_BLOCK_SIZE */
+		.aead = {
+			.setkey = picocrypto_setkey,
+			.setauthsize = picocrypto_setauthsize,
+			.encrypt = picocrypto_encrypt_null_non,
+			.decrypt = picocrypto_decrypt_null_non,
+			.givencrypt = picocrypto_givencrypt_null_non,
+			.geniv = "<built-in>",
+			.ivsize = 0,		/* NULL Encryption */
+			.maxauthsize = 0,	/* NON Authentication */
+		},
+	},
+};
+
+
+/*
+ * Allocate a picocrypto record to hold the alogithm details before registration
+ * Inputs:
+ * 	pdata = pointer to private data structure (not NULL)
+ *	template = supported algorithm details ready for registration
+ * Outputs:
+ *	pdata structure updated with linked list of registered crypto
+ *	algorithms
+ * Return:
+ *	0 = success, otherwise an error has occurred 
+ */
+static struct picocrypto_alg_record *picocrypto_alg_alloc( struct private_driver_data *pdata,
+	struct picocrypto_alg_template *template )
+{
+	struct picocrypto_alg_record *palg;	/* points to our local record */
+	struct crypto_alg *pkalg;	/* points to a Kernel algorithm structure */
+
+	/* allocate a record */
+	palg = kzalloc( sizeof( struct picocrypto_alg_record ), GFP_KERNEL );
+	if ( palg == NULL ) {
+		/* allocation failed */
+		return NULL;
+	}
+
+	/*
+	 * allow other our functions to access the private data
+	 * by using container of
+	 */
+	palg->driver_info = pdata;
+
+	/* point to Kernel algorithm structure in the record */
+	pkalg = &palg->crypto_alg;
+
+	/* insert the name of the algorithm */
+	snprintf( pkalg->cra_name, CRYPTO_MAX_ALG_NAME, "%s", template->name );
+	snprintf( pkalg->cra_driver_name, CRYPTO_MAX_ALG_NAME, "%s",
+		template->driver_name);
+
+	/* copy details from the template and enter fixed settings */
+	pkalg->cra_module = THIS_MODULE;
+	pkalg->cra_priority = template->priority;
+	pkalg->cra_flags = CRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_ASYNC;
+	pkalg->cra_blocksize = template->blocksize;
+	pkalg->cra_alignmask = 0;
+	pkalg->cra_type = &crypto_aead_type;	/* Pick the AEAD Kernel API */
+	/* tell the API to allocate memory for our private ctx data */
+	pkalg->cra_ctxsize = sizeof( struct private_ctx_data );
+	pkalg->cra_init = init_private_ctx_data;	/* init function for our private ctx data */
+	pkalg->cra_exit = release_private_ctx_data;	/* release function for our private ctx data */
+	pkalg->cra_u.aead = template->aead;	/* copy our AEAD settings */
+
+	return palg;
+}
+
+/*
+ * Register the driver's crypto algorithms using the Kernel's Crypto API
+ * Inputs:
+ * 	pdata = pointer to private data structure (not NULL)
+ * Outputs:
+ *	pdata structure updated with linked list of registered crypto
+ *	algorithms
+ * Return:
+ *	0 = success, otherwise an error has occurred 
+ */
+static int register_driver_crypto( struct private_driver_data *pdata )
+{
+	int err;
+	int i;
+
+	DRIVER_DEBUG( KERN_INFO "Registering the driver's crypto algorithms...\n" );
+
+	WARN_ON( pdata == NULL );
+
+	if ( pdata == NULL ) {
+		/* pointer to private data structure */
+		return -ENOMEM;
+	}
+
+	/* initialise the linked list */
+	INIT_LIST_HEAD( &pdata->alg_list );
+
+	/* register the crypto algorithms that the PicoArray supports */
+	for (i = 0; i < ARRAY_SIZE( crypto_driver_algs ); i++) {
+		struct picocrypto_alg_record *palg;
+
+		/* allocate an algorithm record for the linked list */
+		palg = picocrypto_alg_alloc( pdata, &crypto_driver_algs[i] );
+		if ( palg == NULL ) {
+			err = -ENOMEM;
+			goto err_out;
+		}
+
+		/* Call the Kernel API to register this algorithm. */
+		/* container of can be used to get back palg */
+		err = crypto_register_alg( &palg->crypto_alg );
+		if ( err ) {
+			/* failed to register the algorithm */
+			DRIVER_ERROR( KERN_ERR "ERROR: Failed to register driver algorithm: %s\n",
+				palg->crypto_alg.cra_name );
+			kfree( palg );
+
+			err = -EPERM;
+			goto err_out;
+
+		} else {
+			/* add the registered algorithm record to the linked list */
+			list_add_tail( &palg->entry, &pdata->alg_list );
+		}
+	}
+
+	return 0;
+
+/* error handlers */
+err_out:
+	return err;
+
+}
+
+
+/*
+ * Unregister the driver's crypto algorithms using the Kernel's Crypto API
+ * Inputs:
+ * 	pdata = pointer to private data structure (not NULL)
+ * Outputs:
+ *	pdata structure updated with linked list of unregistered crypto
+ *	algorithms
+ * Return:
+ *	0 = success, otherwise an error has occurred 
+ */
+static int unregister_driver_crypto( struct private_driver_data *pdata )
+{
+	struct picocrypto_alg_record *palg;
+	struct picocrypto_alg_record *pnext;
+
+	DRIVER_DEBUG( KERN_INFO "Unregistering the driver's crypto algorithms...\n" );
+
+	WARN_ON( pdata == NULL );
+
+	if ( pdata == NULL ) {
+		/* pointer to private data structure */
+		return -ENOMEM;
+	}
+
+	/* Unregister the algorithms by spinning through the linked list */
+	list_for_each_entry_safe( palg, pnext, &pdata->alg_list, entry ) {
+		crypto_unregister_alg( &palg->crypto_alg );
+		list_del( &palg->entry );
+		kfree( palg );
+	}
+
+	return 0;
+}
+
+
+/**********************************
+ * Driver's Crypto AEAD functions *
+ **********************************/
+
+/*
+ * Function to initialise our private context data, called during the
+ * keying and rekeying process of IKEv2.
+ * Called once per transform instance
+ * Inputs:
+ * 	tfm = pointer to transform structure
+ * Outputs:
+ *	Initialises our private ctx data at the end of the tfm structure
+ * Return:
+ *	0 = success, otherwise an error has occurred 
+ */
+static int init_private_ctx_data( struct crypto_tfm *tfm )
+{
+	/* get a pointer to the picocrypto algorithm record */
+	unsigned long irq_flags;
+	u32 time_measure;
+	struct crypto_alg *alg = tfm->__crt_alg;
+	struct picocrypto_alg_record *precord =
+		 container_of( alg, struct picocrypto_alg_record, crypto_alg );
+
+	/*
+	 * get a pointer to the unitialised private context
+	 * data allocated from the kernel
+	 */
+	struct private_ctx_data *pctx = crypto_tfm_ctx( tfm );
+
+	DRIVER_DEBUG( KERN_INFO "Called: %s\n", __FUNCTION__ );
+
+	/*
+	 * store the private driver info pointer into the context data
+	 * to allow crypto functions to have access to it
+	 */
+	pctx->driver_info = precord->driver_info;
+
+	/* protect critical code from interruptig context alloc and release calls */
+	spin_lock_irqsave( &pctx->driver_info->driver_lock, irq_flags );
+	time_measure = ioread32(__io(TIMER_VAL_REG));
+
+	/* allocate a SRAM context structure */
+	pctx->context_addr = alloc_sram_context_structure( pctx->driver_info );
+
+	time_measure -= ioread32(__io(TIMER_VAL_REG));
+	if (pctx->driver_info->max_irq_off_time < time_measure) {
+		pctx->driver_info->max_irq_off_time = time_measure;
+		pctx->driver_info->culprit = "init_private_ctx_data";
+	}
+	spin_unlock_irqrestore( &pctx->driver_info->driver_lock, irq_flags );
+
+	if ( pctx->context_addr == 0 ) {
+		DRIVER_ERROR( KERN_ERR "ERROR: Failed to allocate a SRAM context structure\n" );
+	}
+
+	return 0;
+}
+
+
+/*
+ * Function to release our private context data when the keys are dead.
+ * Called once per transform instance
+ * Inputs:
+ * 	tfm = pointer to transform structure
+ * Outputs:
+ *	Context data is dead
+ * Return:
+ *	None 
+ */
+static void release_private_ctx_data(struct crypto_tfm *tfm)
+{
+	unsigned long irq_flags;
+	u32 time_measure;
+	struct private_ctx_data *pctx = crypto_tfm_ctx( tfm );
+
+	DRIVER_DEBUG( KERN_INFO "Called: %s\n", __FUNCTION__ );
+
+	/* protect critical code from interruptig context alloc and release calls */
+	spin_lock_irqsave( &pctx->driver_info->driver_lock, irq_flags );
+	time_measure = ioread32(__io(TIMER_VAL_REG));
+
+	/* free the SRAM context structure */
+	free_sram_context_structure( pctx->driver_info, pctx->context_addr );
+
+	time_measure -= ioread32(__io(TIMER_VAL_REG));
+	if (pctx->driver_info->max_irq_off_time < time_measure) {
+		pctx->driver_info->max_irq_off_time = time_measure;
+		pctx->driver_info->culprit = "release_private_ctx_data";
+	}
+	spin_unlock_irqrestore( &pctx->driver_info->driver_lock, irq_flags );
+
+	pctx->context_addr = 0;
+}
+
+
+/*
+ * Function to set the keys, called during the
+ * algorithm selection process by upper layers. eg. IKEv2.
+ * Called once per transform instance
+ * Inputs:
+ * 	authenc = pointer to authentication and encryption details
+ *	all_keys = to rtattr struct and needs to use RTA macros
+ *		to allow dereferencing.
+ *		all_key contains the encryption key followed by the auth key.
+ *	total_keylen = key length and needs to be corrected using RTA macros
+ * Outputs:
+ *	Update our private ctx data with new authentication and encryption
+ *	details.
+ * Return:
+ *	0 = success, otherwise an error has occurred 
+ */
+static int picocrypto_setkey( struct crypto_aead *authenc, const u8 *all_keys,
+	unsigned int total_keylen )
+{
+	/* get access to the private context data for this transform */
+	struct private_ctx_data *pctx = crypto_aead_ctx( authenc );
+
+	/* use rtnetlink info from include/linux/rtnetlink.h */
+	struct rtattr *rta = (void *)all_keys;
+	struct crypto_authenc_key_param *param;
+
+	unsigned int authkeylen;
+	unsigned int enckeylen;
+
+	DRIVER_DEBUG( KERN_INFO "Called: %s\n", __FUNCTION__ );
+
+	if ( !RTA_OK(rta, total_keylen) ) {
+		DRIVER_ERROR( KERN_ERR "BADKEY: failed OK\n" );
+		goto badkey;
+	}
+
+	if ( rta->rta_type != CRYPTO_AUTHENC_KEYA_PARAM ) {
+		DRIVER_ERROR( KERN_ERR "BADKEY: failed TYPE\n" );
+		goto badkey;
+	}
+
+	if ( RTA_PAYLOAD(rta) < sizeof(*param) ) {
+		DRIVER_ERROR( KERN_ERR "BADKEY: failed SIZEOF\n" );
+		goto badkey;
+	}
+
+	/* save the raw keys in the context for use with software based encryption */
+	if ( ( sizeof( struct rtattr ) + total_keylen ) <= MAX_RAWKEY_LEN ) {
+		memcpy( &pctx->rawkey[0], &all_keys[ 0 ], ( sizeof( struct rtattr ) + total_keylen ) );
+		pctx->rawkey_len = total_keylen;
+	} else {
+		DRIVER_ERROR( KERN_ERR "BADKEY: rawkey array too small: rtattr = %d, total_keylen = %d, max = %d\n",
+			sizeof( struct rtattr ), total_keylen, MAX_RAWKEY_LEN );
+		goto badkey;
+	}
+
+	param = RTA_DATA( rta );
+	enckeylen = be32_to_cpu(param->enckeylen);
+
+	/* update the pointers */
+	all_keys += RTA_ALIGN( rta->rta_len );
+	total_keylen -= RTA_ALIGN( rta->rta_len );
+
+	if ( total_keylen < enckeylen ) {
+		DRIVER_ERROR( KERN_ERR "BADKEY: failed length check\n" );
+		goto badkey;
+	}
+
+	/* calculate the auth key length */
+	authkeylen = total_keylen - enckeylen;
+
+	DRIVER_DEBUG( KERN_INFO "setkey: total keylen %d\n", total_keylen );
+	DRIVER_DEBUG( KERN_INFO "setkey: enckeylen %d bits\n", enckeylen * 8 );
+	DRIVER_DEBUG( KERN_INFO "setkey: authkeylen %d bits\n", authkeylen * 8 );
+
+	if ( authkeylen > MAX_AUTHKEY_LEN ) {
+		DRIVER_ERROR( KERN_ERR "BADKEY: authentication key too long\n" );
+		goto badkey;
+	}
+
+	if ( enckeylen > MAX_ENCKEY_LEN ) {
+		DRIVER_ERROR( KERN_ERR "BADKEY: encryption key too long\n" );
+		goto badkey;
+	}
+
+	/* grab the keys and put into crypto SW context */
+	memcpy( &pctx->authkey[0], &all_keys[ 0 ], authkeylen );
+	pctx->authkey_len = authkeylen;
+
+	/* grab the encryption key and put into crypto SW context */
+	memcpy( &pctx->enckey[0], &all_keys[ authkeylen ], enckeylen );
+	pctx->enckey_len = enckeylen;
+
+	/* indicate that the crypto direction is unknown */
+	pctx->flags_set = CTX_FLAGS_UNKNOWN;
+
+	/* grab the keys and put into PicoArray SRAM context */
+	write_sram_context_keys( pctx->driver_info, pctx->context_addr, &all_keys[0], authkeylen, enckeylen );
+
+	return 0;
+
+badkey:
+	DRIVER_ERROR( KERN_ERR "Received a BADKEY\n" );
+	crypto_aead_set_flags( authenc, CRYPTO_TFM_RES_BAD_KEY_LEN );
+	return -EINVAL;
+}
+	
+/*
+ * Function to set the authsize
+ * Inputs:
+ *	authenc = session info
+ * 	authsize = size of the authentication field
+ * Outputs:
+ *	Update our private ctx data with new authentication tag size.
+ * Return:
+ *	0 = success, otherwise an error has occurred 
+ */
+static int picocrypto_setauthsize( struct crypto_aead *authenc,
+	unsigned int authsize )
+{
+	/* get access to the private data for this transform */
+	struct private_ctx_data *pctx = crypto_aead_ctx( authenc );
+
+	DRIVER_DEBUG( KERN_INFO "Called: %s\n", __FUNCTION__ );
+
+	DRIVER_DEBUG( KERN_INFO "setauth: authsize %d bits\n", authsize * 8 );
+
+	/* save the size of the authentication field */
+	pctx->authsize = authsize;
+
+	return 0;
+}
+
+
+/***************************
+ * Common Enc/Dec routines *
+ ***************************/
+
+/*
+ * Function to copy assoc crypto data into the PDU
+ * Inputs:
+ *	req = AEAD request information
+ *	sram_pdu = address of the allocated PDU
+ * Outputs:
+ *	Copies the assoc crypto data into the PDU
+ * Return:
+ *	None.
+ */
+static void copy_assoc_to_pdu( struct aead_request *req, u32 sram_pdu )
+{
+	struct scatterlist *sg = req->assoc;
+	u32 assoc_len = req->assoclen;	/* total length of the associated data */
+	u32 seqment_tot = sg_count( sg, assoc_len );	/* number of segments */
+	u8 *passoc_data;
+	u32 seqment_len;
+	u32 pdu_pos = SRAM_PDU_ASSOC_OFFSET;	/* start at the assoc field in the PDU */
+
+	while ( ( seqment_tot > 0 ) && ( assoc_len > 0 )  ) {
+		/* get a pointer to the assoc data */
+		passoc_data = sg_virt( sg );
+
+		/* get the length of this seqment */
+		seqment_len = sg->length;
+
+		/* assoc length might be shorter than the segment length */
+		if ( assoc_len < seqment_len ) {
+			seqment_len = assoc_len;
+		}
+
+		/* copy this segment to the PDU */
+		copy_crypto_to_pdu_sram( sram_pdu + pdu_pos, passoc_data, seqment_len );
+
+		/* update the assoc length */
+		assoc_len -= seqment_len;
+
+		/* move pdu pos onto the next location */ 
+		pdu_pos += seqment_len;
+
+		/* move to the next segment */
+		sg = sg_next(sg);
+		seqment_tot--;
+	}
+} 
+
+
+/*
+ * Function to copy IV crypto data into the PDU
+ * Inputs:
+ *	req = AEAD request information
+ *	sram_pdu = address of the allocated PDU
+ * Outputs:
+ *	Copies the IV crypto data into the PDU
+ *	IV field may be empty but copy anyway
+ * Return:
+ *	None.
+ */
+static void copy_iv_to_pdu( struct aead_request *req, u32 sram_pdu )
+{
+	u8 *piv_data = req->iv;
+
+	/* copy the IV data to the PDU */
+	copy_crypto_to_pdu_sram( sram_pdu + SRAM_PDU_IV_OFFSET, piv_data, AES_BLOCK_SIZE );
+} 
+
+
+/*
+ * Function to copy enc/dec + auth crypto data into the PDU
+ * Inputs:
+ *	req = AEAD request information
+ *	sram_pdu = address of the allocated PDU
+ * 	data_length = length of enc_dec + auth size
+ * Outputs:
+ *	Copies the enc/dec + auth crypto data into the PDU
+ * Return:
+ *	None.
+ * Note do not use req->cryptlen as the length is different for encryption and decryption.
+ */
+static void copy_authenc_to_pdu( struct aead_request *req, u32 sram_pdu, u32 data_length )
+{
+	struct scatterlist *sg = req->src;
+
+	u32 crypt_len = data_length;
+	u32 seqment_tot = sg_count( sg, crypt_len );	/* number of segments */
+	u8 *psrc_data;
+	u32 seqment_len;
+	u32 pdu_pos = SRAM_PDU_AUTHENC_OFFSET;	/* start at the AUTHENC field in the PDU */
+
+	while ( ( seqment_tot > 0 ) && ( crypt_len > 0 )  ) {
+		/* get a pointer to the src data */
+		psrc_data = sg_virt( sg );
+
+		/* get the length of this seqment */
+		seqment_len = sg->length;
+
+		/* crypt length might be shorter than the segment length */
+		if ( crypt_len < seqment_len ) {
+			seqment_len = crypt_len;
+		}
+
+		/* copy this segment to the PDU */
+		copy_crypto_to_pdu_sram( sram_pdu + pdu_pos, psrc_data, seqment_len );
+
+		/* TEST CODE: NUKE the src/dst data to check copy from PDU works */
+#ifndef PDU_SRAM_CMP
+		memset( psrc_data, 0, seqment_len );
+#endif
+		/* update the crypt length */
+		crypt_len -= seqment_len;
+
+		/* move pdu pos onto the next location */ 
+		pdu_pos += seqment_len;
+
+		/* move to the next segment */
+		sg = sg_next(sg);
+		seqment_tot--;
+	}
+
+	if ( crypt_len != 0 ) {
+		DRIVER_ERROR( KERN_ERR "ERROR: Failed to copy all crypto data from src\n" );
+	}
+} 
+
+
+/*
+ * Function to copy enc/dec + auth crypto data from the PDU
+ * Inputs:
+ *	req = AEAD request information
+ *	sram_pdu = address of the allocated PDU
+ * Outputs:
+ *	Copies the enc/dec + auth crypto data from the PDU
+ * Return:
+ *	None.
+ */
+static void copy_authenc_from_pdu( struct aead_request *req, u32 sram_pdu )
+{
+	struct crypto_aead *authenc = crypto_aead_reqtfm( req );
+	struct private_ctx_data *pctx = crypto_aead_ctx( authenc );
+
+	struct scatterlist *sg = req->dst;
+	u32 crypt_len; 
+	u32 seqment_tot;	/* total number of segments */
+	u8 *pdst_data;
+	u32 seqment_len;
+	u32 pdu_pos = SRAM_PDU_AUTHENC_OFFSET;	/* start at the AUTHENC field in the PDU */
+
+	/* calculate the length of the (plaintext or ciphertext) plus authsize ( enc only ) */
+	if ( pctx->enc_dec_dir == CTX_FLAG_DEC_DIR ) {
+		/* for decryption need to modify cryptlen to remove the length of the auth field */
+		crypt_len = req->cryptlen - pctx->authsize;
+	} else {
+		/* for encryption need to modify cryptlen to add the legth of the auth field */
+		crypt_len = req->cryptlen + pctx->authsize;
+	}
+
+	seqment_tot = sg_count( sg, crypt_len );	/* number of segments */
+
+	while ( ( seqment_tot > 0 ) && ( crypt_len > 0 )  ) {
+		/* get a pointer to the dst data */
+		pdst_data = sg_virt( sg );
+
+		/* get the length of this seqment */
+		seqment_len = sg->length;
+
+		/* crypt length might be shorter than the segment length */
+		if ( crypt_len < seqment_len ) {
+			seqment_len = crypt_len;
+		}
+
+#ifndef PDU_SRAM_CMP
+		/* copy from PDU to this segment */
+		copy_crypto_from_pdu_sram( sram_pdu + pdu_pos, pdst_data, seqment_len );
+#else
+		{
+			/* Test for corrupted PDU in SRAM */
+			u8 res;
+			res = cmp_crypto_from_pdu_sram( sram_pdu + pdu_pos, pdst_data, seqment_len );
+
+			if ( res == 1 ) {
+				DRIVER_ERROR( KERN_ERR "ERROR: PDU dst mismatch with src\n" );
+			}
+		}
+#endif
+		/* update the crypt length */
+		crypt_len -= seqment_len;
+
+		/* move pdu pos onto the next location */ 
+		pdu_pos += seqment_len;
+
+		/* move to the next segment */
+		sg = sg_next(sg);
+		seqment_tot--;
+	}
+
+	if ( crypt_len != 0 ) {
+		DRIVER_ERROR( KERN_ERR "ERROR: Failed to copy all crypto data to dst\n" );
+	}
+} 
+
+
+/*
+ * MUST HAVE LOCK BEFORE CALLING
+ * THIS FUNCTION NEEDS TO RE-ENTRANT
+ * Function to process a BD
+ * Inputs:
+ *	pdata = pointer to the private driver data
+ *	psram_bd = pointer to the BD sram variable
+ *	bdr_num = number of the BD ring
+ *	cleanup = 1 to indicate to clean up the AEAD req
+ * Outputs:
+ *	Checks the BD and processes any completed PDUs
+ *	updates *psram_bd to point to the next BD
+ *  updates *aead_pp to NULL or the aead request that's completed
+ *  updates *aead_err_p to return code to pass to aead completion
+ * Return:
+ *	1 for processed or 0 for failure
+ */
+static u8 process_a_bd( struct private_driver_data *pdata, u32 *psram_bd, u8 bdr_num, u8 cleanup, struct aead_request **aead_pp, int *aead_err_p, u32* sram_pdu_p )
+{
+	/* re-entrancy check */
+	struct aead_request *req;
+	u32 sram_bd = *psram_bd;
+	u32 sram_pdu;	/* address of the current PDU */
+	enum bd_status bd_status; 
+	u8 processed = 1;
+
+	*aead_pp = NULL;
+	*sram_pdu_p = 0;
+	
+	DRIVER_DEBUG( KERN_INFO "Called: %s\n", __FUNCTION__ );
+
+	if( sram_bd == 0 ) {
+		/* Buffer Descriptor must not be 0 */
+		processed = 0;
+		goto bad_bd;
+	}
+
+	/* get the status of the BD, has the PicoArray processed it ? */
+	bd_status = get_bd_sram_status( sram_bd );
+
+#ifdef PICO_FIRMWARE_NOT_AVAILABLE
+	if ( cleanup != 1 ) {
+		/* IP.ACCESS REMOVE WHEN PICOARRAY FIRMWARE IS AVAILABLE */ 
+		bd_status = BD_DATA_PROCESSED;
+	}
+#endif
+
+	switch ( bd_status ) {
+	case BD_DATA_PROCESSED:
+		/* PicoArray has completed the PDU so give back to Kernel */
+
+		DRIVER_DEBUG( KERN_INFO "Called: %s: BD_DATA_PROCESSED\n", __FUNCTION__ );
+
+		/* retrive the AEAD Request pointer from the buffer descriptor */
+		req = get_bd_sram_aead_request( sram_bd );
+
+		/* calculate PDU address */
+		sram_pdu = get_bd_sram_pdu_address( pdata, sram_bd );
+
+		DRIVER_DEBUG( KERN_INFO "Called: %s: BD_DATA_PROCESSED: PDU address 0x%08X\n", __FUNCTION__, sram_pdu );
+
+		/* Indicate finished with current BD and get next BD to process */
+		finished_sram_buffer_descriptor( &pdata->bdr_info[ bdr_num ] );
+
+		if ( req != NULL ) {
+			DRIVER_DEBUG( KERN_INFO "aead_request_complete called\n" );
+
+			/* WARNING: CALLBACK CAN CAUSE RE-CURSION INTO THE ENCRYPTION/DECRYPTION FUNCTIONS */
+			/* Therefore, make sure all SRAM handling for the current PDU is finished first */
+
+			/* tell the Kernel crypto completed */
+			*aead_pp = req;
+			*aead_err_p = 0;
+			*sram_pdu_p = sram_pdu;
+		}
+		else
+		{
+			DRIVER_DEBUG( KERN_INFO "Called: %s: BD_DATA_PROCESSED: before free: PDU address 0x%08X\n", __FUNCTION__, sram_pdu );
+
+			/* free the PDU */
+			if ( sram_pdu != 0 && free_sram_pdu( &pdata->pdu_info, sram_pdu ) != 0 ) {
+				/* Free failed */
+				/* TODO: Remove this test code */
+				DRIVER_ERROR( KERN_ERR "DUMP: BD_DATA_PROCESSED\n" );
+				dump_sram_structures( pdata );
+				BUG();
+			}
+		}
+
+		break;
+
+	case BD_NO_PROCESSED_DATA:
+		DRIVER_DEBUG( KERN_INFO "Called: %s: BD_NO_PROCESSED_DATA\n", __FUNCTION__ );
+
+		/* no PDU completed so exit this BDR check */
+		processed = 0;
+		break;
+
+	case BD_DATA_PENDING:
+		if( cleanup == 1 ) {
+			DRIVER_DEBUG( KERN_INFO "Called: %s: BD_DATA_PENDING: cleanup\n", __FUNCTION__ );
+
+			/* process the AEAD Req to allow the driver to be removed */
+
+			/* retrive the AEAD Request pointer from the buffer descriptor */
+			req = get_bd_sram_aead_request( sram_bd );
+
+			/* calculate PDU address */
+			sram_pdu = get_bd_sram_pdu_address( pdata, sram_bd );
+
+			/* free the PDU */
+			if ( sram_pdu != 0 && free_sram_pdu( &pdata->pdu_info, sram_pdu ) != 0 ) {
+				/* Free failed */
+				/* TODO: Remove this test code */
+				DRIVER_ERROR( KERN_ERR "DUMP: BD_DATA_PENDING\n" );
+				dump_sram_structures( pdata );
+			}
+
+			/* Indicate finished with current BD and get next BD to process */
+			finished_sram_buffer_descriptor( &pdata->bdr_info[ bdr_num ] );
+
+			if ( req != NULL ) {
+
+				DRIVER_DEBUG( KERN_INFO "Cleaned up an AEAD Req in a BD\n" );
+
+				/* WARNING: CALLBACK CAN CAUSE RE-CURSION INTO THE ENCRYPTION/DECRYPTION FUNCTIONS */
+				/* Therefore, make sure all SRAM handling for the current PDU is finished first */
+
+				/* tell the Kernel crypto completed with error */
+				*aead_pp = req;
+				*aead_err_p = -EINVAL;
+			}
+
+		} else {
+			DRIVER_DEBUG( KERN_INFO "Called: %s: BD_DATA_PENDING: picoArray\n", __FUNCTION__ );
+
+			/* Allow the PicoArray to process this BD */
+			processed = 0;
+		}
+
+		break;
+
+	case BD_ERROR_OCCURRED:
+		DRIVER_DEBUG( KERN_INFO "Called: %s: BD_ERROR_OCCURRED\n", __FUNCTION__ );
+
+		/* PicoArray has reported an error so inform the Kernel */
+
+		/* retrive the AEAD Request pointer from the buffer descriptor */
+		req = get_bd_sram_aead_request( sram_bd );
+
+		/* calculate PDU address */
+		sram_pdu = get_bd_sram_pdu_address( pdata, sram_bd );
+
+		/* free the PDU */
+		if ( sram_pdu != 0 && free_sram_pdu( &pdata->pdu_info, sram_pdu ) != 0 ) {
+			/* Free failed */
+			/* TODO: Remove this test code */
+			DRIVER_ERROR( KERN_ERR "DUMP: BD_ERROR_OCCURRED\n" );
+			dump_sram_structures( pdata );
+		}
+
+		/* Indicate finished with current BD and get next BD to process */
+		finished_sram_buffer_descriptor( &pdata->bdr_info[ bdr_num ] );
+
+		if ( req != NULL ) {
+
+			DRIVER_DEBUG( KERN_ERR "aead_request_complete called with error\n" );
+
+			/* WARNING: CALLBACK CAN CAUSE RE-CURSION INTO THE ENCRYPTION/DECRYPTION FUNCTIONS */
+			/* Therefore, make sure all SRAM handling for the current PDU is finished first */
+
+			/* tell the Kernel crypto completed with error */
+			*aead_pp = req;
+			*aead_err_p = -EINVAL;
+		}
+
+		break;
+	}
+
+	/* get the new current BD after possible re-cursion */
+	*psram_bd = get_current_sram_buffer_descriptor( &pdata->bdr_info[ bdr_num ] );
+
+bad_bd:
+
+	DRIVER_DEBUG( KERN_INFO "Exited: %s\n", __FUNCTION__ );
+
+	/* check for re-entrancy */
+	return ( processed );
+}
+
+
+/*
+ * Function to check for any active the BDs
+ * Inputs:
+ *	pdata = pointer to the private driver data
+ * Outputs:
+ *	Checks each BDR for any active BD
+ * Return:
+ *	0 = no active BDs or 1 = an active BD has been found
+ */
+static u8 check_active_bds( struct private_driver_data *pdata )
+{
+	unsigned long irq_flags;
+	u32 time_measure;
+	u8 bdr_num;	/* BDR number */
+	u32 sram_bd;	/* current sram buffer descriptor to process */
+	u8 found_active_bd = 0;
+
+	/* protect critical code from decrypt and encrypt calls */
+	spin_lock_irqsave( &pdata->driver_lock, irq_flags );
+	time_measure = ioread32(__io(TIMER_VAL_REG));
+
+	DRIVER_DEBUG( KERN_INFO "Called: %s\n", __FUNCTION__ );
+
+	/* spin through each Buffer Descriptor Ring */
+	for ( bdr_num = 0; bdr_num < BDR_TOTAL_NUM; bdr_num++ )
+	{
+		/* check Buffer Descriptor Ring for any active BDs */
+		sram_bd = get_current_sram_buffer_descriptor( &pdata->bdr_info[ bdr_num ] );
+
+		if ( sram_bd != 0 ) {
+			/* found an active BD */
+			found_active_bd = 1;
+			break;
+		}
+	}
+
+	DRIVER_DEBUG( KERN_INFO "Exited: %s\n", __FUNCTION__ );
+
+	time_measure -= ioread32(__io(TIMER_VAL_REG));
+	if (pdata->max_irq_off_time < time_measure) {
+		pdata->max_irq_off_time = time_measure;
+		pdata->culprit = "check_active_bds";
+	}
+	spin_unlock_irqrestore( &pdata->driver_lock, irq_flags );
+
+	return ( found_active_bd );
+}
+
+
+/*
+ * MUST HAVE LOCK BEFORE USING THIS FUNCTION
+ * Function to check whether there is a spare BD in a given BDR
+ * Inputs:
+ *	pdata = pointer to the private driver data
+ *	bdr_num = number of the given BDR
+ * Outputs:
+ *	Checks to whether the maximum number of BDs is use
+ * Return:
+ *	0 = no free BDs or 1 = there is at least 1 free BD
+ */
+static inline u8 check_for_free_bd( struct private_driver_data *pdata, enum bdr_number bdr_num )
+{
+	u8 found_free_bd = 0;
+
+	DRIVER_DEBUG( KERN_INFO "Called: %s\n", __FUNCTION__ );
+
+	if ( pdata->bdr_info[ bdr_num ].num_bds_in_use < pdata->bdr_info[ bdr_num ].total_num_bds ) {
+		/* there is a free BD */
+		found_free_bd = 1;
+	} else {
+		DRIVER_DEBUG( KERN_ERR "ERROR: BDR #%d is full\n", bdr_num + 1 );
+	}
+
+	DRIVER_DEBUG( KERN_INFO "Exited: %s\n", __FUNCTION__ );
+
+	return ( found_free_bd );
+}
+
+
+/*
+ * Function to process the BDRs
+ * Inputs:
+ *	pdata = pointer to the private driver data
+ *	cleanup = 1 to indicate to clean up any remaing AEAD reqs
+ * Outputs:
+ *	Checks each BDR and processes any completed PDUs
+ * Return:
+ *	None.
+ */
+static u8 process_bdrs( struct private_driver_data *pdata, u8 cleanup )
+{
+	/* re-entrancy check */
+	unsigned long irq_flags;
+	u32 time_measure;
+	u32 test2;
+	static atomic_t process_bdrs_check = ATOMIC_INIT(0);
+	u8 bdr_num;	/* BDR number */
+	u32 sram_bd;	/* current sram buffer descriptor to process */
+	u8 exit;
+	int next_completed;
+
+	/* re-entrancy test */
+	if ( atomic_read( &process_bdrs_check ) != 0 ) {
+		DRIVER_DEBUG( KERN_ERR "WARNING: RE-ENTRANCY DETECTED in %s: returning to caller\n", __FUNCTION__ );
+		return 0;
+	}
+
+	/* protect critical code from decrypt and encrypt calls */
+	spin_lock_irqsave( &pdata->driver_lock, irq_flags );
+	time_measure = ioread32(__io(TIMER_VAL_REG));
+
+	/* check for re-entrancy */
+	atomic_inc( &process_bdrs_check );
+
+	DRIVER_DEBUG( KERN_INFO "Called: %s\n", __FUNCTION__ );
+
+	next_completed = pdata->completed_head+1;
+	if (next_completed >= MAX_COMPLETED_AEADS)
+	{
+		next_completed = 0;
+	}
+	
+	/* spin through each Buffer Descriptor Ring */
+	for ( bdr_num = 0; bdr_num < BDR_TOTAL_NUM; bdr_num++ )
+	{
+		exit = 1;
+
+		/* check Buffer Descriptor Ring for any active BDs */
+		sram_bd = get_current_sram_buffer_descriptor( &pdata->bdr_info[ bdr_num ] );
+
+		while ( ( sram_bd != 0 ) && ( exit == 1 ) && ( next_completed != pdata->completed_tail ) ) {
+
+			/* process the BD, sram_bd updated with the next BD address */
+			struct aead_request *req = NULL;
+			int                 err = 0;
+			u32                 sram_pdu = 0;
+			
+			test2 = ioread32(__io(TIMER_VAL_REG));
+			exit = process_a_bd( pdata, &sram_bd, bdr_num, cleanup, &req, &err, &sram_pdu );
+			test2 -= ioread32(__io(TIMER_VAL_REG));
+			if (pdata->max_test_time_2 < test2 ) {
+				pdata->max_test_time_2 = test2 ;
+			}
+			
+			/* Accumulate completed aead requests */
+			if (req != NULL) {
+			
+				int idx = pdata->completed_head;
+				
+				pdata->completed[idx].req = req;
+				pdata->completed[idx].err = err;
+				pdata->completed[idx].sram_pdu = sram_pdu;
+				
+				pdata->completed_head = next_completed;
+				
+				next_completed++;
+				if (next_completed >= MAX_COMPLETED_AEADS)
+				{
+					next_completed = 0;
+				}
+			}
+		}
+	}
+
+	DRIVER_DEBUG( KERN_INFO "Exited: %s\n", __FUNCTION__ );
+
+	/* check for re-entrancy */
+	atomic_dec( &process_bdrs_check );
+
+	time_measure -= ioread32(__io(TIMER_VAL_REG));
+	if (pdata->max_irq_off_time < time_measure) {
+		pdata->max_irq_off_time = time_measure;
+		pdata->culprit = "process_bdrs search";
+	}
+	spin_unlock_irqrestore( &pdata->driver_lock, irq_flags );
+
+	tasklet_schedule(&pdata->tasklet);
+	
+	return 0;
+}
+		
+static void picocrypto_tasklet_callback(unsigned long data)
+{
+	struct private_driver_data *pdata = (struct private_driver_data *)data;
+	unsigned long irq_flags;
+	u32 time_measure;
+	
+	/* Once the interrupts have been re-enabled we can process all
+	   the completed aead requests without the risk of calling a slow
+	   path with interrupts disabled. */
+	spin_lock_irqsave( &pdata->driver_lock, irq_flags );
+	time_measure = ioread32(__io(TIMER_VAL_REG));
+		
+	while (pdata->completed_tail != pdata->completed_head) {
+	
+		struct aead_request *req     = pdata->completed[pdata->completed_tail].req;
+		int                 err      = pdata->completed[pdata->completed_tail].err;
+		u32                 sram_pdu = pdata->completed[pdata->completed_tail].sram_pdu;
+		
+		pdata->completed_tail++;
+		if (pdata->completed_tail >= MAX_COMPLETED_AEADS)
+		{
+			pdata->completed_tail = 0;
+		}
+		
+		time_measure -= ioread32(__io(TIMER_VAL_REG));
+		if (pdata->max_irq_off_time < time_measure) {
+			pdata->max_irq_off_time = time_measure;
+			pdata->culprit = "picocrypto_tasklet_callback 1";
+		}
+		spin_unlock_irqrestore( &pdata->driver_lock, irq_flags );
+	
+		if ( sram_pdu ) {
+		
+			/* read the encrypted or decrypted data into the dst scatterlist */
+			copy_authenc_from_pdu( req, sram_pdu );
+
+			spin_lock_irqsave( &pdata->driver_lock, irq_flags );
+			time_measure = ioread32(__io(TIMER_VAL_REG));
+			
+			/* free the PDU */
+			if ( free_sram_pdu( &pdata->pdu_info, sram_pdu ) != 0 ) {
+				/* Free failed */
+				/* TODO: Remove this test code */
+				DRIVER_ERROR( KERN_ERR "DUMP: BD_DATA_PROCESSED\n" );
+				dump_sram_structures( pdata );
+				BUG();
+			}
+			
+			time_measure -= ioread32(__io(TIMER_VAL_REG));
+			if (pdata->max_irq_off_time < time_measure) {
+				pdata->max_irq_off_time = time_measure;
+				pdata->culprit = "picocrypto_tasklet_callback 3";
+			}
+			spin_unlock_irqrestore( &pdata->driver_lock, irq_flags );
+		}
+
+		aead_request_complete( req, err );
+		
+		spin_lock_irqsave( &pdata->driver_lock, irq_flags );
+		time_measure = ioread32(__io(TIMER_VAL_REG));
+	}
+	
+	time_measure -= ioread32(__io(TIMER_VAL_REG));
+	if (pdata->max_irq_off_time < time_measure) {
+		pdata->max_irq_off_time = time_measure;
+		pdata->culprit = "picocrypto_tasklet_callback 3";
+	}
+	spin_unlock_irqrestore( &pdata->driver_lock, irq_flags );
+}
+
+
+/*
+ * Called in an Interrupt (ATOMIC) context so must not sleep.
+ * This function is re-entrant
+ * Function to add the crypto data to the Buffer Descriptor Ring
+ * Inputs:
+ *	req = AEAD request information
+ *	pctx = pointer to private context information
+ *	bdr_num = number of the BDR to use
+ * Outputs:
+ *	Inserts a Buffer Descriptor into a ring.
+ *	Allocates a PDU and populates it with IV, ciphertext and auth data.
+ * Return:
+ *	-EINPROGRESS = added async offload OK, otherwise -EBUSY for an error has occurred 
+ */
+static int picocrypto_add_to_bdr( struct aead_request *req, struct private_ctx_data *pctx, enum bdr_number bdr_num )
+{
+	/* re-entrancy check */
+	unsigned long irq_flags;
+	u32 time_measure;
+	u32 sram_bd;
+	u32 sram_pdu;
+	u32 pdu_size;
+	u16 wrap_bit_flag;
+	u8 *error_msg;
+	u32 enc_dec_len;	/* plaintext or chiphertext length of the data */
+
+	DRIVER_DEBUG( KERN_INFO "Called: %s\n", __FUNCTION__ );
+
+	atomic_inc( &pctx->driver_info->number_of_pdus );
+	
+	/* calculate the length of the plaintext or ciphertext */
+	if ( pctx->enc_dec_dir == CTX_FLAG_DEC_DIR ) {
+		/* for decryption need to modify cryptlen to remove the length of the auth field */
+		enc_dec_len = req->cryptlen - pctx->authsize;
+	} else {
+		/* for encryption cryptlen does not include the auth field length so it correct */
+		enc_dec_len = req->cryptlen;
+	}
+
+	/* check for exceeding maximum enclength of the PicoArray */
+	if ( enc_dec_len > PICO_MAX_ENC_LENGTH ) {
+		/* encryption/decryption data is too long for the PicoArray */
+		if ( pctx->enc_dec_dir == CTX_FLAG_DEC_DIR ) {
+			atomic_inc( &pctx->driver_info->number_of_dec_size_drops );
+			if (enc_dec_len > atomic_read( &pctx->driver_info->largest_dec_dropped ))
+			{
+				atomic_set( &pctx->driver_info->largest_dec_dropped, enc_dec_len );
+			}
+		} else {
+			atomic_inc( &pctx->driver_info->number_of_enc_size_drops );
+			if (enc_dec_len > atomic_read( &pctx->driver_info->largest_enc_dropped ))
+			{
+				atomic_set( &pctx->driver_info->largest_enc_dropped, enc_dec_len );
+			}
+		}
+		error_msg = "Max enc/dec length exceeded";
+		goto invalid_request_error;
+	}
+
+	/* calculate the size of the PDU */
+	pdu_size = PDU_ASSOC_IV_LENGTH + enc_dec_len + pctx->authsize;
+
+	/* protect critical code from async events */
+	spin_lock_irqsave( &pctx->driver_info->driver_lock, irq_flags );
+	time_measure = ioread32(__io(TIMER_VAL_REG));
+
+	/*
+	 * first check that a BD is free before attempting to alloc a PDU,
+	 * otherwise it wastes a PDU allocation
+	 */
+	if ( check_for_free_bd( pctx->driver_info, bdr_num ) == 0 ) {
+		/* no free BD so abandon */
+		error_msg = "No free BD";
+		if (bdr_num) {
+			atomic_inc( &pctx->driver_info->number_of_bd_2_pre_drops );
+		} else {
+			atomic_inc( &pctx->driver_info->number_of_bd_1_pre_drops );
+		}
+		goto no_bd_error;
+	}
+
+	/* Try allocating a new PDU but with no recovery action if no PDUs are available */ 
+
+	/* try allocating a PDU for passing the crypto data to the SRAM */
+	sram_pdu = alloc_sram_pdu( &pctx->driver_info->pdu_info, pdu_size, bdr_num );
+
+	if ( sram_pdu == 0 ) {
+		/* no PDUs available even after processing BDs in this ring */
+		error_msg = "No PDUs available";
+		atomic_inc( &pctx->driver_info->number_of_pdu_drops );
+		goto no_pdu_error;
+	}
+
+
+	/* Get a BD from Buffer Descriptor ring */
+	sram_bd = alloc_sram_buffer_descriptor( &pctx->driver_info->bdr_info[ bdr_num ], &wrap_bit_flag );
+
+	if( sram_bd == 0 ) {
+		/* no BDs available */
+		if (bdr_num) {
+			atomic_inc( &pctx->driver_info->number_of_bd_2_drops );
+		} else {
+			atomic_inc( &pctx->driver_info->number_of_bd_1_drops );
+		}
+		error_msg = "No BDs available";
+		goto busy_error;
+	}
+
+	time_measure -= ioread32(__io(TIMER_VAL_REG));
+	if (pctx->driver_info->max_irq_off_time < time_measure) {
+		pctx->driver_info->max_irq_off_time = time_measure;
+		pctx->driver_info->culprit = "picocrypto_add_to_bdr 1";
+	}
+	spin_unlock_irqrestore( &pctx->driver_info->driver_lock, irq_flags );
+
+	/* insert the length in bytes of the encryption/decryption data into the bd */
+	insert_bd_sram_enc_dec_len( sram_bd, enc_dec_len );
+
+	/* insert the associated relative context address into the bd */
+	insert_bd_sram_context_address( sram_bd, (u16) ( pctx->context_addr - pctx->driver_info->header_address ) );
+
+	/* insert the AEAD Request pointer into the bd for later retrival */
+	insert_bd_sram_aead_request( sram_bd, req );
+
+	/* insert the relative address of the PDU into the bd */
+	insert_bd_sram_pdu_address( sram_bd, (u16) (sram_pdu - pctx->driver_info->header_address ) );
+
+	/* copy assoc crypto data into the PDU */
+	copy_assoc_to_pdu( req, sram_pdu ); 
+
+	/* copy IV crypto data into the PDU, may be empty */
+	copy_iv_to_pdu( req, sram_pdu );
+
+	/* copy authenc crypto data into the PDU */
+	copy_authenc_to_pdu( req, sram_pdu, enc_dec_len + pctx->authsize ); 
+
+	/* tell the PicoArray to process the buffer descriptor */
+	mark_bd_sram_ready( sram_bd, wrap_bit_flag );
+
+	DRIVER_DEBUG( KERN_INFO "Exited: %s\n", __FUNCTION__ );
+
+	/* inidicate performing an async offload */
+	return -EINPROGRESS;
+
+busy_error:
+	/* free the PDU ( in an out of sequence fashion ) */
+	free_sram_pdu( &pctx->driver_info->pdu_info, sram_pdu );
+
+no_bd_error:
+no_pdu_error:
+
+	time_measure -= ioread32(__io(TIMER_VAL_REG));
+	if (pctx->driver_info->max_irq_off_time < time_measure) {
+		pctx->driver_info->max_irq_off_time = time_measure;
+		pctx->driver_info->culprit = "picocrypto_add_to_bdr 2";
+	}
+	spin_unlock_irqrestore( &pctx->driver_info->driver_lock, irq_flags );
+
+invalid_request_error:
+
+	DRIVER_DEBUG( KERN_ERR "ERROR: Dropped crypto packet during insertion to BDR: %s\n", error_msg );
+
+	/* TEST CODE */
+/*	dump_sram_structures( pctx->driver_info );	*/
+
+	DRIVER_DEBUG( KERN_INFO "Exited: %s\n", __FUNCTION__ );
+
+	/* indicate something went wrong and packet needs to be dropped */
+	return -EBUSY;
+}
+
+
+/*****************************************
+ * Decryption routines, IV data provided *
+ *****************************************/
+
+/*
+ * Function to setup decryption of AES ciphertext plus HMAC auth field
+ * Inputs:
+ *	req = AEAD request information
+ * Outputs:
+ *	Update our private ctx data with decryption context flags.
+ *	Inserts a Buffer Descriptor.
+ *	Allocates a PDU and populates it with IV, ciphertext and auth data.
+ * Return:
+ *	-EINPROGRESS = added async offload OK, otherwise -EBUSY for an error has occurred 
+ */
+static int picocrypto_decrypt( struct aead_request *req )
+{
+	struct crypto_aead *authenc = crypto_aead_reqtfm( req );
+	struct private_ctx_data *pctx = crypto_aead_ctx( authenc );
+
+	int result;
+	u8 current_state;
+
+	DRIVER_DEBUG( KERN_INFO "Called: %s\n", __FUNCTION__ );
+
+	if( pctx->context_addr == 0 )
+	{
+		/* We couldn't allocate a context for the picoArray to use,
+		 * so fall back to SW decryption */
+		current_state = DRIVER_ALL_SW;
+	}
+	else
+	{
+		if( pctx->flags_set == CTX_FLAGS_UNKNOWN ) {
+			/* This decryption has AES and HMAC */
+			write_sram_context_flags( pctx->driver_info, pctx->context_addr,
+				CTX_FLAG_DEC_DIR | CTX_FLAG_ESN_OFF | CTX_FLAG_AUTH_ON | CTX_FLAG_ENC_ON );
+	
+			/* set the direction in our context data */
+			pctx->enc_dec_dir = CTX_FLAG_DEC_DIR;
+	
+			/* set SEQH to zero, ESN not supported */
+			write_sram_context_seqh( pctx->driver_info, pctx->context_addr, 0 );
+	
+			/* set the context crypto flags upon the first decryption */
+			pctx->flags_set = CTX_FLAGS_SET;
+		}
+	
+		current_state = atomic_read( &pctx->driver_info->driver_transit_state );
+	}
+
+	if ( ( current_state == DRIVER_ALL_HW ) || ( current_state == DRIVER_SWITCH_TO_HW ) ) {
+		/* Insert the crypto data into a buffer descriptor */
+		result = picocrypto_add_to_bdr( req, pctx, BDR_NUM_FOR_DEC );
+
+#ifdef ENABLE_BDR_PROCESSING_AFTER_ENC_DEC
+		/* process all the BDRs for any completed PDUs */
+		process_bdrs( pctx->driver_info, 0 );
+#endif	
+
+	} else {
+		/* Give to SW decryption */
+		result = swcrypto_do_it( req, SW_CRYPTO_AUTH, SW_DO_DEC );
+	}
+
+	DRIVER_DEBUG( KERN_INFO "Exited: %s\n", __FUNCTION__ );
+
+	return ( result );
+}
+
+
+static int picocrypto_decrypt_non( struct aead_request *req )
+{
+	struct crypto_aead *authenc = crypto_aead_reqtfm( req );
+	struct private_ctx_data *pctx = crypto_aead_ctx( authenc );
+
+	int result;
+	u8 current_state;
+
+	DRIVER_DEBUG( KERN_INFO "Called: %s\n", __FUNCTION__ );
+
+	if( pctx->context_addr == 0 )
+	{
+		/* We couldn't allocate a context for the picoArray to use,
+		 * so fall back to SW decryption */
+		current_state = DRIVER_ALL_SW;
+	}
+	else
+	{
+		if( pctx->flags_set == CTX_FLAGS_UNKNOWN ) {
+			/* This decryption has AES and non auth */
+			write_sram_context_flags( pctx->driver_info, pctx->context_addr,
+				CTX_FLAG_DEC_DIR | CTX_FLAG_ESN_OFF | CTX_FLAG_NON_AUTH | CTX_FLAG_ENC_ON );
+	
+			/* set the direction in our context data */
+			pctx->enc_dec_dir = CTX_FLAG_DEC_DIR;
+	
+			/* set SEQH to zero, ESN not supported */
+			write_sram_context_seqh( pctx->driver_info, pctx->context_addr, 0 );
+	
+			/* set the context crypto flags upon the first decryption */
+			pctx->flags_set = CTX_FLAGS_SET;
+		}
+	
+		current_state = atomic_read( &pctx->driver_info->driver_transit_state );
+	}
+
+	if ( ( current_state == DRIVER_ALL_HW ) || ( current_state == DRIVER_SWITCH_TO_HW ) ) {
+		/* Insert the crypto data into a buffer descriptor */
+		result = picocrypto_add_to_bdr( req, pctx, BDR_NUM_FOR_DEC );
+
+#ifdef ENABLE_BDR_PROCESSING_AFTER_ENC_DEC
+		/* process all the BDRs for any completed PDUs */
+		process_bdrs( pctx->driver_info, 0 );
+#endif	
+
+	} else {
+		/* Give to SW decryption */
+		result = swcrypto_do_it( req, SW_CRYPTO_NON, SW_DO_DEC );
+	}
+
+	DRIVER_DEBUG( KERN_INFO "Exited: %s\n", __FUNCTION__ );
+
+	return ( result );
+}
+
+
+static int picocrypto_decrypt_null( struct aead_request *req )
+{
+	struct crypto_aead *authenc = crypto_aead_reqtfm( req );
+	struct private_ctx_data *pctx = crypto_aead_ctx( authenc );
+
+	int result;
+	u8 current_state;
+
+	DRIVER_DEBUG( KERN_INFO "Called: %s\n", __FUNCTION__ );
+
+	if( pctx->context_addr == 0 )
+	{
+		/* We couldn't allocate a context for the picoArray to use,
+		 * so fall back to SW decryption */
+		current_state = DRIVER_ALL_SW;
+	}
+	else
+	{
+		if( pctx->flags_set == CTX_FLAGS_UNKNOWN ) {
+			/* This decryption has null decryption and HMAC */
+			write_sram_context_flags( pctx->driver_info, pctx->context_addr,
+				CTX_FLAG_DEC_DIR | CTX_FLAG_ESN_OFF | CTX_FLAG_AUTH_ON | CTX_FLAG_NULL_ENC );
+	
+			/* set the direction in our context data */
+			pctx->enc_dec_dir = CTX_FLAG_DEC_DIR;
+	
+			/* set SEQH to zero, ESN not supported */
+			write_sram_context_seqh( pctx->driver_info, pctx->context_addr, 0 );
+	
+			/* set the context crypto flags upon the first decryption */
+			pctx->flags_set = CTX_FLAGS_SET;
+		}
+	
+		current_state = atomic_read( &pctx->driver_info->driver_transit_state );
+	}
+
+	if ( ( current_state == DRIVER_ALL_HW ) || ( current_state == DRIVER_SWITCH_TO_HW ) ) {
+		/* Insert the crypto data into a buffer descriptor */
+		result = picocrypto_add_to_bdr( req, pctx, BDR_NUM_FOR_DEC );
+
+#ifdef ENABLE_BDR_PROCESSING_AFTER_ENC_DEC
+		/* process all the BDRs for any completed PDUs */
+		process_bdrs( pctx->driver_info, 0 );
+#endif	
+
+	} else {
+		/* Give to SW decryption */
+		result = swcrypto_do_it( req, SW_NULL_AUTH, SW_DO_DEC );
+	}
+
+	DRIVER_DEBUG( KERN_INFO "Exited: %s\n", __FUNCTION__ );
+
+	return ( result );
+}
+
+
+static int picocrypto_decrypt_null_non( struct aead_request *req )
+{
+	struct crypto_aead *authenc = crypto_aead_reqtfm( req );
+	struct private_ctx_data *pctx = crypto_aead_ctx( authenc );
+
+	int result;
+	u8 current_state;
+
+	DRIVER_DEBUG( KERN_INFO "Called: %s\n", __FUNCTION__ );
+
+	if( pctx->context_addr == 0 )
+	{
+		/* We couldn't allocate a context for the picoArray to use,
+		 * so fall back to SW decryption */
+		current_state = DRIVER_ALL_SW;
+	}
+	else
+	{
+		if( pctx->flags_set == CTX_FLAGS_UNKNOWN ) {
+			/* This decryption has null decryption and non auth */
+			write_sram_context_flags( pctx->driver_info, pctx->context_addr,
+				CTX_FLAG_DEC_DIR | CTX_FLAG_ESN_OFF | CTX_FLAG_NON_AUTH | CTX_FLAG_NULL_ENC );
+	
+			/* set the direction in our context data */
+			pctx->enc_dec_dir = CTX_FLAG_DEC_DIR;
+	
+			/* set SEQH to zero, ESN not supported */
+			write_sram_context_seqh( pctx->driver_info, pctx->context_addr, 0 );
+	
+			/* set the context crypto flags upon the first decryption */
+			pctx->flags_set = CTX_FLAGS_SET;
+		}
+	
+		current_state = atomic_read( &pctx->driver_info->driver_transit_state );
+	}
+
+	if ( ( current_state == DRIVER_ALL_HW ) || ( current_state == DRIVER_SWITCH_TO_HW ) ) {
+		/* Insert the crypto data into a buffer descriptor */
+		result = picocrypto_add_to_bdr( req, pctx, BDR_NUM_FOR_DEC );
+
+#ifdef ENABLE_BDR_PROCESSING_AFTER_ENC_DEC
+		/* process all the BDRs for any completed PDUs */
+		process_bdrs( pctx->driver_info, 0 );
+#endif	
+
+	} else {
+		/* Give to SW decryption */
+		result = swcrypto_do_it( req, SW_NULL_NON, SW_DO_DEC );
+	}
+
+	DRIVER_DEBUG( KERN_INFO "Exited: %s\n", __FUNCTION__ );
+
+	return ( result );
+}
+
+
+/********************************************
+ * Encryption routines, IV data is provided *
+ ********************************************/
+
+static int picocrypto_encrypt( struct aead_request *req )
+{
+	struct crypto_aead *authenc = crypto_aead_reqtfm( req );
+	struct private_ctx_data *pctx = crypto_aead_ctx( authenc );
+
+	int result;
+	u8 current_state;
+
+	DRIVER_DEBUG( KERN_INFO "Called: %s\n", __FUNCTION__ );
+
+	if( pctx->context_addr == 0 )
+	{
+		/* We couldn't allocate a context for the picoArray to use,
+		 * so fall back to SW encryption */
+		current_state = DRIVER_ALL_SW;
+	}
+	else
+	{
+		if( pctx->flags_set == CTX_FLAGS_UNKNOWN ) {
+			/* This encryption has AES and HMAC */
+			write_sram_context_flags( pctx->driver_info, pctx->context_addr,
+				CTX_FLAG_ENC_DIR | CTX_FLAG_ESN_OFF | CTX_FLAG_AUTH_ON | CTX_FLAG_ENC_ON );
+	
+			/* set the direction in our context data */
+			pctx->enc_dec_dir = CTX_FLAG_ENC_DIR;
+	
+			/* set SEQH to zero, ESN not supported */
+			write_sram_context_seqh( pctx->driver_info, pctx->context_addr, 0 );
+	
+			/* set the context crypto flags upon the first encryption */
+			pctx->flags_set = CTX_FLAGS_SET;
+		}
+
+		current_state = atomic_read( &pctx->driver_info->driver_transit_state );
+	}
+
+	if ( ( current_state == DRIVER_ALL_HW ) || ( current_state == DRIVER_SWITCH_TO_HW ) ) {
+		/* Insert the crypto data into a buffer descriptor */
+		result = picocrypto_add_to_bdr( req, pctx, BDR_NUM_FOR_ENC );
+
+#ifdef ENABLE_BDR_PROCESSING_AFTER_ENC_DEC
+		/* process all the BDRs for any completed PDUs */
+		process_bdrs( pctx->driver_info, 0 );
+#endif	
+
+	} else {
+		/* Give to SW encryption */
+		result = swcrypto_do_it( req, SW_CRYPTO_AUTH, SW_DO_ENC );
+	}
+
+	DRIVER_DEBUG( KERN_INFO "Exited: %s\n", __FUNCTION__ );
+
+	return ( result );
+}
+
+
+static int picocrypto_encrypt_non( struct aead_request *req )
+{
+	struct crypto_aead *authenc = crypto_aead_reqtfm( req );
+	struct private_ctx_data *pctx = crypto_aead_ctx( authenc );
+
+	int result;
+	u8 current_state;
+
+	DRIVER_DEBUG( KERN_INFO "Called: %s\n", __FUNCTION__ );
+
+	if( pctx->context_addr == 0 )
+	{
+		/* We couldn't allocate a context for the picoArray to use,
+		 * so fall back to SW encryption */
+		current_state = DRIVER_ALL_SW;
+	}
+	else
+	{
+		if( pctx->flags_set == CTX_FLAGS_UNKNOWN ) {
+			/* This encryption has AES and non authentication*/
+			write_sram_context_flags( pctx->driver_info, pctx->context_addr,
+				CTX_FLAG_ENC_DIR | CTX_FLAG_ESN_OFF | CTX_FLAG_NON_AUTH | CTX_FLAG_ENC_ON );
+	
+			/* set the direction in our context data */
+			pctx->enc_dec_dir = CTX_FLAG_ENC_DIR;
+	
+			/* set SEQH to zero, ESN not supported */
+			write_sram_context_seqh( pctx->driver_info, pctx->context_addr, 0 );
+	
+			/* set the context crypto flags upon the first encryption */
+			pctx->flags_set = CTX_FLAGS_SET;
+		}
+	
+		current_state = atomic_read( &pctx->driver_info->driver_transit_state );
+	}
+
+	if ( ( current_state == DRIVER_ALL_HW ) || ( current_state == DRIVER_SWITCH_TO_HW ) ) {
+		/* Insert the crypto data into a buffer descriptor */
+		result = picocrypto_add_to_bdr( req, pctx, BDR_NUM_FOR_ENC );
+
+#ifdef ENABLE_BDR_PROCESSING_AFTER_ENC_DEC
+		/* process all the BDRs for any completed PDUs */
+		process_bdrs( pctx->driver_info, 0 );
+#endif	
+
+	} else {
+		/* Give to SW encryption */
+		result = swcrypto_do_it( req, SW_CRYPTO_NON, SW_DO_ENC );
+	}
+
+	DRIVER_DEBUG( KERN_INFO "Exited: %s\n", __FUNCTION__ );
+
+	return ( result );
+}
+
+
+static int picocrypto_encrypt_null( struct aead_request *req )
+{
+	struct crypto_aead *authenc = crypto_aead_reqtfm( req );
+	struct private_ctx_data *pctx = crypto_aead_ctx( authenc );
+
+	int result;
+	u8 current_state;
+
+	DRIVER_DEBUG( KERN_INFO "Called: %s\n", __FUNCTION__ );
+
+	if( pctx->context_addr == 0 )
+	{
+		/* We couldn't allocate a context for the picoArray to use,
+		 * so fall back to SW encryption */
+		current_state = DRIVER_ALL_SW;
+	}
+	else
+	{
+		if( pctx->flags_set == CTX_FLAGS_UNKNOWN ) {
+			/* This encryption has null encryption and HMAC */
+			write_sram_context_flags( pctx->driver_info, pctx->context_addr,
+				CTX_FLAG_ENC_DIR | CTX_FLAG_ESN_OFF | CTX_FLAG_AUTH_ON | CTX_FLAG_NULL_ENC );
+	
+			/* set the direction in our context data */
+			pctx->enc_dec_dir = CTX_FLAG_ENC_DIR;
+	
+			/* set SEQH to zero, ESN not supported */
+			write_sram_context_seqh( pctx->driver_info, pctx->context_addr, 0 );
+	
+			/* set the context crypto flags upon the first encryption */
+			pctx->flags_set = CTX_FLAGS_SET;
+		}
+	
+		current_state = atomic_read( &pctx->driver_info->driver_transit_state );
+	}
+
+	if ( ( current_state == DRIVER_ALL_HW ) || ( current_state == DRIVER_SWITCH_TO_HW ) ) {
+		/* Insert the crypto data into a buffer descriptor */
+		result = picocrypto_add_to_bdr( req, pctx, BDR_NUM_FOR_ENC );
+
+#ifdef ENABLE_BDR_PROCESSING_AFTER_ENC_DEC
+		/* process all the BDRs for any completed PDUs */
+		process_bdrs( pctx->driver_info, 0 );
+#endif	
+
+	} else {
+		/* Give to SW encryption */
+		result = swcrypto_do_it( req, SW_NULL_AUTH, SW_DO_ENC );
+	}
+
+	DRIVER_DEBUG( KERN_INFO "Exited: %s\n", __FUNCTION__ );
+
+	return ( result );
+}
+
+
+static int picocrypto_encrypt_null_non( struct aead_request *req )
+{
+	struct crypto_aead *authenc = crypto_aead_reqtfm( req );
+	struct private_ctx_data *pctx = crypto_aead_ctx( authenc );
+
+	int result;
+	u8 current_state;
+
+	DRIVER_DEBUG( KERN_INFO "Called: %s\n", __FUNCTION__ );
+
+	if( pctx->context_addr == 0 )
+	{
+		/* We couldn't allocate a context for the picoArray to use,
+		 * so fall back to SW encryption */
+		current_state = DRIVER_ALL_SW;
+	}
+	else
+	{
+		if( pctx->flags_set == CTX_FLAGS_UNKNOWN ) {
+			/* This encryption has null encryption and non authentication */
+			write_sram_context_flags( pctx->driver_info, pctx->context_addr,
+				CTX_FLAG_ENC_DIR | CTX_FLAG_ESN_OFF | CTX_FLAG_NON_AUTH | CTX_FLAG_NULL_ENC );
+	
+			/* set the direction in our context data */
+			pctx->enc_dec_dir = CTX_FLAG_ENC_DIR;
+	
+			/* set SEQH to zero, ESN not supported */
+			write_sram_context_seqh( pctx->driver_info, pctx->context_addr, 0 );
+	
+			/* set the context crypto flags upon the first encryption */
+			pctx->flags_set = CTX_FLAGS_SET;
+		}
+	
+		current_state = atomic_read( &pctx->driver_info->driver_transit_state );
+	}
+
+	if ( ( current_state == DRIVER_ALL_HW ) || ( current_state == DRIVER_SWITCH_TO_HW ) ) {
+		/* Insert the crypto data into a buffer descriptor */
+		result = picocrypto_add_to_bdr( req, pctx, BDR_NUM_FOR_ENC );
+
+#ifdef ENABLE_BDR_PROCESSING_AFTER_ENC_DEC
+		/* process all the BDRs for any completed PDUs */
+		process_bdrs( pctx->driver_info, 0 );
+#endif	
+
+	} else {
+		/* Give to SW encryption */
+		result = swcrypto_do_it( req, SW_NULL_NON, SW_DO_ENC );
+	}
+
+	DRIVER_DEBUG( KERN_INFO "Exited: %s\n", __FUNCTION__ );
+
+	return ( result );
+}
+
+
+/*************************************
+ * Encryption with IV data generator *
+ *************************************/
+
+static int picocrypto_givencrypt( struct aead_givcrypt_request *req )
+{
+	struct aead_request *areq = &req->areq;
+	struct crypto_aead *authenc = crypto_aead_reqtfm( areq );
+	struct private_ctx_data *pctx = crypto_aead_ctx( authenc );
+
+	int result;
+	u8 current_state;
+
+	DRIVER_DEBUG( KERN_INFO "Called: %s\n", __FUNCTION__ );
+
+	/* generate IV data */
+	/* TODO: IV data needs to be suitably random, is this good enough ? */
+	get_random_bytes( areq->iv, crypto_aead_ivsize( authenc ) );
+
+	/* 
+	 * req->giv[0..15] contains the IV data that goes into the ESP packet
+	 * Make the areq->[0..15] for encrypt routine be the same
+	 * as req->giv[0..15] for the ESP packet
+	 */ 
+	memcpy( req->giv, areq->iv, crypto_aead_ivsize( authenc ) );
+
+	if( pctx->context_addr == 0 )
+	{
+		/* We couldn't allocate a context for the picoArray to use,
+		 * so fall back to SW encryption */
+		current_state = DRIVER_ALL_SW;
+	}
+	else
+	{
+		if( pctx->flags_set == CTX_FLAGS_UNKNOWN ) {
+			/* This encryption has AES and HMAC */
+			write_sram_context_flags( pctx->driver_info, pctx->context_addr,
+				CTX_FLAG_ENC_DIR | CTX_FLAG_ESN_OFF | CTX_FLAG_AUTH_ON | CTX_FLAG_ENC_ON );
+	
+			/* set the direction in our context data */
+			pctx->enc_dec_dir = CTX_FLAG_ENC_DIR;
+	
+			/* set SEQH to zero, ESN not supported */
+			write_sram_context_seqh( pctx->driver_info, pctx->context_addr, 0 );
+	
+			/* set the context crypto flags upon the first encryption */
+			pctx->flags_set = CTX_FLAGS_SET;
+		}
+	
+		current_state = atomic_read( &pctx->driver_info->driver_transit_state );
+	}
+
+	if ( ( current_state == DRIVER_ALL_HW ) || ( current_state == DRIVER_SWITCH_TO_HW ) ) {
+		/* Insert the crypto data into a buffer descriptor */
+		result = picocrypto_add_to_bdr( areq, pctx, BDR_NUM_FOR_ENC );
+
+#ifdef ENABLE_BDR_PROCESSING_AFTER_ENC_DEC
+		/* process all the BDRs for any completed PDUs */
+		process_bdrs( pctx->driver_info, 0 );
+#endif	
+
+	} else {
+		/* Give to SW encryption */
+		result = swcrypto_do_it( areq, SW_CRYPTO_AUTH, SW_DO_ENC );
+	}
+
+	DRIVER_DEBUG( KERN_INFO "Exited: %s\n", __FUNCTION__ );
+
+	return ( result );
+}
+
+
+static int picocrypto_givencrypt_non( struct aead_givcrypt_request *req )
+{
+	struct aead_request *areq = &req->areq;
+	struct crypto_aead *authenc = crypto_aead_reqtfm( areq );
+	struct private_ctx_data *pctx = crypto_aead_ctx( authenc );
+
+	int result;
+	u8 current_state;
+
+	DRIVER_DEBUG( KERN_INFO "Called: %s\n", __FUNCTION__ );
+
+	/* generate IV data */
+	/* TODO: IV data needs to be suitably random, is this good enough ? */
+	get_random_bytes( areq->iv, crypto_aead_ivsize( authenc ) );
+
+	/* 
+	 * req->giv[0..15] contains the IV data that goes into the ESP packet
+	 * Make the areq->[0..15] for encrypt routine be the same
+	 * as req->giv[0..15] for the ESP packet
+	 */ 
+	memcpy( req->giv, areq->iv, crypto_aead_ivsize( authenc ) );
+
+	if( pctx->context_addr == 0 )
+	{
+		/* We couldn't allocate a context for the picoArray to use,
+		 * so fall back to SW encryption */
+		current_state = DRIVER_ALL_SW;
+	}
+	else
+	{
+		if( pctx->flags_set == CTX_FLAGS_UNKNOWN ) {
+			/* This encryption has AES and non authentication */
+			write_sram_context_flags( pctx->driver_info, pctx->context_addr,
+				CTX_FLAG_ENC_DIR | CTX_FLAG_ESN_OFF | CTX_FLAG_NON_AUTH | CTX_FLAG_ENC_ON );
+	
+			/* set the direction in our context data */
+			pctx->enc_dec_dir = CTX_FLAG_ENC_DIR;
+	
+			/* set SEQH to zero, ESN not supported */
+			write_sram_context_seqh( pctx->driver_info, pctx->context_addr, 0 );
+	
+			/* set the context crypto flags upon the first encryption */
+			pctx->flags_set = CTX_FLAGS_SET;
+		}
+	
+		current_state = atomic_read( &pctx->driver_info->driver_transit_state );
+	}
+
+	if ( ( current_state == DRIVER_ALL_HW ) || ( current_state == DRIVER_SWITCH_TO_HW ) ) {
+		/* Insert the crypto data into a buffer descriptor */
+		result = picocrypto_add_to_bdr( areq, pctx, BDR_NUM_FOR_ENC );
+
+#ifdef ENABLE_BDR_PROCESSING_AFTER_ENC_DEC
+		/* process all the BDRs for any completed PDUs */
+		process_bdrs( pctx->driver_info, 0 );
+#endif	
+
+	} else {
+		/* Give to SW encryption */
+		result = swcrypto_do_it( areq, SW_CRYPTO_NON, SW_DO_ENC );
+	}
+
+	DRIVER_DEBUG( KERN_INFO "Exited: %s\n", __FUNCTION__ );
+
+	return ( result );
+}
+
+
+static int picocrypto_givencrypt_null( struct aead_givcrypt_request *req )
+{
+	struct aead_request *areq = &req->areq;
+	struct crypto_aead *authenc = crypto_aead_reqtfm( areq );
+	struct private_ctx_data *pctx = crypto_aead_ctx( authenc );
+
+	int result;
+	u8 current_state;
+
+	DRIVER_DEBUG( KERN_INFO "Called: %s\n", __FUNCTION__ );
+
+	if( pctx->context_addr == 0 )
+	{
+		/* We couldn't allocate a context for the picoArray to use,
+		 * so fall back to SW encryption */
+		current_state = DRIVER_ALL_SW;
+	}
+	else
+	{
+		if( pctx->flags_set == CTX_FLAGS_UNKNOWN ) {
+			/* This encryption has non encryption and HMAC */
+			write_sram_context_flags( pctx->driver_info, pctx->context_addr,
+				CTX_FLAG_ENC_DIR | CTX_FLAG_ESN_OFF | CTX_FLAG_AUTH_ON | CTX_FLAG_NULL_ENC );
+	
+			/* set the direction in our context data */
+			pctx->enc_dec_dir = CTX_FLAG_ENC_DIR;
+	
+			/* set SEQH to zero, ESN not supported */
+			write_sram_context_seqh( pctx->driver_info, pctx->context_addr, 0 );
+	
+			/* set the context crypto flags upon the first encryption */
+			pctx->flags_set = CTX_FLAGS_SET;
+		}
+	
+		current_state = atomic_read( &pctx->driver_info->driver_transit_state );
+	}
+
+	if ( ( current_state == DRIVER_ALL_HW ) || ( current_state == DRIVER_SWITCH_TO_HW ) ) {
+		/* Insert the crypto data into a buffer descriptor */
+		result = picocrypto_add_to_bdr( areq, pctx, BDR_NUM_FOR_ENC );
+
+#ifdef ENABLE_BDR_PROCESSING_AFTER_ENC_DEC
+		/* process all the BDRs for any completed PDUs */
+		process_bdrs( pctx->driver_info, 0 );
+#endif	
+
+	} else {
+		/* Give to SW encryption */
+		result = swcrypto_do_it( areq, SW_NULL_AUTH, SW_DO_ENC );
+	}
+
+	DRIVER_DEBUG( KERN_INFO "Exited: %s\n", __FUNCTION__ );
+
+	return ( result );
+}
+
+
+static int picocrypto_givencrypt_null_non( struct aead_givcrypt_request *req )
+{
+	struct aead_request *areq = &req->areq;
+	struct crypto_aead *authenc = crypto_aead_reqtfm( areq );
+	struct private_ctx_data *pctx = crypto_aead_ctx( authenc );
+
+	int result;
+	u8 current_state;
+
+	DRIVER_DEBUG( KERN_INFO "Called: %s\n", __FUNCTION__ );
+
+	if( pctx->context_addr == 0 )
+	{
+		/* We couldn't allocate a context for the picoArray to use,
+		 * so fall back to SW encryption */
+		current_state = DRIVER_ALL_SW;
+	}
+	else
+	{
+		if( pctx->flags_set == CTX_FLAGS_UNKNOWN ) {
+			/* This encryption has null encryption and non authentication */
+			write_sram_context_flags( pctx->driver_info, pctx->context_addr,
+				CTX_FLAG_ENC_DIR | CTX_FLAG_ESN_OFF | CTX_FLAG_NON_AUTH | CTX_FLAG_NULL_ENC );
+	
+			/* set the direction in our context data */
+			pctx->enc_dec_dir = CTX_FLAG_ENC_DIR;
+	
+			/* set SEQH to zero, ESN not supported */
+			write_sram_context_seqh( pctx->driver_info, pctx->context_addr, 0 );
+	
+			/* set the context crypto flags upon the first encryption */
+			pctx->flags_set = CTX_FLAGS_SET;
+		}
+	
+		current_state = atomic_read( &pctx->driver_info->driver_transit_state );
+	}
+
+	if ( ( current_state == DRIVER_ALL_HW ) || ( current_state == DRIVER_SWITCH_TO_HW ) ) {
+		/* Insert the crypto data into a buffer descriptor */
+		result = picocrypto_add_to_bdr( areq, pctx, BDR_NUM_FOR_ENC );
+
+#ifdef ENABLE_BDR_PROCESSING_AFTER_ENC_DEC
+		/* process all the BDRs for any completed PDUs */
+		process_bdrs( pctx->driver_info, 0 );
+#endif	
+
+	} else {
+		/* Give to SW encryption */
+		result = swcrypto_do_it( areq, SW_NULL_NON, SW_DO_ENC );
+	}
+
+	DRIVER_DEBUG( KERN_INFO "Exited: %s\n", __FUNCTION__ );
+
+	return ( result );
+}
+
+
+/*************************
+ * Async event test code *
+ *************************/
+
+/* allow container of to be used */
+struct work_item {
+	struct delayed_work dwork;
+	struct private_driver_data *pdata;
+};	
+
+
+/* GLOBALS */
+static struct workqueue_struct *atest_work_queue = NULL;
+/* create a work item */
+struct work_item *atest_work_item = NULL;
+
+void atest_work_fn( struct work_struct *pwork )
+{
+	u8 current_state;
+	
+	/* get back the delayed work item */
+	struct delayed_work *pdwork = 
+		container_of( pwork, struct delayed_work, work );
+
+	struct work_item *pitem =
+		container_of( pdwork, struct work_item, dwork );
+
+	/* process all the BDRs for any completed PDUs */
+	current_state = atomic_read( &pitem->pdata->driver_transit_state );
+
+	if ( current_state != DRIVER_ALL_SW ) {
+		process_bdrs( pitem->pdata, 0 );
+	}
+
+	/* add it back again, reuse the existing malloced structure */
+	/* initialise the delayed work item */
+	INIT_DELAYED_WORK( pdwork, &atest_work_fn );
+
+	/* add work item to the work queue after a delay */
+#if 1
+	queue_delayed_work( atest_work_queue, pdwork, HZ/200 );	/* 5ms */
+#else
+	queue_delayed_work( atest_work_queue, pdwork, HZ/10 );	/* 100ms */
+#endif
+}
+
+
+static void start_async_test( struct private_driver_data *pdata )
+{
+	/* create a work queue for simulating the async event */
+	atest_work_queue = create_singlethread_workqueue( "async_test" );
+	if( atest_work_queue == NULL ) {
+		DRIVER_ERROR( KERN_ERR "Failed to create work queue\n" );
+		return;
+	}
+
+	/* allocate memory for the work item */
+	atest_work_item = kmalloc( sizeof( struct work_item ), GFP_KERNEL );
+	if( atest_work_item == NULL ) {
+		DRIVER_ERROR( KERN_ERR "Failed to create work item\n" );
+		return;
+	}
+
+	/* make a note of the private driver info for the work function to use */
+	atest_work_item->pdata = pdata;
+
+	/* initialise the dealyed work item */
+	INIT_DELAYED_WORK( &atest_work_item->dwork, &atest_work_fn );
+
+	/* add work item to the work queue after a delay */
+	queue_delayed_work( atest_work_queue, &atest_work_item->dwork, 5*HZ );
+}
+
+
+static void stop_async_test( struct private_driver_data *pdata )
+{
+	if( atest_work_queue != NULL ) {
+		/* empty the work queue */
+		flush_workqueue( atest_work_queue );
+
+		/* finished with the work queue so delete it */
+		destroy_workqueue( atest_work_queue );
+	}
+
+	if( atest_work_item != NULL ) {
+		/* free the work item */
+		kfree( atest_work_item );
+		atest_work_item = NULL;
+	}
+}
+
+
+/*************************
+ * sysfs access function *
+ *************************/
+/*
+ * Global variable for sysfs to allow the private
+ * data structures to be accessed.
+ */
+
+struct private_driver_data *pglob_sysfs_private = NULL;
+
+static ssize_t picocrypto_show_zero( struct device_driver *drv, char *buf )
+{
+        return scnprintf( buf, PAGE_SIZE, "%d\n", 0 );
+}
+
+
+static ssize_t picocrypto_clear_aead_reqs( struct device_driver *drv, const char *buf, size_t count )
+{
+	DRIVER_DEBUG( KERN_INFO "Trying to clean up AEAD Reqs in the BDRs...\n" );
+
+	if ( pglob_sysfs_private != NULL ) {
+		/* process any remaining AEAD reqs in the BDRs to allow the driver to be removed */
+		u8 current_state = atomic_read( &pglob_sysfs_private->driver_transit_state );
+
+		if ( ( current_state == DRIVER_ALL_HW ) || ( current_state == DRIVER_SWITCH_TO_HW ) ) {
+			process_bdrs( pglob_sysfs_private, 1 );
+		}
+	}
+
+        return count;
+}
+
+
+static ssize_t picocrypto_dump_sram( struct device_driver *drv, const char *buf, size_t count )
+{
+	DRIVER_INFO( KERN_INFO "Trying to dump the SRAM...\n" );
+
+	if ( pglob_sysfs_private != NULL ) {
+		/* dump the SRAM contents */
+		dump_sram_structures( pglob_sysfs_private );
+	}
+
+        return count;
+}
+
+/* TODO: needs to return the result state back to user-land */
+static ssize_t picocrypto_open_pico( struct device_driver *drv, const char *buf, size_t count )
+{
+	u8 current_state;
+
+	DRIVER_DEBUG( KERN_INFO "Trying to open the picoArray...\n" );
+
+	if ( pglob_sysfs_private != NULL ) {
+
+		if ( ! read_pico_active_state( pglob_sysfs_private ) ) {
+			/* failed to OPEN the picoArray */
+
+			/* fallback to using SW */
+			atomic_set( &pglob_sysfs_private->driver_transit_state, DRIVER_ALL_SW );
+
+			DRIVER_DEBUG( KERN_INFO "Set to SW mode\n" );
+			
+		} else {
+
+			u8 picoActive = 1;
+			
+			current_state = atomic_read( &pglob_sysfs_private->driver_transit_state );
+			
+			if (current_state != DRIVER_ALL_HW)
+			{
+				picoActive = init_sram_structures( pglob_sysfs_private );
+			}
+			
+			/* try opening the picoArray */
+			if ( ( ! picoActive)  || ( request_sram_pico_open( pglob_sysfs_private ) == 1 ) ) {
+				/* failed to OPEN the picoArray */
+	
+				/* fallback to using SW */
+				atomic_set( &pglob_sysfs_private->driver_transit_state, DRIVER_ALL_SW );
+	
+				DRIVER_DEBUG( KERN_INFO "Set to SW mode\n" );
+	
+			} else {
+				/* read the current transit state */
+				current_state = atomic_read( &pglob_sysfs_private->driver_transit_state );
+	
+				switch ( current_state ) {
+				case DRIVER_ALL_HW:
+					/* Already in HW enc/dec therefore do not change state */
+					break;
+	
+				case DRIVER_SWITCH_TO_HW:
+					/* Error condition, switch to HW had previously failed ? */
+					/* fall-through */
+	
+				case DRIVER_ALL_SW:
+					/* Expected state */
+					/* fall-through */
+	
+				case DRIVER_SWITCH_TO_SW:
+					/* Error condition, switch to SW had previously failed ? */
+	
+					/*
+					* change the transit state to redirect input to HW enc/dec
+					* to allow SW to finish processing all remaining jobs.
+					*/
+					atomic_set( &pglob_sysfs_private->driver_transit_state, DRIVER_SWITCH_TO_HW );
+	
+					break;
+				}
+	
+				/* No need to wait for SW to finish processing all pending jobs because it is synchronous */
+	
+				/*
+				* No SW jobs pending so it is safe to 
+				* change the transit state to redirect output of HW enc/dec.
+				* Note. still possible for the picoArray to fail to enter the OPENED state.
+				*/
+				atomic_set( &pglob_sysfs_private->driver_transit_state, DRIVER_ALL_HW );
+	
+				DRIVER_DEBUG( KERN_INFO "Set to HW mode\n" );
+			}
+		}
+	}
+
+        return count;
+}
+
+
+/* TODO: needs to return the result state back to user-land */
+/* TODO: WARNING: THERE IS NO LOCKING BETWEEN CHECKING ACTIVE BDs AND RE-SETTING THE BDRS */
+/* SPIN-LOCKS ARE NOT POSSIBLE DUE TO SLEEPING WITHIN THE CLOSE_REQ FUNCTION */ 
+/* TODO: Needs locking against other sysfs close and opens */ 
+static ssize_t picocrypto_close_pico( struct device_driver *drv, const char *buf, size_t count )
+{
+	u8 error = 0;
+	u8 current_state;
+
+	DRIVER_DEBUG( KERN_INFO "Trying to close the picoArray...\n" );
+
+	if ( pglob_sysfs_private != NULL ) {
+
+		/* read the current transit state */
+		current_state = atomic_read( &pglob_sysfs_private->driver_transit_state );
+
+		switch ( current_state ) {
+		case DRIVER_ALL_SW:
+			/* Already in SW enc/dec therefore do not change state */
+			break;
+
+		case DRIVER_SWITCH_TO_HW:
+			/* Error condition, switch to HW had previously failed ? */
+			/* fall-through */
+
+		case DRIVER_ALL_HW:
+			/* Expected state */
+			/* fall-through */
+
+		case DRIVER_SWITCH_TO_SW:
+			/* Error condition, switch to SW had previously failed ? */
+
+			/*
+			 * change the transit state to redirect input to SW enc/dec
+			 * to allow hw to finish processing all remaining active BDs.
+			 */
+			atomic_set( &pglob_sysfs_private->driver_transit_state, DRIVER_SWITCH_TO_SW );
+
+			/* check for any active BDs before closing */ 
+			if ( check_active_bds( pglob_sysfs_private ) == 1 ) {
+	
+				/* a BD is active so wait until it has been processed */
+				msleep( BD_PROCESS_TIMEOUT );
+	
+				if ( check_active_bds( pglob_sysfs_private ) == 1 ) {
+	
+					/* there is still at least 1 active BD so cannot close the picoArray */
+					error = 1;
+				}
+			}
+			
+			if ( error == 0 ) {
+				/*
+				* No active BDs so it is safe to 
+				* change the transit state to redirect output of SW enc/dec.
+				* Note. still possible for the picoArray to fail to enter the CLOSED state.
+				*/
+				atomic_set( &pglob_sysfs_private->driver_transit_state, DRIVER_ALL_SW );
+	
+				/* try closing the picoArray */
+				if ( request_sram_pico_close( pglob_sysfs_private ) == 0 ) {
+					/* successfully ACTIONED a change to the CLOSED state */
+					/* Ignore the no change of state */
+	
+					/*
+					* CAUTION: ALL BDRs MUST NOT BE IN USE BEFORE
+					* RE-INITIALISING THE BDR's CURRENT BD POINTER
+					* TO THE START OF THE RING TO MATCH THE
+					* PICOARRAYS POINTERS UPON ENTERING THE CLOSED STATE.
+					*/ 
+					init_sram_structures( pglob_sysfs_private );
+				}
+			} else {
+				DRIVER_ERROR( KERN_ERR "ERROR: Cannot CLOSE picoArray due to at least 1 active BD\n" );
+			}
+			break;
+		}
+
+		DRIVER_DEBUG( KERN_INFO "Set to SW mode\n" );
+	}
+
+        return count;
+}
+
+
+static ssize_t picocrypto_pico_status( struct device_driver *drv, char *buf )
+{
+	u32 cnf_state = 0;
+
+	DRIVER_DEBUG( KERN_INFO "Trying to obtain the picoArray status...\n" );
+
+	if ( pglob_sysfs_private != NULL ) {
+
+		/* read picoArray confirmed status */
+		cnf_state = read_sram_confirmed_state( pglob_sysfs_private );
+	}
+
+        return scnprintf( buf, PAGE_SIZE, "0x%08X\n", cnf_state );
+}
+
+
+static ssize_t picocrypto_show_mode( struct device_driver *drv, char *buf )
+{
+	u8 *mode = "Unknown";
+	u8 current_state;
+
+	DRIVER_DEBUG( KERN_INFO "Trying to obtain the driver's mode...\n" );
+
+	if ( pglob_sysfs_private != NULL ) {
+
+		/* get the current state of the driver */
+		current_state = atomic_read( &pglob_sysfs_private->driver_transit_state );
+
+		switch ( current_state ) {
+		case DRIVER_ALL_HW:
+			mode = "HW mode";
+			break;
+
+		case DRIVER_SWITCH_TO_HW:
+			mode = "HW mode (switching)";
+			break;
+
+		case DRIVER_ALL_SW:
+			mode = "SW mode";
+			break;
+
+		case DRIVER_SWITCH_TO_SW:
+			mode = "SW mode (switching)";
+			break;
+		}
+	}
+
+        return scnprintf( buf, PAGE_SIZE, "%s\n", mode );
+}
+
+
+static ssize_t picocrypto_show_stats( struct device_driver *drv, char *buf )
+{
+	u32 max_irq_off = 0;
+	u32 test1 = 0;
+	u32 test2 = 0;
+	u32 test3 = 0;
+	u32 test4 = 0;
+	u32 number_of_pdu_drops = 0;
+	u32 number_of_bd_1_pre_drops = 0;
+	u32 number_of_bd_2_pre_drops = 0;
+	u32 number_of_bd_1_drops = 0;
+	u32 number_of_bd_2_drops = 0;
+	u32 number_of_dec_size_drops = 0;
+	u32 number_of_enc_size_drops = 0;
+	u32 largest_dec_dropped = 0;
+	u32 largest_enc_dropped = 0;
+	u32 number_of_pdus = 0;
+	const char* culprit = "None";
+
+	if ( pglob_sysfs_private != NULL ) {
+
+		/* get the current state of the driver */
+		max_irq_off = pglob_sysfs_private->max_irq_off_time;
+		culprit = pglob_sysfs_private->culprit;
+		test1 = pglob_sysfs_private->max_test_time_1;
+		test2 = pglob_sysfs_private->max_test_time_2;
+		test3 = pglob_sysfs_private->max_test_time_3;
+		test4 = pglob_sysfs_private->max_test_time_4;
+		number_of_pdu_drops = atomic_read( &pglob_sysfs_private->number_of_pdu_drops );
+		number_of_bd_1_pre_drops = atomic_read( &pglob_sysfs_private->number_of_bd_1_pre_drops );
+		number_of_bd_2_pre_drops = atomic_read( &pglob_sysfs_private->number_of_bd_2_pre_drops );
+		number_of_bd_1_drops = atomic_read( &pglob_sysfs_private->number_of_bd_1_drops );
+		number_of_bd_2_drops = atomic_read( &pglob_sysfs_private->number_of_bd_2_drops );
+		number_of_dec_size_drops = atomic_read( &pglob_sysfs_private->number_of_dec_size_drops );
+		number_of_enc_size_drops = atomic_read( &pglob_sysfs_private->number_of_enc_size_drops );
+		largest_dec_dropped = atomic_read( &pglob_sysfs_private->largest_dec_dropped );
+		largest_enc_dropped = atomic_read( &pglob_sysfs_private->largest_enc_dropped );
+		number_of_pdus = atomic_read( &pglob_sysfs_private->number_of_pdus );
+		
+	}
+
+	return scnprintf( buf, PAGE_SIZE, "max_irq_off=%d in %s\n"
+	                                  "total_pdus=%d pdu_drops=%d \n"
+	                                  "dec_size_drops=%d enc_size_drops=%d largest_dec_drop=%d largest_enc_drop=%d\n"
+	                                  "bd_1_pre_drops=%d bd_2_pre_drops=%d bd_1_drops=%d bd_2_drops=%d\n"
+	                                  "test1=%d test2=%d test3=%d test4=%d\n",
+	                                   max_irq_off, culprit,
+	                                   number_of_pdus, number_of_pdu_drops,
+	                                   number_of_dec_size_drops, number_of_enc_size_drops, largest_dec_dropped, largest_enc_dropped,
+	                                   number_of_bd_1_pre_drops, number_of_bd_2_pre_drops, number_of_bd_1_drops, number_of_bd_2_drops,
+	                                   test1, test2, test3, test4
+	                 );
+}
+
+
+/* sysfs global structures */
+/* TODO: Check S_IRUGO | S_IWUSR settings */
+DRIVER_ATTR( clear_aead_reqs, S_IRUGO | S_IWUSR, picocrypto_show_zero,
+	    picocrypto_clear_aead_reqs );
+
+DRIVER_ATTR( dump_sram, S_IRUGO | S_IWUSR, picocrypto_show_zero,
+	    picocrypto_dump_sram );
+
+DRIVER_ATTR( open_pico, S_IRUGO | S_IWUSR, picocrypto_show_zero,
+	    picocrypto_open_pico );
+
+DRIVER_ATTR( close_pico, S_IRUGO | S_IWUSR, picocrypto_show_zero,
+	    picocrypto_close_pico );
+
+DRIVER_ATTR( pico_status, S_IRUGO | S_IWUSR, picocrypto_pico_status,
+	    NULL );
+
+DRIVER_ATTR( show_mode, S_IRUGO | S_IWUSR, picocrypto_show_mode,
+	    NULL );
+
+DRIVER_ATTR( show_stats, S_IRUGO | S_IWUSR, picocrypto_show_stats,
+	    NULL );
+
+/*************************************************
+ * Module initialisation and deregistration code *
+ *************************************************/
+
+int picocrypto_probe(struct platform_device *pdev)
+{
+	struct private_driver_data *pdata;
+
+	DRIVER_DEBUG( KERN_INFO "Probing PicoArray...\n" );
+
+	/* allocate some zeored out memory for private data, sleep is possible */
+	pdata = kmalloc( sizeof( struct private_driver_data ), GFP_KERNEL );
+ 
+	if( pdata == NULL ) {
+		DRIVER_ERROR( KERN_ERR "Failed to allocate memory for private data\n" );
+		goto err_alloc;
+	}
+
+	/* Initialise the spin lock */
+	spin_lock_init( &pdata->driver_lock );
+
+	/* Initialise the mutex locks */
+	mutex_init( &pdata->pico_state_mutex );
+
+	pdata->completed_head = 0;
+	pdata->completed_tail = 0;
+	
+	atomic_set( &pdata->number_of_pdus, 0);
+	atomic_set( &pdata->number_of_pdu_drops, 0);
+	atomic_set( &pdata->number_of_bd_1_pre_drops, 0);
+	atomic_set( &pdata->number_of_bd_2_pre_drops, 0);
+	atomic_set( &pdata->number_of_bd_1_drops, 0);
+	atomic_set( &pdata->number_of_bd_2_drops, 0);
+	atomic_set( &pdata->number_of_dec_size_drops, 0);
+	atomic_set( &pdata->number_of_enc_size_drops, 0);
+	atomic_set( &pdata->largest_dec_dropped, 0);
+	atomic_set( &pdata->largest_enc_dropped, 0);
+
+	pdata->max_irq_off_time = 0;
+	pdata->max_test_time_1 = 0;
+	pdata->max_test_time_2 = 0;
+	pdata->max_test_time_3 = 0;
+	pdata->max_test_time_4 = 0;
+	pdata->culprit = "None";
+	
+	tasklet_init(&pdata->tasklet, picocrypto_tasklet_callback, (unsigned long)pdata);
+
+	/*
+	 * add a pointer to the private data in the platform device structure.
+	 * This allows the private data to be retrieved later.
+	 */
+	platform_set_drvdata( pdev, pdata );
+
+	/* PicoArray SRAM physical base address */
+	pdata->phys_sram_base_address = SRAM_PHYS_ADDRESS;
+	pdata->sram_size = SRAM_LENGTH;	/* PicoArray SRAM length */
+
+	/* Register the SRAM memory with the Kernel to make sure this driver has 100% control of it */
+	if ( request_mem_region( pdata->phys_sram_base_address, pdata->sram_size, DRVNAME ) == NULL ) {
+		/* failed */
+		DRIVER_ERROR( KERN_ERR "Failed to register the SRAM memory\n" );
+		goto err_alloc2;
+	}
+
+	/* Map the SRAM physical addresses to virtual addresses */
+	pdata->vert_sram_base_address = ioremap_nocache( pdata->phys_sram_base_address, pdata->sram_size );
+
+	if ( pdata->vert_sram_base_address == NULL ) {
+		/* failed */
+		DRIVER_ERROR( KERN_ERR "Failed to ioremap the SRAM memory\n" );
+		goto err_alloc3;
+	}
+
+	init_context_structure_block( pdata, SRAM_CTX_MAX_NUMBER );
+	
+	init_sram_structures( pdata );
+
+	/* Register the driver/PicoArray algorithms */
+	if ( register_driver_crypto( pdata ) != 0 ) {
+		/* failed to register the algorithms */
+		DRIVER_ERROR( KERN_ERR "Failed to register the algorithms with the Kernel\n" );
+		goto err_alloc4;
+	}
+
+	/* allocate the Software based algorithm transforms using the Kernel generic crypto */
+	if ( swcrypto_alloc_tfms() != 0 ) {
+		/* failed to allocate the SW algorithms */
+		/* Note the algorithms are unregistered by swcrypto_alloc_tfms() upon failure */
+		DRIVER_ERROR( KERN_ERR "Failed to allocate the Software based algorithms with the Kernel\n" );
+		goto err_alloc4;
+	}
+
+	/* Save the private data structure for use by the sysfs functions */
+	pglob_sysfs_private = pdata;
+
+
+	/* test code */
+#if 1
+	start_async_test( pdata );	
+#endif
+
+	return 0;
+
+/* Error handling */
+
+err_alloc4:
+	/* unregister the algorithms */
+	unregister_driver_crypto( pdata );
+
+err_alloc3:
+	/* unregister the SRAM memory */
+	release_mem_region( pdata->phys_sram_base_address, pdata->sram_size );
+
+err_alloc2:
+	tasklet_kill(&pdata->tasklet);
+		
+	/* free the private data */
+	platform_set_drvdata( pdev, NULL );
+	kfree( pdata );
+
+	/* clear the private data structure used by the sysfs functions */
+	pglob_sysfs_private = NULL;
+
+err_alloc:
+	return -ENOMEM;
+}
+
+
+int picocrypto_remove( struct platform_device *pdev )
+{
+	struct private_driver_data *pdata;
+
+	DRIVER_INFO( KERN_INFO "Removing driver...\n" );
+
+	/* release the Software based algorithm transforms */
+	swcrypto_release_tfms();
+
+	/* get access to the private data */
+	pdata = platform_get_drvdata( pdev );
+
+	/* is the private data available ? */
+	if ( pdata != NULL ) {
+
+		u8 current_state;
+		
+		/* test code */
+		stop_async_test( pdata );	
+
+		tasklet_kill(&pdata->tasklet);
+		
+		/* try closing the picoArray to stop it processing any BDs */
+		request_sram_pico_close( pdata );
+
+		/* process any remaining AEAD reqs in the BDRs to allow the driver to be removed */
+		current_state = atomic_read( &pdata->driver_transit_state );
+
+		if ( ( current_state == DRIVER_ALL_HW ) || ( current_state == DRIVER_SWITCH_TO_HW ) ) {
+			process_bdrs( pdata, 1 );
+		}
+
+		/* Unregister the algorithms from the Kernel */
+		unregister_driver_crypto( pdata );
+
+		/* umap the IOMEM space */
+		iounmap( pdata->vert_sram_base_address );
+
+		/* release the SRAM memory region */
+		release_mem_region( pdata->phys_sram_base_address, pdata->sram_size );
+
+		/* free the private data */
+		kfree( pdata );
+
+		/* clear the private data structure used by the sysfs functions */
+		pglob_sysfs_private = NULL;
+	}
+
+	return 0;
+}
+
+
+struct platform_driver picocrypto_platform = {
+	.probe = picocrypto_probe,
+	.remove = picocrypto_remove,
+	.shutdown = NULL,
+	.suspend = NULL,
+	.resume = NULL,
+	.driver = {
+		/* Must match name of platform device */
+		.name = DRVNAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+
+static int __init picocrypto_init(void)
+{
+	int err;
+
+	DRIVER_INFO( KERN_INFO "PicoCrypto initialising version %s...\n", DRVVERS );
+
+	err = platform_driver_register( &picocrypto_platform );
+
+	if( err ) {
+		DRIVER_ERROR( KERN_ERR "Failed to register the driver for %s. Check kernel platform support.\n",
+			picocrypto_platform.driver.name );
+		goto error_init;
+	}
+
+	err = driver_create_file( &picocrypto_platform.driver, &driver_attr_clear_aead_reqs );
+
+	if( err ) {
+		DRIVER_ERROR( KERN_ERR "Failed to create sysfs file clear_aead_reqs for the driver for %s.\n",
+			picocrypto_platform.driver.name );
+		goto error_aead_clear;
+	}
+
+	err = driver_create_file( &picocrypto_platform.driver, &driver_attr_dump_sram );
+
+	if( err ) {
+		DRIVER_ERROR( KERN_ERR "Failed to create sysfs file dump_sram for the driver for %s.\n",
+			picocrypto_platform.driver.name );
+		goto error_sysfs_dump;
+	}
+
+	err = driver_create_file( &picocrypto_platform.driver, &driver_attr_open_pico );
+
+	if( err ) {
+		DRIVER_ERROR( KERN_ERR "Failed to create sysfs file open_pico for the driver for %s.\n",
+			picocrypto_platform.driver.name );
+		goto error_sysfs_open_pico;
+	}
+
+	err = driver_create_file( &picocrypto_platform.driver, &driver_attr_close_pico );
+
+	if( err ) {
+		DRIVER_ERROR( KERN_ERR "Failed to create sysfs file close_pico for the driver for %s.\n",
+			picocrypto_platform.driver.name );
+		goto error_sysfs_close_pico;
+	}
+
+	err = driver_create_file( &picocrypto_platform.driver, &driver_attr_pico_status );
+
+	if( err ) {
+		DRIVER_ERROR( KERN_ERR "Failed to create sysfs file pico_status for the driver for %s.\n",
+			picocrypto_platform.driver.name );
+		goto error_sysfs_pico_status;
+	}
+
+	err = driver_create_file( &picocrypto_platform.driver, &driver_attr_show_mode );
+
+	if( err ) {
+		DRIVER_ERROR( KERN_ERR "Failed to create sysfs file show_mode for the driver for %s.\n",
+			picocrypto_platform.driver.name );
+		goto error_sysfs_show_mode;
+	}
+
+	err = driver_create_file( &picocrypto_platform.driver, &driver_attr_show_stats );
+
+	if( err ) {
+		DRIVER_ERROR( KERN_ERR "Failed to create sysfs file show_stats for the driver for %s.\n",
+			picocrypto_platform.driver.name );
+		goto error_sysfs_show_stats;
+	}
+
+	return ( err );
+
+/* error handlers */
+
+error_sysfs_show_stats:
+	driver_remove_file( &picocrypto_platform.driver, &driver_attr_show_stats );
+
+error_sysfs_show_mode:
+	driver_remove_file( &picocrypto_platform.driver, &driver_attr_show_mode );
+
+error_sysfs_pico_status:
+	driver_remove_file( &picocrypto_platform.driver, &driver_attr_pico_status );
+
+error_sysfs_close_pico:
+	driver_remove_file( &picocrypto_platform.driver, &driver_attr_close_pico );
+
+error_sysfs_open_pico:
+	driver_remove_file( &picocrypto_platform.driver, &driver_attr_open_pico );
+
+error_sysfs_dump:
+	driver_remove_file( &picocrypto_platform.driver, &driver_attr_dump_sram );
+
+error_aead_clear:
+	driver_remove_file( &picocrypto_platform.driver, &driver_attr_clear_aead_reqs );
+
+error_init:
+	platform_driver_unregister( &picocrypto_platform );
+
+	return err;
+}
+
+static void __exit picocrypto_exit(void)
+{
+	DRIVER_INFO( KERN_INFO "PicoCrypto deregistering...\n" );
+
+	driver_remove_file( &picocrypto_platform.driver, &driver_attr_show_stats );
+	driver_remove_file( &picocrypto_platform.driver, &driver_attr_show_mode );
+	driver_remove_file( &picocrypto_platform.driver, &driver_attr_pico_status );
+	driver_remove_file( &picocrypto_platform.driver, &driver_attr_close_pico );
+	driver_remove_file( &picocrypto_platform.driver, &driver_attr_open_pico );
+	driver_remove_file( &picocrypto_platform.driver, &driver_attr_dump_sram );
+	driver_remove_file( &picocrypto_platform.driver, &driver_attr_clear_aead_reqs );
+
+	platform_driver_unregister( &picocrypto_platform );
+}
+
+module_init(picocrypto_init);
+module_exit(picocrypto_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Dean Jenkins <djenkins@mvista.com>");
+MODULE_DESCRIPTION("MontaVista IPsec PicoArray Crypto driver");
diff -Naur pico_2.6.28/drivers/ipa/crypto/picosram.c ipa_2.6.28/drivers/ipa/crypto/picosram.c
--- pico_2.6.28/drivers/ipa/crypto/picosram.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/ipa/crypto/picosram.c	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,2023 @@
+/*
+ * This file contains the PicoArray Crypto SRAM driver functions to facilitate IPsec crypto.
+ *
+ * File: picosram.c
+ * Author: Dean Jenkins <djenkins@mvista.com>
+ *
+ * 2008 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+/* kernel related headers */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/rtnetlink.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+
+/* Kernel crypto related headers */
+#include <linux/crypto.h>
+#include <crypto/algapi.h>
+#include <crypto/aead.h>
+#include <crypto/authenc.h>
+#include <crypto/aes.h>
+#include <crypto/sha.h>
+
+#include <asm/io.h>
+
+#include "picocrypto.h"
+
+/******************
+ * local #defines *
+ ******************/
+
+#undef USE_MEMCPY_FOR_SRAM
+#define USE_MEMCPY_FOR_SRAM	1
+
+#undef DEBUG_PDU_MANAGEMENT
+/* #define DEBUG_PDU_MANAGEMENT	1	*/
+
+#undef DEBUG_PDU_MANAGEMENT_NO_ROOM
+/* #define DEBUG_PDU_MANAGEMENT_NO_ROOM	1 */
+
+#undef DEBUG_BDR_MANAGEMENT
+/* #define DEBUG_BDR_MANAGEMENT	1	*/
+
+#undef DEBUG_SRAM
+/* #define DEBUG_SRAM	1	*/
+
+#undef VERBOSE_SRAM
+/* #define VERBOSE_SRAM	1	*/
+
+#ifdef DEBUG_SRAM
+#define SRAM_DEBUG(fmt,args...)	printk( fmt ,##args )
+#else
+#define SRAM_DEBUG(fmt,args...)
+#endif
+
+#define SRAM_INFO(fmt,args...)	printk( fmt ,##args )
+#define SRAM_ERROR(fmt,args...)	printk( fmt ,##args )
+
+static void copy_all_context_structures( struct private_driver_data *pdata );
+
+/****************************
+ * SRAM Interface functions *
+ ****************************/
+
+/*
+ * SRAM Memory Map
+ *
+ * header block
+ * context structure block 
+ * BD ring #1
+ * BD ring #2
+ * BD ring #3
+ * BD ring #4
+ * buffer pool
+ */
+
+/*
+ * Writes 4 bytes to the SRAM on a 4 byte boundary
+ * Inputs:
+ * 	base = virtual address
+ *	offset = offset from base address
+ *	data = data to be written 
+ * Outputs:
+ *	writes information into the PicoArray SRAM
+ * Return:
+ *	void 
+ */
+inline static void sram_write_u32( u32 base, u32 offset, u32 data )
+{
+	wmb();
+	iowrite32( cpu_to_le32( data ), (base + offset) );
+}
+
+
+/*
+ * Writes 4 bytes to the SRAM on a 4 byte boundary always in SRAM little-endian
+ * Used for writing crypto data + keys to the SRAM
+ * Inputs:
+ * 	base = virtual address
+ *	offset = offset from base address
+ *	data = data to be written 
+ * Outputs:
+ *	writes information into the PicoArray SRAM
+ * Return:
+ *	void 
+ */
+inline static void sram_write_u32_le( u32 base, u32 offset, u32 data )
+{
+	wmb();
+	iowrite32( data, (base + offset) );
+}
+
+
+/*
+ * Writes 2 bytes to the SRAM on a 2 byte boundary
+ * Inputs:
+ * 	base = virtual address
+ *	offset = offset from base address
+ *	data = data to be written 
+ * Outputs:
+ *	writes information into the PicoArray SRAM
+ * Return:
+ *	void 
+ */
+inline static void sram_write_u16( u32 base, u32 offset, u16 data )
+{
+	wmb();
+	iowrite16( cpu_to_le16( data ), (base + offset) );
+}
+
+
+/*
+ * Writes a bytes to the SRAM on a byte boundary
+ * Inputs:
+ * 	base = virtual address
+ *	offset = offset from base address
+ *	data = data to be written 
+ * Outputs:
+ *	writes information into the PicoArray SRAM
+ * Return:
+ *	void 
+ */
+inline static void sram_write_u8( u32 base, u32 offset, u8 data )
+{
+	wmb();
+	iowrite8( data, (base + offset) );
+}
+
+
+/*
+ * Reads 4 bytes from the SRAM on a 4 byte boundary
+ * Inputs:
+ * 	base = virtual address
+ *	offset = offset from base address
+ * Outputs:
+ *	Reads information from the PicoArray SRAM
+ * Return:
+ *	4 byte data from the SRAM 
+ */
+inline static u32 sram_read_u32( u32 base, u32 offset )
+{
+	rmb();
+	return le32_to_cpu( ioread32( ( base + offset ) ) );
+}
+
+
+/*
+ * Reads 4 bytes from the SRAM on a 4 byte boundary always in SRAM little-endian
+ * Used for reading crypto data + keys from the SRAM
+ * Inputs:
+ * 	base = virtual address
+ *	offset = offset from base address
+ * Outputs:
+ *	Reads information from the PicoArray SRAM
+ * Return:
+ *	4 byte data from the SRAM 
+ */
+inline static u32 sram_read_u32_le( u32 base, u32 offset )
+{
+	rmb();
+	return ioread32( ( base + offset ) );
+}
+
+
+/*
+ * Reads 2 bytes from the SRAM on a 2 byte boundary
+ * Inputs:
+ * 	base = virtual address
+ *	offset = offset from base address
+ * Outputs:
+ *	Reads information from the PicoArray SRAM
+ * Return:
+ *	2 byte data from the SRAM 
+ */
+inline static u16 sram_read_u16( u32 base, u32 offset )
+{
+	rmb();
+	return le16_to_cpu( ioread16( ( base + offset ) ) );
+}
+
+
+/*
+ * Reads a byte from the SRAM on a byte boundary
+ * Inputs:
+ * 	base = virtual address
+ *	offset = offset from base address
+ * Outputs:
+ *	Reads information from the PicoArray SRAM
+ * Return:
+ *	a byte data from the SRAM 
+ */
+inline static u8 sram_read_u8( u32 base, u32 offset )
+{
+	rmb();
+	return ioread8( base + offset );
+}
+
+
+/* Debug support function */
+static void sram_hexdump( char *name, u32 buf_address, u32 len)
+{
+	u32 pos;
+	u32 data;
+
+	SRAM_INFO( KERN_INFO "%s: address 0x%08X: len %d\n", name, buf_address, len );
+
+	/* step up in 4 byte steps */
+	for ( pos = 0; pos < len; pos += 4 ) {
+		data = sram_read_u32( buf_address, pos );
+		SRAM_INFO( KERN_INFO "0x%08X: 0x%04X: 0x%08X\n", buf_address + pos, pos, data );
+	}
+
+}
+
+
+/* Debug function */
+void dump_sram_structures( struct private_driver_data *pdata )
+{
+	/* Note dump will be modified by interruptting decrypt, encrypt calls and async events */
+
+	SRAM_INFO( KERN_INFO "Dumping the SRAM structures\n" );
+
+	sram_hexdump( "Header", pdata->header_address, SRAM_HEADER_SIZE );
+
+	sram_hexdump( "Context", pdata->context_info.context_base_address,
+		SRAM_CTX_SIZE * SRAM_CTX_MAX_NUMBER );
+
+	sram_hexdump( "Context shadow", (u32) &pdata->context_info.shadow[ 0 ],
+		sizeof(pdata->context_info.shadow) );
+
+	sram_hexdump( "Ring 1 info", (u32) &pdata->bdr_info[ 0 ], sizeof( pdata->bdr_info[ 0 ] ) );
+	sram_hexdump( "Ring 1", pdata->bdr_info[ 0 ].bdr_base_address, SRAM_BD_SIZE * SRAM_BD_RING1_NUMBER );
+	sram_hexdump( "Ring 2 info", (u32) &pdata->bdr_info[ 1 ], sizeof( pdata->bdr_info[ 1 ] ) );
+	sram_hexdump( "Ring 2", pdata->bdr_info[ 1 ].bdr_base_address, SRAM_BD_SIZE * SRAM_BD_RING2_NUMBER );
+	sram_hexdump( "Ring 3 info", (u32) &pdata->bdr_info[ 2 ], sizeof( pdata->bdr_info[ 2 ] ) );
+	sram_hexdump( "Ring 3", pdata->bdr_info[ 2 ].bdr_base_address, SRAM_BD_SIZE * SRAM_BD_RING3_NUMBER );
+	sram_hexdump( "Ring 4 info", (u32) &pdata->bdr_info[ 3 ], sizeof( pdata->bdr_info[ 3 ] ) );
+	sram_hexdump( "Ring 4", pdata->bdr_info[ 3 ].bdr_base_address, SRAM_BD_SIZE * SRAM_BD_RING4_NUMBER );
+
+	sram_hexdump( "PDU pool info", (u32) &pdata->pdu_info, sizeof( pdata->pdu_info ) );
+	sram_hexdump( "PDU pool data", pdata->pdu_info.pdu_pool_base_address, pdata->pdu_info.pdu_pool_size );
+
+}
+
+
+/* Debug function */
+char *sram_confirmed_state_text( u32 cnf_state )
+{
+	char *ptext = NULL;
+
+	switch ( cnf_state ) {
+	case HEADER_CNF_STATE_READY:
+		ptext = "READY";
+		break;
+
+	case HEADER_CNF_STATE_CLOSED:
+		ptext = "CLOSED";
+		break;
+
+	case HEADER_CNF_STATE_OPENED:
+		ptext = "OPENED";
+		break;
+
+	default:
+		ptext = "INVALID";
+		break;
+	}
+
+	return ( ptext );
+}
+
+
+
+/*
+ * Perform the CLOSE procedure
+ * Inputs:
+ * 	pdata = pointer to private data structure (not NULL)
+ * Outputs:
+ *	writes information into the PicoArray SRAM Request State
+ *	and reads the Confirmed State
+ * Return:
+ *	0 for success or 1 for failure or 2 for already in correct state (READY or CLOSED).
+ */
+u8 request_sram_pico_close( struct private_driver_data *pdata )
+{
+	u32 cnf_state;
+	u8 error = 0;
+
+	/* grab the mutex to prevent clash */
+	mutex_lock( &pdata->pico_state_mutex );
+
+	SRAM_DEBUG( KERN_INFO "Pending CLOSE_REQ\n");
+
+	/* read the current PicoArray Confirmed State */
+	cnf_state = sram_read_u32( pdata->header_address, SRAM_HEADER_CNF_STATE_OFFSET );
+	SRAM_DEBUG( KERN_INFO "PicoArray Confirmed State was %08X: %s\n",
+		cnf_state, sram_confirmed_state_text( cnf_state ) );
+
+	switch ( cnf_state ) {
+	case HEADER_CNF_STATE_READY:
+	case HEADER_CNF_STATE_CLOSED:
+		/* do nothing */
+		error = 2;
+		break;
+
+	case HEADER_CNF_STATE_OPENED:
+		/* the picoArray is in the OPENED state so */
+		/* request the PicoArray enters the closed state */
+		sram_write_u32( pdata->header_address, SRAM_HEADER_REQ_STATE_OFFSET, HEADER_REQ_STATE_CLOSE_REQ );
+
+		/* wait a while to time-out the CLOSED confirmation */
+		msleep( CNF_STATE_TIMEOUT );
+ 
+		/* now read the new Confirmed State */
+		cnf_state = sram_read_u32( pdata->header_address, SRAM_HEADER_CNF_STATE_OFFSET );
+		SRAM_DEBUG( KERN_INFO "PicoArray new Confirmed State is %08X: %s\n",
+			cnf_state, sram_confirmed_state_text( cnf_state ) );
+
+		if ( cnf_state == HEADER_CNF_STATE_CLOSED ) {
+			SRAM_DEBUG( KERN_INFO "CLOSED confirmed\n");
+		} else {
+			SRAM_ERROR( KERN_ERR "ERROR: Failed to put the PicoArray into the CLOSED state: state is %08X: %s\n",
+				cnf_state, sram_confirmed_state_text( cnf_state ) );
+#ifndef PICO_FIRMWARE_NOT_AVAILABLE
+			error = 1;
+#endif
+		}
+
+		break;
+
+	default:
+		SRAM_ERROR( KERN_ERR "ERROR: PicoArray Confirmed State is invalid: %08X: %s\n",
+			cnf_state, sram_confirmed_state_text( cnf_state ) );
+#ifndef PICO_FIRMWARE_NOT_AVAILABLE
+		error = 1;
+#endif
+		break;
+	}
+
+	/*
+	 * write NO_REQ to the Request State so that the PicoArray will see the next request
+	 */
+	sram_write_u32( pdata->header_address, SRAM_HEADER_REQ_STATE_OFFSET, HEADER_REQ_STATE_NO_REQ );
+
+	/* wait a while to allow the picoArray to see it */
+	msleep( CNF_STATE_TIMEOUT );
+
+	SRAM_DEBUG( KERN_INFO "Completed CLOSE_REQ\n");
+
+	mutex_unlock( &pdata->pico_state_mutex );
+
+	return ( error );
+}
+
+
+/*
+ * Perform the OPEN procedure
+ * Inputs:
+ * 	pdata = pointer to private data structure (not NULL)
+ * Outputs:
+ *	writes information into the PicoArray SRAM Request State
+ *	and reads the Confirmed State
+ * Return:
+ *	0 for success or 1 for failure or 2 for already in the OPENED state.
+ */
+u8 request_sram_pico_open( struct private_driver_data *pdata )
+{
+	u32 cnf_state;
+	u8 error = 0;
+	u32 version;
+
+	/* grab the mutex to prevent clash */
+	mutex_lock( &pdata->pico_state_mutex );
+
+	SRAM_DEBUG( KERN_INFO "Pending OPEN_REQ\n");
+
+	copy_all_context_structures( pdata );
+	
+	/* read the current PicoArray Confirmed State */
+	cnf_state = sram_read_u32( pdata->header_address, SRAM_HEADER_CNF_STATE_OFFSET );
+	SRAM_DEBUG( KERN_INFO "PicoArray Confirmed State was %08X: %s\n",
+		cnf_state, sram_confirmed_state_text( cnf_state ) );
+
+	switch ( cnf_state ) {
+	case HEADER_CNF_STATE_READY:
+	case HEADER_CNF_STATE_CLOSED:
+		/* if in the READY or CLOSED confirmed states then */
+		/* request the PicoArray enters the open state */
+		sram_write_u32( pdata->header_address, SRAM_HEADER_REQ_STATE_OFFSET, HEADER_REQ_STATE_OPEN_REQ );
+
+		/* wait a while to time-out the OPENED confirmation */
+		msleep( CNF_STATE_TIMEOUT );
+ 
+		/* now read the new Confirmed State */
+		cnf_state = sram_read_u32( pdata->header_address, SRAM_HEADER_CNF_STATE_OFFSET );
+		SRAM_DEBUG( KERN_INFO "PicoArray new Confirmed State is %08X: %s\n",
+			cnf_state, sram_confirmed_state_text( cnf_state ) );
+
+		if ( cnf_state == HEADER_CNF_STATE_OPENED ) {
+			SRAM_DEBUG( KERN_INFO "OPENED confirmed\n");
+		} else {
+			SRAM_ERROR( KERN_ERR "ERROR: Failed to put the PicoArray into the OPENED state: state is %08X: %s\n",
+				cnf_state, sram_confirmed_state_text( cnf_state ) );
+#ifndef PICO_FIRMWARE_NOT_AVAILABLE
+			error = 1;
+#endif
+		}
+
+		break;
+
+	case HEADER_CNF_STATE_OPENED:
+		/* do nothing */
+		error = 2;
+		break;
+
+	default:
+		SRAM_ERROR( KERN_ERR "ERROR: PicoArray Confirmed State is invalid: %08X: %s\n",
+			cnf_state, sram_confirmed_state_text( cnf_state ) );
+#ifndef PICO_FIRMWARE_NOT_AVAILABLE
+		error = 1;
+#endif
+		break;
+	}
+
+	if ( ( error == 0 ) || ( error == 2 ) ) {
+		/* read the PicoArray firmware version */
+		version = sram_read_u32( pdata->header_address, SRAM_HEADER_VERSION_OFFSET );
+		SRAM_DEBUG( KERN_INFO "PicoArray version is %08X\n", version );
+	}
+
+	/*
+	 * write NO_REQ to the Request State so that the PicoArray will see the next request
+	 */
+	sram_write_u32( pdata->header_address, SRAM_HEADER_REQ_STATE_OFFSET, HEADER_REQ_STATE_NO_REQ );
+
+	/* wait a while to allow the picoArray to see it */
+	msleep( CNF_STATE_TIMEOUT );
+
+	SRAM_DEBUG( KERN_INFO "Completed OPEN_REQ\n");
+
+	mutex_unlock( &pdata->pico_state_mutex );
+
+	return ( error );
+}
+
+
+/*
+ * Read the Confirmed State
+ * Inputs:
+ * 	pdata = pointer to private data structure (not NULL)
+ * Outputs:
+ *	reads the Confirmed State
+ * Return:
+ *	the Confirmed State.
+ */
+u32 read_sram_confirmed_state( struct private_driver_data *pdata )
+{
+	u32 cnf_state;
+
+	/* grab the mutex to prevent clash */
+	mutex_lock( &pdata->pico_state_mutex );
+
+	/* read the current PicoArray Confirmed State */
+	cnf_state = sram_read_u32( pdata->header_address, SRAM_HEADER_CNF_STATE_OFFSET );
+	SRAM_DEBUG( KERN_INFO "PicoArray Confirmed State was %08X: %s\n",
+		cnf_state, sram_confirmed_state_text( cnf_state ) );
+
+	mutex_unlock( &pdata->pico_state_mutex );
+
+	return ( cnf_state );
+}
+
+
+/*
+ * Check whether the picoArray has been programmed with the IPsec image
+ * This is far from infallible at the moment.
+ * Inputs:
+ * 	pdata = pointer to private data structure (not NULL)
+ * Outputs:
+ *	reads the Confirmed State
+ * Return:
+ *	the Confirmed State.
+ */
+u8 read_pico_active_state( struct private_driver_data *pdata )
+{
+	u32 picoState = 0;
+	u8  picoActive = 0;
+
+	picoState = read_sram_confirmed_state( pdata );
+	
+	switch ( picoState ) {
+	case HEADER_CNF_STATE_READY:
+	case HEADER_CNF_STATE_CLOSED:
+	case HEADER_CNF_STATE_OPENED:
+		picoActive = 1;
+		break;
+
+	default:
+		picoActive = 0;
+		break;
+	}
+	
+	return picoActive;
+}
+
+/*
+ * Initialises the SRAM header but ignores the picoArray state
+ * Inputs:
+ * 	pdata = pointer to private data structure (not NULL)
+ * Outputs:
+ *	writes information into the PicoArray SRAM
+ * Return:
+ *	void 
+ */
+static void init_sram_header( struct private_driver_data *pdata )
+{
+	/* set the BD ring #1 pointer, relative to start of the SRAM */
+	sram_write_u32( pdata->header_address, SRAM_HEADER_BDR_PTR1_OFFSET,
+		 pdata->bdr_info[ 0 ].bdr_base_address - pdata->header_address );
+
+	/* set the BD ring #2 pointer, relative to start of the SRAM */
+	sram_write_u32( pdata->header_address, SRAM_HEADER_BDR_PTR2_OFFSET,
+		 pdata->bdr_info[ 1 ].bdr_base_address - pdata->header_address );
+
+	/* set the BD ring #3 pointer, relative to start of the SRAM */
+	sram_write_u32( pdata->header_address, SRAM_HEADER_BDR_PTR3_OFFSET,
+		 pdata->bdr_info[ 2 ].bdr_base_address - pdata->header_address );
+
+	/* set the BD ring #4 pointer, relative to start of the SRAM */
+	sram_write_u32( pdata->header_address, SRAM_HEADER_BDR_PTR4_OFFSET,
+		 pdata->bdr_info[ 3 ].bdr_base_address - pdata->header_address );
+}
+
+
+/*
+ * Initialises the specified Buffer Descriptor ring
+ * Inputs:
+ *	pbdr_info = pointer to bdr mananagement information
+ *	number_bds = number of bds in the ring
+ * Outputs:
+ *	writes information into the PicoArray SRAM buffer descriptor ring
+ * Return:
+ *	void 
+ */
+static void init_buffer_descriptor_ring( struct bdr_management *pbdr_info, u8 number_bds )
+{
+	u32 pos;
+	u32 ring_base = pbdr_info->bdr_base_address;
+
+	/* Initialise the spin lock */
+	spin_lock_init( &pbdr_info->bdr_lock );
+
+	/* save the total number of bds for the ring */
+	pbdr_info->total_num_bds = number_bds;
+
+	/* indicate no bds are in use */
+	pbdr_info->num_bds_in_use = 0;
+
+	/* start allocating from the first bd in the ring */
+	pbdr_info->last_free_bd = ring_base;
+
+	/* current bd in the ring to be processed */
+	pbdr_info->current_bd_processed = ring_base;
+
+
+	/* zero out the buffer ring */
+	/* increment in 4 byte steps */
+	for ( pos = 0; pos < ( SRAM_BD_SIZE * number_bds ); pos += 4 ) {
+		/* Initialise the memory to zero */  
+		sram_write_u32( ring_base, pos, 0 );
+	}
+
+	if ( number_bds >= 1 ) {
+		/* on the last BD, set the wrap bit */
+		sram_write_u32( ring_base,
+			( SRAM_BD_SIZE * ( number_bds - 1 ) ) + SRAM_BD_CONTROL_FLAGS_OFFSET,
+			BD_WRAP_BIT );
+	}
+}
+
+
+/*
+ * Allocate a buffer descriptor from a BD ring. 
+ * Allocation will be in buffer order.
+ * Inputs:
+ *	pbdr_info = pointer to bdr mananagement information
+ *	pwrap_bit_flag = pointer to bd wrap bit flag
+ * Outputs:
+ *	allocates a buffer descriptor from a BD ring and indicates the wrap bit
+ * Return:
+ *	address of allocated BD or 0 if error occurred
+ */
+u32 alloc_sram_buffer_descriptor( struct bdr_management *pbdr_info, u16 *pwrap_bit_flag )
+{
+	u32 allocated_bd;
+
+	/* get the number of bds */
+	u8 number_bds = pbdr_info->total_num_bds;
+
+	/* get the base address of the ring buffer */
+	u32 ring_base = pbdr_info->bdr_base_address;
+
+#if ( SRAM_LOCKING == LOCK_SPINLOCK_IRQ ) 
+	/* protect critical code from async event */
+	spin_lock_irqsave( &pbdr_info->bdr_lock, pbdr_info->bdr_flags );
+#endif
+
+	/* are any bds free ? */
+	if ( pbdr_info->num_bds_in_use < number_bds ) {
+		/* there is a free bd so use it */
+		pbdr_info->num_bds_in_use++;
+
+#ifdef DEBUG_BDR_MANAGEMENT
+		SRAM_INFO( KERN_INFO "Alloc: BDs in use: %02d\n", pbdr_info->num_bds_in_use );
+#endif
+
+		/* allocate to last free bd */
+		allocated_bd = pbdr_info->last_free_bd;
+
+		/* identify next "free bd" */
+		/* if all bds are in use then the last free bd is actually currently in use */
+
+		/* move to the next free bd */
+		pbdr_info->last_free_bd += SRAM_BD_SIZE;
+
+		if ( pbdr_info->last_free_bd >= ( ring_base + ( SRAM_BD_SIZE * number_bds ) ) ) {
+			/* reached end of the ring so wrap around */
+			pbdr_info->last_free_bd = ring_base;
+
+			/* indicate wrap */
+			*pwrap_bit_flag = BD_WRAP_BIT;
+
+		} else {
+			/* no wrap */
+			*pwrap_bit_flag = 0;
+		}
+
+	} else {
+		/* failed to allocate a buffer descriptor */
+		allocated_bd = 0;
+
+		/* no wrap */
+		*pwrap_bit_flag = 0;
+	}
+
+#if ( SRAM_LOCKING == LOCK_SPINLOCK_IRQ ) 
+	spin_unlock_irqrestore( &pbdr_info->bdr_lock, pbdr_info->bdr_flags );
+#endif
+
+	return ( allocated_bd );
+}
+
+
+/*
+ * Free the current processed buffer descriptor from a BD ring.
+ * FREES MUST BE IN THE SAME SEQUENCE ORDER AS THE ALLOCATION eg. in buffer order. 
+ * Inputs:
+ *	pbdr_info = pointer to bdr mananagement information
+ * Outputs:
+ *	free the current proceessed buffer descriptor from a BD ring
+ * Return:
+ *	Address of the next db to process or 0 if no active db
+ */
+u32 finished_sram_buffer_descriptor( struct bdr_management *pbdr_info )
+{
+	u32 current_bd;
+
+	/* get the base address of the ring buffer */
+	u32 ring_base = pbdr_info->bdr_base_address;
+
+#if ( SRAM_LOCKING == LOCK_SPINLOCK_IRQ ) 
+	/* protect critical code from async event */
+	spin_lock_irqsave( &pbdr_info->bdr_lock, pbdr_info->bdr_flags );
+#endif
+
+	/* are there any allocated bds ? */
+	if ( pbdr_info->num_bds_in_use >= 1 ) {
+		/* free up the bd */
+		pbdr_info->num_bds_in_use--;
+
+#ifdef DEBUG_BDR_MANAGEMENT
+		SRAM_INFO( KERN_INFO "Finished: BDs in use: %02d\n", pbdr_info->num_bds_in_use );
+#endif
+
+		/* Mark the current BD as now free */
+		mark_bd_sram_free( pbdr_info->current_bd_processed );
+
+		/* free is achieved by moving to the next db to be processed */
+		pbdr_info->current_bd_processed += SRAM_BD_SIZE;
+
+		if ( pbdr_info->current_bd_processed >=
+			( ring_base + ( SRAM_BD_SIZE * pbdr_info->total_num_bds ) ) ) {
+			/* reached end of the ring so wrap around */
+			pbdr_info->current_bd_processed = ring_base;
+		}
+	}
+
+	/* are there any more allocated bds ? */
+	if ( pbdr_info->num_bds_in_use >= 1 ) {
+		/* report back the current bd */
+		current_bd = pbdr_info->current_bd_processed;
+
+	} else {
+		/* no active db */
+		current_bd = 0;
+	}
+
+#if ( SRAM_LOCKING == LOCK_SPINLOCK_IRQ ) 
+	spin_unlock_irqrestore( &pbdr_info->bdr_lock, pbdr_info->bdr_flags );
+#endif
+
+	return ( current_bd );
+}
+
+
+/*
+ * Get the current processed buffer descriptor from a BD ring.
+ * Inputs:
+ *	pbdr_info = pointer to bdr mananagement information
+ * Outputs:
+ *	gets the current proceessed buffer descriptor from a BD ring
+ * Return:
+ *	Address of the current db to process or 0 if no active bd 
+ */
+u32 get_current_sram_buffer_descriptor( struct bdr_management *pbdr_info )
+{
+	u32 current_bd;
+
+#if ( SRAM_LOCKING == LOCK_SPINLOCK_IRQ ) 
+	/* protect critical code from async event */
+	spin_lock_irqsave( &pbdr_info->bdr_lock, pbdr_info->bdr_flags );
+#endif
+
+	/* are there any allocated bds ? */
+	if ( pbdr_info->num_bds_in_use >= 1 ) {
+		/* report back the current bd */
+		current_bd = pbdr_info->current_bd_processed;
+
+	} else {
+		/* no active db */
+		current_bd = 0;
+	}
+
+#if ( SRAM_LOCKING == LOCK_SPINLOCK_IRQ ) 
+	spin_unlock_irqrestore( &pbdr_info->bdr_lock, pbdr_info->bdr_flags );
+#endif
+
+	return ( current_bd );
+}
+
+
+/*
+ * Mark the bd as free in a buffer descriptor.
+ * Inputs:
+ *	allocated_bd = address of the buffer descriptor.
+ * Outputs:
+ *	Marks the bd as free in the control flags and clears the error flags.
+ *	Also makes sure to keep the wrap flag 
+ * Return:
+ *	None.
+ */
+void mark_bd_sram_free( u32 allocated_bd )
+{
+	u16 control_err_flags;
+
+	/* read the control and error flags */
+	control_err_flags = sram_read_u16( allocated_bd, SRAM_BD_CONTROL_FLAGS_OFFSET );
+
+#ifdef DEBUG_BDR_MANAGEMENT
+	SRAM_INFO( KERN_INFO "Freeing BD: BEFORE control_err_flags %02X\n", control_err_flags );
+#endif
+
+	/* clear status and error flags eg. mark it free, make sure not to lose the wrap bit */
+	control_err_flags &= ~BD_STATUS_MASK & 0x00FF;
+	control_err_flags |= BD_STATUS_FREE;
+
+#ifdef DEBUG_BDR_MANAGEMENT
+	SRAM_INFO( KERN_INFO "Freeing BD: AFTER control_err_flags %02X\n", control_err_flags );
+#endif
+
+	/* write the control and error flags back */
+	sram_write_u16( allocated_bd, SRAM_BD_CONTROL_FLAGS_OFFSET, control_err_flags );
+}
+
+
+/*
+ * Mark the bd as ready in a buffer descriptor.
+ * Inputs:
+ *	allocated_bd = address of the buffer descriptor.
+ *	wrap_bit_flag = value of the WRAP_BIT
+ * Outputs:
+ *	Marks the bd as ready in the control flags and clears the error flags.
+ *	Also makes sure to keep the wrap flag 
+ * Return:
+ *	None.
+ */
+void mark_bd_sram_ready( u32 allocated_bd, u16 wrap_bit_flag )
+{
+	u16 control_err_flags;
+
+	/* clear status flags and mark it ready and clear error flags, make sure not to lose the wrap bit */
+	control_err_flags = wrap_bit_flag | BD_STATUS_READY;
+
+	/* write the control and error flags together */
+	sram_write_u16( allocated_bd, SRAM_BD_CONTROL_FLAGS_OFFSET, control_err_flags );
+}
+
+
+/*
+ * Get the bd status from a buffer descriptor.
+ * Inputs:
+ *	allocated_bd = address of the buffer descriptor.
+ * Outputs:
+ *	Reads the control and error flags to generate a status.
+ * Return:
+ *	status as enum bd_status.
+ */
+enum bd_status get_bd_sram_status( u32 allocated_bd )
+{
+	enum bd_status status = BD_NO_PROCESSED_DATA;
+	u16 control_err_flags;
+	u8 control_flags;
+	u8 error_flags;
+
+	/* read the control and error flags */
+	control_err_flags = sram_read_u16( allocated_bd, SRAM_BD_CONTROL_FLAGS_OFFSET );
+
+	/* get status flags */
+	control_flags = control_err_flags & BD_STATUS_MASK;
+
+	if ( control_flags == BD_STATUS_PROCESSED ) {
+		/* PicoArray has processed the BD */
+
+		/* get the error flags */
+		error_flags = ( control_err_flags >> 8 );
+
+		if ( error_flags == 0 ) {
+			/* all is good */
+			status = BD_DATA_PROCESSED;
+
+		} else {
+			SRAM_ERROR( KERN_ERR "ERROR: PicoArray reported an error: 0x%02X at 0x%08X\n",
+ 					error_flags, allocated_bd );
+
+			/* else an error occured */
+			status = BD_ERROR_OCCURRED;
+		}
+	} else if ( control_flags != BD_STATUS_FREE ) {
+			/* indicate data is pending processing */
+			status = BD_DATA_PENDING;
+	}
+
+	return ( status );
+}
+
+
+/*
+ * Insert the enc_dec_len into a buffer descriptor.
+ * Inputs:
+ *	allocated_bd = address of the buffer descriptor.
+ *	enc_dec_len = length of the encryption/decryption data in bytes
+ * Outputs:
+ *	Insert the enc_dec_len into a buffer descriptor.
+ * Return:
+ *	None.
+ */
+void insert_bd_sram_enc_dec_len( u32 allocated_bd, u32 enc_dec_len )
+{
+	/* write the enc_dec_len to the bd and convert to number of bits */
+	sram_write_u16( allocated_bd, SRAM_BD_ENC_DEC_LENGTH_OFFSET, (u16) ( enc_dec_len * 8 ) );
+}
+
+
+/*
+ * Insert the context structure address into a buffer descriptor.
+ * Inputs:
+ *	allocated_bd = address of the buffer descriptor.
+ *	context_address = address of the context structure relative to the start of sram
+ * Outputs:
+ *	Insert the context structure address into a buffer descriptor.
+ * Return:
+ *	None.
+ */
+void insert_bd_sram_context_address( u32 allocated_bd, u16 context_address )
+{
+	/* write the context structure address to the bd */
+	sram_write_u16( allocated_bd, SRAM_BD_CTX_PTR_OFFSET, context_address );
+}
+
+
+/*
+ * Insert the PDU address into a buffer descriptor.
+ * Inputs:
+ *	allocated_bd = address of the buffer descriptor.
+ *	pdu_address = address of the pdu relative to the start of sram
+ * Outputs:
+ *	Insert the PDU address into a buffer descriptor.
+ * Return:
+ *	None.
+ */
+void insert_bd_sram_pdu_address( u32 allocated_bd, u16 pdu_address )
+{
+	/* write the PDU address to the bd */
+	sram_write_u16( allocated_bd, SRAM_BD_PDU_PTR_OFFSET, pdu_address );
+}
+
+
+/*
+ * TODO: IMPLEMENT LOCKING
+ * Get the absolute PDU address from a buffer descriptor.
+ * Inputs:
+ *	allocated_bd = address of the buffer descriptor.
+ * Outputs:
+ *	Reads the PDU address from a buffer descriptor.
+ *	Checks that the PDU is in use
+ *	Converts the PDU address to absolute
+ * Return:
+ *	PDU absolute address or 0 for PDU not in use error
+ */
+u32 get_bd_sram_pdu_address( struct private_driver_data *pdata, u32 allocated_bd )
+{
+	u32 pdu_address; 
+	u32 pdu_state;
+
+	/* convert relative address to virtual absolute address */
+	pdu_address = sram_read_u16( allocated_bd, SRAM_BD_PDU_PTR_OFFSET ) + pdata->header_address;
+
+	/* check that the PDU is in use */
+	pdu_state = sram_read_u32( pdu_address - SRAM_PDU_HEADER_SIZE, SRAM_PDU_HDR_STATE_OFFSET );
+
+	if ( ( pdu_state & PDU_HDR_STATE_MASK ) != PDU_HDR_STATE_IN_USE ) {
+		SRAM_ERROR( KERN_ERR "ERROR: BD 0x%08X contains a PDU address that is not in use: 0x%08X\n",
+			allocated_bd, pdu_address - SRAM_PDU_HEADER_SIZE );
+
+		pdu_address = 0;	/* indicate error */
+	}
+
+	return ( pdu_address );
+}
+
+
+/*
+ * Insert the AEAD Request pointer into a buffer descriptor.
+ * Inputs:
+ *	allocated_bd = address of the buffer descriptor.
+ *	req = pointer to AEAD request structure.
+ * Outputs:
+ *	Insert the AEAD Request pointer into a buffer descriptor.
+ * Return:
+ *	None.
+ */
+void insert_bd_sram_aead_request( u32 allocated_bd, struct aead_request *req )
+{
+	/* write the AEAD Request pointer to the bd */
+	sram_write_u32( allocated_bd, SRAM_BD_AEAD_REQ_PTR_OFFSET, (u32) req );
+}
+
+
+/*
+ * Get the AEAD Request pointer from a buffer descriptor.
+ * Inputs:
+ *	allocated_bd = address of the buffer descriptor.
+ * Outputs:
+ *	Gets the AEAD Request pointer from a buffer descriptor.
+ * Return:
+ *	AEAD Request pointer.
+ */
+struct aead_request *get_bd_sram_aead_request( u32 allocated_bd )
+{
+	/* reads the AEAD Request pointer from the bd */
+	return ( (struct aead_request *) sram_read_u32( allocated_bd, SRAM_BD_AEAD_REQ_PTR_OFFSET ) );
+}
+
+
+/*
+ * Initialises the shadow block of context structures.  The SRAM copy is not initialised
+ * here, since the picoArray may not be active yet.  This will be called once at driver
+ * startup.
+ * Inputs:
+ * 	pdata = pointer to private data structure (not NULL)
+ *	number_contexts = number of contexts in the block of context structures
+ * Outputs:
+ *	writes information into the PicoArray SRAM context structure block
+ * Return:
+ *	void 
+ */
+void init_context_structure_block( struct private_driver_data *pdata, u8 number_contexts )
+{
+	u32 ctx;
+
+	/* save the number of context structures within the block */
+	pdata->context_info.total_num_ctxs = number_contexts;
+
+	/* Initialise the working variables */
+	pdata->context_info.last_free_ctx = 0;
+	pdata->context_info.num_ctx_in_use = 0;
+
+	/* Initialise the memory to zero */  
+	memset( pdata->context_info.shadow, 0, sizeof(pdata->context_info.shadow) );
+
+	/* set the status to free on each context */
+	/* increment in context steps */
+	for ( ctx = 0; ctx < number_contexts; ctx++ ) {
+		/* Initialise the status to free */  
+		pdata->context_info.shadow[ctx].state = CTX_FREE;
+	}
+}
+
+
+/*
+ * Copies a single context from the driver's shadow copy to SRAM
+ * Inputs:
+ * 	pdata = pointer to private data structure (not NULL)
+ *	ctx   = index of the context to copy from driver memory to SRAM
+ * Outputs:
+ *	writes information into the PicoArray SRAM context structure block
+ * Return:
+ *	void 
+ */
+static void copy_context_structure( struct private_driver_data *pdata, int ctx )
+{
+	u32 pos;
+	u32 *shadow_p = (u32*)&pdata->context_info.shadow[ctx];
+
+	u8 current_state = atomic_read( &pdata->driver_transit_state );
+	
+	SRAM_DEBUG( KERN_INFO "copy_context_structure: %d %d\n", current_state, ctx );
+
+	/* Only copy to SRAM if the picoArray is active */
+	if ( ( current_state == DRIVER_ALL_HW ) || ( current_state == DRIVER_SWITCH_TO_HW ) ) {
+	
+		/* get the base address of the particular context structure to be written to */
+		u32 context_base = pdata->context_info.context_base_address + ctx*SRAM_CTX_SIZE;
+	
+		SRAM_DEBUG( KERN_INFO "copy_context_structure: from %p to 0x%08X\n", shadow_p, context_base );
+		
+		/* Copy from shadow context to active context */
+		for ( pos = 0; pos < SRAM_CTX_SIZE; pos += 4 ) {
+			sram_write_u32( context_base, pos, *shadow_p );
+			shadow_p++;
+		}
+	}
+}
+
+
+/*
+ * Copies all the context structures from driver's shadow copy to SRAM
+ * Inputs:
+ * 	pdata = pointer to private data structure (not NULL)
+ * Outputs:
+ *	writes information into the PicoArray SRAM context structure block
+ * Return:
+ *	void 
+ */
+static void copy_all_context_structures( struct private_driver_data *pdata )
+{
+	u32 pos;
+	u32 *shadow_p = (u32*)pdata->context_info.shadow;
+
+	/* get the base address of the block of context structures */
+	u32 context_base = pdata->context_info.context_base_address;
+	u32 number_contexts = pdata->context_info.total_num_ctxs;
+
+	SRAM_DEBUG( KERN_INFO "copy_all_context_structures: from %p to 0x%08X\n", shadow_p, context_base );
+	
+	for ( pos = 0; pos < (SRAM_CTX_SIZE * number_contexts); pos += 4 ) {
+		sram_write_u32( context_base, pos, *shadow_p );
+		shadow_p++;
+	}
+}
+
+
+/*
+ * Allocate a context structure, uses the context status flag 
+ * Inputs:
+ * 	pdata = pointer to private data structure (not NULL)
+ * Outputs:
+ *	allocates a context structure from the PicoArray SRAM context structure block
+ * Return:
+ *	address of allocated context structure or 0 if error occurred
+ */
+u32 alloc_sram_context_structure( struct private_driver_data *pdata )
+{
+	u32 allocated_ctx;
+	u32 data;
+
+	/* get the number of contexts */
+	u8 number_contexts = pdata->context_info.total_num_ctxs;
+
+	/* get the base address of the block of context structures */
+	u32 context_base = pdata->context_info.context_base_address;
+
+	/* are any contexts free ?   We look in the shadow copy. */
+	if ( pdata->context_info.num_ctx_in_use < number_contexts ) {
+		/* there is a free context so use it */
+		pdata->context_info.num_ctx_in_use++;
+
+		/* allocate to last free context.  This is the address where the active copy will be
+		 * and is returned to the caller to allow it to link the BD to the context in SRAM.
+		 */
+		allocated_ctx = context_base + (pdata->context_info.last_free_ctx * SRAM_CTX_SIZE);
+
+		/* mark the shadow context as used */
+		pdata->context_info.shadow[pdata->context_info.last_free_ctx].state = CTX_IN_USE;
+
+		/* identify a new free context in the shadow area */
+		if ( pdata->context_info.num_ctx_in_use < number_contexts ) {
+
+			do {
+				/* move to the next context structure */
+				pdata->context_info.last_free_ctx++;
+
+				if ( pdata->context_info.last_free_ctx >= number_contexts ) {
+					/* reached end of block so wrap around */
+					pdata->context_info.last_free_ctx = 0;
+				}
+
+				/* read the context status */
+				data = pdata->context_info.shadow[pdata->context_info.last_free_ctx].state;
+
+			} while ( data != CTX_FREE );
+
+		} else {
+			/* none available */
+			pdata->context_info.last_free_ctx = -1;
+		}
+	} else {
+		/* failed to allocate a context structure */
+		allocated_ctx = 0;
+	}
+
+	return ( allocated_ctx );
+}
+
+
+/*
+ * Map from a context address in the SRAM to a context index.  The driver uses
+ * the former for linking from BDs to contexts, but we need the latter for
+ * easy access to contexts in the shadow area.
+ * Inputs:
+ * 	pdata         = pointer to private data structure (not NULL)
+ *	allocated_ctx = address of context that is to be accessed
+ * Outputs:
+ * Return:
+ *	Index of the context or -1 if an error occurred
+ */
+int map_context_structure_to_index( struct private_driver_data *pdata, u32 allocated_ctx )
+{
+	u32  context_base    = pdata->context_info.context_base_address;
+	u8   number_contexts = pdata->context_info.total_num_ctxs;
+	int  ctx             = -1;
+
+	if ( ( allocated_ctx >= context_base ) && ( allocated_ctx < ( context_base + number_contexts*SRAM_CTX_SIZE) ) ) {
+		ctx = (allocated_ctx - context_base) / SRAM_CTX_SIZE;
+	}
+	
+	return ctx;
+}
+
+/*
+ * Free a context structure, uses the context status flag.
+ * Frees can be in any order.
+ * Inputs:
+ * 	pdata = pointer to private data structure (not NULL)
+ *	allocated_ctx = address of context that is to be freed
+ * Outputs:
+ *	frees a context structure from the PicoArray SRAM context structure block
+ * Return:
+ *	0 for success or 1 if an error occurred
+ */
+u32 free_sram_context_structure( struct private_driver_data *pdata, u32 allocated_ctx )
+{
+	u32 error = 0;
+	u32 data;
+	int ctx = map_context_structure_to_index( pdata, allocated_ctx );
+
+	if ( ctx >= 0 ) {
+		/* check that the context is in use */
+		data = pdata->context_info.shadow[ctx].state;
+	
+		if ( data == CTX_IN_USE ) {
+			/* context address is valid */
+	
+			if ( pdata->context_info.num_ctx_in_use == pdata->context_info.total_num_ctxs ) {
+				/* if all contexts active then allocate this context as the last free context */
+				pdata->context_info.last_free_ctx = ctx;
+			}
+	
+			/* count down the context in use counter */
+			pdata->context_info.num_ctx_in_use--;
+	
+			/* mark the context as free */
+			pdata->context_info.shadow[ctx].state = CTX_FREE;
+	
+		} else {
+			/* address is invalid */
+			error = 1;
+		}
+		
+	} else {
+		/* address is invalid */
+		error = 1;
+	}
+
+	return ( error );
+}
+
+
+/*
+ * Writes the authentication and encryption keys to the shadow
+ * context area and copies to the SRAM context structure if possible.
+ * Inputs:
+ *	allocated_ctx = address of context
+ *	pall_keys = pointer to all keys string
+ *	authkeylen = length of the authentication key
+ *	enckeylen = length of the encryption key
+ * Outputs:
+ *	Writes the keys to the SRAM context structure
+ * Return:
+ *	none
+ */
+void write_sram_context_keys( struct private_driver_data *pdata, u32 allocated_ctx, const u8 *pall_keys, u8 authkeylen, u8 enckeylen )
+{
+	int ctx = map_context_structure_to_index( pdata, allocated_ctx );
+
+	if (ctx >= 0) {
+		/* copy authentication key */
+		if ( authkeylen == MAX_AUTHKEY_LEN ) {
+	
+			/* copy the authentication key to the SRAM context */
+			memcpy(pdata->context_info.shadow[ctx].auth_key, pall_keys, MAX_AUTHKEY_LEN);
+		} else {
+			/* no key so fill SRAM context with zeros */
+			memset(pdata->context_info.shadow[ctx].auth_key, 0, MAX_AUTHKEY_LEN);
+		}
+	
+		/* copy encryption key */
+		if ( enckeylen == MAX_ENCKEY_LEN ) {
+	
+			/* copy the encryption key to the SRAM context */
+			memcpy(pdata->context_info.shadow[ctx].aes_key, pall_keys+authkeylen, MAX_ENCKEY_LEN);
+		} else {
+			/* no key so fill SRAM context with zeros */
+			memset(pdata->context_info.shadow[ctx].aes_key, 0, MAX_ENCKEY_LEN);
+		}
+	
+		copy_context_structure( pdata, ctx );
+
+	/* MV Debug */
+#ifdef DEBUG_SRAM
+		{
+			unsigned int pos;
+	
+			SRAM_INFO( KERN_INFO "input key: \n");
+			for ( pos = 0; pos < ( authkeylen + enckeylen ); pos++ ) {
+				SRAM_INFO( KERN_INFO "%02X\n", pall_keys[pos] );
+			}
+	
+			sram_hexdump( "SRAM keys", allocated_ctx + SRAM_CTX_AUTHKEY_OFFSET,
+				MAX_AUTHKEY_LEN + MAX_ENCKEY_LEN );
+	
+		}
+#endif
+	}
+}
+
+
+/*
+ * Writes the SEQH value to the shadow context area and copies to
+ * the SRAM context structure if possible.
+ * ESN not supported so set SEQH to zero.
+ * TODO: in order to support ESN, SEQH needs to be moved to the PDU.
+ * Inputs:
+ *	seqh = seqh value ( should be zero as ESN not supported )
+ * Outputs:
+ *	Writes SEQH to the SRAM context structure
+ * Return:
+ *	none
+ */
+void write_sram_context_seqh( struct private_driver_data *pdata, u32 allocated_ctx, u32 seqh )
+{
+	int ctx = map_context_structure_to_index( pdata, allocated_ctx );
+
+	if (ctx >= 0) {
+		/* write SEQH to the context structure */
+		pdata->context_info.shadow[ctx].seqh = seqh;
+		copy_context_structure( pdata, ctx );
+	}
+}
+
+
+/*
+ * Writes the context flags to the shadow context area and copies to
+ * the SRAM context structure if possible.
+ * Inputs:
+ *	allocated_ctx = address of context
+ *	flags = context flags
+ * Outputs:
+ *	Writes the context flags to the SRAM context structure
+ * Return:
+ *	none
+ */
+void write_sram_context_flags( struct private_driver_data *pdata, u32 allocated_ctx, u8 flags )
+{
+	int ctx = map_context_structure_to_index( pdata, allocated_ctx );
+
+	if (ctx >= 0) {
+	/* write the context flags to the context structure */
+		pdata->context_info.shadow[ctx].flags = flags;
+		copy_context_structure( pdata, ctx );
+	}
+}
+
+
+/*
+ * Initialises the PDU pool
+ * Inputs:
+ *	ppdu_info = pointer to pdu mananagement information
+ * Outputs:
+ *	writes information into the pdu management structure
+ * Return:
+ *	void 
+ */
+static void init_pdu_pool( struct pdu_management *ppdu_info )
+{
+	/* calculate the pool end address, points 1 byte past the end */
+	ppdu_info->pdu_pool_end_address = ppdu_info->pdu_pool_base_address + ppdu_info->pdu_pool_size;
+
+	/* Initialise the spin lock */
+	spin_lock_init( &ppdu_info->pdu_lock );
+
+	/* initialise the first PDU address to start at the base of the pool */
+	ppdu_info->next_alloc_pdu = ppdu_info->pdu_pool_base_address;
+
+	/* initialise the oldest PDU address to be same as the next to be allocated */
+	ppdu_info->oldest_pdu = ppdu_info->next_alloc_pdu;
+
+	/* initialise the metric of how many PDUs are in use */
+	ppdu_info->num_pdus_in_use = 0;
+
+	/* initialise the metric of how many PDUs are allocated */
+	ppdu_info->num_pdus_alloced = 0;
+}
+
+
+/*
+ * Allocates a PDU from the PDU pool
+ * Inputs:
+ *	ppdu_info = pointer to pdu mananagement information
+ *	pdu_size = requested PDU size
+ *	bdr_num = the number of the BDR so that the oldest PDU can be processed
+ * Outputs:
+ *	Allocates a PDU
+ * Return:
+ *	address of the PDU or 0 if an error occurred
+ */
+u32 alloc_sram_pdu( struct pdu_management *ppdu_info, u32 pdu_size, enum bdr_number bdr_num )
+{
+	u32 test_next_alloc_pdu;	/* test next PDU without committing to allocate it */
+
+	/* PDUs are allocated on 4 byte boundaries and butt up to each other in the pool */
+	/* The pool contains variable length PDUs for maximum efficiency */
+
+	u32 allocated_pdu = 0;
+	
+	/* first align size to a 4 byte boundary */
+	pdu_size = ( pdu_size + 0x3 ) & (~0x3);
+
+	if ( pdu_size > PDU_MAX_SIZE ) {
+		/* requested PDU is too large */
+		SRAM_ERROR( KERN_ERR "ERROR: %s Requested PDU too large %d > %d\n", __FUNCTION__, pdu_size, PDU_MAX_SIZE );
+		goto pdu_error;
+	}
+
+	/* reserve space for the PDU header (ARMs usage) */
+	pdu_size += SRAM_PDU_HEADER_SIZE;
+
+#if ( SRAM_LOCKING == LOCK_SPINLOCK_IRQ ) 
+	/* protect critical code from async event */
+	spin_lock_irqsave( &ppdu_info->pdu_lock, ppdu_info->pdu_flags );
+#endif
+
+	/* use a working copy to test for the next PDU allocation */
+	test_next_alloc_pdu = ppdu_info->next_alloc_pdu;
+
+#ifdef DEBUG_PDU_MANAGEMENT
+	SRAM_INFO( KERN_INFO "Alloc: oldest PDU is 0x%08X, current next is 0x%08X\n",
+		ppdu_info->oldest_pdu, ppdu_info->next_alloc_pdu );
+#endif
+
+	/* is there room at the end of the pool ? reserve space for a PDU header at the end of the pool */
+	if ( test_next_alloc_pdu >=
+		( ppdu_info->pdu_pool_end_address - pdu_size - SRAM_PDU_HEADER_SIZE ) ) {
+		/*
+		 * Check before correcting for the end of the pool in case the oldest PDU
+		 * is near the end of the pool.
+		 */
+		if ( ppdu_info->oldest_pdu >=
+			( ppdu_info->pdu_pool_end_address - pdu_size - SRAM_PDU_HEADER_SIZE ) ) {
+			/* oldest is also near the end of the pool */
+
+			if ( test_next_alloc_pdu < ppdu_info->oldest_pdu ) {
+				/* ERROR: out of room because allocation would move past the oldest PDU */  
+#ifdef DEBUG_PDU_MANAGEMENT_NO_ROOM
+				SRAM_INFO( KERN_INFO "PDU alloc out of room: dead area\n" );
+#endif
+				goto pdu_no_room;
+			}
+		}
+
+		/* not enough space at pool end, so wrap around to the start of the pool */
+		test_next_alloc_pdu = ppdu_info->pdu_pool_base_address;
+
+		if ( test_next_alloc_pdu == ppdu_info->oldest_pdu ) {
+			/* ERROR: out of room because allocation would be on top of the oldest PDU */  
+#ifdef DEBUG_PDU_MANAGEMENT_NO_ROOM
+			SRAM_INFO( KERN_INFO "PDU alloc out of room: on top of oldest PDU\n" );
+#endif
+			goto pdu_no_room;
+		}
+
+
+	}
+
+	if ( test_next_alloc_pdu < ppdu_info->oldest_pdu ) {
+		/* allocation pointer is heading towards the oldest PDU */
+
+		if ( ( test_next_alloc_pdu + pdu_size ) >= ppdu_info->oldest_pdu ) {
+			/* ERROR: out of room because allocation would include the oldest PDU */  
+#ifdef DEBUG_PDU_MANAGEMENT_NO_ROOM
+			SRAM_INFO( KERN_INFO "PDU alloc out of room: includes oldest PDU\n" );
+#endif
+			goto pdu_no_room;
+		}
+	}
+
+	/* do the allocation, remember to reserve space for the ARM PDU header */
+	allocated_pdu = test_next_alloc_pdu + SRAM_PDU_HEADER_SIZE;
+
+	if ( test_next_alloc_pdu != ppdu_info->next_alloc_pdu ) {
+		/*
+		 * a wrap has occurred at the end of the pool, so flag it
+		 * flag the reserved header of the last PDU as the last PDU header in the pool
+		 */ 
+		sram_write_u32( ppdu_info->next_alloc_pdu, SRAM_PDU_HDR_STATE_OFFSET, PDU_HDR_STATE_POOL_WRAP | bdr_num );
+
+		/* insert PDU pointer in the first PDU in the pool */
+		sram_write_u32( test_next_alloc_pdu, SRAM_PDU_HDR_PTR_OFFSET, test_next_alloc_pdu + pdu_size );
+
+#ifdef DEBUG_PDU_MANAGEMENT
+		SRAM_INFO( KERN_INFO "Alloc: Making last header as pool end\n" );
+#endif
+	}
+
+	/* flag this allocated PDU as in use, may be the wrapped PDU */ 
+	sram_write_u32( test_next_alloc_pdu, SRAM_PDU_HDR_STATE_OFFSET, PDU_HDR_STATE_IN_USE | bdr_num );
+
+	/* move past the end of the allocation to define the base of the next allocation */
+	test_next_alloc_pdu += pdu_size;
+
+	/*
+	 * update the PDU header pointer to point to the next PDU to be allocate
+	 * could be in the reserved PDU header at the end of the pool
+	 */ 
+	sram_write_u32( ppdu_info->next_alloc_pdu, SRAM_PDU_HDR_PTR_OFFSET, test_next_alloc_pdu );
+
+	/* update the next allocation PDU pointer */
+	ppdu_info->next_alloc_pdu = test_next_alloc_pdu;
+
+#ifdef DEBUG_PDU_MANAGEMENT
+	SRAM_INFO( KERN_INFO "Alloc: oldest PDU is 0x%08X, NEW next is 0x%08X\n",
+		ppdu_info->oldest_pdu, ppdu_info->next_alloc_pdu );
+#endif
+
+	/* record the number of in use PDUs eg. excludes freed PDUs */
+	ppdu_info->num_pdus_in_use++;
+
+	/* record the number of alloced eg. includes freed PDUs */
+	ppdu_info->num_pdus_alloced++;
+
+#ifdef DEBUG_PDU_MANAGEMENT
+	SRAM_INFO( KERN_INFO "PDU alloc: allocated %d, in use %d\n",
+		ppdu_info->num_pdus_alloced, ppdu_info->num_pdus_in_use );
+#endif
+
+#if ( SRAM_LOCKING == LOCK_SPINLOCK_IRQ ) 
+	spin_unlock_irqrestore( &ppdu_info->pdu_lock, ppdu_info->pdu_flags );
+#endif
+
+#ifdef DEBUG_SRAM
+	SRAM_DEBUG( KERN_INFO "PDU allocated: 0x%08X size: 0x%08X\n", allocated_pdu, pdu_size );
+#endif
+	return ( allocated_pdu );
+
+pdu_no_room:
+#ifdef DEBUG_PDU_MANAGEMENT_NO_ROOM
+	SRAM_ERROR( KERN_ERR "ERROR: No room in PDU pool to allocate this PDU: allocated %d, in use %d\n",
+		ppdu_info->num_pdus_alloced, ppdu_info->num_pdus_in_use );
+#endif
+
+#if ( SRAM_LOCKING == LOCK_SPINLOCK_IRQ ) 
+	spin_unlock_irqrestore( &ppdu_info->pdu_lock, ppdu_info->pdu_flags );
+#endif
+
+pdu_error:
+	return ( allocated_pdu );
+}
+
+
+/*
+ * Get the BDR number of the oldest PDU
+ * Inputs:
+ *	ppdu_info = pointer to pdu mananagement information
+ *	pbdr_num = pointer to a bdr_num variable of the calling function
+ * Outputs:
+ *	reads the BDR number out of the PDU header state field
+ * Return:
+ *	0 for success and 1 for failure
+ */
+u8 get_bdr_num_of_oldest_pdu( struct pdu_management *ppdu_info, enum bdr_number *pbdr_num )
+{
+	u32 oldest_state;
+	u8 error = 0;
+	enum bdr_number tmp_bdr_num;
+
+#if ( SRAM_LOCKING == LOCK_SPINLOCK_IRQ ) 
+	/* protect critical code from async event */
+	spin_lock_irqsave( &ppdu_info->pdu_lock, ppdu_info->pdu_flags );
+#endif
+
+#ifdef DEBUG_PDU_MANAGEMENT
+	SRAM_INFO( KERN_INFO "Called %s\n", __FUNCTION__ );
+#endif
+
+	/* read the state of the oldest PDU */
+	oldest_state = sram_read_u32( ppdu_info->oldest_pdu, SRAM_PDU_HDR_STATE_OFFSET );
+
+	if ( ( oldest_state & PDU_HDR_STATE_MASK ) == PDU_HDR_STATE_IN_USE ) {
+		/* bdr_num only valid for PDUs that are in use */
+
+		/* get the bdr_num of the oldest allocated PDU */
+		tmp_bdr_num = ( oldest_state & PDU_HDR_STATE_BDR_MASK );
+
+		if ( tmp_bdr_num < BDR_TOTAL_NUM ) {
+			/* inform the calling function */
+			*pbdr_num = tmp_bdr_num;
+#ifdef DEBUG_PDU_MANAGEMENT
+			SRAM_INFO( KERN_INFO "Oldest PDU is in BDR number %d\n", tmp_bdr_num );
+#endif
+		} else {
+			/* out of range */
+			error = 1;
+		}
+	} else {
+		/* bdr_num not available, probably due to PDU being freed */
+		error = 1;
+	}
+
+#if ( SRAM_LOCKING == LOCK_SPINLOCK_IRQ ) 
+	spin_unlock_irqrestore( &ppdu_info->pdu_lock, ppdu_info->pdu_flags );
+#endif
+
+	return ( error );
+}
+
+
+/*
+ * Frees a PDU from the PDU pool
+ * Inputs:
+ *	ppdu_info = pointer to pdu mananagement information
+ *	allocated_pdu = address of the allocated PDU
+ * Outputs:
+ *	Frees a PDU
+ * Return:
+ *	0 for success and 1 for failure
+ */
+u8 free_sram_pdu( struct pdu_management *ppdu_info, u32 allocated_pdu )
+{
+	/* point to the header of the PDU */ 
+	u32 freeing_pdu = allocated_pdu - SRAM_PDU_HEADER_SIZE;
+	u32 next_pdu;
+	u32 pdu_state;
+	u32 oldest_state;
+	u8 error = 0;
+
+#if ( SRAM_LOCKING == LOCK_SPINLOCK_IRQ ) 
+	/* protect critical code from async event */
+	spin_lock_irqsave( &ppdu_info->pdu_lock, ppdu_info->pdu_flags );
+#endif
+
+	if ( allocated_pdu == 0 )
+	{
+		SRAM_ERROR( KERN_ERR "ERROR: Attempting to free invalid PDU\n" );
+		error = 1;
+		goto free_error;
+	}
+
+#ifdef DEBUG_PDU_MANAGEMENT
+	sram_hexdump( "Free PDU Header", freeing_pdu, SRAM_PDU_HEADER_SIZE );
+#endif
+
+	/* read the header of the PDU to be freed */
+	next_pdu = sram_read_u32( freeing_pdu, SRAM_PDU_HDR_PTR_OFFSET );
+	pdu_state = sram_read_u32( freeing_pdu, SRAM_PDU_HDR_STATE_OFFSET );
+
+	if ( ( pdu_state & PDU_HDR_STATE_MASK ) != PDU_HDR_STATE_IN_USE ) {
+		SRAM_ERROR( KERN_ERR "ERROR: Attempting to free a PDU that is not in use: 0x%08X\n", freeing_pdu );
+		error = 1;
+		goto free_error;
+	}
+
+	/* read the state of the oldest PDU */
+	oldest_state = sram_read_u32( ppdu_info->oldest_pdu, SRAM_PDU_HDR_STATE_OFFSET );
+
+	if ( ( oldest_state & PDU_HDR_STATE_MASK ) == PDU_HDR_STATE_POOL_WRAP ) {
+		/*
+		 * oldest was marked as the end of the pool in the reserved PDU header
+		 * by the allocator so wrap to start of the pool
+		 */
+		ppdu_info->oldest_pdu = ppdu_info->pdu_pool_base_address;
+
+#ifdef DEBUG_PDU_MANAGEMENT
+		SRAM_INFO( KERN_INFO "Freeing: wrap detected\n" );
+#endif
+	}
+
+	if ( freeing_pdu == ppdu_info->oldest_pdu ) {
+		/* now freeing the oldest PDU */
+
+		/*
+		 * spin through the linked PDUs to update the oldest
+		 * PDU pointer by jumping freed PDUs
+		 */
+		while ( next_pdu != ppdu_info->next_alloc_pdu ) {
+			/* not reached end of the allocated PDUs so spin */
+
+			/* read the state of the next PDU in the list */
+			pdu_state = sram_read_u32( next_pdu, SRAM_PDU_HDR_STATE_OFFSET );
+
+			if ( ( pdu_state & PDU_HDR_STATE_MASK ) == PDU_HDR_STATE_FREE ) {
+				/* this PDU also free so move to the next PDU */
+				next_pdu = sram_read_u32( next_pdu, SRAM_PDU_HDR_PTR_OFFSET );
+
+				/* one less PDU allocated */
+				ppdu_info->num_pdus_alloced--;
+
+			} else if ( ( pdu_state & PDU_HDR_STATE_MASK ) == PDU_HDR_STATE_POOL_WRAP ) {
+				/* end of the pool found, so do a wrap */
+				next_pdu = ppdu_info->pdu_pool_base_address;
+
+#ifdef DEBUG_PDU_MANAGEMENT
+				SRAM_INFO( KERN_INFO "Freeing: doing a wrap\n" );
+#endif
+			} else {
+				/* assume in use */
+				break;
+			}
+		}
+
+		/* count the oldest PDU as unallocated */
+		ppdu_info->num_pdus_alloced--;
+
+		/* update the oldest PDU pointer */
+		ppdu_info->oldest_pdu = next_pdu;
+
+#ifdef DEBUG_PDU_MANAGEMENT
+		SRAM_INFO( KERN_INFO "New oldest PDU is 0x%08X, next is 0x%08X\n",
+			ppdu_info->oldest_pdu, ppdu_info->next_alloc_pdu );
+#endif
+
+	} else {
+		/* This is a random free that is not the oldest PDU */
+		
+		/* Mark this PDU as free, BDR num not specified */
+		sram_write_u32( freeing_pdu, SRAM_PDU_HDR_STATE_OFFSET, PDU_HDR_STATE_FREE );
+
+		SRAM_DEBUG( KERN_INFO "PDU freed randomly\n" );
+	}
+
+	/* update the number of in use PDUs */
+	ppdu_info->num_pdus_in_use--;
+
+#ifdef DEBUG_PDU_MANAGEMENT
+	SRAM_INFO( KERN_INFO "PDU free: allocated %d, in use %d\n",
+		ppdu_info->num_pdus_alloced, ppdu_info->num_pdus_in_use );
+#endif
+
+free_error:
+
+#if ( SRAM_LOCKING == LOCK_SPINLOCK_IRQ ) 
+	spin_unlock_irqrestore( &ppdu_info->pdu_lock, ppdu_info->pdu_flags );
+#endif
+
+	return ( error );
+}
+
+
+/*
+ * Copy crypto data into a PDU
+ * Inputs:
+ *	pdu_address = address within an allocated PDU
+ *	pcrypto = pointer to the crypto data (source)
+ *	length = length of crypto data in bytes
+ * Outputs:
+ *	Copies crypto data
+ * Return:
+ *	none
+ */
+void copy_crypto_to_pdu_sram( u32 pdu_address, u8 *pcrypto, u32 length )
+{
+#ifdef USE_MEMCPY_FOR_SRAM
+
+        memcpy((void*)pdu_address, pcrypto, length);
+        
+#else /* memcpy */
+
+#ifdef DEBUG_SRAM
+	u32 debug_address = pdu_address;
+	u32 debug_length = length;
+#endif
+
+	/* Watch out IP packets are in BIG ENDIAN format */
+
+	if ( ( ( (u32) pcrypto ) & 0x00000003 ) == 0 ) {
+		/* crypto data is on a 4 byte boundary so copy 4 bytes at a time */
+
+		u32 *pcrypto_u32 = (u32 * ) pcrypto; 
+
+		/* convert length into number of 4 byte words */ 
+		length = (length + 3)/4;
+
+		/*
+		 * COPY CRYTPO DATA ALWAYS IN "LITTLE-ENDIAN" FORMAT TO THE SRAM
+		 * REGARDLESS OF THE CPU'S ENDIANNESS BECAUSE THE DATA IS IN CRYPTO FORMAT
+		 * eg. a bit stream
+		 */
+		while ( length > 0 ) {
+			sram_write_u32_le( pdu_address, 0, *pcrypto_u32++ );
+			length--;
+			pdu_address += 4;
+		}
+
+		SRAM_DEBUG( KERN_INFO "Used 4 byte copy\n" ); 
+	} else {
+		/* not on a 4 byte boundary so copy 1 byte at a time */
+		while ( length > 0 ) {
+			sram_write_u8( pdu_address++, 0, *pcrypto++ );
+			length--;
+		}
+	}
+
+#ifdef DEBUG_SRAM
+	sram_hexdump( "Copy to PDU", debug_address, debug_length );
+#endif
+
+#endif /* memcpy */
+}
+
+
+/*
+ * Copy crypto data from a PDU
+ * Inputs:
+ *	pdu_address = address within an allocated PDU
+ *	pcrypto = pointer to the crypto data (destination)
+ *	length = length of crypto data in bytes
+ * Outputs:
+ *	Copies crypto data 
+ * Return:
+ *	none
+ */
+void copy_crypto_from_pdu_sram( u32 pdu_address, u8 *pcrypto, u32 length )
+{
+#ifdef USE_MEMCPY_FOR_SRAM
+
+        memcpy(pcrypto, (void*)pdu_address, length);
+        
+#else /* memcpy */
+
+#ifdef DEBUG_SRAM
+	sram_hexdump( "Copy from PDU", pdu_address, length );
+#endif
+	/* Watch out IP packets are in BIG ENDIAN format */
+
+	if ( ( ( (u32) pcrypto ) & 0x00000003 ) == 0 ) {
+		/* crypto data is on a 4 byte boundary so read 4 bytes at a time */
+
+		u32 *pcrypto_u32 = (u32 * ) pcrypto; 
+
+		/* convert length into number of 4 byte words */ 
+		length = (length + 3)/4;
+
+		/*
+		 * READ CRYTPO DATA ALWAYS IN "LITTLE-ENDIAN" FORMAT FROM THE SRAM
+		 * REGARDLESS OF THE CPU'S ENDIANNESS BECAUSE THE DATA IS IN CRYPTO FORMAT
+		 * eg. a bit stream
+		 */
+		while ( length > 0 ) {
+			*pcrypto_u32++ = sram_read_u32_le( pdu_address, 0 );
+			length--;
+			pdu_address += 4;
+		}
+
+		SRAM_DEBUG( KERN_INFO "Used 4 byte read\n" ); 
+	} else {
+		/* not on a 4 byte boundary so read 1 byte at a time */
+		while ( length > 0 ) {
+			*pcrypto++ = sram_read_u8( pdu_address++, 0 );
+			length--;
+		}
+	}
+#endif /* memcpy */
+}
+
+
+/*
+ * Compare crypto data with PDU data
+ * Inputs:
+ *	pdu_address = address within an allocated PDU
+ *	pcrypto = pointer to the crypto data (destination)
+ *	length = length of crypto data in bytes
+ * Outputs:
+ *	Compares crypto data 
+ * Return:
+ *	0 for OK, 1 for mismatch
+ */
+u8 cmp_crypto_from_pdu_sram( u32 pdu_address, u8 *pcrypto, u32 length )
+{
+	u8 err = 0;
+	u32 error_address = pdu_address;
+	u32 error_length = length;
+
+	/* Watch out IP packets are in BIG ENDIAN format */
+	/* TODO: Consider comparing using u32 instead */
+	while ( length > 0 ) {
+		if ( *pcrypto++ != sram_read_u8( pdu_address++, 0 ) ) {
+			err = 1;
+		}
+		length--;
+	}
+
+	if ( err == 1 ) {
+		sram_hexdump( "PDU ERROR", error_address, error_length );
+	}
+
+	return ( err );
+}
+
+
+/*
+ * (Re-)Initialises the Buffer Descriptor Rings
+ * Inputs:
+ * 	pdata = pointer to private data structure (not NULL)
+ * Outputs:
+ *	writes information into the PicoArray SRAM
+ * Return:
+ *	None. 
+ */
+void init_sram_bdrs( struct private_driver_data *pdata )
+{
+	/* Initialise the BD ring #1 */
+	init_buffer_descriptor_ring( &pdata->bdr_info[ BDR_NUM_1 ], SRAM_BD_RING1_NUMBER );
+
+	/* Initialise the BD ring #2 */
+	init_buffer_descriptor_ring( &pdata->bdr_info[ BDR_NUM_2 ], SRAM_BD_RING2_NUMBER );
+
+	/* Initialise the BD ring #3 */
+	init_buffer_descriptor_ring( &pdata->bdr_info[ BDR_NUM_3 ], SRAM_BD_RING3_NUMBER );
+
+	/* Initialise the BD ring #4 */
+	init_buffer_descriptor_ring( &pdata->bdr_info[ BDR_NUM_4 ], SRAM_BD_RING4_NUMBER );
+}
+
+
+/*
+ * Initialises the SRAM structures
+ * Inputs:
+ * 	pdata = pointer to private data structure (not NULL)
+ * Outputs:
+ *	writes information into the PicoArray SRAM
+ * Return:
+ *	0 for success and 1 for failiure 
+ */
+u8 init_sram_structures( struct private_driver_data *pdata )
+{
+	u8 picoActive = 0;
+
+	SRAM_DEBUG( KERN_INFO "init_sram_structures called\n");
+	
+	/* calcuate the header address */
+	pdata->header_address = (u32) pdata->vert_sram_base_address; 
+
+
+	/* calculate the context block base address allowing space for the header */
+	pdata->context_info.context_base_address = pdata->header_address + SRAM_HEADER_SIZE;
+
+	picoActive = read_pico_active_state( pdata );
+	SRAM_DEBUG( KERN_INFO "picoActive is %d\n", picoActive);
+		
+
+	/* calculate the buffer descriptor ring #1 start address allowing space for contexts */
+	pdata->bdr_info[ 0 ].bdr_base_address = pdata->context_info.context_base_address +
+		( SRAM_CTX_SIZE * SRAM_CTX_MAX_NUMBER );
+
+	/* calculate the buffer descriptor ring #2 start address allowing space for ring #1 */
+	pdata->bdr_info[ 1 ].bdr_base_address = pdata->bdr_info[ 0 ].bdr_base_address +
+		( SRAM_BD_SIZE * SRAM_BD_RING1_NUMBER );
+
+	/* calculate the buffer descriptor ring #3 start address allowing space for ring #2 */
+	pdata->bdr_info[ 2 ].bdr_base_address = pdata->bdr_info[ 1 ].bdr_base_address +
+		( SRAM_BD_SIZE * SRAM_BD_RING2_NUMBER );
+
+	/* calculate the buffer descriptor ring #4 start address allowing space for ring #3 */
+	pdata->bdr_info[ 3 ].bdr_base_address = pdata->bdr_info[ 2 ].bdr_base_address +
+		( SRAM_BD_SIZE * SRAM_BD_RING3_NUMBER );
+
+
+	/* calculate the pdu buffer pool base address allowing space for ring #4 */
+	pdata->pdu_info.pdu_pool_base_address = pdata->bdr_info[ 3 ].bdr_base_address +
+		( SRAM_BD_SIZE * SRAM_BD_RING4_NUMBER );
+
+	/* calculate the pdu pool size */
+	if ( ( pdata->pdu_info.pdu_pool_base_address - pdata->header_address ) < pdata->sram_size ) {
+		pdata->pdu_info.pdu_pool_size = pdata->sram_size - (pdata->pdu_info.pdu_pool_base_address - pdata->header_address );
+	} else {
+		SRAM_ERROR( KERN_ERR "ERROR: Insufficient SRAM space for the PDU pool\n" );
+		pdata->pdu_info.pdu_pool_size = 0;
+	}
+
+	SRAM_DEBUG( KERN_INFO "PDU pool size is %d bytes\n", pdata->pdu_info.pdu_pool_size );
+
+	/* set the transit state to all SW */
+	atomic_set( &pdata->driver_transit_state, DRIVER_ALL_SW );
+
+	SRAM_DEBUG( KERN_INFO "Set to SW mode\n" );
+
+	if ( picoActive ) {
+	
+		SRAM_DEBUG( KERN_INFO "writing all data structures\n");
+		
+		/* try to CLOSE the picoArray but run in SW Fallback mode anyway */
+		request_sram_pico_close( pdata );
+	
+		/* Initialise the SRAM header */
+		init_sram_header( pdata );
+
+#ifdef VERBOSE_SRAM
+		sram_hexdump( "Header", pdata->header_address, SRAM_HEADER_SIZE );
+#endif
+
+		/* Initialise the context structure block */
+		copy_all_context_structures( pdata );
+		
+#ifdef VERBOSE_SRAM
+		sram_hexdump( "Context", pdata->context_info.context_base_address,
+			SRAM_CTX_SIZE * SRAM_CTX_MAX_NUMBER );
+#endif
+
+		/* Initialise all the Buffer Descriptor Rings */
+		init_sram_bdrs( pdata );
+
+#ifdef VERBOSE_SRAM
+		sram_hexdump( "Ring 1", pdata->bdr_info[ BDR_NUM_1 ].bdr_base_address, SRAM_BD_SIZE * SRAM_BD_RING1_NUMBER );
+		sram_hexdump( "Ring 2", pdata->bdr_info[ BDR_NUM_2 ].bdr_base_address, SRAM_BD_SIZE * SRAM_BD_RING2_NUMBER );
+		sram_hexdump( "Ring 3", pdata->bdr_info[ BDR_NUM_3 ].bdr_base_address, SRAM_BD_SIZE * SRAM_BD_RING3_NUMBER );
+		sram_hexdump( "Ring 4", pdata->bdr_info[ BDR_NUM_4 ].bdr_base_address, SRAM_BD_SIZE * SRAM_BD_RING4_NUMBER );
+#endif
+
+		/* Initialise the PDU pool */
+		init_pdu_pool( &pdata->pdu_info );
+
+#ifdef VERBOSE_SRAM
+		sram_hexdump( "PDU pool info", (u32) &pdata->pdu_info, sizeof( pdata->pdu_info ) );
+#endif
+
+#ifdef APPLICATION_NOT_AVAILABLE
+		/* Test code to OPEN the picoArray when the Linux Application is not available */
+		/* put the picoAray into the OPENED state */
+		if( request_sram_pico_open( pdata ) == 1 ) {
+			/* Failed to OPEN the picoArray */
+	
+			SRAM_DEBUG( KERN_INFO "Set to SW mode\n" );
+	
+			/* set the transit state to all SW Fallback */
+			atomic_set( &pdata->driver_transit_state, DRIVER_ALL_SW );
+		} else {
+	
+			SRAM_DEBUG( KERN_INFO "Set to HW mode\n" );
+
+			/* set the transit state to all HW */
+			atomic_set( &pdata->driver_transit_state, DRIVER_ALL_HW );
+		}
+#endif
+	}
+
+	return( picoActive );
+}
+
diff -Naur pico_2.6.28/drivers/ipa/crypto/swcrypto.c ipa_2.6.28/drivers/ipa/crypto/swcrypto.c
--- pico_2.6.28/drivers/ipa/crypto/swcrypto.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/ipa/crypto/swcrypto.c	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,365 @@
+/******************************************************************************
+ *
+ * This file contains the Software based cryptographic calls to the Kernel's Crypto functions.
+ *
+ * File: swcrypto.c
+ * Author: Dean Jenkins <djenkins@mvista.com>
+ *
+ * 2009 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *****************************************************************************
+ * Filename: 
+ *****************************************************************************/
+
+/* kernel related headers */
+#include <linux/kernel.h>
+#include <linux/rtnetlink.h>
+#include <linux/interrupt.h>
+
+/* Kernel crypto related headers */
+#include <linux/crypto.h>
+#include <crypto/algapi.h>
+#include <crypto/aead.h>
+
+#include "picocrypto.h"
+#include "swcrypto.h"
+
+/******************
+ * local #defines *
+ ******************/
+
+#undef DEBUG_SWCRYPTO
+/* #define DEBUG_SWCRYPTO	1	*/
+
+#ifdef DEBUG_SWCRYPTO
+#define SWCRYPTO_DEBUG(fmt,args...)	printk( fmt ,##args )
+#else
+#define SWCRYPTO_DEBUG(fmt,args...)
+#endif
+
+#define SWCRYPTO_INFO(fmt,args...)	printk( fmt ,##args )
+#define SWCRYPTO_ERROR(fmt,args...)	printk( fmt ,##args )
+
+
+/***************
+ * local types *
+ ***************/
+
+struct sw_tfm {
+	struct crypto_aead *tfm;
+	char *driver_name;
+};
+
+
+/******************
+ * local globals  *
+ ******************/
+
+/* array to store the pointers of the SW transforms */
+static struct sw_tfm swcrypto_tfms[ NUM_SW_TFMS ] = {
+	/* SW_CRYPTO_AUTH */
+	{
+		.tfm = NULL,
+		.driver_name = "authenc(hmac(sha1-generic),cbc(aes-generic))",
+	},
+	/* SW_CRYPTO_NON */
+	{
+		.tfm = NULL,
+		.driver_name = "authenc(digest_null-generic,cbc(aes-generic))",
+	},
+	/* SW_NULL_AUTH */
+	{
+		.tfm = NULL,
+		.driver_name = "authenc(hmac(sha1-generic),ecb-cipher_null)",
+	},
+	/* SW_NULL_NON */
+	{
+		.tfm = NULL,
+		.driver_name = "authenc(digest_null-generic,ecb-cipher_null)",
+	}
+};
+
+
+/*********************************
+ * SW Crypto Interface functions *
+ *********************************/
+
+/*
+ * Allocs SW algorithm transforms
+ * Inputs:
+ *	None
+ * Outputs:
+ *	allocates all the required SW based algorithm transforms
+ * Return:
+ *	0 for success else 1 for failure
+ */
+u8 swcrypto_alloc_tfms( void )
+{
+	u8 error = 0;
+	u8 tfm_cnt;
+	u8 tfm_err_cnt;
+
+	for ( tfm_cnt = 0; tfm_cnt < NUM_SW_TFMS; tfm_cnt++ ) {
+
+		swcrypto_tfms[ tfm_cnt ].tfm = crypto_alloc_aead( swcrypto_tfms[ tfm_cnt ].driver_name,
+							0, 0 );
+
+		if ( IS_ERR( swcrypto_tfms[ tfm_cnt ].tfm ) ) {
+			SWCRYPTO_ERROR( KERN_ERR "ERROR: Failed to load transform for %s\n",
+				swcrypto_tfms[ tfm_cnt ].driver_name );
+			error = 1;
+			break;
+		}
+	}
+
+	if ( error == 1 ) {
+		/* on error unallocate tfms */
+		for ( tfm_err_cnt = 0; tfm_err_cnt < tfm_cnt; tfm_err_cnt++ ) {
+			crypto_free_aead( swcrypto_tfms[ tfm_err_cnt ].tfm );
+			swcrypto_tfms[ tfm_err_cnt ].tfm = NULL;
+		}
+	}
+
+	return ( error );
+}
+
+
+/*
+ * Releases allocated SW algorithm transforms
+ * Inputs:
+ *	None
+ * Outputs:
+ *	Releases all the allocated SW based algorithm transforms
+ * Return:
+ *	None
+ */
+void swcrypto_release_tfms( void )
+{
+	u8 tfm_cnt;
+
+	for ( tfm_cnt = 0; tfm_cnt < NUM_SW_TFMS; tfm_cnt++ ) {
+		if ( swcrypto_tfms[ tfm_cnt ].tfm != NULL ) {
+			crypto_free_aead( swcrypto_tfms[ tfm_cnt ].tfm );
+			swcrypto_tfms[ tfm_cnt ].tfm = NULL;
+		}
+	}
+}
+
+
+/*
+ * Actions the Software based crypto
+ * Inputs:
+ *	req = pointer to the crypto request
+ *	tfm_num = the number of algorithm transform in swcrypto_tfms[]
+ *	encdec = flag for decryption or encryption
+ * Outputs:
+ *	Substitutes the picoArray tfm for the SW tfm
+ *	Actions the SW encryption or decryption
+ * Return:
+ *	Error code
+ */
+int swcrypto_do_it( struct aead_request *req, u8 tfm_num, u8 encdec )
+{
+	int error = 0;
+	int ret;
+
+	/* Get the pointer to the appropriate SW algorithm transform */
+	struct crypto_aead *sw_tfm = swcrypto_tfms[ tfm_num ].tfm;
+
+	/* get the hw algorithm transform info */
+	struct crypto_aead *hw_tfm = crypto_aead_reqtfm( req );
+	/* get the context data for the hw request */
+	struct private_ctx_data *pctx = crypto_aead_ctx( hw_tfm );
+
+	struct aead_request *sw_req;
+
+	SWCRYPTO_DEBUG( KERN_INFO "%s called\n", __FUNCTION__ );
+
+	SWCRYPTO_DEBUG( KERN_INFO "hw: reqsize %d, sw: reqsize %d\n",
+		crypto_aead_reqsize( hw_tfm ), crypto_aead_reqsize( sw_tfm ) );
+
+	crypto_aead_clear_flags( sw_tfm, ~0 );
+
+	/* set the key for SW algorithm transform */
+	ret = crypto_aead_setkey( sw_tfm, &pctx->rawkey[0], pctx->rawkey_len );
+	if( ret ) {
+		SWCRYPTO_ERROR( KERN_ERR "%s: ERROR: failed to set the key\n", __FUNCTION__ );
+		return -EBUSY;
+	}
+
+#ifdef DEBUG_SWCRYPTO
+	dump_aead_req_enckey( pctx );
+#endif
+
+	/* set the authsize ( authentication field length ) for SW algorithm transform */
+	ret = crypto_aead_setauthsize( sw_tfm, pctx->authsize );
+	if( ret ) {
+		SWCRYPTO_ERROR( KERN_ERR "%s: ERROR: failed to set the authsize of %d\n", __FUNCTION__, pctx->authsize );
+		return -EBUSY;
+	}
+
+#ifdef DEBUG_SWCRYPTO
+	dump_aead_req_authkey( pctx );
+#endif
+
+	/*****************/
+	/* Use a new req */
+	/*****************/
+
+	/* allocate a request for the software algorithm */
+	sw_req = aead_request_alloc( sw_tfm, GFP_ATOMIC );
+	if (!sw_req) {
+		SWCRYPTO_ERROR( KERN_ERR "ERROR: failed to allocate request\n" );
+		return -EBUSY;
+	}
+
+
+	/* transfer HW request info into the SW request */
+
+	aead_request_set_callback( sw_req, req->base.flags, req->base.complete,
+				  req->base.data );
+	aead_request_set_crypt( sw_req, req->src, req->dst, req->cryptlen, req->iv );
+	aead_request_set_assoc( sw_req, req->assoc, req->assoclen );
+
+#ifdef DEBUG_SWCRYPTO
+	dump_aead_req_assoc( sw_req );
+	dump_aead_req_iv( sw_req );
+	dump_aead_req_src( sw_req );
+#endif
+
+	/* do it */
+	if ( encdec == SW_DO_DEC ) {
+		SWCRYPTO_DEBUG( KERN_INFO "Doing SW req decryption\n" );
+
+		/* action decryption */
+		error = crypto_aead_decrypt( sw_req );
+	} else {
+		SWCRYPTO_DEBUG( KERN_INFO "Doing SW req encryption\n" );
+
+		/* action encryption */
+		error = crypto_aead_encrypt( sw_req );
+	}
+
+#ifdef DEBUG_SWCRYPTO
+	/* now print out the result */
+	dump_aead_req_dst( sw_req );
+#endif
+
+	/* free the SW AEAD request as now finished with it */
+	aead_request_free( sw_req );
+
+	SWCRYPTO_DEBUG( KERN_INFO "OK so far...error: %d tfm_num: %d\n", error, tfm_num );
+
+	return (error);
+}
+
+
+
+void dump_aead_req_assoc( struct aead_request *req )
+{
+	u8 *psrc_data;
+	u32 seqment_len;
+	u8 pos;
+
+	/* get a pointer to the assoc data */
+	psrc_data = sg_virt( req->assoc );
+
+	/* get the length of this seqment */
+	seqment_len = req->assoc->length;
+
+	SWCRYPTO_DEBUG( KERN_INFO "DUMP assoc data: ptr = %p, len = %d\n", psrc_data, seqment_len );
+
+	for ( pos = 0; pos < seqment_len; pos++ ) {
+		SWCRYPTO_DEBUG( KERN_INFO "data[%d] = %02X\n", pos, psrc_data[ pos ] );
+	}
+} 
+
+
+void dump_aead_req_iv( struct aead_request *req )
+{
+	u8 *psrc_data;
+	u32 len;
+	u8 pos;
+
+	/* get a pointer to the IV data */
+	psrc_data = req->iv;
+
+	/* get the length */
+	len = 16;
+
+	SWCRYPTO_DEBUG( KERN_INFO "DUMP iv data: ptr = %p, len = %d\n", psrc_data, len );
+
+	for ( pos = 0; pos < len; pos++ ) {
+		SWCRYPTO_DEBUG( KERN_INFO "data[%d] = %02X\n", pos, psrc_data[ pos ] );
+	}
+}
+
+
+void dump_aead_req_src( struct aead_request *req )
+{
+	u8 *psrc_data;
+	u32 seqment_len;
+	u8 pos;
+
+	/* get a pointer to the src data */
+	psrc_data = sg_virt( req->src );
+
+	/* get the length of this seqment */
+	seqment_len = req->src->length;
+
+	SWCRYPTO_DEBUG( KERN_INFO "DUMP src: ptr = %p, len = %d\n", psrc_data, seqment_len );
+
+	for ( pos = 0; pos < seqment_len; pos++ ) {
+		SWCRYPTO_DEBUG( KERN_INFO "data[%d] = %02X\n", pos, psrc_data[ pos ] );
+	}
+}
+
+
+void dump_aead_req_dst( struct aead_request *req )
+{
+	u8 *pdst_data;
+	u32 seqment_len;
+	u8 pos;
+
+	/* get a pointer to the dst data */
+	pdst_data = sg_virt( req->dst );
+
+	/* get the length of this seqment */
+	seqment_len = req->src->length;
+
+	SWCRYPTO_DEBUG( KERN_INFO "DUMP dst: ptr = %p, len = %d\n", pdst_data, seqment_len );
+
+	for ( pos = 0; pos < seqment_len; pos++ ) {
+		SWCRYPTO_DEBUG( KERN_INFO "data[%d] = %02X\n", pos, pdst_data[ pos ] );
+	}
+}
+
+
+void dump_aead_req_enckey( struct private_ctx_data *pctx )
+{
+	u32 len = pctx->enckey_len;
+	u8 pos;
+
+	SWCRYPTO_DEBUG( KERN_INFO "DUMP enckey data: len = %d\n", len );
+
+	for ( pos = 0; pos < len; pos++ ) {
+		SWCRYPTO_DEBUG( KERN_INFO "data[%d] = %02X\n", pos, pctx->enckey[ pos ] );
+	}
+}
+
+
+void dump_aead_req_authkey( struct private_ctx_data *pctx )
+{
+	u32 len = pctx->authkey_len;
+	u8 pos;
+
+	SWCRYPTO_DEBUG( KERN_INFO "DUMP authkey data: len = %d\n", len );
+
+	for ( pos = 0; pos < len; pos++ ) {
+		SWCRYPTO_DEBUG( KERN_INFO "data[%d] = %02X\n", pos, pctx->authkey[ pos ] );
+	}
+}
+
+
diff -Naur pico_2.6.28/drivers/ipa/crypto/swcrypto.h ipa_2.6.28/drivers/ipa/crypto/swcrypto.h
--- pico_2.6.28/drivers/ipa/crypto/swcrypto.h	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/ipa/crypto/swcrypto.h	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,44 @@
+/*
+ * This file contains the Software based Crypto #defines, types and prototypes.
+ *
+ * File: swcrypto.h
+ * Author: Dean Jenkins <djenkins@mvista.com>
+ *
+ * 2009 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+/*******************
+ * common #defines *
+ *******************/
+
+#define NUM_SW_TFMS	(4)	/* Number of SW transform algorithms */
+
+/* SW transform algorithms */
+#define SW_CRYPTO_AUTH	(0)
+#define SW_CRYPTO_NON	(1)
+#define SW_NULL_AUTH	(2)
+#define SW_NULL_NON	(3)
+
+#define SW_DO_ENC	(0)	/* do SW encryption */
+#define SW_DO_DEC	(1)	/* do SW decryption */
+
+
+/***********************
+ * function prototypes *
+ ***********************/
+
+extern u8 swcrypto_alloc_tfms( void );
+extern void swcrypto_release_tfms( void );
+
+extern int swcrypto_do_it( struct aead_request *req, u8 tfm_num, u8 encdec );
+
+extern void dump_aead_req_assoc( struct aead_request *req );
+extern void dump_aead_req_iv( struct aead_request *req );
+extern void dump_aead_req_src( struct aead_request *req );
+extern void dump_aead_req_dst( struct aead_request *req );
+extern void dump_aead_req_enckey( struct private_ctx_data *pctx );
+extern void dump_aead_req_authkey( struct private_ctx_data *pctx );
+
diff -Naur pico_2.6.28/drivers/ipa/crypto/tcrypt.h ipa_2.6.28/drivers/ipa/crypto/tcrypt.h
--- pico_2.6.28/drivers/ipa/crypto/tcrypt.h	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/ipa/crypto/tcrypt.h	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,9036 @@
+/*
+ * Quick & dirty crypto testing module.
+ * Based on tcrypt and modified to test the PicoCrypto sub-system
+ *
+ * Author: Dean Jenkins <djenkins@mvista.com>
+ *
+ * 2008 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+/*
+ * Copyright (c) 2002 James Morris <jmorris@intercode.com.au>
+ * Copyright (c) 2002 Jean-Francois Dive <jef@linuxbe.org>
+ * Copyright (c) 2007 Nokia Siemens Networks
+ */
+#ifndef _CRYPTO_TCRYPT_H
+#define _CRYPTO_TCRYPT_H
+
+#define MAX_DIGEST_SIZE		64
+#define MAX_TAP			8
+
+#define MAX_KEYLEN		56
+#define MAX_IVLEN		32
+
+struct hash_testvec {
+	/* only used with keyed hash algorithms */
+	char *key;
+	char *plaintext;
+	char *digest;
+	unsigned char tap[MAX_TAP];
+	unsigned char psize;
+	unsigned char np;
+	unsigned char ksize;
+};
+
+struct cipher_testvec {
+	char *key;
+	char *iv;
+	char *input;
+	char *result;
+	unsigned char tap[MAX_TAP];
+	int np;
+	unsigned char fail;
+	unsigned char wk; /* weak key flag */
+	unsigned char klen;
+	unsigned short ilen;
+	unsigned short rlen;
+};
+
+struct aead_testvec {
+	char *key;
+	char *iv;
+	char *input;
+	char *assoc;
+	char *result;
+	unsigned char tap[MAX_TAP];
+	unsigned char atap[MAX_TAP];
+	int np;
+	int anp;
+	unsigned char fail;
+	unsigned char wk; /* weak key flag */
+	unsigned char klen;
+	unsigned short ilen;
+	unsigned short alen;
+	unsigned short rlen;
+};
+
+struct authenc_testvec {
+	char *enckey;
+	char *authkey;
+	char *iv;
+	char *input;
+	char *assoc;
+	char *result;
+	unsigned char tap[MAX_TAP];
+	unsigned char atap[MAX_TAP];
+	int np;
+	int anp;
+	unsigned char fail;
+	unsigned char wk; /* weak key flag */
+	unsigned char enckeylen;
+	unsigned char authkeylen;
+	unsigned short ilen;
+	unsigned short alen;
+	unsigned short rlen;
+};
+
+struct hash_speed {
+	unsigned int blen;	/* buffer length */
+	unsigned int plen;	/* per-update length */
+};
+
+static char zeroed_string[48];
+
+
+#define PICOCRYPTO_NULL_ENC_NON_TEST_VECTORS		1
+
+static struct authenc_testvec picocrypto_null_ecb_enc_non_tv_template[] = {
+	{ 
+		/* ENC NULL_NON */
+		.enckeylen   = 0,
+		.authkeylen  = 0,
+		.input  = "Single block msg",
+		.ilen   = 16,
+		.result = "Single block msg",
+		.rlen   = 16,
+	}
+};
+
+#define PICOCRYPTO_NULL_DEC_NON_TEST_VECTORS		1
+
+static struct authenc_testvec picocrypto_null_ecb_dec_non_tv_template[] = {
+	{ 
+		/* DEC NULL_NON */
+		.enckeylen   = 0,
+		.authkeylen  = 0,
+		.input  = "Single block msg",
+		.ilen   = 16,
+		.result = "Single block msg",
+		.rlen   = 16,
+	}
+};
+
+#define PICOCRYPTO_NULL_ENC_AUTH_TEST_VECTORS		1
+
+static struct authenc_testvec picocrypto_null_ecb_enc_auth_tv_template[] = {
+	{ 
+		/* ENC NULL_AUTH */
+		.enckeylen   = 0,
+		.assoc = "\x08\x07\x06\x05\x04\x03\x02\x01",
+		.alen = 8,
+		.authkey = "\x01\x02\x03\x04\x05\x06\x07\x08"
+			"\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
+			"\x11\x12\x13\x14",
+		.authkeylen  = 20,
+		.input  = "Single block msg",
+		.ilen   = 16,
+		.result = "Single block msg"
+			  "\xfb\x7e\x4e\xa5\x6b\x2d\x5c\xde\xfa\x87\x69\x14",	/* this HMAC data needs validating */
+		.rlen   = 28,
+	}
+};
+
+#define PICOCRYPTO_NULL_DEC_AUTH_TEST_VECTORS		1
+
+static struct authenc_testvec picocrypto_null_ecb_dec_auth_tv_template[] = {
+	{ 
+		/* DEC NULL_AUTH */
+		.enckeylen   = 0,
+		.assoc = "\x08\x07\x06\x05\x04\x03\x02\x01",
+		.alen = 8,
+		.authkey = "\x01\x02\x03\x04\x05\x06\x07\x08"
+			"\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
+			"\x11\x12\x13\x14",
+		.authkeylen  = 20,
+		.input  = "Single block msg"
+			  "\xfb\x7e\x4e\xa5\x6b\x2d\x5c\xde\xfa\x87\x69\x14",	/* this HMAC data needs validating */
+		.ilen   = 28,
+		.result = "Single block msg",
+		.rlen   = 16,
+	}
+};
+
+
+
+#define PICOCRYPTO_AES_ENC_NON_TEST_VECTORS		2
+
+/* PicoCrypto test data */
+static struct authenc_testvec picocrypto_aes_cbc_enc_non_tv_template[] = {
+	{ /* From RFC 3602 */
+		/* ENC AES_NON */
+		.enckey = "\x06\xa9\x21\x40\x36\xb8\xa1\x5b"
+			  "\x51\x2e\x03\xd5\x34\x12\x00\x06",
+		.enckeylen   = 16,
+		.authkeylen  = 0,
+		.iv	= "\x3d\xaf\xba\x42\x9d\x9e\xb4\x30"
+			  "\xb4\x22\xda\x80\x2c\x9f\xac\x41",
+		.input	= "Single block msg",
+		.ilen   = 16,
+		.result = "\xe3\x53\x77\x9c\x10\x79\xae\xb8"
+			  "\x27\x08\x94\x2d\xbe\x77\x18\x1a",
+		.rlen   = 16,
+	},
+	{ /* IPsec ping reply */
+		/* ENC AES_NON */
+		.enckey = "\xE0\x34\x8E\xB0\xF2\xD6\xDC\x99"
+			  "\x26\x37\x98\xEC\xAD\xFE\x20\xD3",
+		.enckeylen   = 16,
+		.authkeylen  = 0,
+		.iv	= "\x7F\x45\x4C\x46\x01\x01\x01\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.input	= "\x45\x00\x00\x54\xE4\xA4\x00\x00"
+			  "\x40\x01\x00\xA9\xC0\xA8\x0A\x0A"
+			  "\xC0\xA8\x0A\x01\x00\x00\x1F\x69"
+			  "\xCC\x44\x00\x01\x58\x37\x66\x49"
+			  "\x64\xCD\x06\x00\x08\x09\x0A\x0B"
+			  "\x0C\x0D\x0E\x0F\x10\x11\x12\x13"
+			  "\x14\x15\x16\x17\x18\x19\x1A\x1B"
+			  "\x1C\x1D\x1E\x1F\x20\x21\x22\x23"
+			  "\x24\x25\x26\x27\x28\x29\x2A\x2B"
+			  "\x2C\x2D\x2E\x2F\x30\x31\x32\x33"
+			  "\x34\x35\x36\x37\x01\x02\x03\x04"
+			  "\x05\x06\x07\x08\x09\x0A\x0A\x04",
+		.ilen   = 96,
+		.result = "\xc0\xf3\xab\x3e\x39\x22\x7a\x95"
+			  "\x30\x75\x96\x23\xad\x2a\x9b\x99"
+			  "\xdb\x2e\x25\x8b\xd8\x3f\x71\xb2"
+			  "\x13\xe5\xb6\xbd\xfd\x42\x42\x2a"
+			  "\x69\x36\x4c\x47\xcf\x28\xd2\xbb"
+			  "\x0a\xc5\xb1\xaa\xf3\x2d\xa6\x33"
+			  "\x32\xe4\x36\x88\xaa\xea\xba\x60"
+			  "\xeb\x97\x26\x77\xc6\xba\xcf\x1c"
+			  "\x74\xfa\xb3\xd0\x21\x8d\x06\x43"
+			  "\x04\x82\xa0\xbf\xfb\x2a\x39\x19"
+			  "\xfd\x68\x7f\xae\x42\xf9\x2e\xc5"
+			  "\xdd\xda\xe6\x6e\x8c\x69\xfe\x51",
+		.rlen   = 96,
+	}
+};
+
+#define PICOCRYPTO_AES_DEC_NON_TEST_VECTORS		2
+
+static struct authenc_testvec picocrypto_aes_cbc_dec_non_tv_template[] = {
+	{ /* From RFC 3602 */
+		/* DEC AES_NON */
+		.enckey    = "\x06\xa9\x21\x40\x36\xb8\xa1\x5b"
+			  "\x51\x2e\x03\xd5\x34\x12\x00\x06",
+		.enckeylen   = 16,
+		.authkeylen  = 0,
+		.iv     = "\x3d\xaf\xba\x42\x9d\x9e\xb4\x30"
+			  "\xb4\x22\xda\x80\x2c\x9f\xac\x41",
+		.input  = "\xe3\x53\x77\x9c\x10\x79\xae\xb8"
+			  "\x27\x08\x94\x2d\xbe\x77\x18\x1a",
+		.ilen   = 16,
+		.result = "Single block msg",
+		.rlen   = 16,
+	},
+	{ /* IPsec ping request */
+		/* DEC AES_NON */
+		.enckey    = "\xF4\x51\x38\x68\x95\x44\xA2\xAD"
+			  "\x3F\xB6\x0A\xE4\xAA\xED\x6F\xD8",
+		.enckeylen   = 16,
+		.authkeylen  = 0,
+		.iv     = "\x90\x5B\x6F\xB2\xFC\xE9\x3E\x59"
+			  "\xBD\xFF\x50\xF1\x5A\x19\xAF\x1C",
+		.input  = "\xE6\x49\x53\x7C\xAF\x9A\x67\xC2"
+			  "\xE6\xDA\xD9\xDD\xD8\x39\xF0\xC7"
+			  "\x3F\xA4\xC6\x83\x58\x54\x41\x4A"
+			  "\x49\x03\x96\x35\x72\xD4\x90\x49"
+			  "\x55\x39\x2B\xA5\xAE\x72\x88\x07"
+			  "\x58\x57\x32\x15\x7D\x37\xBC\x48"
+			  "\xFE\x16\xD2\x81\x94\xA9\x9C\x97"
+			  "\x61\x72\xFC\x7D\xAC\xA5\xC8\x87"
+			  "\x24\xF8\xB5\x2B\x92\x8E\x3D\xDC"
+			  "\x01\x37\xFA\x44\x75\xC7\xC8\x5F"
+			  "\x69\x9A\xC7\x73\x7A\x5E\x23\x6F"
+			  "\x95\x77\x53\xE2\xD9\x73\xA1\xEF",
+		.ilen   = 96,
+		.result = "\x45\x00\x00\x54\x00\x00\x40\x00"
+			  "\x40\x01\xa5\x4d\xc0\xa8\x0a\x01"
+			  "\xc0\xa8\x0a\x0a\x08\x00\x17\x69"
+			  "\xcc\x44\x00\x01\x58\x37\x66\x49"
+			  "\x64\xcd\x06\x00\x08\x09\x0a\x0b"
+			  "\x0c\x0d\x0e\x0f\x10\x11\x12\x13"
+			  "\x14\x15\x16\x17\x18\x19\x1a\x1b"
+			  "\x1c\x1d\x1e\x1f\x20\x21\x22\x23"
+			  "\x24\x25\x26\x27\x28\x29\x2a\x2b"
+			  "\x2c\x2d\x2e\x2f\x30\x31\x32\x33"
+			  "\x34\x35\x36\x37\x01\x02\x03\x04"
+			  "\x05\x06\x07\x08\x09\x0a\x0a\x04",
+		.rlen   = 96,
+	}
+};
+
+#define PICOCRYPTO_AES_ENC_AUTH_TEST_VECTORS		1
+
+/* PicoCrypto test data */
+static struct authenc_testvec picocrypto_aes_cbc_enc_auth_tv_template[] = {
+	{ /* From RFC 3602 */
+		/* ENC AES_AUTH */
+		.enckey = "\x06\xa9\x21\x40\x36\xb8\xa1\x5b"
+			  "\x51\x2e\x03\xd5\x34\x12\x00\x06",
+		.enckeylen   = 16,
+		.assoc = "\x08\x07\x06\x05\x04\x03\x02\x01",
+		.alen = 8,
+		.authkey = "\x01\x02\x03\x04\x05\x06\x07\x08"
+			"\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
+			"\x11\x12\x13\x14",
+		.authkeylen  = 20,
+		.iv	= "\x3d\xaf\xba\x42\x9d\x9e\xb4\x30"
+			  "\xb4\x22\xda\x80\x2c\x9f\xac\x41",
+		.input	= "Single block msg",
+		.ilen   = 16,
+		.result = "\xe3\x53\x77\x9c\x10\x79\xae\xb8"
+			  "\x27\x08\x94\x2d\xbe\x77\x18\x1a"
+			  "\xaf\x47\x73\xef\xf7\xcd\x46\xfe\x72\x87\x15\x5b",	/* this HMAC data needs validating */
+		.rlen   = 28,
+	}
+};
+
+#define PICOCRYPTO_AES_DEC_AUTH_TEST_VECTORS		1
+
+static struct authenc_testvec picocrypto_aes_cbc_dec_auth_tv_template[] = {
+	{ /* From RFC 3602 */
+		/* DEC AES_AUTH */
+		.enckey    = "\x06\xa9\x21\x40\x36\xb8\xa1\x5b"
+			  "\x51\x2e\x03\xd5\x34\x12\x00\x06",
+		.enckeylen   = 16,
+		.authkeylen  = 0,
+		.assoc = "\x08\x07\x06\x05\x04\x03\x02\x01",
+		.alen = 8,
+		.authkey = "\x01\x02\x03\x04\x05\x06\x07\x08"
+			"\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
+			"\x11\x12\x13\x14",
+		.authkeylen  = 20,
+		.iv     = "\x3d\xaf\xba\x42\x9d\x9e\xb4\x30"
+			  "\xb4\x22\xda\x80\x2c\x9f\xac\x41",
+		.input  = "\xe3\x53\x77\x9c\x10\x79\xae\xb8"
+			  "\x27\x08\x94\x2d\xbe\x77\x18\x1a"
+			  "\xaf\x47\x73\xef\xf7\xcd\x46\xfe\x72\x87\x15\x5b",	/* this HMAC data needs validating */
+		.ilen   = 28,
+		.result = "Single block msg",
+		.rlen   = 16,
+	}
+};
+
+/*
+ * MD4 test vectors from RFC1320
+ */
+#define MD4_TEST_VECTORS	7
+
+static struct hash_testvec md4_tv_template [] = {
+	{
+		.plaintext = "",
+		.digest	= "\x31\xd6\xcf\xe0\xd1\x6a\xe9\x31"
+			  "\xb7\x3c\x59\xd7\xe0\xc0\x89\xc0",
+	}, {
+		.plaintext = "a",
+		.psize	= 1,
+		.digest	= "\xbd\xe5\x2c\xb3\x1d\xe3\x3e\x46"
+			  "\x24\x5e\x05\xfb\xdb\xd6\xfb\x24",
+	}, {
+		.plaintext = "abc",
+		.psize	= 3,
+		.digest	= "\xa4\x48\x01\x7a\xaf\x21\xd8\x52"
+			  "\x5f\xc1\x0a\xe8\x7a\xa6\x72\x9d",
+	}, {
+		.plaintext = "message digest",
+		.psize	= 14,
+		.digest	= "\xd9\x13\x0a\x81\x64\x54\x9f\xe8"
+			"\x18\x87\x48\x06\xe1\xc7\x01\x4b",
+	}, {
+		.plaintext = "abcdefghijklmnopqrstuvwxyz",
+		.psize	= 26,
+		.digest	= "\xd7\x9e\x1c\x30\x8a\xa5\xbb\xcd"
+			  "\xee\xa8\xed\x63\xdf\x41\x2d\xa9",
+		.np	= 2,
+		.tap	= { 13, 13 },
+	}, {
+		.plaintext = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
+		.psize	= 62,
+		.digest	= "\x04\x3f\x85\x82\xf2\x41\xdb\x35"
+			  "\x1c\xe6\x27\xe1\x53\xe7\xf0\xe4",
+	}, {
+		.plaintext = "123456789012345678901234567890123456789012345678901234567890123"
+			   "45678901234567890",
+		.psize	= 80,
+		.digest	= "\xe3\x3b\x4d\xdc\x9c\x38\xf2\x19"
+			  "\x9c\x3e\x7b\x16\x4f\xcc\x05\x36",
+	},
+};
+
+/*
+ * MD5 test vectors from RFC1321
+ */
+#define MD5_TEST_VECTORS	7
+
+static struct hash_testvec md5_tv_template[] = {
+	{
+		.digest	= "\xd4\x1d\x8c\xd9\x8f\x00\xb2\x04"
+			  "\xe9\x80\x09\x98\xec\xf8\x42\x7e",
+	}, {
+		.plaintext = "a",
+		.psize	= 1,
+		.digest	= "\x0c\xc1\x75\xb9\xc0\xf1\xb6\xa8"
+			  "\x31\xc3\x99\xe2\x69\x77\x26\x61",
+	}, {
+		.plaintext = "abc",
+		.psize	= 3,
+		.digest	= "\x90\x01\x50\x98\x3c\xd2\x4f\xb0"
+			  "\xd6\x96\x3f\x7d\x28\xe1\x7f\x72",
+	}, {
+		.plaintext = "message digest",
+		.psize	= 14,
+		.digest	= "\xf9\x6b\x69\x7d\x7c\xb7\x93\x8d"
+			  "\x52\x5a\x2f\x31\xaa\xf1\x61\xd0",
+	}, {
+		.plaintext = "abcdefghijklmnopqrstuvwxyz",
+		.psize	= 26,
+		.digest	= "\xc3\xfc\xd3\xd7\x61\x92\xe4\x00"
+			  "\x7d\xfb\x49\x6c\xca\x67\xe1\x3b",
+		.np	= 2,
+		.tap	= {13, 13}
+	}, {
+		.plaintext = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
+		.psize	= 62,
+		.digest	= "\xd1\x74\xab\x98\xd2\x77\xd9\xf5"
+			  "\xa5\x61\x1c\x2c\x9f\x41\x9d\x9f",
+	}, {
+		.plaintext = "12345678901234567890123456789012345678901234567890123456789012"
+			   "345678901234567890",
+		.psize	= 80,
+		.digest	= "\x57\xed\xf4\xa2\x2b\xe3\xc9\x55"
+			  "\xac\x49\xda\x2e\x21\x07\xb6\x7a",
+	}
+
+};
+
+/*
+ * RIPEMD-128 test vectors from ISO/IEC 10118-3:2004(E)
+ */
+#define RMD128_TEST_VECTORS     10
+
+static struct hash_testvec rmd128_tv_template[] = {
+	{
+		.digest	= "\xcd\xf2\x62\x13\xa1\x50\xdc\x3e"
+			  "\xcb\x61\x0f\x18\xf6\xb3\x8b\x46",
+	}, {
+		.plaintext = "a",
+		.psize	= 1,
+		.digest	= "\x86\xbe\x7a\xfa\x33\x9d\x0f\xc7"
+			  "\xcf\xc7\x85\xe7\x2f\x57\x8d\x33",
+	}, {
+		.plaintext = "abc",
+		.psize	= 3,
+		.digest	= "\xc1\x4a\x12\x19\x9c\x66\xe4\xba"
+			  "\x84\x63\x6b\x0f\x69\x14\x4c\x77",
+	}, {
+		.plaintext = "message digest",
+		.psize	= 14,
+		.digest	= "\x9e\x32\x7b\x3d\x6e\x52\x30\x62"
+			  "\xaf\xc1\x13\x2d\x7d\xf9\xd1\xb8",
+	}, {
+		.plaintext = "abcdefghijklmnopqrstuvwxyz",
+		.psize	= 26,
+		.digest	= "\xfd\x2a\xa6\x07\xf7\x1d\xc8\xf5"
+			  "\x10\x71\x49\x22\xb3\x71\x83\x4e",
+	}, {
+		.plaintext = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcde"
+			     "fghijklmnopqrstuvwxyz0123456789",
+		.psize	= 62,
+		.digest	= "\xd1\xe9\x59\xeb\x17\x9c\x91\x1f"
+			  "\xae\xa4\x62\x4c\x60\xc5\xc7\x02",
+	}, {
+		.plaintext = "1234567890123456789012345678901234567890"
+			     "1234567890123456789012345678901234567890",
+		.psize	= 80,
+		.digest	= "\x3f\x45\xef\x19\x47\x32\xc2\xdb"
+			  "\xb2\xc4\xa2\xc7\x69\x79\x5f\xa3",
+        }, {
+		.plaintext = "abcdbcdecdefdefgefghfghighij"
+			     "hijkijkljklmklmnlmnomnopnopq",
+		.psize	= 56,
+		.digest	= "\xa1\xaa\x06\x89\xd0\xfa\xfa\x2d"
+			  "\xdc\x22\xe8\x8b\x49\x13\x3a\x06",
+		.np	= 2,
+		.tap	= { 28, 28 },
+	}, {
+		.plaintext = "abcdefghbcdefghicdefghijdefghijkefghijklfghi"
+			     "jklmghijklmnhijklmnoijklmnopjklmnopqklmnopqr"
+			     "lmnopqrsmnopqrstnopqrstu",
+		.psize	= 112,
+		.digest	= "\xd4\xec\xc9\x13\xe1\xdf\x77\x6b"
+			  "\xf4\x8d\xe9\xd5\x5b\x1f\x25\x46",
+	}, {
+		.plaintext = "abcdbcdecdefdefgefghfghighijhijk",
+		.psize	= 32,
+		.digest	= "\x13\xfc\x13\xe8\xef\xff\x34\x7d"
+			  "\xe1\x93\xff\x46\xdb\xac\xcf\xd4",
+	}
+};
+
+/*
+ * RIPEMD-160 test vectors from ISO/IEC 10118-3:2004(E)
+ */
+#define RMD160_TEST_VECTORS     10
+
+static struct hash_testvec rmd160_tv_template[] = {
+	{
+		.digest	= "\x9c\x11\x85\xa5\xc5\xe9\xfc\x54\x61\x28"
+			  "\x08\x97\x7e\xe8\xf5\x48\xb2\x25\x8d\x31",
+	}, {
+		.plaintext = "a",
+		.psize	= 1,
+		.digest	= "\x0b\xdc\x9d\x2d\x25\x6b\x3e\xe9\xda\xae"
+			  "\x34\x7b\xe6\xf4\xdc\x83\x5a\x46\x7f\xfe",
+	}, {
+		.plaintext = "abc",
+		.psize	= 3,
+		.digest	= "\x8e\xb2\x08\xf7\xe0\x5d\x98\x7a\x9b\x04"
+			  "\x4a\x8e\x98\xc6\xb0\x87\xf1\x5a\x0b\xfc",
+	}, {
+		.plaintext = "message digest",
+		.psize	= 14,
+		.digest	= "\x5d\x06\x89\xef\x49\xd2\xfa\xe5\x72\xb8"
+			  "\x81\xb1\x23\xa8\x5f\xfa\x21\x59\x5f\x36",
+	}, {
+		.plaintext = "abcdefghijklmnopqrstuvwxyz",
+		.psize	= 26,
+		.digest	= "\xf7\x1c\x27\x10\x9c\x69\x2c\x1b\x56\xbb"
+			  "\xdc\xeb\x5b\x9d\x28\x65\xb3\x70\x8d\xbc",
+	}, {
+		.plaintext = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcde"
+			     "fghijklmnopqrstuvwxyz0123456789",
+		.psize	= 62,
+		.digest	= "\xb0\xe2\x0b\x6e\x31\x16\x64\x02\x86\xed"
+			  "\x3a\x87\xa5\x71\x30\x79\xb2\x1f\x51\x89",
+	}, {
+		.plaintext = "1234567890123456789012345678901234567890"
+			     "1234567890123456789012345678901234567890",
+		.psize	= 80,
+		.digest	= "\x9b\x75\x2e\x45\x57\x3d\x4b\x39\xf4\xdb"
+			  "\xd3\x32\x3c\xab\x82\xbf\x63\x32\x6b\xfb",
+        }, {
+		.plaintext = "abcdbcdecdefdefgefghfghighij"
+			     "hijkijkljklmklmnlmnomnopnopq",
+		.psize	= 56,
+		.digest	= "\x12\xa0\x53\x38\x4a\x9c\x0c\x88\xe4\x05"
+			  "\xa0\x6c\x27\xdc\xf4\x9a\xda\x62\xeb\x2b",
+		.np	= 2,
+		.tap	= { 28, 28 },
+	}, {
+		.plaintext = "abcdefghbcdefghicdefghijdefghijkefghijklfghi"
+			     "jklmghijklmnhijklmnoijklmnopjklmnopqklmnopqr"
+			     "lmnopqrsmnopqrstnopqrstu",
+		.psize	= 112,
+		.digest	= "\x6f\x3f\xa3\x9b\x6b\x50\x3c\x38\x4f\x91"
+			  "\x9a\x49\xa7\xaa\x5c\x2c\x08\xbd\xfb\x45",
+	}, {
+		.plaintext = "abcdbcdecdefdefgefghfghighijhijk",
+		.psize	= 32,
+		.digest	= "\x94\xc2\x64\x11\x54\x04\xe6\x33\x79\x0d"
+			  "\xfc\xc8\x7b\x58\x7d\x36\x77\x06\x7d\x9f",
+	}
+};
+
+/*
+ * RIPEMD-256 test vectors
+ */
+#define RMD256_TEST_VECTORS     8
+
+static struct hash_testvec rmd256_tv_template[] = {
+	{
+		.digest	= "\x02\xba\x4c\x4e\x5f\x8e\xcd\x18"
+			  "\x77\xfc\x52\xd6\x4d\x30\xe3\x7a"
+			  "\x2d\x97\x74\xfb\x1e\x5d\x02\x63"
+			  "\x80\xae\x01\x68\xe3\xc5\x52\x2d",
+	}, {
+		.plaintext = "a",
+		.psize	= 1,
+		.digest	= "\xf9\x33\x3e\x45\xd8\x57\xf5\xd9"
+			  "\x0a\x91\xba\xb7\x0a\x1e\xba\x0c"
+			  "\xfb\x1b\xe4\xb0\x78\x3c\x9a\xcf"
+			  "\xcd\x88\x3a\x91\x34\x69\x29\x25",
+	}, {
+		.plaintext = "abc",
+		.psize	= 3,
+		.digest	= "\xaf\xbd\x6e\x22\x8b\x9d\x8c\xbb"
+			  "\xce\xf5\xca\x2d\x03\xe6\xdb\xa1"
+			  "\x0a\xc0\xbc\x7d\xcb\xe4\x68\x0e"
+			  "\x1e\x42\xd2\xe9\x75\x45\x9b\x65",
+	}, {
+		.plaintext = "message digest",
+		.psize	= 14,
+		.digest	= "\x87\xe9\x71\x75\x9a\x1c\xe4\x7a"
+			  "\x51\x4d\x5c\x91\x4c\x39\x2c\x90"
+			  "\x18\xc7\xc4\x6b\xc1\x44\x65\x55"
+			  "\x4a\xfc\xdf\x54\xa5\x07\x0c\x0e",
+	}, {
+		.plaintext = "abcdefghijklmnopqrstuvwxyz",
+		.psize	= 26,
+		.digest	= "\x64\x9d\x30\x34\x75\x1e\xa2\x16"
+			  "\x77\x6b\xf9\xa1\x8a\xcc\x81\xbc"
+			  "\x78\x96\x11\x8a\x51\x97\x96\x87"
+			  "\x82\xdd\x1f\xd9\x7d\x8d\x51\x33",
+	}, {
+		.plaintext = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcde"
+			     "fghijklmnopqrstuvwxyz0123456789",
+		.psize	= 62,
+		.digest	= "\x57\x40\xa4\x08\xac\x16\xb7\x20"
+			  "\xb8\x44\x24\xae\x93\x1c\xbb\x1f"
+			  "\xe3\x63\xd1\xd0\xbf\x40\x17\xf1"
+			  "\xa8\x9f\x7e\xa6\xde\x77\xa0\xb8",
+	}, {
+		.plaintext = "1234567890123456789012345678901234567890"
+			     "1234567890123456789012345678901234567890",
+		.psize	= 80,
+		.digest	= "\x06\xfd\xcc\x7a\x40\x95\x48\xaa"
+			  "\xf9\x13\x68\xc0\x6a\x62\x75\xb5"
+			  "\x53\xe3\xf0\x99\xbf\x0e\xa4\xed"
+			  "\xfd\x67\x78\xdf\x89\xa8\x90\xdd",
+        }, {
+		.plaintext = "abcdbcdecdefdefgefghfghighij"
+			     "hijkijkljklmklmnlmnomnopnopq",
+		.psize	= 56,
+		.digest	= "\x38\x43\x04\x55\x83\xaa\xc6\xc8"
+			  "\xc8\xd9\x12\x85\x73\xe7\xa9\x80"
+			  "\x9a\xfb\x2a\x0f\x34\xcc\xc3\x6e"
+			  "\xa9\xe7\x2f\x16\xf6\x36\x8e\x3f",
+		.np	= 2,
+		.tap	= { 28, 28 },
+	}
+};
+
+/*
+ * RIPEMD-320 test vectors
+ */
+#define RMD320_TEST_VECTORS     8
+
+static struct hash_testvec rmd320_tv_template[] = {
+	{
+		.digest	= "\x22\xd6\x5d\x56\x61\x53\x6c\xdc\x75\xc1"
+			  "\xfd\xf5\xc6\xde\x7b\x41\xb9\xf2\x73\x25"
+			  "\xeb\xc6\x1e\x85\x57\x17\x7d\x70\x5a\x0e"
+			  "\xc8\x80\x15\x1c\x3a\x32\xa0\x08\x99\xb8",
+	}, {
+		.plaintext = "a",
+		.psize	= 1,
+		.digest	= "\xce\x78\x85\x06\x38\xf9\x26\x58\xa5\xa5"
+			  "\x85\x09\x75\x79\x92\x6d\xda\x66\x7a\x57"
+			  "\x16\x56\x2c\xfc\xf6\xfb\xe7\x7f\x63\x54"
+			  "\x2f\x99\xb0\x47\x05\xd6\x97\x0d\xff\x5d",
+	}, {
+		.plaintext = "abc",
+		.psize	= 3,
+		.digest	= "\xde\x4c\x01\xb3\x05\x4f\x89\x30\xa7\x9d"
+			  "\x09\xae\x73\x8e\x92\x30\x1e\x5a\x17\x08"
+			  "\x5b\xef\xfd\xc1\xb8\xd1\x16\x71\x3e\x74"
+			  "\xf8\x2f\xa9\x42\xd6\x4c\xdb\xc4\x68\x2d",
+	}, {
+		.plaintext = "message digest",
+		.psize	= 14,
+		.digest	= "\x3a\x8e\x28\x50\x2e\xd4\x5d\x42\x2f\x68"
+			  "\x84\x4f\x9d\xd3\x16\xe7\xb9\x85\x33\xfa"
+			  "\x3f\x2a\x91\xd2\x9f\x84\xd4\x25\xc8\x8d"
+			  "\x6b\x4e\xff\x72\x7d\xf6\x6a\x7c\x01\x97",
+	}, {
+		.plaintext = "abcdefghijklmnopqrstuvwxyz",
+		.psize	= 26,
+		.digest	= "\xca\xbd\xb1\x81\x0b\x92\x47\x0a\x20\x93"
+			  "\xaa\x6b\xce\x05\x95\x2c\x28\x34\x8c\xf4"
+			  "\x3f\xf6\x08\x41\x97\x51\x66\xbb\x40\xed"
+			  "\x23\x40\x04\xb8\x82\x44\x63\xe6\xb0\x09",
+	}, {
+		.plaintext = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcde"
+			     "fghijklmnopqrstuvwxyz0123456789",
+		.psize	= 62,
+		.digest	= "\xed\x54\x49\x40\xc8\x6d\x67\xf2\x50\xd2"
+			  "\x32\xc3\x0b\x7b\x3e\x57\x70\xe0\xc6\x0c"
+			  "\x8c\xb9\xa4\xca\xfe\x3b\x11\x38\x8a\xf9"
+			  "\x92\x0e\x1b\x99\x23\x0b\x84\x3c\x86\xa4",
+	}, {
+		.plaintext = "1234567890123456789012345678901234567890"
+			     "1234567890123456789012345678901234567890",
+		.psize	= 80,
+		.digest	= "\x55\x78\x88\xaf\x5f\x6d\x8e\xd6\x2a\xb6"
+			  "\x69\x45\xc6\xd2\xa0\xa4\x7e\xcd\x53\x41"
+			  "\xe9\x15\xeb\x8f\xea\x1d\x05\x24\x95\x5f"
+			  "\x82\x5d\xc7\x17\xe4\xa0\x08\xab\x2d\x42",
+        }, {
+		.plaintext = "abcdbcdecdefdefgefghfghighij"
+			     "hijkijkljklmklmnlmnomnopnopq",
+		.psize	= 56,
+		.digest	= "\xd0\x34\xa7\x95\x0c\xf7\x22\x02\x1b\xa4"
+			  "\xb8\x4d\xf7\x69\xa5\xde\x20\x60\xe2\x59"
+			  "\xdf\x4c\x9b\xb4\xa4\x26\x8c\x0e\x93\x5b"
+			  "\xbc\x74\x70\xa9\x69\xc9\xd0\x72\xa1\xac",
+		.np	= 2,
+		.tap	= { 28, 28 },
+	}
+};
+
+/*
+ * SHA1 test vectors  from from FIPS PUB 180-1
+ */
+#define SHA1_TEST_VECTORS	2
+
+static struct hash_testvec sha1_tv_template[] = {
+	{
+		.plaintext = "abc",
+		.psize	= 3,
+		.digest	= "\xa9\x99\x3e\x36\x47\x06\x81\x6a\xba\x3e"
+			  "\x25\x71\x78\x50\xc2\x6c\x9c\xd0\xd8\x9d",
+	}, {
+		.plaintext = "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
+		.psize	= 56,
+		.digest	= "\x84\x98\x3e\x44\x1c\x3b\xd2\x6e\xba\xae"
+			  "\x4a\xa1\xf9\x51\x29\xe5\xe5\x46\x70\xf1",
+		.np	= 2,
+		.tap	= { 28, 28 }
+	}
+};
+
+
+/*
+ * SHA224 test vectors from from FIPS PUB 180-2
+ */
+#define SHA224_TEST_VECTORS     2
+
+static struct hash_testvec sha224_tv_template[] = {
+	{
+		.plaintext = "abc",
+		.psize  = 3,
+		.digest = "\x23\x09\x7D\x22\x34\x05\xD8\x22"
+			  "\x86\x42\xA4\x77\xBD\xA2\x55\xB3"
+			  "\x2A\xAD\xBC\xE4\xBD\xA0\xB3\xF7"
+			  "\xE3\x6C\x9D\xA7",
+	}, {
+		.plaintext =
+		"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
+		.psize  = 56,
+		.digest = "\x75\x38\x8B\x16\x51\x27\x76\xCC"
+			  "\x5D\xBA\x5D\xA1\xFD\x89\x01\x50"
+			  "\xB0\xC6\x45\x5C\xB4\xF5\x8B\x19"
+			  "\x52\x52\x25\x25",
+		.np     = 2,
+		.tap    = { 28, 28 }
+	}
+};
+
+/*
+ * SHA256 test vectors from from NIST
+ */
+#define SHA256_TEST_VECTORS	2
+
+static struct hash_testvec sha256_tv_template[] = {
+	{
+		.plaintext = "abc",
+		.psize	= 3,
+		.digest	= "\xba\x78\x16\xbf\x8f\x01\xcf\xea"
+			  "\x41\x41\x40\xde\x5d\xae\x22\x23"
+			  "\xb0\x03\x61\xa3\x96\x17\x7a\x9c"
+			  "\xb4\x10\xff\x61\xf2\x00\x15\xad",
+	}, {
+		.plaintext = "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
+		.psize	= 56,
+		.digest	= "\x24\x8d\x6a\x61\xd2\x06\x38\xb8"
+			  "\xe5\xc0\x26\x93\x0c\x3e\x60\x39"
+			  "\xa3\x3c\xe4\x59\x64\xff\x21\x67"
+			  "\xf6\xec\xed\xd4\x19\xdb\x06\xc1",
+		.np	= 2,
+		.tap	= { 28, 28 }
+	},
+};
+
+/*
+ * SHA384 test vectors from from NIST and kerneli
+ */
+#define SHA384_TEST_VECTORS	4
+
+static struct hash_testvec sha384_tv_template[] = {
+	{
+		.plaintext= "abc",
+		.psize	= 3,
+		.digest	= "\xcb\x00\x75\x3f\x45\xa3\x5e\x8b"
+			  "\xb5\xa0\x3d\x69\x9a\xc6\x50\x07"
+			  "\x27\x2c\x32\xab\x0e\xde\xd1\x63"
+			  "\x1a\x8b\x60\x5a\x43\xff\x5b\xed"
+			  "\x80\x86\x07\x2b\xa1\xe7\xcc\x23"
+			  "\x58\xba\xec\xa1\x34\xc8\x25\xa7",
+	}, {
+		.plaintext = "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
+		.psize	= 56,
+		.digest	= "\x33\x91\xfd\xdd\xfc\x8d\xc7\x39"
+			  "\x37\x07\xa6\x5b\x1b\x47\x09\x39"
+			  "\x7c\xf8\xb1\xd1\x62\xaf\x05\xab"
+			  "\xfe\x8f\x45\x0d\xe5\xf3\x6b\xc6"
+			  "\xb0\x45\x5a\x85\x20\xbc\x4e\x6f"
+			  "\x5f\xe9\x5b\x1f\xe3\xc8\x45\x2b",
+	}, {
+		.plaintext = "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn"
+			   "hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu",
+		.psize	= 112,
+		.digest	= "\x09\x33\x0c\x33\xf7\x11\x47\xe8"
+			  "\x3d\x19\x2f\xc7\x82\xcd\x1b\x47"
+			  "\x53\x11\x1b\x17\x3b\x3b\x05\xd2"
+			  "\x2f\xa0\x80\x86\xe3\xb0\xf7\x12"
+			  "\xfc\xc7\xc7\x1a\x55\x7e\x2d\xb9"
+			  "\x66\xc3\xe9\xfa\x91\x74\x60\x39",
+	}, {
+		.plaintext = "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd"
+			   "efghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz",
+		.psize	= 104,
+		.digest	= "\x3d\x20\x89\x73\xab\x35\x08\xdb"
+			  "\xbd\x7e\x2c\x28\x62\xba\x29\x0a"
+			  "\xd3\x01\x0e\x49\x78\xc1\x98\xdc"
+			  "\x4d\x8f\xd0\x14\xe5\x82\x82\x3a"
+			  "\x89\xe1\x6f\x9b\x2a\x7b\xbc\x1a"
+			  "\xc9\x38\xe2\xd1\x99\xe8\xbe\xa4",
+		.np	= 4,
+		.tap	= { 26, 26, 26, 26 }
+	},
+};
+
+/*
+ * SHA512 test vectors from from NIST and kerneli
+ */
+#define SHA512_TEST_VECTORS	4
+
+static struct hash_testvec sha512_tv_template[] = {
+	{
+		.plaintext = "abc",
+		.psize	= 3,
+		.digest	= "\xdd\xaf\x35\xa1\x93\x61\x7a\xba"
+			  "\xcc\x41\x73\x49\xae\x20\x41\x31"
+			  "\x12\xe6\xfa\x4e\x89\xa9\x7e\xa2"
+			  "\x0a\x9e\xee\xe6\x4b\x55\xd3\x9a"
+			  "\x21\x92\x99\x2a\x27\x4f\xc1\xa8"
+			  "\x36\xba\x3c\x23\xa3\xfe\xeb\xbd"
+			  "\x45\x4d\x44\x23\x64\x3c\xe8\x0e"
+			  "\x2a\x9a\xc9\x4f\xa5\x4c\xa4\x9f",
+	}, {
+		.plaintext = "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
+		.psize	= 56,
+		.digest	= "\x20\x4a\x8f\xc6\xdd\xa8\x2f\x0a"
+			  "\x0c\xed\x7b\xeb\x8e\x08\xa4\x16"
+			  "\x57\xc1\x6e\xf4\x68\xb2\x28\xa8"
+			  "\x27\x9b\xe3\x31\xa7\x03\xc3\x35"
+			  "\x96\xfd\x15\xc1\x3b\x1b\x07\xf9"
+			  "\xaa\x1d\x3b\xea\x57\x78\x9c\xa0"
+			  "\x31\xad\x85\xc7\xa7\x1d\xd7\x03"
+			  "\x54\xec\x63\x12\x38\xca\x34\x45",
+	}, {
+		.plaintext = "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn"
+			   "hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu",
+		.psize	= 112,
+		.digest	= "\x8e\x95\x9b\x75\xda\xe3\x13\xda"
+			  "\x8c\xf4\xf7\x28\x14\xfc\x14\x3f"
+			  "\x8f\x77\x79\xc6\xeb\x9f\x7f\xa1"
+			  "\x72\x99\xae\xad\xb6\x88\x90\x18"
+			  "\x50\x1d\x28\x9e\x49\x00\xf7\xe4"
+			  "\x33\x1b\x99\xde\xc4\xb5\x43\x3a"
+			  "\xc7\xd3\x29\xee\xb6\xdd\x26\x54"
+			  "\x5e\x96\xe5\x5b\x87\x4b\xe9\x09",
+	}, {
+		.plaintext = "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd"
+			   "efghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz",
+		.psize	= 104,
+		.digest	= "\x93\x0d\x0c\xef\xcb\x30\xff\x11"
+			  "\x33\xb6\x89\x81\x21\xf1\xcf\x3d"
+			  "\x27\x57\x8a\xfc\xaf\xe8\x67\x7c"
+			  "\x52\x57\xcf\x06\x99\x11\xf7\x5d"
+			  "\x8f\x58\x31\xb5\x6e\xbf\xda\x67"
+			  "\xb2\x78\xe6\x6d\xff\x8b\x84\xfe"
+			  "\x2b\x28\x70\xf7\x42\xa5\x80\xd8"
+			  "\xed\xb4\x19\x87\x23\x28\x50\xc9",
+		.np	= 4,
+		.tap	= { 26, 26, 26, 26 }
+	},
+};
+
+
+/*
+ * WHIRLPOOL test vectors from Whirlpool package
+ * by Vincent Rijmen and Paulo S. L. M. Barreto as part of the NESSIE
+ * submission
+ */
+#define WP512_TEST_VECTORS	8
+
+static struct hash_testvec wp512_tv_template[] = {
+	{
+		.plaintext = "",
+		.psize	= 0,
+		.digest	= "\x19\xFA\x61\xD7\x55\x22\xA4\x66"
+			  "\x9B\x44\xE3\x9C\x1D\x2E\x17\x26"
+			  "\xC5\x30\x23\x21\x30\xD4\x07\xF8"
+			  "\x9A\xFE\xE0\x96\x49\x97\xF7\xA7"
+			  "\x3E\x83\xBE\x69\x8B\x28\x8F\xEB"
+			  "\xCF\x88\xE3\xE0\x3C\x4F\x07\x57"
+			  "\xEA\x89\x64\xE5\x9B\x63\xD9\x37"
+			  "\x08\xB1\x38\xCC\x42\xA6\x6E\xB3",
+
+
+	}, {
+		.plaintext = "a",
+		.psize	= 1,
+		.digest	= "\x8A\xCA\x26\x02\x79\x2A\xEC\x6F"
+			  "\x11\xA6\x72\x06\x53\x1F\xB7\xD7"
+			  "\xF0\xDF\xF5\x94\x13\x14\x5E\x69"
+			  "\x73\xC4\x50\x01\xD0\x08\x7B\x42"
+			  "\xD1\x1B\xC6\x45\x41\x3A\xEF\xF6"
+			  "\x3A\x42\x39\x1A\x39\x14\x5A\x59"
+			  "\x1A\x92\x20\x0D\x56\x01\x95\xE5"
+			  "\x3B\x47\x85\x84\xFD\xAE\x23\x1A",
+	}, {
+		.plaintext = "abc",
+		.psize	= 3,
+		.digest	= "\x4E\x24\x48\xA4\xC6\xF4\x86\xBB"
+			  "\x16\xB6\x56\x2C\x73\xB4\x02\x0B"
+			  "\xF3\x04\x3E\x3A\x73\x1B\xCE\x72"
+			  "\x1A\xE1\xB3\x03\xD9\x7E\x6D\x4C"
+			  "\x71\x81\xEE\xBD\xB6\xC5\x7E\x27"
+			  "\x7D\x0E\x34\x95\x71\x14\xCB\xD6"
+			  "\xC7\x97\xFC\x9D\x95\xD8\xB5\x82"
+			  "\xD2\x25\x29\x20\x76\xD4\xEE\xF5",
+	}, {
+		.plaintext = "message digest",
+		.psize	= 14,
+		.digest	= "\x37\x8C\x84\xA4\x12\x6E\x2D\xC6"
+			  "\xE5\x6D\xCC\x74\x58\x37\x7A\xAC"
+			  "\x83\x8D\x00\x03\x22\x30\xF5\x3C"
+			  "\xE1\xF5\x70\x0C\x0F\xFB\x4D\x3B"
+			  "\x84\x21\x55\x76\x59\xEF\x55\xC1"
+			  "\x06\xB4\xB5\x2A\xC5\xA4\xAA\xA6"
+			  "\x92\xED\x92\x00\x52\x83\x8F\x33"
+			  "\x62\xE8\x6D\xBD\x37\xA8\x90\x3E",
+	}, {
+		.plaintext = "abcdefghijklmnopqrstuvwxyz",
+		.psize	= 26,
+		.digest	= "\xF1\xD7\x54\x66\x26\x36\xFF\xE9"
+			  "\x2C\x82\xEB\xB9\x21\x2A\x48\x4A"
+			  "\x8D\x38\x63\x1E\xAD\x42\x38\xF5"
+			  "\x44\x2E\xE1\x3B\x80\x54\xE4\x1B"
+			  "\x08\xBF\x2A\x92\x51\xC3\x0B\x6A"
+			  "\x0B\x8A\xAE\x86\x17\x7A\xB4\xA6"
+			  "\xF6\x8F\x67\x3E\x72\x07\x86\x5D"
+			  "\x5D\x98\x19\xA3\xDB\xA4\xEB\x3B",
+	}, {
+		.plaintext = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+			   "abcdefghijklmnopqrstuvwxyz0123456789",
+		.psize	= 62,
+		.digest	= "\xDC\x37\xE0\x08\xCF\x9E\xE6\x9B"
+			  "\xF1\x1F\x00\xED\x9A\xBA\x26\x90"
+			  "\x1D\xD7\xC2\x8C\xDE\xC0\x66\xCC"
+			  "\x6A\xF4\x2E\x40\xF8\x2F\x3A\x1E"
+			  "\x08\xEB\xA2\x66\x29\x12\x9D\x8F"
+			  "\xB7\xCB\x57\x21\x1B\x92\x81\xA6"
+			  "\x55\x17\xCC\x87\x9D\x7B\x96\x21"
+			  "\x42\xC6\x5F\x5A\x7A\xF0\x14\x67",
+	}, {
+		.plaintext = "1234567890123456789012345678901234567890"
+			   "1234567890123456789012345678901234567890",
+		.psize	= 80,
+		.digest	= "\x46\x6E\xF1\x8B\xAB\xB0\x15\x4D"
+			  "\x25\xB9\xD3\x8A\x64\x14\xF5\xC0"
+			  "\x87\x84\x37\x2B\xCC\xB2\x04\xD6"
+			  "\x54\x9C\x4A\xFA\xDB\x60\x14\x29"
+			  "\x4D\x5B\xD8\xDF\x2A\x6C\x44\xE5"
+			  "\x38\xCD\x04\x7B\x26\x81\xA5\x1A"
+			  "\x2C\x60\x48\x1E\x88\xC5\xA2\x0B"
+			  "\x2C\x2A\x80\xCF\x3A\x9A\x08\x3B",
+	}, {
+		.plaintext = "abcdbcdecdefdefgefghfghighijhijk",
+		.psize	= 32,
+		.digest	= "\x2A\x98\x7E\xA4\x0F\x91\x70\x61"
+			  "\xF5\xD6\xF0\xA0\xE4\x64\x4F\x48"
+			  "\x8A\x7A\x5A\x52\xDE\xEE\x65\x62"
+			  "\x07\xC5\x62\xF9\x88\xE9\x5C\x69"
+			  "\x16\xBD\xC8\x03\x1B\xC5\xBE\x1B"
+			  "\x7B\x94\x76\x39\xFE\x05\x0B\x56"
+			  "\x93\x9B\xAA\xA0\xAD\xFF\x9A\xE6"
+			  "\x74\x5B\x7B\x18\x1C\x3B\xE3\xFD",
+	},
+};
+
+#define WP384_TEST_VECTORS	8
+
+static struct hash_testvec wp384_tv_template[] = {
+	{
+		.plaintext = "",
+		.psize	= 0,
+		.digest	= "\x19\xFA\x61\xD7\x55\x22\xA4\x66"
+			  "\x9B\x44\xE3\x9C\x1D\x2E\x17\x26"
+			  "\xC5\x30\x23\x21\x30\xD4\x07\xF8"
+			  "\x9A\xFE\xE0\x96\x49\x97\xF7\xA7"
+			  "\x3E\x83\xBE\x69\x8B\x28\x8F\xEB"
+			  "\xCF\x88\xE3\xE0\x3C\x4F\x07\x57",
+
+
+	}, {
+		.plaintext = "a",
+		.psize	= 1,
+		.digest	= "\x8A\xCA\x26\x02\x79\x2A\xEC\x6F"
+			  "\x11\xA6\x72\x06\x53\x1F\xB7\xD7"
+			  "\xF0\xDF\xF5\x94\x13\x14\x5E\x69"
+			  "\x73\xC4\x50\x01\xD0\x08\x7B\x42"
+			  "\xD1\x1B\xC6\x45\x41\x3A\xEF\xF6"
+			  "\x3A\x42\x39\x1A\x39\x14\x5A\x59",
+	}, {
+		.plaintext = "abc",
+		.psize	= 3,
+		.digest	= "\x4E\x24\x48\xA4\xC6\xF4\x86\xBB"
+			  "\x16\xB6\x56\x2C\x73\xB4\x02\x0B"
+			  "\xF3\x04\x3E\x3A\x73\x1B\xCE\x72"
+			  "\x1A\xE1\xB3\x03\xD9\x7E\x6D\x4C"
+			  "\x71\x81\xEE\xBD\xB6\xC5\x7E\x27"
+			  "\x7D\x0E\x34\x95\x71\x14\xCB\xD6",
+	}, {
+		.plaintext = "message digest",
+		.psize	= 14,
+		.digest	= "\x37\x8C\x84\xA4\x12\x6E\x2D\xC6"
+			  "\xE5\x6D\xCC\x74\x58\x37\x7A\xAC"
+			  "\x83\x8D\x00\x03\x22\x30\xF5\x3C"
+			  "\xE1\xF5\x70\x0C\x0F\xFB\x4D\x3B"
+			  "\x84\x21\x55\x76\x59\xEF\x55\xC1"
+			  "\x06\xB4\xB5\x2A\xC5\xA4\xAA\xA6",
+	}, {
+		.plaintext = "abcdefghijklmnopqrstuvwxyz",
+		.psize	= 26,
+		.digest	= "\xF1\xD7\x54\x66\x26\x36\xFF\xE9"
+			  "\x2C\x82\xEB\xB9\x21\x2A\x48\x4A"
+			  "\x8D\x38\x63\x1E\xAD\x42\x38\xF5"
+			  "\x44\x2E\xE1\x3B\x80\x54\xE4\x1B"
+			  "\x08\xBF\x2A\x92\x51\xC3\x0B\x6A"
+			  "\x0B\x8A\xAE\x86\x17\x7A\xB4\xA6",
+	}, {
+		.plaintext = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+			   "abcdefghijklmnopqrstuvwxyz0123456789",
+		.psize	= 62,
+		.digest	= "\xDC\x37\xE0\x08\xCF\x9E\xE6\x9B"
+			  "\xF1\x1F\x00\xED\x9A\xBA\x26\x90"
+			  "\x1D\xD7\xC2\x8C\xDE\xC0\x66\xCC"
+			  "\x6A\xF4\x2E\x40\xF8\x2F\x3A\x1E"
+			  "\x08\xEB\xA2\x66\x29\x12\x9D\x8F"
+			  "\xB7\xCB\x57\x21\x1B\x92\x81\xA6",
+	}, {
+		.plaintext = "1234567890123456789012345678901234567890"
+			   "1234567890123456789012345678901234567890",
+		.psize	= 80,
+		.digest	= "\x46\x6E\xF1\x8B\xAB\xB0\x15\x4D"
+			  "\x25\xB9\xD3\x8A\x64\x14\xF5\xC0"
+			  "\x87\x84\x37\x2B\xCC\xB2\x04\xD6"
+			  "\x54\x9C\x4A\xFA\xDB\x60\x14\x29"
+			  "\x4D\x5B\xD8\xDF\x2A\x6C\x44\xE5"
+			  "\x38\xCD\x04\x7B\x26\x81\xA5\x1A",
+	}, {
+		.plaintext = "abcdbcdecdefdefgefghfghighijhijk",
+		.psize	= 32,
+		.digest	= "\x2A\x98\x7E\xA4\x0F\x91\x70\x61"
+			  "\xF5\xD6\xF0\xA0\xE4\x64\x4F\x48"
+			  "\x8A\x7A\x5A\x52\xDE\xEE\x65\x62"
+			  "\x07\xC5\x62\xF9\x88\xE9\x5C\x69"
+			  "\x16\xBD\xC8\x03\x1B\xC5\xBE\x1B"
+			  "\x7B\x94\x76\x39\xFE\x05\x0B\x56",
+	},
+};
+
+#define WP256_TEST_VECTORS	8
+
+static struct hash_testvec wp256_tv_template[] = {
+	{
+		.plaintext = "",
+		.psize	= 0,
+		.digest	= "\x19\xFA\x61\xD7\x55\x22\xA4\x66"
+			  "\x9B\x44\xE3\x9C\x1D\x2E\x17\x26"
+			  "\xC5\x30\x23\x21\x30\xD4\x07\xF8"
+			  "\x9A\xFE\xE0\x96\x49\x97\xF7\xA7",
+
+
+	}, {
+		.plaintext = "a",
+		.psize	= 1,
+		.digest	= "\x8A\xCA\x26\x02\x79\x2A\xEC\x6F"
+			  "\x11\xA6\x72\x06\x53\x1F\xB7\xD7"
+			  "\xF0\xDF\xF5\x94\x13\x14\x5E\x69"
+			  "\x73\xC4\x50\x01\xD0\x08\x7B\x42",
+	}, {
+		.plaintext = "abc",
+		.psize	= 3,
+		.digest	= "\x4E\x24\x48\xA4\xC6\xF4\x86\xBB"
+			  "\x16\xB6\x56\x2C\x73\xB4\x02\x0B"
+			  "\xF3\x04\x3E\x3A\x73\x1B\xCE\x72"
+			  "\x1A\xE1\xB3\x03\xD9\x7E\x6D\x4C",
+	}, {
+		.plaintext = "message digest",
+		.psize	= 14,
+		.digest	= "\x37\x8C\x84\xA4\x12\x6E\x2D\xC6"
+			  "\xE5\x6D\xCC\x74\x58\x37\x7A\xAC"
+			  "\x83\x8D\x00\x03\x22\x30\xF5\x3C"
+			  "\xE1\xF5\x70\x0C\x0F\xFB\x4D\x3B",
+	}, {
+		.plaintext = "abcdefghijklmnopqrstuvwxyz",
+		.psize	= 26,
+		.digest	= "\xF1\xD7\x54\x66\x26\x36\xFF\xE9"
+			  "\x2C\x82\xEB\xB9\x21\x2A\x48\x4A"
+			  "\x8D\x38\x63\x1E\xAD\x42\x38\xF5"
+			  "\x44\x2E\xE1\x3B\x80\x54\xE4\x1B",
+	}, {
+		.plaintext = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+			   "abcdefghijklmnopqrstuvwxyz0123456789",
+		.psize	= 62,
+		.digest	= "\xDC\x37\xE0\x08\xCF\x9E\xE6\x9B"
+			  "\xF1\x1F\x00\xED\x9A\xBA\x26\x90"
+			  "\x1D\xD7\xC2\x8C\xDE\xC0\x66\xCC"
+			  "\x6A\xF4\x2E\x40\xF8\x2F\x3A\x1E",
+	}, {
+		.plaintext = "1234567890123456789012345678901234567890"
+			   "1234567890123456789012345678901234567890",
+		.psize	= 80,
+		.digest	= "\x46\x6E\xF1\x8B\xAB\xB0\x15\x4D"
+			  "\x25\xB9\xD3\x8A\x64\x14\xF5\xC0"
+			  "\x87\x84\x37\x2B\xCC\xB2\x04\xD6"
+			  "\x54\x9C\x4A\xFA\xDB\x60\x14\x29",
+	}, {
+		.plaintext = "abcdbcdecdefdefgefghfghighijhijk",
+		.psize	= 32,
+		.digest	= "\x2A\x98\x7E\xA4\x0F\x91\x70\x61"
+			  "\xF5\xD6\xF0\xA0\xE4\x64\x4F\x48"
+			  "\x8A\x7A\x5A\x52\xDE\xEE\x65\x62"
+			  "\x07\xC5\x62\xF9\x88\xE9\x5C\x69",
+	},
+};
+
+/*
+ * TIGER test vectors from Tiger website
+ */
+#define TGR192_TEST_VECTORS	6
+
+static struct hash_testvec tgr192_tv_template[] = {
+	{
+		.plaintext = "",
+		.psize	= 0,
+		.digest = "\x24\xf0\x13\x0c\x63\xac\x93\x32"
+			  "\x16\x16\x6e\x76\xb1\xbb\x92\x5f"
+			  "\xf3\x73\xde\x2d\x49\x58\x4e\x7a",
+	}, {
+		.plaintext = "abc",
+		.psize	= 3,
+		.digest = "\xf2\x58\xc1\xe8\x84\x14\xab\x2a"
+			  "\x52\x7a\xb5\x41\xff\xc5\xb8\xbf"
+			  "\x93\x5f\x7b\x95\x1c\x13\x29\x51",
+	}, {
+		.plaintext = "Tiger",
+		.psize	= 5,
+		.digest = "\x9f\x00\xf5\x99\x07\x23\x00\xdd"
+			  "\x27\x6a\xbb\x38\xc8\xeb\x6d\xec"
+			  "\x37\x79\x0c\x11\x6f\x9d\x2b\xdf",
+	}, {
+		.plaintext = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-",
+		.psize	= 64,
+		.digest = "\x87\xfb\x2a\x90\x83\x85\x1c\xf7"
+			  "\x47\x0d\x2c\xf8\x10\xe6\xdf\x9e"
+			  "\xb5\x86\x44\x50\x34\xa5\xa3\x86",
+	}, {
+		.plaintext = "ABCDEFGHIJKLMNOPQRSTUVWXYZ=abcdefghijklmnopqrstuvwxyz+0123456789",
+		.psize	= 64,
+		.digest = "\x46\x7d\xb8\x08\x63\xeb\xce\x48"
+			  "\x8d\xf1\xcd\x12\x61\x65\x5d\xe9"
+			  "\x57\x89\x65\x65\x97\x5f\x91\x97",
+	}, {
+		.plaintext = "Tiger - A Fast New Hash Function, "
+			   "by Ross Anderson and Eli Biham, "
+			   "proceedings of Fast Software Encryption 3, "
+			   "Cambridge, 1996.",
+		.psize  = 125,
+		.digest = "\x3d\x9a\xeb\x03\xd1\xbd\x1a\x63"
+			  "\x57\xb2\x77\x4d\xfd\x6d\x5b\x24"
+			  "\xdd\x68\x15\x1d\x50\x39\x74\xfc",
+	},
+};
+
+#define TGR160_TEST_VECTORS	6
+
+static struct hash_testvec tgr160_tv_template[] = {
+	{
+		.plaintext = "",
+		.psize	= 0,
+		.digest = "\x24\xf0\x13\x0c\x63\xac\x93\x32"
+			  "\x16\x16\x6e\x76\xb1\xbb\x92\x5f"
+			  "\xf3\x73\xde\x2d",
+	}, {
+		.plaintext = "abc",
+		.psize	= 3,
+		.digest = "\xf2\x58\xc1\xe8\x84\x14\xab\x2a"
+			  "\x52\x7a\xb5\x41\xff\xc5\xb8\xbf"
+			  "\x93\x5f\x7b\x95",
+	}, {
+		.plaintext = "Tiger",
+		.psize	= 5,
+		.digest = "\x9f\x00\xf5\x99\x07\x23\x00\xdd"
+			  "\x27\x6a\xbb\x38\xc8\xeb\x6d\xec"
+			  "\x37\x79\x0c\x11",
+	}, {
+		.plaintext = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-",
+		.psize	= 64,
+		.digest = "\x87\xfb\x2a\x90\x83\x85\x1c\xf7"
+			  "\x47\x0d\x2c\xf8\x10\xe6\xdf\x9e"
+			  "\xb5\x86\x44\x50",
+	}, {
+		.plaintext = "ABCDEFGHIJKLMNOPQRSTUVWXYZ=abcdefghijklmnopqrstuvwxyz+0123456789",
+		.psize	= 64,
+		.digest = "\x46\x7d\xb8\x08\x63\xeb\xce\x48"
+			  "\x8d\xf1\xcd\x12\x61\x65\x5d\xe9"
+			  "\x57\x89\x65\x65",
+	}, {
+		.plaintext = "Tiger - A Fast New Hash Function, "
+			   "by Ross Anderson and Eli Biham, "
+			   "proceedings of Fast Software Encryption 3, "
+			   "Cambridge, 1996.",
+		.psize  = 125,
+		.digest = "\x3d\x9a\xeb\x03\xd1\xbd\x1a\x63"
+			  "\x57\xb2\x77\x4d\xfd\x6d\x5b\x24"
+			  "\xdd\x68\x15\x1d",
+	},
+};
+
+#define TGR128_TEST_VECTORS	6
+
+static struct hash_testvec tgr128_tv_template[] = {
+	{
+		.plaintext = "",
+		.psize	= 0,
+		.digest = "\x24\xf0\x13\x0c\x63\xac\x93\x32"
+			  "\x16\x16\x6e\x76\xb1\xbb\x92\x5f",
+	}, {
+		.plaintext = "abc",
+		.psize	= 3,
+		.digest = "\xf2\x58\xc1\xe8\x84\x14\xab\x2a"
+			  "\x52\x7a\xb5\x41\xff\xc5\xb8\xbf",
+	}, {
+		.plaintext = "Tiger",
+		.psize	= 5,
+		.digest = "\x9f\x00\xf5\x99\x07\x23\x00\xdd"
+			  "\x27\x6a\xbb\x38\xc8\xeb\x6d\xec",
+	}, {
+		.plaintext = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-",
+		.psize	= 64,
+		.digest = "\x87\xfb\x2a\x90\x83\x85\x1c\xf7"
+			  "\x47\x0d\x2c\xf8\x10\xe6\xdf\x9e",
+	}, {
+		.plaintext = "ABCDEFGHIJKLMNOPQRSTUVWXYZ=abcdefghijklmnopqrstuvwxyz+0123456789",
+		.psize	= 64,
+		.digest = "\x46\x7d\xb8\x08\x63\xeb\xce\x48"
+			  "\x8d\xf1\xcd\x12\x61\x65\x5d\xe9",
+	}, {
+		.plaintext = "Tiger - A Fast New Hash Function, "
+			   "by Ross Anderson and Eli Biham, "
+			   "proceedings of Fast Software Encryption 3, "
+			   "Cambridge, 1996.",
+		.psize  = 125,
+		.digest = "\x3d\x9a\xeb\x03\xd1\xbd\x1a\x63"
+			  "\x57\xb2\x77\x4d\xfd\x6d\x5b\x24",
+	},
+};
+
+/*
+ * HMAC-MD5 test vectors from RFC2202
+ * (These need to be fixed to not use strlen).
+ */
+#define HMAC_MD5_TEST_VECTORS	7
+
+static struct hash_testvec hmac_md5_tv_template[] =
+{
+	{
+		.key	= "\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b",
+		.ksize	= 16,
+		.plaintext = "Hi There",
+		.psize	= 8,
+		.digest	= "\x92\x94\x72\x7a\x36\x38\xbb\x1c"
+			  "\x13\xf4\x8e\xf8\x15\x8b\xfc\x9d",
+	}, {
+		.key	= "Jefe",
+		.ksize	= 4,
+		.plaintext = "what do ya want for nothing?",
+		.psize	= 28,
+		.digest	= "\x75\x0c\x78\x3e\x6a\xb0\xb5\x03"
+			  "\xea\xa8\x6e\x31\x0a\x5d\xb7\x38",
+		.np	= 2,
+		.tap	= {14, 14}
+	}, {
+		.key	= "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa",
+		.ksize	= 16,
+		.plaintext = "\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd"
+			"\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd"
+			"\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd"
+			"\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd",
+		.psize	= 50,
+		.digest	= "\x56\xbe\x34\x52\x1d\x14\x4c\x88"
+			  "\xdb\xb8\xc7\x33\xf0\xe8\xb3\xf6",
+	}, {
+		.key	= "\x01\x02\x03\x04\x05\x06\x07\x08"
+			  "\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
+			  "\x11\x12\x13\x14\x15\x16\x17\x18\x19",
+		.ksize	= 25,
+		.plaintext = "\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd"
+			"\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd"
+			"\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd"
+			"\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd",
+		.psize	= 50,
+		.digest	= "\x69\x7e\xaf\x0a\xca\x3a\x3a\xea"
+			  "\x3a\x75\x16\x47\x46\xff\xaa\x79",
+	}, {
+		.key	= "\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c",
+		.ksize	= 16,
+		.plaintext = "Test With Truncation",
+		.psize	= 20,
+		.digest	= "\x56\x46\x1e\xf2\x34\x2e\xdc\x00"
+			  "\xf9\xba\xb9\x95\x69\x0e\xfd\x4c",
+	}, {
+		.key	= "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa",
+		.ksize	= 80,
+		.plaintext = "Test Using Larger Than Block-Size Key - Hash Key First",
+		.psize	= 54,
+		.digest	= "\x6b\x1a\xb7\xfe\x4b\xd7\xbf\x8f"
+			  "\x0b\x62\xe6\xce\x61\xb9\xd0\xcd",
+	}, {
+		.key	= "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa",
+		.ksize	= 80,
+		.plaintext = "Test Using Larger Than Block-Size Key and Larger Than One "
+			   "Block-Size Data",
+		.psize	= 73,
+		.digest	= "\x6f\x63\x0f\xad\x67\xcd\xa0\xee"
+			  "\x1f\xb1\xf5\x62\xdb\x3a\xa5\x3e",
+	},
+};
+
+/*
+ * HMAC-RIPEMD128 test vectors from RFC2286
+ */
+#define HMAC_RMD128_TEST_VECTORS	7
+
+static struct hash_testvec hmac_rmd128_tv_template[] = {
+	{
+		.key	= "\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b",
+		.ksize	= 16,
+		.plaintext = "Hi There",
+		.psize	= 8,
+		.digest	= "\xfb\xf6\x1f\x94\x92\xaa\x4b\xbf"
+			  "\x81\xc1\x72\xe8\x4e\x07\x34\xdb",
+	}, {
+		.key	= "Jefe",
+		.ksize	= 4,
+		.plaintext = "what do ya want for nothing?",
+		.psize	= 28,
+		.digest	= "\x87\x5f\x82\x88\x62\xb6\xb3\x34"
+			  "\xb4\x27\xc5\x5f\x9f\x7f\xf0\x9b",
+		.np	= 2,
+		.tap	= { 14, 14 },
+	}, {
+		.key	= "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa",
+		.ksize	= 16,
+		.plaintext = "\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd"
+			"\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd"
+			"\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd"
+			"\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd",
+		.psize	= 50,
+		.digest	= "\x09\xf0\xb2\x84\x6d\x2f\x54\x3d"
+			  "\xa3\x63\xcb\xec\x8d\x62\xa3\x8d",
+	}, {
+		.key	= "\x01\x02\x03\x04\x05\x06\x07\x08"
+			  "\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
+			  "\x11\x12\x13\x14\x15\x16\x17\x18\x19",
+		.ksize	= 25,
+		.plaintext = "\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd"
+			"\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd"
+			"\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd"
+			"\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd",
+		.psize	= 50,
+		.digest	= "\xbd\xbb\xd7\xcf\x03\xe4\x4b\x5a"
+			  "\xa6\x0a\xf8\x15\xbe\x4d\x22\x94",
+	}, {
+		.key	= "\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c",
+		.ksize	= 16,
+		.plaintext = "Test With Truncation",
+		.psize	= 20,
+		.digest	= "\xe7\x98\x08\xf2\x4b\x25\xfd\x03"
+			  "\x1c\x15\x5f\x0d\x55\x1d\x9a\x3a",
+	}, {
+		.key	= "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa",
+		.ksize	= 80,
+		.plaintext = "Test Using Larger Than Block-Size Key - Hash Key First",
+		.psize	= 54,
+		.digest	= "\xdc\x73\x29\x28\xde\x98\x10\x4a"
+			  "\x1f\x59\xd3\x73\xc1\x50\xac\xbb",
+	}, {
+		.key	= "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa",
+		.ksize	= 80,
+		.plaintext = "Test Using Larger Than Block-Size Key and Larger Than One "
+			   "Block-Size Data",
+		.psize	= 73,
+		.digest	= "\x5c\x6b\xec\x96\x79\x3e\x16\xd4"
+			  "\x06\x90\xc2\x37\x63\x5f\x30\xc5",
+	},
+};
+
+/*
+ * HMAC-RIPEMD160 test vectors from RFC2286
+ */
+#define HMAC_RMD160_TEST_VECTORS	7
+
+static struct hash_testvec hmac_rmd160_tv_template[] = {
+	{
+		.key	= "\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b",
+		.ksize	= 20,
+		.plaintext = "Hi There",
+		.psize	= 8,
+		.digest	= "\x24\xcb\x4b\xd6\x7d\x20\xfc\x1a\x5d\x2e"
+			  "\xd7\x73\x2d\xcc\x39\x37\x7f\x0a\x56\x68",
+	}, {
+		.key	= "Jefe",
+		.ksize	= 4,
+		.plaintext = "what do ya want for nothing?",
+		.psize	= 28,
+		.digest	= "\xdd\xa6\xc0\x21\x3a\x48\x5a\x9e\x24\xf4"
+			  "\x74\x20\x64\xa7\xf0\x33\xb4\x3c\x40\x69",
+		.np	= 2,
+		.tap	= { 14, 14 },
+	}, {
+		.key	= "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa",
+		.ksize	= 20,
+		.plaintext = "\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd"
+			"\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd"
+			"\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd"
+			"\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd",
+		.psize	= 50,
+		.digest	= "\xb0\xb1\x05\x36\x0d\xe7\x59\x96\x0a\xb4"
+			  "\xf3\x52\x98\xe1\x16\xe2\x95\xd8\xe7\xc1",
+	}, {
+		.key	= "\x01\x02\x03\x04\x05\x06\x07\x08"
+			  "\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
+			  "\x11\x12\x13\x14\x15\x16\x17\x18\x19",
+		.ksize	= 25,
+		.plaintext = "\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd"
+			"\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd"
+			"\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd"
+			"\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd",
+		.psize	= 50,
+		.digest	= "\xd5\xca\x86\x2f\x4d\x21\xd5\xe6\x10\xe1"
+			  "\x8b\x4c\xf1\xbe\xb9\x7a\x43\x65\xec\xf4",
+	}, {
+		.key	= "\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c",
+		.ksize	= 20,
+		.plaintext = "Test With Truncation",
+		.psize	= 20,
+		.digest	= "\x76\x19\x69\x39\x78\xf9\x1d\x90\x53\x9a"
+			  "\xe7\x86\x50\x0f\xf3\xd8\xe0\x51\x8e\x39",
+	}, {
+		.key	= "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa",
+		.ksize	= 80,
+		.plaintext = "Test Using Larger Than Block-Size Key - Hash Key First",
+		.psize	= 54,
+		.digest	= "\x64\x66\xca\x07\xac\x5e\xac\x29\xe1\xbd"
+			  "\x52\x3e\x5a\xda\x76\x05\xb7\x91\xfd\x8b",
+	}, {
+		.key	= "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa",
+		.ksize	= 80,
+		.plaintext = "Test Using Larger Than Block-Size Key and Larger Than One "
+			   "Block-Size Data",
+		.psize	= 73,
+		.digest	= "\x69\xea\x60\x79\x8d\x71\x61\x6c\xce\x5f"
+			  "\xd0\x87\x1e\x23\x75\x4c\xd7\x5d\x5a\x0a",
+	},
+};
+
+/*
+ * HMAC-SHA1 test vectors from RFC2202
+ */
+#define HMAC_SHA1_TEST_VECTORS	7
+
+static struct hash_testvec hmac_sha1_tv_template[] = {
+	{
+		.key	= "\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b",
+		.ksize	= 20,
+		.plaintext = "Hi There",
+		.psize	= 8,
+		.digest	= "\xb6\x17\x31\x86\x55\x05\x72\x64"
+			  "\xe2\x8b\xc0\xb6\xfb\x37\x8c\x8e\xf1"
+			  "\x46\xbe",
+	}, {
+		.key	= "Jefe",
+		.ksize	= 4,
+		.plaintext = "what do ya want for nothing?",
+		.psize	= 28,
+		.digest	= "\xef\xfc\xdf\x6a\xe5\xeb\x2f\xa2\xd2\x74"
+			  "\x16\xd5\xf1\x84\xdf\x9c\x25\x9a\x7c\x79",
+		.np	= 2,
+		.tap	= { 14, 14 }
+	}, {
+		.key	= "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa",
+		.ksize	= 20,
+		.plaintext = "\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd"
+			"\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd"
+			"\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd"
+			"\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd",
+		.psize	= 50,
+		.digest	= "\x12\x5d\x73\x42\xb9\xac\x11\xcd\x91\xa3"
+			  "\x9a\xf4\x8a\xa1\x7b\x4f\x63\xf1\x75\xd3",
+	}, {
+		.key	= "\x01\x02\x03\x04\x05\x06\x07\x08"
+			  "\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
+			  "\x11\x12\x13\x14\x15\x16\x17\x18\x19",
+		.ksize	= 25,
+		.plaintext = "\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd"
+			"\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd"
+			"\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd"
+			"\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd",
+		.psize	= 50,
+		.digest	= "\x4c\x90\x07\xf4\x02\x62\x50\xc6\xbc\x84"
+			  "\x14\xf9\xbf\x50\xc8\x6c\x2d\x72\x35\xda",
+	}, {
+		.key	= "\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c",
+		.ksize	= 20,
+		.plaintext = "Test With Truncation",
+		.psize	= 20,
+		.digest	= "\x4c\x1a\x03\x42\x4b\x55\xe0\x7f\xe7\xf2"
+			  "\x7b\xe1\xd5\x8b\xb9\x32\x4a\x9a\x5a\x04",
+	}, {
+		.key	= "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa",
+		.ksize	= 80,
+		.plaintext = "Test Using Larger Than Block-Size Key - Hash Key First",
+		.psize	= 54,
+		.digest	= "\xaa\x4a\xe5\xe1\x52\x72\xd0\x0e\x95\x70"
+			  "\x56\x37\xce\x8a\x3b\x55\xed\x40\x21\x12",
+	}, {
+		.key	= "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa",
+		.ksize	= 80,
+		.plaintext = "Test Using Larger Than Block-Size Key and Larger Than One "
+			   "Block-Size Data",
+		.psize	= 73,
+		.digest	= "\xe8\xe9\x9d\x0f\x45\x23\x7d\x78\x6d\x6b"
+			  "\xba\xa7\x96\x5c\x78\x08\xbb\xff\x1a\x91",
+	},
+};
+
+
+/*
+ * SHA224 HMAC test vectors from RFC4231
+ */
+#define HMAC_SHA224_TEST_VECTORS    4
+
+static struct hash_testvec hmac_sha224_tv_template[] = {
+	{
+		.key    = "\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b"
+			"\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b"
+			"\x0b\x0b\x0b\x0b",
+		.ksize  = 20,
+		/*  ("Hi There") */
+		.plaintext = "\x48\x69\x20\x54\x68\x65\x72\x65",
+		.psize  = 8,
+		.digest = "\x89\x6f\xb1\x12\x8a\xbb\xdf\x19"
+			"\x68\x32\x10\x7c\xd4\x9d\xf3\x3f"
+			"\x47\xb4\xb1\x16\x99\x12\xba\x4f"
+			"\x53\x68\x4b\x22",
+	}, {
+		.key    = "Jefe",
+		.ksize  = 4,
+		/* ("what do ya want for nothing?") */
+		.plaintext = "\x77\x68\x61\x74\x20\x64\x6f\x20"
+			"\x79\x61\x20\x77\x61\x6e\x74\x20"
+			"\x66\x6f\x72\x20\x6e\x6f\x74\x68"
+			"\x69\x6e\x67\x3f",
+		.psize  = 28,
+		.digest = "\xa3\x0e\x01\x09\x8b\xc6\xdb\xbf"
+			"\x45\x69\x0f\x3a\x7e\x9e\x6d\x0f"
+			"\x8b\xbe\xa2\xa3\x9e\x61\x48\x00"
+			"\x8f\xd0\x5e\x44",
+		.np = 4,
+		.tap    = { 7, 7, 7, 7 }
+	}, {
+		.key    = "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa",
+		.ksize  = 131,
+		/* ("Test Using Larger Than Block-Size Key - Hash Key First") */
+		.plaintext = "\x54\x65\x73\x74\x20\x55\x73\x69"
+			"\x6e\x67\x20\x4c\x61\x72\x67\x65"
+			"\x72\x20\x54\x68\x61\x6e\x20\x42"
+			"\x6c\x6f\x63\x6b\x2d\x53\x69\x7a"
+			"\x65\x20\x4b\x65\x79\x20\x2d\x20"
+			"\x48\x61\x73\x68\x20\x4b\x65\x79"
+			"\x20\x46\x69\x72\x73\x74",
+		.psize  = 54,
+		.digest = "\x95\xe9\xa0\xdb\x96\x20\x95\xad"
+			"\xae\xbe\x9b\x2d\x6f\x0d\xbc\xe2"
+			"\xd4\x99\xf1\x12\xf2\xd2\xb7\x27"
+			"\x3f\xa6\x87\x0e",
+	}, {
+		.key    = "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa",
+		.ksize  = 131,
+		/* ("This is a test using a larger than block-size key and a")
+		(" larger than block-size data. The key needs to be")
+			(" hashed before being used by the HMAC algorithm.") */
+		.plaintext = "\x54\x68\x69\x73\x20\x69\x73\x20"
+			"\x61\x20\x74\x65\x73\x74\x20\x75"
+			"\x73\x69\x6e\x67\x20\x61\x20\x6c"
+			"\x61\x72\x67\x65\x72\x20\x74\x68"
+			"\x61\x6e\x20\x62\x6c\x6f\x63\x6b"
+			"\x2d\x73\x69\x7a\x65\x20\x6b\x65"
+			"\x79\x20\x61\x6e\x64\x20\x61\x20"
+			"\x6c\x61\x72\x67\x65\x72\x20\x74"
+			"\x68\x61\x6e\x20\x62\x6c\x6f\x63"
+			"\x6b\x2d\x73\x69\x7a\x65\x20\x64"
+			"\x61\x74\x61\x2e\x20\x54\x68\x65"
+			"\x20\x6b\x65\x79\x20\x6e\x65\x65"
+			"\x64\x73\x20\x74\x6f\x20\x62\x65"
+			"\x20\x68\x61\x73\x68\x65\x64\x20"
+			"\x62\x65\x66\x6f\x72\x65\x20\x62"
+			"\x65\x69\x6e\x67\x20\x75\x73\x65"
+			"\x64\x20\x62\x79\x20\x74\x68\x65"
+			"\x20\x48\x4d\x41\x43\x20\x61\x6c"
+			"\x67\x6f\x72\x69\x74\x68\x6d\x2e",
+		.psize  = 152,
+		.digest = "\x3a\x85\x41\x66\xac\x5d\x9f\x02"
+			"\x3f\x54\xd5\x17\xd0\xb3\x9d\xbd"
+			"\x94\x67\x70\xdb\x9c\x2b\x95\xc9"
+			"\xf6\xf5\x65\xd1",
+	},
+};
+
+/*
+ * HMAC-SHA256 test vectors from
+ * draft-ietf-ipsec-ciph-sha-256-01.txt
+ */
+#define HMAC_SHA256_TEST_VECTORS	10
+
+static struct hash_testvec hmac_sha256_tv_template[] = {
+	{
+		.key	= "\x01\x02\x03\x04\x05\x06\x07\x08"
+			  "\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
+			  "\x11\x12\x13\x14\x15\x16\x17\x18"
+			  "\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20",
+		.ksize	= 32,
+		.plaintext = "abc",
+		.psize	= 3,
+		.digest	= "\xa2\x1b\x1f\x5d\x4c\xf4\xf7\x3a"
+			  "\x4d\xd9\x39\x75\x0f\x7a\x06\x6a"
+			  "\x7f\x98\xcc\x13\x1c\xb1\x6a\x66"
+			  "\x92\x75\x90\x21\xcf\xab\x81\x81",
+	}, {
+		.key	= "\x01\x02\x03\x04\x05\x06\x07\x08"
+			  "\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
+			  "\x11\x12\x13\x14\x15\x16\x17\x18"
+			  "\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20",
+		.ksize	= 32,
+		.plaintext = "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
+		.psize	= 56,
+		.digest	= "\x10\x4f\xdc\x12\x57\x32\x8f\x08"
+			  "\x18\x4b\xa7\x31\x31\xc5\x3c\xae"
+			  "\xe6\x98\xe3\x61\x19\x42\x11\x49"
+			  "\xea\x8c\x71\x24\x56\x69\x7d\x30",
+	}, {
+		.key	= "\x01\x02\x03\x04\x05\x06\x07\x08"
+			  "\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
+			  "\x11\x12\x13\x14\x15\x16\x17\x18"
+			  "\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20",
+		.ksize	= 32,
+		.plaintext = "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"
+			   "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
+		.psize	= 112,
+		.digest	= "\x47\x03\x05\xfc\x7e\x40\xfe\x34"
+			  "\xd3\xee\xb3\xe7\x73\xd9\x5a\xab"
+			  "\x73\xac\xf0\xfd\x06\x04\x47\xa5"
+			  "\xeb\x45\x95\xbf\x33\xa9\xd1\xa3",
+	}, {
+		.key	= "\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b"
+			"\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b"
+			"\x0b\x0b\x0b\x0b\x0b\x0b",
+		.ksize	= 32,
+		.plaintext = "Hi There",
+		.psize	= 8,
+		.digest	= "\x19\x8a\x60\x7e\xb4\x4b\xfb\xc6"
+			  "\x99\x03\xa0\xf1\xcf\x2b\xbd\xc5"
+			  "\xba\x0a\xa3\xf3\xd9\xae\x3c\x1c"
+			  "\x7a\x3b\x16\x96\xa0\xb6\x8c\xf7",
+	}, {
+		.key	= "Jefe",
+		.ksize	= 4,
+		.plaintext = "what do ya want for nothing?",
+		.psize	= 28,
+		.digest	= "\x5b\xdc\xc1\x46\xbf\x60\x75\x4e"
+			  "\x6a\x04\x24\x26\x08\x95\x75\xc7"
+			  "\x5a\x00\x3f\x08\x9d\x27\x39\x83"
+			  "\x9d\xec\x58\xb9\x64\xec\x38\x43",
+		.np	= 2,
+		.tap	= { 14, 14 }
+	}, {
+		.key	= "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa",
+		.ksize	= 32,
+		.plaintext = "\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd"
+			"\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd"
+			"\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd"
+			"\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd",
+		.psize	= 50,
+		.digest	= "\xcd\xcb\x12\x20\xd1\xec\xcc\xea"
+			  "\x91\xe5\x3a\xba\x30\x92\xf9\x62"
+			  "\xe5\x49\xfe\x6c\xe9\xed\x7f\xdc"
+			  "\x43\x19\x1f\xbd\xe4\x5c\x30\xb0",
+	}, {
+		.key	= "\x01\x02\x03\x04\x05\x06\x07\x08"
+			  "\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
+			  "\x11\x12\x13\x14\x15\x16\x17\x18"
+			  "\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
+			  "\x21\x22\x23\x24\x25",
+		.ksize	= 37,
+		.plaintext = "\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd"
+			"\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd"
+			"\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd"
+			"\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd",
+		.psize	= 50,
+		.digest	= "\xd4\x63\x3c\x17\xf6\xfb\x8d\x74"
+			  "\x4c\x66\xde\xe0\xf8\xf0\x74\x55"
+			  "\x6e\xc4\xaf\x55\xef\x07\x99\x85"
+			  "\x41\x46\x8e\xb4\x9b\xd2\xe9\x17",
+	}, {
+		.key	= "\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c"
+			"\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c"
+			"\x0c\x0c\x0c\x0c\x0c\x0c",
+		.ksize	= 32,
+		.plaintext = "Test With Truncation",
+		.psize	= 20,
+		.digest	= "\x75\x46\xaf\x01\x84\x1f\xc0\x9b"
+			  "\x1a\xb9\xc3\x74\x9a\x5f\x1c\x17"
+			  "\xd4\xf5\x89\x66\x8a\x58\x7b\x27"
+			  "\x00\xa9\xc9\x7c\x11\x93\xcf\x42",
+	}, {
+		.key	= "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa",
+		.ksize	= 80,
+		.plaintext = "Test Using Larger Than Block-Size Key - Hash Key First",
+		.psize	= 54,
+		.digest	= "\x69\x53\x02\x5e\xd9\x6f\x0c\x09"
+			  "\xf8\x0a\x96\xf7\x8e\x65\x38\xdb"
+			  "\xe2\xe7\xb8\x20\xe3\xdd\x97\x0e"
+			  "\x7d\xdd\x39\x09\x1b\x32\x35\x2f",
+	}, {
+		.key	= "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa",
+		.ksize	= 80,
+		.plaintext = "Test Using Larger Than Block-Size Key and Larger Than "
+			   "One Block-Size Data",
+		.psize	= 73,
+		.digest	= "\x63\x55\xac\x22\xe8\x90\xd0\xa3"
+			  "\xc8\x48\x1a\x5c\xa4\x82\x5b\xc8"
+			  "\x84\xd3\xe7\xa1\xff\x98\xa2\xfc"
+			  "\x2a\xc7\xd8\xe0\x64\xc3\xb2\xe6",
+	},
+};
+
+#define XCBC_AES_TEST_VECTORS 6
+
+static struct hash_testvec aes_xcbc128_tv_template[] = {
+	{
+		.key	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f",
+		.plaintext = zeroed_string,
+		.digest = "\x75\xf0\x25\x1d\x52\x8a\xc0\x1c"
+			  "\x45\x73\xdf\xd5\x84\xd7\x9f\x29",
+		.psize	= 0,
+		.ksize	= 16,
+	}, {
+		.key	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f",
+		.plaintext = "\x00\x01\x02",
+		.digest	= "\x5b\x37\x65\x80\xae\x2f\x19\xaf"
+			  "\xe7\x21\x9c\xee\xf1\x72\x75\x6f",
+		.psize	= 3,
+		.ksize	= 16,
+	} , {
+		.key	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f",
+		.plaintext = "\x00\x01\x02\x03\x04\x05\x06\x07"
+			     "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f",
+		.digest = "\xd2\xa2\x46\xfa\x34\x9b\x68\xa7"
+			  "\x99\x98\xa4\x39\x4f\xf7\xa2\x63",
+		.psize	= 16,
+		.ksize	= 16,
+	}, {
+		.key	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f",
+		.plaintext = "\x00\x01\x02\x03\x04\x05\x06\x07"
+			     "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+			     "\x10\x11\x12\x13",
+		.digest = "\x47\xf5\x1b\x45\x64\x96\x62\x15"
+			  "\xb8\x98\x5c\x63\x05\x5e\xd3\x08",
+		.tap	= { 10, 10 },
+		.psize	= 20,
+		.np	= 2,
+		.ksize	= 16,
+	}, {
+		.key	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f",
+		.plaintext = "\x00\x01\x02\x03\x04\x05\x06\x07"
+			     "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+			     "\x10\x11\x12\x13\x14\x15\x16\x17"
+			     "\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f",
+		.digest = "\xf5\x4f\x0e\xc8\xd2\xb9\xf3\xd3"
+			  "\x68\x07\x73\x4b\xd5\x28\x3f\xd4",
+		.psize	= 32,
+		.ksize	= 16,
+	}, {
+		.key	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f",
+		.plaintext = "\x00\x01\x02\x03\x04\x05\x06\x07"
+			     "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+			     "\x10\x11\x12\x13\x14\x15\x16\x17"
+			     "\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
+			     "\x20\x21",
+		.digest = "\xbe\xcb\xb3\xbc\xcd\xb5\x18\xa3"
+			  "\x06\x77\xd5\x48\x1f\xb6\xb4\xd8",
+		.tap	= { 17, 17 },
+		.psize	= 34,
+		.np	= 2,
+		.ksize	= 16,
+	}
+};
+
+/*
+ * SHA384 HMAC test vectors from RFC4231
+ */
+
+#define HMAC_SHA384_TEST_VECTORS	4
+
+static struct hash_testvec hmac_sha384_tv_template[] = {
+	{
+		.key	= "\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b"
+			  "\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b"
+			  "\x0b\x0b\x0b\x0b",
+		.ksize	= 20,
+		.plaintext = "Hi There",
+		.psize	= 8,
+		.digest	= "\xaf\xd0\x39\x44\xd8\x48\x95\x62"
+			  "\x6b\x08\x25\xf4\xab\x46\x90\x7f"
+			  "\x15\xf9\xda\xdb\xe4\x10\x1e\xc6"
+			  "\x82\xaa\x03\x4c\x7c\xeb\xc5\x9c"
+			  "\xfa\xea\x9e\xa9\x07\x6e\xde\x7f"
+			  "\x4a\xf1\x52\xe8\xb2\xfa\x9c\xb6",
+	}, {
+		.key	= "Jefe",
+		.ksize	= 4,
+		.plaintext = "what do ya want for nothing?",
+		.psize	= 28,
+		.digest	= "\xaf\x45\xd2\xe3\x76\x48\x40\x31"
+			  "\x61\x7f\x78\xd2\xb5\x8a\x6b\x1b"
+			  "\x9c\x7e\xf4\x64\xf5\xa0\x1b\x47"
+			  "\xe4\x2e\xc3\x73\x63\x22\x44\x5e"
+			  "\x8e\x22\x40\xca\x5e\x69\xe2\xc7"
+			  "\x8b\x32\x39\xec\xfa\xb2\x16\x49",
+		.np	= 4,
+		.tap	= { 7, 7, 7, 7 }
+	}, {
+		.key	= "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa",
+		.ksize	= 131,
+		.plaintext = "Test Using Larger Than Block-Siz"
+			   "e Key - Hash Key First",
+		.psize	= 54,
+		.digest	= "\x4e\xce\x08\x44\x85\x81\x3e\x90"
+			  "\x88\xd2\xc6\x3a\x04\x1b\xc5\xb4"
+			  "\x4f\x9e\xf1\x01\x2a\x2b\x58\x8f"
+			  "\x3c\xd1\x1f\x05\x03\x3a\xc4\xc6"
+			  "\x0c\x2e\xf6\xab\x40\x30\xfe\x82"
+			  "\x96\x24\x8d\xf1\x63\xf4\x49\x52",
+	}, {
+		.key	= "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa",
+		.ksize	= 131,
+		.plaintext = "This is a test u"
+			   "sing a larger th"
+			   "an block-size ke"
+			   "y and a larger t"
+			   "han block-size d"
+			   "ata. The key nee"
+			   "ds to be hashed "
+			   "before being use"
+			   "d by the HMAC al"
+			   "gorithm.",
+		.psize	= 152,
+		.digest	= "\x66\x17\x17\x8e\x94\x1f\x02\x0d"
+			  "\x35\x1e\x2f\x25\x4e\x8f\xd3\x2c"
+			  "\x60\x24\x20\xfe\xb0\xb8\xfb\x9a"
+			  "\xdc\xce\xbb\x82\x46\x1e\x99\xc5"
+			  "\xa6\x78\xcc\x31\xe7\x99\x17\x6d"
+			  "\x38\x60\xe6\x11\x0c\x46\x52\x3e",
+	},
+};
+
+/*
+ * SHA512 HMAC test vectors from RFC4231
+ */
+
+#define HMAC_SHA512_TEST_VECTORS	4
+
+static struct hash_testvec hmac_sha512_tv_template[] = {
+	{
+		.key	= "\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b"
+			  "\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b"
+			  "\x0b\x0b\x0b\x0b",
+		.ksize	= 20,
+		.plaintext = "Hi There",
+		.psize	= 8,
+		.digest	= "\x87\xaa\x7c\xde\xa5\xef\x61\x9d"
+			  "\x4f\xf0\xb4\x24\x1a\x1d\x6c\xb0"
+			  "\x23\x79\xf4\xe2\xce\x4e\xc2\x78"
+			  "\x7a\xd0\xb3\x05\x45\xe1\x7c\xde"
+			  "\xda\xa8\x33\xb7\xd6\xb8\xa7\x02"
+			  "\x03\x8b\x27\x4e\xae\xa3\xf4\xe4"
+			  "\xbe\x9d\x91\x4e\xeb\x61\xf1\x70"
+			  "\x2e\x69\x6c\x20\x3a\x12\x68\x54",
+	}, {
+		.key	= "Jefe",
+		.ksize	= 4,
+		.plaintext = "what do ya want for nothing?",
+		.psize	= 28,
+		.digest	= "\x16\x4b\x7a\x7b\xfc\xf8\x19\xe2"
+			  "\xe3\x95\xfb\xe7\x3b\x56\xe0\xa3"
+			  "\x87\xbd\x64\x22\x2e\x83\x1f\xd6"
+			  "\x10\x27\x0c\xd7\xea\x25\x05\x54"
+			  "\x97\x58\xbf\x75\xc0\x5a\x99\x4a"
+			  "\x6d\x03\x4f\x65\xf8\xf0\xe6\xfd"
+			  "\xca\xea\xb1\xa3\x4d\x4a\x6b\x4b"
+			  "\x63\x6e\x07\x0a\x38\xbc\xe7\x37",
+		.np	= 4,
+		.tap	= { 7, 7, 7, 7 }
+	}, {
+		.key	= "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			  "\xaa\xaa\xaa",
+		.ksize	= 131,
+		.plaintext = "Test Using Large"
+			   "r Than Block-Siz"
+			   "e Key - Hash Key"
+			   " First",
+		.psize	= 54,
+		.digest	= "\x80\xb2\x42\x63\xc7\xc1\xa3\xeb"
+			"\xb7\x14\x93\xc1\xdd\x7b\xe8\xb4"
+			"\x9b\x46\xd1\xf4\x1b\x4a\xee\xc1"
+			"\x12\x1b\x01\x37\x83\xf8\xf3\x52"
+			"\x6b\x56\xd0\x37\xe0\x5f\x25\x98"
+			"\xbd\x0f\xd2\x21\x5d\x6a\x1e\x52"
+			"\x95\xe6\x4f\x73\xf6\x3f\x0a\xec"
+			"\x8b\x91\x5a\x98\x5d\x78\x65\x98",
+	}, {
+		.key	= "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
+			"\xaa\xaa\xaa",
+		.ksize	= 131,
+		.plaintext =
+			  "This is a test u"
+			  "sing a larger th"
+			  "an block-size ke"
+			  "y and a larger t"
+			  "han block-size d"
+			  "ata. The key nee"
+			  "ds to be hashed "
+			  "before being use"
+			  "d by the HMAC al"
+			  "gorithm.",
+		.psize	= 152,
+		.digest	= "\xe3\x7b\x6a\x77\x5d\xc8\x7d\xba"
+			"\xa4\xdf\xa9\xf9\x6e\x5e\x3f\xfd"
+			"\xde\xbd\x71\xf8\x86\x72\x89\x86"
+			"\x5d\xf5\xa3\x2d\x20\xcd\xc9\x44"
+			"\xb6\x02\x2c\xac\x3c\x49\x82\xb1"
+			"\x0d\x5e\xeb\x55\xc3\xe4\xde\x15"
+			"\x13\x46\x76\xfb\x6d\xe0\x44\x60"
+			"\x65\xc9\x74\x40\xfa\x8c\x6a\x58",
+	},
+};
+
+/*
+ * DES test vectors.
+ */
+#define DES_ENC_TEST_VECTORS		10
+#define DES_DEC_TEST_VECTORS		4
+#define DES_CBC_ENC_TEST_VECTORS	5
+#define DES_CBC_DEC_TEST_VECTORS	4
+#define DES3_EDE_ENC_TEST_VECTORS	3
+#define DES3_EDE_DEC_TEST_VECTORS	3
+#define DES3_EDE_CBC_ENC_TEST_VECTORS	1
+#define DES3_EDE_CBC_DEC_TEST_VECTORS	1
+
+static struct cipher_testvec des_enc_tv_template[] = {
+	{ /* From Applied Cryptography */
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.klen	= 8,
+		.input	= "\x01\x23\x45\x67\x89\xab\xcd\xe7",
+		.ilen	= 8,
+		.result	= "\xc9\x57\x44\x25\x6a\x5e\xd3\x1d",
+		.rlen	= 8,
+	}, { /* Same key, different plaintext block */
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.klen	= 8,
+		.input	= "\x22\x33\x44\x55\x66\x77\x88\x99",
+		.ilen	= 8,
+		.result	= "\xf7\x9c\x89\x2a\x33\x8f\x4a\x8b",
+		.rlen	= 8,
+	}, { /* Sbox test from NBS */
+		.key	= "\x7c\xa1\x10\x45\x4a\x1a\x6e\x57",
+		.klen	= 8,
+		.input	= "\x01\xa1\xd6\xd0\x39\x77\x67\x42",
+		.ilen	= 8,
+		.result	= "\x69\x0f\x5b\x0d\x9a\x26\x93\x9b",
+		.rlen	= 8,
+	}, { /* Three blocks */
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.klen	= 8,
+		.input	= "\x01\x23\x45\x67\x89\xab\xcd\xe7"
+			  "\x22\x33\x44\x55\x66\x77\x88\x99"
+			  "\xca\xfe\xba\xbe\xfe\xed\xbe\xef",
+		.ilen	= 24,
+		.result	= "\xc9\x57\x44\x25\x6a\x5e\xd3\x1d"
+			  "\xf7\x9c\x89\x2a\x33\x8f\x4a\x8b"
+			  "\xb4\x99\x26\xf7\x1f\xe1\xd4\x90",
+		.rlen	= 24,
+	}, { /* Weak key */
+		.fail	= 1,
+		.wk	= 1,
+		.key	= "\x01\x01\x01\x01\x01\x01\x01\x01",
+		.klen	= 8,
+		.input	= "\x01\x23\x45\x67\x89\xab\xcd\xe7",
+		.ilen	= 8,
+		.result	= "\xc9\x57\x44\x25\x6a\x5e\xd3\x1d",
+		.rlen	= 8,
+	}, { /* Two blocks -- for testing encryption across pages */
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.klen	= 8,
+		.input	= "\x01\x23\x45\x67\x89\xab\xcd\xe7"
+			  "\x22\x33\x44\x55\x66\x77\x88\x99",
+		.ilen	= 16,
+		.result	= "\xc9\x57\x44\x25\x6a\x5e\xd3\x1d"
+			  "\xf7\x9c\x89\x2a\x33\x8f\x4a\x8b",
+		.rlen	= 16,
+		.np	= 2,
+		.tap	= { 8, 8 }
+	}, { /* Four blocks -- for testing encryption with chunking */
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.klen	= 8,
+		.input	= "\x01\x23\x45\x67\x89\xab\xcd\xe7"
+			  "\x22\x33\x44\x55\x66\x77\x88\x99"
+			  "\xca\xfe\xba\xbe\xfe\xed\xbe\xef"
+			  "\x22\x33\x44\x55\x66\x77\x88\x99",
+		.ilen	= 32,
+		.result	= "\xc9\x57\x44\x25\x6a\x5e\xd3\x1d"
+			  "\xf7\x9c\x89\x2a\x33\x8f\x4a\x8b"
+			  "\xb4\x99\x26\xf7\x1f\xe1\xd4\x90"
+			  "\xf7\x9c\x89\x2a\x33\x8f\x4a\x8b",
+		.rlen	= 32,
+		.np	= 3,
+		.tap	= { 14, 10, 8 }
+	}, {
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.klen	= 8,
+		.input	= "\x01\x23\x45\x67\x89\xab\xcd\xe7"
+			  "\x22\x33\x44\x55\x66\x77\x88\x99"
+			  "\xca\xfe\xba\xbe\xfe\xed\xbe\xef",
+		.ilen	= 24,
+		.result	= "\xc9\x57\x44\x25\x6a\x5e\xd3\x1d"
+			  "\xf7\x9c\x89\x2a\x33\x8f\x4a\x8b"
+			  "\xb4\x99\x26\xf7\x1f\xe1\xd4\x90",
+		.rlen	= 24,
+		.np	= 4,
+		.tap	= { 2, 1, 3, 18 }
+	}, {
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.klen	= 8,
+		.input	= "\x01\x23\x45\x67\x89\xab\xcd\xe7"
+			  "\x22\x33\x44\x55\x66\x77\x88\x99",
+		.ilen	= 16,
+		.result	= "\xc9\x57\x44\x25\x6a\x5e\xd3\x1d"
+			  "\xf7\x9c\x89\x2a\x33\x8f\x4a\x8b",
+		.rlen	= 16,
+		.np	= 5,
+		.tap	= { 2, 2, 2, 2, 8 }
+	}, {
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.klen	= 8,
+		.input	= "\x01\x23\x45\x67\x89\xab\xcd\xe7",
+		.ilen	= 8,
+		.result	= "\xc9\x57\x44\x25\x6a\x5e\xd3\x1d",
+		.rlen	= 8,
+		.np	= 8,
+		.tap	= { 1, 1, 1, 1, 1, 1, 1, 1 }
+	},
+};
+
+static struct cipher_testvec des_dec_tv_template[] = {
+	{ /* From Applied Cryptography */
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.klen	= 8,
+		.input	= "\xc9\x57\x44\x25\x6a\x5e\xd3\x1d",
+		.ilen	= 8,
+		.result	= "\x01\x23\x45\x67\x89\xab\xcd\xe7",
+		.rlen	= 8,
+	}, { /* Sbox test from NBS */
+		.key	= "\x7c\xa1\x10\x45\x4a\x1a\x6e\x57",
+		.klen	= 8,
+		.input	= "\x69\x0f\x5b\x0d\x9a\x26\x93\x9b",
+		.ilen	= 8,
+		.result	= "\x01\xa1\xd6\xd0\x39\x77\x67\x42",
+		.rlen	= 8,
+	}, { /* Two blocks, for chunking test */
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.klen	= 8,
+		.input	= "\xc9\x57\x44\x25\x6a\x5e\xd3\x1d"
+			  "\x69\x0f\x5b\x0d\x9a\x26\x93\x9b",
+		.ilen	= 16,
+		.result	= "\x01\x23\x45\x67\x89\xab\xcd\xe7"
+			  "\xa3\x99\x7b\xca\xaf\x69\xa0\xf5",
+		.rlen	= 16,
+		.np	= 2,
+		.tap	= { 8, 8 }
+	}, {
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.klen	= 8,
+		.input	= "\xc9\x57\x44\x25\x6a\x5e\xd3\x1d"
+			  "\x69\x0f\x5b\x0d\x9a\x26\x93\x9b",
+		.ilen	= 16,
+		.result	= "\x01\x23\x45\x67\x89\xab\xcd\xe7"
+			  "\xa3\x99\x7b\xca\xaf\x69\xa0\xf5",
+		.rlen	= 16,
+		.np	= 3,
+		.tap	= { 3, 12, 1 }
+	},
+};
+
+static struct cipher_testvec des_cbc_enc_tv_template[] = {
+	{ /* From OpenSSL */
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.klen	= 8,
+		.iv	= "\xfe\xdc\xba\x98\x76\x54\x32\x10",
+		.input	= "\x37\x36\x35\x34\x33\x32\x31\x20"
+			  "\x4e\x6f\x77\x20\x69\x73\x20\x74"
+			  "\x68\x65\x20\x74\x69\x6d\x65\x20",
+		.ilen	= 24,
+		.result	= "\xcc\xd1\x73\xff\xab\x20\x39\xf4"
+			  "\xac\xd8\xae\xfd\xdf\xd8\xa1\xeb"
+			  "\x46\x8e\x91\x15\x78\x88\xba\x68",
+		.rlen	= 24,
+	}, { /* FIPS Pub 81 */
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.klen	= 8,
+		.iv	= "\x12\x34\x56\x78\x90\xab\xcd\xef",
+		.input	= "\x4e\x6f\x77\x20\x69\x73\x20\x74",
+		.ilen	= 8,
+		.result	= "\xe5\xc7\xcd\xde\x87\x2b\xf2\x7c",
+		.rlen	= 8,
+	}, {
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.klen	= 8,
+		.iv	= "\xe5\xc7\xcd\xde\x87\x2b\xf2\x7c",
+		.input	= "\x68\x65\x20\x74\x69\x6d\x65\x20",
+		.ilen	= 8,
+		.result	= "\x43\xe9\x34\x00\x8c\x38\x9c\x0f",
+		.rlen	= 8,
+	}, {
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.klen	= 8,
+		.iv	= "\x43\xe9\x34\x00\x8c\x38\x9c\x0f",
+		.input	= "\x66\x6f\x72\x20\x61\x6c\x6c\x20",
+		.ilen	= 8,
+		.result	= "\x68\x37\x88\x49\x9a\x7c\x05\xf6",
+		.rlen	= 8,
+	}, { /* Copy of openssl vector for chunk testing */
+	     /* From OpenSSL */
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.klen	= 8,
+		.iv	= "\xfe\xdc\xba\x98\x76\x54\x32\x10",
+		.input	= "\x37\x36\x35\x34\x33\x32\x31\x20"
+			  "\x4e\x6f\x77\x20\x69\x73\x20\x74"
+			  "\x68\x65\x20\x74\x69\x6d\x65\x20",
+		.ilen	= 24,
+		.result	= "\xcc\xd1\x73\xff\xab\x20\x39\xf4"
+			  "\xac\xd8\xae\xfd\xdf\xd8\xa1\xeb"
+			  "\x46\x8e\x91\x15\x78\x88\xba\x68",
+		.rlen	= 24,
+		.np	= 2,
+		.tap	= { 13, 11 }
+	},
+};
+
+static struct cipher_testvec des_cbc_dec_tv_template[] = {
+	{ /* FIPS Pub 81 */
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.klen	= 8,
+		.iv	= "\x12\x34\x56\x78\x90\xab\xcd\xef",
+		.input	= "\xe5\xc7\xcd\xde\x87\x2b\xf2\x7c",
+		.ilen	= 8,
+		.result	= "\x4e\x6f\x77\x20\x69\x73\x20\x74",
+		.rlen	= 8,
+	}, {
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.klen	= 8,
+		.iv	= "\xe5\xc7\xcd\xde\x87\x2b\xf2\x7c",
+		.input	= "\x43\xe9\x34\x00\x8c\x38\x9c\x0f",
+		.ilen	= 8,
+		.result	= "\x68\x65\x20\x74\x69\x6d\x65\x20",
+		.rlen	= 8,
+	}, {
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.klen	= 8,
+		.iv	= "\x43\xe9\x34\x00\x8c\x38\x9c\x0f",
+		.input	= "\x68\x37\x88\x49\x9a\x7c\x05\xf6",
+		.ilen	= 8,
+		.result	= "\x66\x6f\x72\x20\x61\x6c\x6c\x20",
+		.rlen	= 8,
+	}, { /* Copy of above, for chunk testing */
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.klen	= 8,
+		.iv	= "\x43\xe9\x34\x00\x8c\x38\x9c\x0f",
+		.input	= "\x68\x37\x88\x49\x9a\x7c\x05\xf6",
+		.ilen	= 8,
+		.result	= "\x66\x6f\x72\x20\x61\x6c\x6c\x20",
+		.rlen	= 8,
+		.np	= 2,
+		.tap	= { 4, 4 }
+	},
+};
+
+static struct cipher_testvec des3_ede_enc_tv_template[] = {
+	{ /* These are from openssl */
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef"
+			  "\x55\x55\x55\x55\x55\x55\x55\x55"
+			  "\xfe\xdc\xba\x98\x76\x54\x32\x10",
+		.klen	= 24,
+		.input	= "\x73\x6f\x6d\x65\x64\x61\x74\x61",
+		.ilen	= 8,
+		.result	= "\x18\xd7\x48\xe5\x63\x62\x05\x72",
+		.rlen	= 8,
+	}, {
+		.key	= "\x03\x52\x02\x07\x67\x20\x82\x17"
+			  "\x86\x02\x87\x66\x59\x08\x21\x98"
+			  "\x64\x05\x6a\xbd\xfe\xa9\x34\x57",
+		.klen	= 24,
+		.input	= "\x73\x71\x75\x69\x67\x67\x6c\x65",
+		.ilen	= 8,
+		.result	= "\xc0\x7d\x2a\x0f\xa5\x66\xfa\x30",
+		.rlen	= 8,
+	}, {
+		.key	= "\x10\x46\x10\x34\x89\x98\x80\x20"
+			  "\x91\x07\xd0\x15\x89\x19\x01\x01"
+			  "\x19\x07\x92\x10\x98\x1a\x01\x01",
+		.klen	= 24,
+		.input	= "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.ilen	= 8,
+		.result	= "\xe1\xef\x62\xc3\x32\xfe\x82\x5b",
+		.rlen	= 8,
+	},
+};
+
+static struct cipher_testvec des3_ede_dec_tv_template[] = {
+	{ /* These are from openssl */
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef"
+			  "\x55\x55\x55\x55\x55\x55\x55\x55"
+			  "\xfe\xdc\xba\x98\x76\x54\x32\x10",
+		.klen	= 24,
+		.input	= "\x18\xd7\x48\xe5\x63\x62\x05\x72",
+		.ilen	= 8,
+		.result	= "\x73\x6f\x6d\x65\x64\x61\x74\x61",
+		.rlen	= 8,
+	}, {
+		.key	= "\x03\x52\x02\x07\x67\x20\x82\x17"
+			  "\x86\x02\x87\x66\x59\x08\x21\x98"
+			  "\x64\x05\x6a\xbd\xfe\xa9\x34\x57",
+		.klen	= 24,
+		.input	= "\xc0\x7d\x2a\x0f\xa5\x66\xfa\x30",
+		.ilen	= 8,
+		.result	= "\x73\x71\x75\x69\x67\x67\x6c\x65",
+		.rlen	= 8,
+	}, {
+		.key	= "\x10\x46\x10\x34\x89\x98\x80\x20"
+			  "\x91\x07\xd0\x15\x89\x19\x01\x01"
+			  "\x19\x07\x92\x10\x98\x1a\x01\x01",
+		.klen	= 24,
+		.input	= "\xe1\xef\x62\xc3\x32\xfe\x82\x5b",
+		.ilen	= 8,
+		.result	= "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.rlen	= 8,
+	},
+};
+
+static struct cipher_testvec des3_ede_cbc_enc_tv_template[] = {
+	{ /* Generated from openssl */
+		.key	= "\xE9\xC0\xFF\x2E\x76\x0B\x64\x24"
+			  "\x44\x4D\x99\x5A\x12\xD6\x40\xC0"
+			  "\xEA\xC2\x84\xE8\x14\x95\xDB\xE8",
+		.klen	= 24,
+		.iv	= "\x7D\x33\x88\x93\x0F\x93\xB2\x42",
+		.input	= "\x6f\x54\x20\x6f\x61\x4d\x79\x6e"
+			  "\x53\x20\x63\x65\x65\x72\x73\x74"
+			  "\x54\x20\x6f\x6f\x4d\x20\x6e\x61"
+			  "\x20\x79\x65\x53\x72\x63\x74\x65"
+			  "\x20\x73\x6f\x54\x20\x6f\x61\x4d"
+			  "\x79\x6e\x53\x20\x63\x65\x65\x72"
+			  "\x73\x74\x54\x20\x6f\x6f\x4d\x20"
+			  "\x6e\x61\x20\x79\x65\x53\x72\x63"
+			  "\x74\x65\x20\x73\x6f\x54\x20\x6f"
+			  "\x61\x4d\x79\x6e\x53\x20\x63\x65"
+			  "\x65\x72\x73\x74\x54\x20\x6f\x6f"
+			  "\x4d\x20\x6e\x61\x20\x79\x65\x53"
+			  "\x72\x63\x74\x65\x20\x73\x6f\x54"
+			  "\x20\x6f\x61\x4d\x79\x6e\x53\x20"
+			  "\x63\x65\x65\x72\x73\x74\x54\x20"
+			  "\x6f\x6f\x4d\x20\x6e\x61\x0a\x79",
+		.ilen	= 128,
+		.result	= "\x0e\x2d\xb6\x97\x3c\x56\x33\xf4"
+			  "\x67\x17\x21\xc7\x6e\x8a\xd5\x49"
+			  "\x74\xb3\x49\x05\xc5\x1c\xd0\xed"
+			  "\x12\x56\x5c\x53\x96\xb6\x00\x7d"
+			  "\x90\x48\xfc\xf5\x8d\x29\x39\xcc"
+			  "\x8a\xd5\x35\x18\x36\x23\x4e\xd7"
+			  "\x76\xd1\xda\x0c\x94\x67\xbb\x04"
+			  "\x8b\xf2\x03\x6c\xa8\xcf\xb6\xea"
+			  "\x22\x64\x47\xaa\x8f\x75\x13\xbf"
+			  "\x9f\xc2\xc3\xf0\xc9\x56\xc5\x7a"
+			  "\x71\x63\x2e\x89\x7b\x1e\x12\xca"
+			  "\xe2\x5f\xaf\xd8\xa4\xf8\xc9\x7a"
+			  "\xd6\xf9\x21\x31\x62\x44\x45\xa6"
+			  "\xd6\xbc\x5a\xd3\x2d\x54\x43\xcc"
+			  "\x9d\xde\xa5\x70\xe9\x42\x45\x8a"
+			  "\x6b\xfa\xb1\x91\x13\xb0\xd9\x19",
+		.rlen	= 128,
+	},
+};
+
+static struct cipher_testvec des3_ede_cbc_dec_tv_template[] = {
+	{ /* Generated from openssl */
+		.key	= "\xE9\xC0\xFF\x2E\x76\x0B\x64\x24"
+			  "\x44\x4D\x99\x5A\x12\xD6\x40\xC0"
+			  "\xEA\xC2\x84\xE8\x14\x95\xDB\xE8",
+		.klen	= 24,
+		.iv	= "\x7D\x33\x88\x93\x0F\x93\xB2\x42",
+		.input	= "\x0e\x2d\xb6\x97\x3c\x56\x33\xf4"
+			  "\x67\x17\x21\xc7\x6e\x8a\xd5\x49"
+			  "\x74\xb3\x49\x05\xc5\x1c\xd0\xed"
+			  "\x12\x56\x5c\x53\x96\xb6\x00\x7d"
+			  "\x90\x48\xfc\xf5\x8d\x29\x39\xcc"
+			  "\x8a\xd5\x35\x18\x36\x23\x4e\xd7"
+			  "\x76\xd1\xda\x0c\x94\x67\xbb\x04"
+			  "\x8b\xf2\x03\x6c\xa8\xcf\xb6\xea"
+			  "\x22\x64\x47\xaa\x8f\x75\x13\xbf"
+			  "\x9f\xc2\xc3\xf0\xc9\x56\xc5\x7a"
+			  "\x71\x63\x2e\x89\x7b\x1e\x12\xca"
+			  "\xe2\x5f\xaf\xd8\xa4\xf8\xc9\x7a"
+			  "\xd6\xf9\x21\x31\x62\x44\x45\xa6"
+			  "\xd6\xbc\x5a\xd3\x2d\x54\x43\xcc"
+			  "\x9d\xde\xa5\x70\xe9\x42\x45\x8a"
+			  "\x6b\xfa\xb1\x91\x13\xb0\xd9\x19",
+		.ilen	= 128,
+		.result	= "\x6f\x54\x20\x6f\x61\x4d\x79\x6e"
+			  "\x53\x20\x63\x65\x65\x72\x73\x74"
+			  "\x54\x20\x6f\x6f\x4d\x20\x6e\x61"
+			  "\x20\x79\x65\x53\x72\x63\x74\x65"
+			  "\x20\x73\x6f\x54\x20\x6f\x61\x4d"
+			  "\x79\x6e\x53\x20\x63\x65\x65\x72"
+			  "\x73\x74\x54\x20\x6f\x6f\x4d\x20"
+			  "\x6e\x61\x20\x79\x65\x53\x72\x63"
+			  "\x74\x65\x20\x73\x6f\x54\x20\x6f"
+			  "\x61\x4d\x79\x6e\x53\x20\x63\x65"
+			  "\x65\x72\x73\x74\x54\x20\x6f\x6f"
+			  "\x4d\x20\x6e\x61\x20\x79\x65\x53"
+			  "\x72\x63\x74\x65\x20\x73\x6f\x54"
+			  "\x20\x6f\x61\x4d\x79\x6e\x53\x20"
+			  "\x63\x65\x65\x72\x73\x74\x54\x20"
+			  "\x6f\x6f\x4d\x20\x6e\x61\x0a\x79",
+		.rlen	= 128,
+	},
+};
+
+/*
+ * Blowfish test vectors.
+ */
+#define BF_ENC_TEST_VECTORS	6
+#define BF_DEC_TEST_VECTORS	6
+#define BF_CBC_ENC_TEST_VECTORS	1
+#define BF_CBC_DEC_TEST_VECTORS	1
+
+static struct cipher_testvec bf_enc_tv_template[] = {
+	{ /* DES test vectors from OpenSSL */
+		.key	= "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.klen	= 8,
+		.input	= "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.ilen	= 8,
+		.result	= "\x4e\xf9\x97\x45\x61\x98\xdd\x78",
+		.rlen	= 8,
+	}, {
+		.key	= "\x1f\x1f\x1f\x1f\x0e\x0e\x0e\x0e",
+		.klen	= 8,
+		.input	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.ilen	= 8,
+		.result	= "\xa7\x90\x79\x51\x08\xea\x3c\xae",
+		.rlen	= 8,
+	}, {
+		.key	= "\xf0\xe1\xd2\xc3\xb4\xa5\x96\x87",
+		.klen	= 8,
+		.input	= "\xfe\xdc\xba\x98\x76\x54\x32\x10",
+		.ilen	= 8,
+		.result	= "\xe8\x7a\x24\x4e\x2c\xc8\x5e\x82",
+		.rlen	= 8,
+	}, { /* Vary the keylength... */
+		.key	= "\xf0\xe1\xd2\xc3\xb4\xa5\x96\x87"
+			  "\x78\x69\x5a\x4b\x3c\x2d\x1e\x0f",
+		.klen	= 16,
+		.input	= "\xfe\xdc\xba\x98\x76\x54\x32\x10",
+		.ilen	= 8,
+		.result	= "\x93\x14\x28\x87\xee\x3b\xe1\x5c",
+		.rlen	= 8,
+	}, {
+		.key	= "\xf0\xe1\xd2\xc3\xb4\xa5\x96\x87"
+			  "\x78\x69\x5a\x4b\x3c\x2d\x1e\x0f"
+			  "\x00\x11\x22\x33\x44",
+		.klen	= 21,
+		.input	= "\xfe\xdc\xba\x98\x76\x54\x32\x10",
+		.ilen	= 8,
+		.result	= "\xe6\xf5\x1e\xd7\x9b\x9d\xb2\x1f",
+		.rlen	= 8,
+	}, { /* Generated with bf488 */
+		.key	= "\xf0\xe1\xd2\xc3\xb4\xa5\x96\x87"
+			  "\x78\x69\x5a\x4b\x3c\x2d\x1e\x0f"
+			  "\x00\x11\x22\x33\x44\x55\x66\x77"
+			  "\x04\x68\x91\x04\xc2\xfd\x3b\x2f"
+			  "\x58\x40\x23\x64\x1a\xba\x61\x76"
+			  "\x1f\x1f\x1f\x1f\x0e\x0e\x0e\x0e"
+			  "\xff\xff\xff\xff\xff\xff\xff\xff",
+		.klen	= 56,
+		.input	= "\xfe\xdc\xba\x98\x76\x54\x32\x10",
+		.ilen	= 8,
+		.result	= "\xc0\x45\x04\x01\x2e\x4e\x1f\x53",
+		.rlen	= 8,
+	},
+};
+
+static struct cipher_testvec bf_dec_tv_template[] = {
+	{ /* DES test vectors from OpenSSL */
+		.key	= "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.klen	= 8,
+		.input	= "\x4e\xf9\x97\x45\x61\x98\xdd\x78",
+		.ilen	= 8,
+		.result	= "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.rlen	= 8,
+	}, {
+		.key	= "\x1f\x1f\x1f\x1f\x0e\x0e\x0e\x0e",
+		.klen	= 8,
+		.input	= "\xa7\x90\x79\x51\x08\xea\x3c\xae",
+		.ilen	= 8,
+		.result	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.rlen	= 8,
+	}, {
+		.key	= "\xf0\xe1\xd2\xc3\xb4\xa5\x96\x87",
+		.klen	= 8,
+		.input	= "\xe8\x7a\x24\x4e\x2c\xc8\x5e\x82",
+		.ilen	= 8,
+		.result	= "\xfe\xdc\xba\x98\x76\x54\x32\x10",
+		.rlen	= 8,
+	}, { /* Vary the keylength... */
+		.key	= "\xf0\xe1\xd2\xc3\xb4\xa5\x96\x87"
+			  "\x78\x69\x5a\x4b\x3c\x2d\x1e\x0f",
+		.klen	= 16,
+		.input	= "\x93\x14\x28\x87\xee\x3b\xe1\x5c",
+		.ilen	= 8,
+		.result	= "\xfe\xdc\xba\x98\x76\x54\x32\x10",
+		.rlen	= 8,
+	}, {
+		.key	= "\xf0\xe1\xd2\xc3\xb4\xa5\x96\x87"
+			  "\x78\x69\x5a\x4b\x3c\x2d\x1e\x0f"
+			  "\x00\x11\x22\x33\x44",
+		.klen	= 21,
+		.input	= "\xe6\xf5\x1e\xd7\x9b\x9d\xb2\x1f",
+		.ilen	= 8,
+		.result	= "\xfe\xdc\xba\x98\x76\x54\x32\x10",
+		.rlen	= 8,
+	}, { /* Generated with bf488, using OpenSSL, Libgcrypt and Nettle */
+		.key	= "\xf0\xe1\xd2\xc3\xb4\xa5\x96\x87"
+			  "\x78\x69\x5a\x4b\x3c\x2d\x1e\x0f"
+			  "\x00\x11\x22\x33\x44\x55\x66\x77"
+			  "\x04\x68\x91\x04\xc2\xfd\x3b\x2f"
+			  "\x58\x40\x23\x64\x1a\xba\x61\x76"
+			  "\x1f\x1f\x1f\x1f\x0e\x0e\x0e\x0e"
+			  "\xff\xff\xff\xff\xff\xff\xff\xff",
+		.klen	= 56,
+		.input	= "\xc0\x45\x04\x01\x2e\x4e\x1f\x53",
+		.ilen	= 8,
+		.result	= "\xfe\xdc\xba\x98\x76\x54\x32\x10",
+		.rlen	= 8,
+	},
+};
+
+static struct cipher_testvec bf_cbc_enc_tv_template[] = {
+	{ /* From OpenSSL */
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef"
+			  "\xf0\xe1\xd2\xc3\xb4\xa5\x96\x87",
+		.klen	= 16,
+		.iv	= "\xfe\xdc\xba\x98\x76\x54\x32\x10",
+		.input	= "\x37\x36\x35\x34\x33\x32\x31\x20"
+			  "\x4e\x6f\x77\x20\x69\x73\x20\x74"
+			  "\x68\x65\x20\x74\x69\x6d\x65\x20"
+			  "\x66\x6f\x72\x20\x00\x00\x00\x00",
+		.ilen	= 32,
+		.result	= "\x6b\x77\xb4\xd6\x30\x06\xde\xe6"
+			  "\x05\xb1\x56\xe2\x74\x03\x97\x93"
+			  "\x58\xde\xb9\xe7\x15\x46\x16\xd9"
+			  "\x59\xf1\x65\x2b\xd5\xff\x92\xcc",
+		.rlen	= 32,
+	},
+};
+
+static struct cipher_testvec bf_cbc_dec_tv_template[] = {
+	{ /* From OpenSSL */
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef"
+			  "\xf0\xe1\xd2\xc3\xb4\xa5\x96\x87",
+		.klen	= 16,
+		.iv	= "\xfe\xdc\xba\x98\x76\x54\x32\x10",
+		.input	= "\x6b\x77\xb4\xd6\x30\x06\xde\xe6"
+			  "\x05\xb1\x56\xe2\x74\x03\x97\x93"
+			  "\x58\xde\xb9\xe7\x15\x46\x16\xd9"
+			  "\x59\xf1\x65\x2b\xd5\xff\x92\xcc",
+		.ilen	= 32,
+		.result	= "\x37\x36\x35\x34\x33\x32\x31\x20"
+			  "\x4e\x6f\x77\x20\x69\x73\x20\x74"
+			  "\x68\x65\x20\x74\x69\x6d\x65\x20"
+			  "\x66\x6f\x72\x20\x00\x00\x00\x00",
+		.rlen	= 32,
+	},
+};
+
+/*
+ * Twofish test vectors.
+ */
+#define TF_ENC_TEST_VECTORS		3
+#define TF_DEC_TEST_VECTORS		3
+#define TF_CBC_ENC_TEST_VECTORS		4
+#define TF_CBC_DEC_TEST_VECTORS		4
+
+static struct cipher_testvec tf_enc_tv_template[] = {
+	{
+		.key	= zeroed_string,
+		.klen	= 16,
+		.input	= zeroed_string,
+		.ilen	= 16,
+		.result	= "\x9f\x58\x9f\x5c\xf6\x12\x2c\x32"
+			  "\xb6\xbf\xec\x2f\x2a\xe8\xc3\x5a",
+		.rlen	= 16,
+	}, {
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef"
+			  "\xfe\xdc\xba\x98\x76\x54\x32\x10"
+			  "\x00\x11\x22\x33\x44\x55\x66\x77",
+		.klen	= 24,
+		.input	= zeroed_string,
+		.ilen	= 16,
+		.result	= "\xcf\xd1\xd2\xe5\xa9\xbe\x9c\xdf"
+			  "\x50\x1f\x13\xb8\x92\xbd\x22\x48",
+		.rlen	= 16,
+	}, {
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef"
+			  "\xfe\xdc\xba\x98\x76\x54\x32\x10"
+			  "\x00\x11\x22\x33\x44\x55\x66\x77"
+			  "\x88\x99\xaa\xbb\xcc\xdd\xee\xff",
+		.klen	= 32,
+		.input	= zeroed_string,
+		.ilen	= 16,
+		.result	= "\x37\x52\x7b\xe0\x05\x23\x34\xb8"
+			  "\x9f\x0c\xfc\xca\xe8\x7c\xfa\x20",
+		.rlen	= 16,
+	},
+};
+
+static struct cipher_testvec tf_dec_tv_template[] = {
+	{
+		.key	= zeroed_string,
+		.klen	= 16,
+		.input	= "\x9f\x58\x9f\x5c\xf6\x12\x2c\x32"
+			  "\xb6\xbf\xec\x2f\x2a\xe8\xc3\x5a",
+		.ilen	= 16,
+		.result	= zeroed_string,
+		.rlen	= 16,
+	}, {
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef"
+			  "\xfe\xdc\xba\x98\x76\x54\x32\x10"
+			  "\x00\x11\x22\x33\x44\x55\x66\x77",
+		.klen	= 24,
+		.input	= "\xcf\xd1\xd2\xe5\xa9\xbe\x9c\xdf"
+			  "\x50\x1f\x13\xb8\x92\xbd\x22\x48",
+		.ilen	= 16,
+		.result	= zeroed_string,
+		.rlen	= 16,
+	}, {
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef"
+			  "\xfe\xdc\xba\x98\x76\x54\x32\x10"
+			  "\x00\x11\x22\x33\x44\x55\x66\x77"
+			  "\x88\x99\xaa\xbb\xcc\xdd\xee\xff",
+		.klen	= 32,
+		.input	= "\x37\x52\x7b\xe0\x05\x23\x34\xb8"
+			  "\x9f\x0c\xfc\xca\xe8\x7c\xfa\x20",
+		.ilen	= 16,
+		.result	= zeroed_string,
+		.rlen	= 16,
+	},
+};
+
+static struct cipher_testvec tf_cbc_enc_tv_template[] = {
+	{ /* Generated with Nettle */
+		.key	= zeroed_string,
+		.klen	= 16,
+		.iv	= zeroed_string,
+		.input	= zeroed_string,
+		.ilen	= 16,
+		.result	= "\x9f\x58\x9f\x5c\xf6\x12\x2c\x32"
+			  "\xb6\xbf\xec\x2f\x2a\xe8\xc3\x5a",
+		.rlen	= 16,
+	}, {
+		.key	= zeroed_string,
+		.klen	= 16,
+		.iv	= "\x9f\x58\x9f\x5c\xf6\x12\x2c\x32"
+			  "\xb6\xbf\xec\x2f\x2a\xe8\xc3\x5a",
+		.input	= zeroed_string,
+		.ilen	= 16,
+		.result	= "\xd4\x91\xdb\x16\xe7\xb1\xc3\x9e"
+			  "\x86\xcb\x08\x6b\x78\x9f\x54\x19",
+		.rlen	= 16,
+	}, {
+		.key	= zeroed_string,
+		.klen	= 16,
+		.iv	= "\xd4\x91\xdb\x16\xe7\xb1\xc3\x9e"
+			  "\x86\xcb\x08\x6b\x78\x9f\x54\x19",
+		.input	= zeroed_string,
+		.ilen	= 16,
+		.result	= "\x05\xef\x8c\x61\xa8\x11\x58\x26"
+			  "\x34\xba\x5c\xb7\x10\x6a\xa6\x41",
+		.rlen	= 16,
+	}, {
+		.key	= zeroed_string,
+		.klen	= 16,
+		.iv	= zeroed_string,
+		.input	= zeroed_string,
+		.ilen	= 48,
+		.result	= "\x9f\x58\x9f\x5c\xf6\x12\x2c\x32"
+			  "\xb6\xbf\xec\x2f\x2a\xe8\xc3\x5a"
+			  "\xd4\x91\xdb\x16\xe7\xb1\xc3\x9e"
+			  "\x86\xcb\x08\x6b\x78\x9f\x54\x19"
+			  "\x05\xef\x8c\x61\xa8\x11\x58\x26"
+			  "\x34\xba\x5c\xb7\x10\x6a\xa6\x41",
+		.rlen	= 48,
+	},
+};
+
+static struct cipher_testvec tf_cbc_dec_tv_template[] = {
+	{ /* Reverse of the first four above */
+		.key	= zeroed_string,
+		.klen	= 16,
+		.iv	= zeroed_string,
+		.input	= "\x9f\x58\x9f\x5c\xf6\x12\x2c\x32"
+			  "\xb6\xbf\xec\x2f\x2a\xe8\xc3\x5a",
+		.ilen	= 16,
+		.result	= zeroed_string,
+		.rlen	= 16,
+	}, {
+		.key	= zeroed_string,
+		.klen	= 16,
+		.iv	= "\x9f\x58\x9f\x5c\xf6\x12\x2c\x32"
+			  "\xb6\xbf\xec\x2f\x2a\xe8\xc3\x5a",
+		.input	= "\xd4\x91\xdb\x16\xe7\xb1\xc3\x9e"
+			  "\x86\xcb\x08\x6b\x78\x9f\x54\x19",
+		.ilen	= 16,
+		.result	= zeroed_string,
+		.rlen	= 16,
+	}, {
+		.key	= zeroed_string,
+		.klen	= 16,
+		.iv	= "\xd4\x91\xdb\x16\xe7\xb1\xc3\x9e"
+			  "\x86\xcb\x08\x6b\x78\x9f\x54\x19",
+		.input	= "\x05\xef\x8c\x61\xa8\x11\x58\x26"
+			  "\x34\xba\x5c\xb7\x10\x6a\xa6\x41",
+		.ilen	= 16,
+		.result	= zeroed_string,
+		.rlen	= 16,
+	}, {
+		.key	= zeroed_string,
+		.klen	= 16,
+		.iv	= zeroed_string,
+		.input	= "\x9f\x58\x9f\x5c\xf6\x12\x2c\x32"
+			  "\xb6\xbf\xec\x2f\x2a\xe8\xc3\x5a"
+			  "\xd4\x91\xdb\x16\xe7\xb1\xc3\x9e"
+			  "\x86\xcb\x08\x6b\x78\x9f\x54\x19"
+			  "\x05\xef\x8c\x61\xa8\x11\x58\x26"
+			  "\x34\xba\x5c\xb7\x10\x6a\xa6\x41",
+		.ilen	= 48,
+		.result	= zeroed_string,
+		.rlen	= 48,
+	},
+};
+
+/*
+ * Serpent test vectors.  These are backwards because Serpent writes
+ * octet sequences in right-to-left mode.
+ */
+#define SERPENT_ENC_TEST_VECTORS	4
+#define SERPENT_DEC_TEST_VECTORS	4
+
+#define TNEPRES_ENC_TEST_VECTORS	4
+#define TNEPRES_DEC_TEST_VECTORS	4
+
+static struct cipher_testvec serpent_enc_tv_template[] = {
+	{
+		.input	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f",
+		.ilen	= 16,
+		.result	= "\x12\x07\xfc\xce\x9b\xd0\xd6\x47"
+			  "\x6a\xe9\x8f\xbe\xd1\x43\xa0\xe2",
+		.rlen	= 16,
+	}, {
+		.key	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f",
+		.klen	= 16,
+		.input	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f",
+		.ilen	= 16,
+		.result	= "\x4c\x7d\x8a\x32\x80\x72\xa2\x2c"
+			  "\x82\x3e\x4a\x1f\x3a\xcd\xa1\x6d",
+		.rlen	= 16,
+	}, {
+		.key	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+			  "\x10\x11\x12\x13\x14\x15\x16\x17"
+			  "\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f",
+		.klen	= 32,
+		.input	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f",
+		.ilen	= 16,
+		.result	= "\xde\x26\x9f\xf8\x33\xe4\x32\xb8"
+			  "\x5b\x2e\x88\xd2\x70\x1c\xe7\x5c",
+		.rlen	= 16,
+	}, {
+		.key	= "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80",
+		.klen	= 16,
+		.input	= zeroed_string,
+		.ilen	= 16,
+		.result	= "\xdd\xd2\x6b\x98\xa5\xff\xd8\x2c"
+			  "\x05\x34\x5a\x9d\xad\xbf\xaf\x49",
+		.rlen	= 16,
+	},
+};
+
+static struct cipher_testvec tnepres_enc_tv_template[] = {
+	{ /* KeySize=128, PT=0, I=1 */
+		.input	= "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.key    = "\x80\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.klen   = 16,
+		.ilen	= 16,
+		.result	= "\x49\xaf\xbf\xad\x9d\x5a\x34\x05"
+			  "\x2c\xd8\xff\xa5\x98\x6b\xd2\xdd",
+		.rlen	= 16,
+	}, { /* KeySize=192, PT=0, I=1 */
+		.key	= "\x80\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.klen	= 24,
+		.input	= "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.ilen	= 16,
+		.result	= "\xe7\x8e\x54\x02\xc7\x19\x55\x68"
+			  "\xac\x36\x78\xf7\xa3\xf6\x0c\x66",
+		.rlen	= 16,
+	}, { /* KeySize=256, PT=0, I=1 */
+		.key	= "\x80\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.klen	= 32,
+		.input	= "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.ilen	= 16,
+		.result	= "\xab\xed\x96\xe7\x66\xbf\x28\xcb"
+			  "\xc0\xeb\xd2\x1a\x82\xef\x08\x19",
+		.rlen	= 16,
+	}, { /* KeySize=256, I=257 */
+		.key	= "\x1f\x1e\x1d\x1c\x1b\x1a\x19\x18"
+			  "\x17\x16\x15\x14\x13\x12\x11\x10"
+			  "\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08"
+			  "\x07\x06\x05\x04\x03\x02\x01\x00",
+		.klen	= 32,
+		.input	= "\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08"
+			  "\x07\x06\x05\x04\x03\x02\x01\x00",
+		.ilen	= 16,
+		.result	= "\x5c\xe7\x1c\x70\xd2\x88\x2e\x5b"
+			  "\xb8\x32\xe4\x33\xf8\x9f\x26\xde",
+		.rlen	= 16,
+	},
+};
+
+
+static struct cipher_testvec serpent_dec_tv_template[] = {
+	{
+		.input	= "\x12\x07\xfc\xce\x9b\xd0\xd6\x47"
+			  "\x6a\xe9\x8f\xbe\xd1\x43\xa0\xe2",
+		.ilen	= 16,
+		.result	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f",
+		.rlen	= 16,
+	}, {
+		.key	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f",
+		.klen	= 16,
+		.input	= "\x4c\x7d\x8a\x32\x80\x72\xa2\x2c"
+			  "\x82\x3e\x4a\x1f\x3a\xcd\xa1\x6d",
+		.ilen	= 16,
+		.result	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f",
+		.rlen	= 16,
+	}, {
+		.key	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+			  "\x10\x11\x12\x13\x14\x15\x16\x17"
+			  "\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f",
+		.klen	= 32,
+		.input	= "\xde\x26\x9f\xf8\x33\xe4\x32\xb8"
+			  "\x5b\x2e\x88\xd2\x70\x1c\xe7\x5c",
+		.ilen	= 16,
+		.result	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f",
+		.rlen	= 16,
+	}, {
+		.key	= "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80",
+		.klen	= 16,
+		.input	= "\xdd\xd2\x6b\x98\xa5\xff\xd8\x2c"
+			  "\x05\x34\x5a\x9d\xad\xbf\xaf\x49",
+		.ilen	= 16,
+		.result	= zeroed_string,
+		.rlen	= 16,
+	},
+};
+
+static struct cipher_testvec tnepres_dec_tv_template[] = {
+	{
+		.input	= "\x41\xcc\x6b\x31\x59\x31\x45\x97"
+			  "\x6d\x6f\xbb\x38\x4b\x37\x21\x28",
+		.ilen	= 16,
+		.result	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f",
+		.rlen	= 16,
+	}, {
+		.key	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f",
+		.klen	= 16,
+		.input	= "\xea\xf4\xd7\xfc\xd8\x01\x34\x47"
+			  "\x81\x45\x0b\xfa\x0c\xd6\xad\x6e",
+		.ilen	= 16,
+		.result	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f",
+		.rlen	= 16,
+	}, {
+		.key	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+			  "\x10\x11\x12\x13\x14\x15\x16\x17"
+			  "\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f",
+		.klen	= 32,
+		.input	= "\x64\xa9\x1a\x37\xed\x9f\xe7\x49"
+			  "\xa8\x4e\x76\xd6\xf5\x0d\x78\xee",
+		.ilen	= 16,
+		.result	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f",
+		.rlen	= 16,
+	}, { /* KeySize=128, I=121 */
+		.key	= "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80",
+		.klen	= 16,
+		.input	= "\x3d\xda\xbf\xc0\x06\xda\xab\x06"
+			  "\x46\x2a\xf4\xef\x81\x54\x4e\x26",
+		.ilen	= 16,
+		.result	= zeroed_string,
+		.rlen	= 16,
+	},
+};
+
+
+/* Cast6 test vectors from RFC 2612 */
+#define CAST6_ENC_TEST_VECTORS	3
+#define CAST6_DEC_TEST_VECTORS  3
+
+static struct cipher_testvec cast6_enc_tv_template[] = {
+	{
+		.key	= "\x23\x42\xbb\x9e\xfa\x38\x54\x2c"
+			  "\x0a\xf7\x56\x47\xf2\x9f\x61\x5d",
+		.klen	= 16,
+		.input	= zeroed_string,
+		.ilen	= 16,
+		.result	= "\xc8\x42\xa0\x89\x72\xb4\x3d\x20"
+			  "\x83\x6c\x91\xd1\xb7\x53\x0f\x6b",
+		.rlen	= 16,
+	}, {
+		.key	= "\x23\x42\xbb\x9e\xfa\x38\x54\x2c"
+			  "\xbe\xd0\xac\x83\x94\x0a\xc2\x98"
+			  "\xba\xc7\x7a\x77\x17\x94\x28\x63",
+		.klen	= 24,
+		.input	= zeroed_string,
+		.ilen	= 16,
+		.result	= "\x1b\x38\x6c\x02\x10\xdc\xad\xcb"
+			  "\xdd\x0e\x41\xaa\x08\xa7\xa7\xe8",
+		.rlen	= 16,
+	}, {
+		.key	= "\x23\x42\xbb\x9e\xfa\x38\x54\x2c"
+			  "\xbe\xd0\xac\x83\x94\x0a\xc2\x98"
+			  "\x8d\x7c\x47\xce\x26\x49\x08\x46"
+			  "\x1c\xc1\xb5\x13\x7a\xe6\xb6\x04",
+		.klen	= 32,
+		.input	= zeroed_string,
+		.ilen	= 16,
+		.result	= "\x4f\x6a\x20\x38\x28\x68\x97\xb9"
+			  "\xc9\x87\x01\x36\x55\x33\x17\xfa",
+		.rlen	= 16,
+	},
+};
+
+static struct cipher_testvec cast6_dec_tv_template[] = {
+	{
+		.key	= "\x23\x42\xbb\x9e\xfa\x38\x54\x2c"
+			  "\x0a\xf7\x56\x47\xf2\x9f\x61\x5d",
+		.klen	= 16,
+		.input	= "\xc8\x42\xa0\x89\x72\xb4\x3d\x20"
+			  "\x83\x6c\x91\xd1\xb7\x53\x0f\x6b",
+		.ilen	= 16,
+		.result	= zeroed_string,
+		.rlen	= 16,
+	}, {
+		.key	= "\x23\x42\xbb\x9e\xfa\x38\x54\x2c"
+			  "\xbe\xd0\xac\x83\x94\x0a\xc2\x98"
+			  "\xba\xc7\x7a\x77\x17\x94\x28\x63",
+		.klen	= 24,
+		.input	= "\x1b\x38\x6c\x02\x10\xdc\xad\xcb"
+			  "\xdd\x0e\x41\xaa\x08\xa7\xa7\xe8",
+		.ilen	= 16,
+		.result	= zeroed_string,
+		.rlen	= 16,
+	}, {
+		.key	= "\x23\x42\xbb\x9e\xfa\x38\x54\x2c"
+			  "\xbe\xd0\xac\x83\x94\x0a\xc2\x98"
+			  "\x8d\x7c\x47\xce\x26\x49\x08\x46"
+			  "\x1c\xc1\xb5\x13\x7a\xe6\xb6\x04",
+		.klen	= 32,
+		.input	= "\x4f\x6a\x20\x38\x28\x68\x97\xb9"
+			  "\xc9\x87\x01\x36\x55\x33\x17\xfa",
+		.ilen	= 16,
+		.result	= zeroed_string,
+		.rlen	= 16,
+	},
+};
+
+
+/*
+ * AES test vectors.
+ */
+#define AES_ENC_TEST_VECTORS 3
+#define AES_DEC_TEST_VECTORS 3
+#define AES_CBC_ENC_TEST_VECTORS 4
+#define AES_CBC_DEC_TEST_VECTORS 4
+#define AES_LRW_ENC_TEST_VECTORS 8
+#define AES_LRW_DEC_TEST_VECTORS 8
+#define AES_XTS_ENC_TEST_VECTORS 4
+#define AES_XTS_DEC_TEST_VECTORS 4
+#define AES_CTR_ENC_TEST_VECTORS 7
+#define AES_CTR_DEC_TEST_VECTORS 6
+#define AES_GCM_ENC_TEST_VECTORS 9
+#define AES_GCM_DEC_TEST_VECTORS 8
+#define AES_CCM_ENC_TEST_VECTORS 7
+#define AES_CCM_DEC_TEST_VECTORS 7
+
+static struct cipher_testvec aes_enc_tv_template[] = {
+	{ /* From FIPS-197 */
+		.key	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f",
+		.klen	= 16,
+		.input	= "\x00\x11\x22\x33\x44\x55\x66\x77"
+			  "\x88\x99\xaa\xbb\xcc\xdd\xee\xff",
+		.ilen	= 16,
+		.result	= "\x69\xc4\xe0\xd8\x6a\x7b\x04\x30"
+			  "\xd8\xcd\xb7\x80\x70\xb4\xc5\x5a",
+		.rlen	= 16,
+	}, {
+		.key	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+			  "\x10\x11\x12\x13\x14\x15\x16\x17",
+		.klen	= 24,
+		.input	= "\x00\x11\x22\x33\x44\x55\x66\x77"
+			  "\x88\x99\xaa\xbb\xcc\xdd\xee\xff",
+		.ilen	= 16,
+		.result	= "\xdd\xa9\x7c\xa4\x86\x4c\xdf\xe0"
+			  "\x6e\xaf\x70\xa0\xec\x0d\x71\x91",
+		.rlen	= 16,
+	}, {
+		.key	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+			  "\x10\x11\x12\x13\x14\x15\x16\x17"
+			  "\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f",
+		.klen	= 32,
+		.input	= "\x00\x11\x22\x33\x44\x55\x66\x77"
+			  "\x88\x99\xaa\xbb\xcc\xdd\xee\xff",
+		.ilen	= 16,
+		.result	= "\x8e\xa2\xb7\xca\x51\x67\x45\xbf"
+			  "\xea\xfc\x49\x90\x4b\x49\x60\x89",
+		.rlen	= 16,
+	},
+};
+
+static struct cipher_testvec aes_dec_tv_template[] = {
+	{ /* From FIPS-197 */
+		.key	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f",
+		.klen	= 16,
+		.input	= "\x69\xc4\xe0\xd8\x6a\x7b\x04\x30"
+			  "\xd8\xcd\xb7\x80\x70\xb4\xc5\x5a",
+		.ilen	= 16,
+		.result	= "\x00\x11\x22\x33\x44\x55\x66\x77"
+			  "\x88\x99\xaa\xbb\xcc\xdd\xee\xff",
+		.rlen	= 16,
+	}, {
+		.key	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+			  "\x10\x11\x12\x13\x14\x15\x16\x17",
+		.klen	= 24,
+		.input	= "\xdd\xa9\x7c\xa4\x86\x4c\xdf\xe0"
+			  "\x6e\xaf\x70\xa0\xec\x0d\x71\x91",
+		.ilen	= 16,
+		.result	= "\x00\x11\x22\x33\x44\x55\x66\x77"
+			  "\x88\x99\xaa\xbb\xcc\xdd\xee\xff",
+		.rlen	= 16,
+	}, {
+		.key	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+			  "\x10\x11\x12\x13\x14\x15\x16\x17"
+			  "\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f",
+		.klen	= 32,
+		.input	= "\x8e\xa2\xb7\xca\x51\x67\x45\xbf"
+			  "\xea\xfc\x49\x90\x4b\x49\x60\x89",
+		.ilen	= 16,
+		.result	= "\x00\x11\x22\x33\x44\x55\x66\x77"
+			  "\x88\x99\xaa\xbb\xcc\xdd\xee\xff",
+		.rlen	= 16,
+	},
+};
+
+static struct cipher_testvec aes_cbc_enc_tv_template[] = {
+	{ /* From RFC 3602 */
+		.key    = "\x06\xa9\x21\x40\x36\xb8\xa1\x5b"
+			  "\x51\x2e\x03\xd5\x34\x12\x00\x06",
+		.klen   = 16,
+		.iv	= "\x3d\xaf\xba\x42\x9d\x9e\xb4\x30"
+			  "\xb4\x22\xda\x80\x2c\x9f\xac\x41",
+		.input	= "Single block msg",
+		.ilen   = 16,
+		.result = "\xe3\x53\x77\x9c\x10\x79\xae\xb8"
+			  "\x27\x08\x94\x2d\xbe\x77\x18\x1a",
+		.rlen   = 16,
+	}, {
+		.key    = "\xc2\x86\x69\x6d\x88\x7c\x9a\xa0"
+			  "\x61\x1b\xbb\x3e\x20\x25\xa4\x5a",
+		.klen   = 16,
+		.iv     = "\x56\x2e\x17\x99\x6d\x09\x3d\x28"
+			  "\xdd\xb3\xba\x69\x5a\x2e\x6f\x58",
+		.input  = "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+			  "\x10\x11\x12\x13\x14\x15\x16\x17"
+			  "\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f",
+		.ilen   = 32,
+		.result = "\xd2\x96\xcd\x94\xc2\xcc\xcf\x8a"
+			  "\x3a\x86\x30\x28\xb5\xe1\xdc\x0a"
+			  "\x75\x86\x60\x2d\x25\x3c\xff\xf9"
+			  "\x1b\x82\x66\xbe\xa6\xd6\x1a\xb1",
+		.rlen   = 32,
+	}, { /* From NIST SP800-38A */
+		.key	= "\x8e\x73\xb0\xf7\xda\x0e\x64\x52"
+			  "\xc8\x10\xf3\x2b\x80\x90\x79\xe5"
+			  "\x62\xf8\xea\xd2\x52\x2c\x6b\x7b",
+		.klen	= 24,
+		.iv	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f",
+		.input	= "\x6b\xc1\xbe\xe2\x2e\x40\x9f\x96"
+			  "\xe9\x3d\x7e\x11\x73\x93\x17\x2a"
+			  "\xae\x2d\x8a\x57\x1e\x03\xac\x9c"
+			  "\x9e\xb7\x6f\xac\x45\xaf\x8e\x51"
+			  "\x30\xc8\x1c\x46\xa3\x5c\xe4\x11"
+			  "\xe5\xfb\xc1\x19\x1a\x0a\x52\xef"
+			  "\xf6\x9f\x24\x45\xdf\x4f\x9b\x17"
+			  "\xad\x2b\x41\x7b\xe6\x6c\x37\x10",
+		.ilen	= 64,
+		.result	= "\x4f\x02\x1d\xb2\x43\xbc\x63\x3d"
+			  "\x71\x78\x18\x3a\x9f\xa0\x71\xe8"
+			  "\xb4\xd9\xad\xa9\xad\x7d\xed\xf4"
+			  "\xe5\xe7\x38\x76\x3f\x69\x14\x5a"
+			  "\x57\x1b\x24\x20\x12\xfb\x7a\xe0"
+			  "\x7f\xa9\xba\xac\x3d\xf1\x02\xe0"
+			  "\x08\xb0\xe2\x79\x88\x59\x88\x81"
+			  "\xd9\x20\xa9\xe6\x4f\x56\x15\xcd",
+		.rlen	= 64,
+	}, {
+		.key	= "\x60\x3d\xeb\x10\x15\xca\x71\xbe"
+			  "\x2b\x73\xae\xf0\x85\x7d\x77\x81"
+			  "\x1f\x35\x2c\x07\x3b\x61\x08\xd7"
+			  "\x2d\x98\x10\xa3\x09\x14\xdf\xf4",
+		.klen	= 32,
+		.iv	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f",
+		.input	= "\x6b\xc1\xbe\xe2\x2e\x40\x9f\x96"
+			  "\xe9\x3d\x7e\x11\x73\x93\x17\x2a"
+			  "\xae\x2d\x8a\x57\x1e\x03\xac\x9c"
+			  "\x9e\xb7\x6f\xac\x45\xaf\x8e\x51"
+			  "\x30\xc8\x1c\x46\xa3\x5c\xe4\x11"
+			  "\xe5\xfb\xc1\x19\x1a\x0a\x52\xef"
+			  "\xf6\x9f\x24\x45\xdf\x4f\x9b\x17"
+			  "\xad\x2b\x41\x7b\xe6\x6c\x37\x10",
+		.ilen	= 64,
+		.result	= "\xf5\x8c\x4c\x04\xd6\xe5\xf1\xba"
+			  "\x77\x9e\xab\xfb\x5f\x7b\xfb\xd6"
+			  "\x9c\xfc\x4e\x96\x7e\xdb\x80\x8d"
+			  "\x67\x9f\x77\x7b\xc6\x70\x2c\x7d"
+			  "\x39\xf2\x33\x69\xa9\xd9\xba\xcf"
+			  "\xa5\x30\xe2\x63\x04\x23\x14\x61"
+			  "\xb2\xeb\x05\xe2\xc3\x9b\xe9\xfc"
+			  "\xda\x6c\x19\x07\x8c\x6a\x9d\x1b",
+		.rlen	= 64,
+	},
+};
+
+static struct cipher_testvec aes_cbc_dec_tv_template[] = {
+	{ /* From RFC 3602 */
+		.key    = "\x06\xa9\x21\x40\x36\xb8\xa1\x5b"
+			  "\x51\x2e\x03\xd5\x34\x12\x00\x06",
+		.klen   = 16,
+		.iv     = "\x3d\xaf\xba\x42\x9d\x9e\xb4\x30"
+			  "\xb4\x22\xda\x80\x2c\x9f\xac\x41",
+		.input  = "\xe3\x53\x77\x9c\x10\x79\xae\xb8"
+			  "\x27\x08\x94\x2d\xbe\x77\x18\x1a",
+		.ilen   = 16,
+		.result = "Single block msg",
+		.rlen   = 16,
+	}, {
+		.key    = "\xc2\x86\x69\x6d\x88\x7c\x9a\xa0"
+			  "\x61\x1b\xbb\x3e\x20\x25\xa4\x5a",
+		.klen   = 16,
+		.iv     = "\x56\x2e\x17\x99\x6d\x09\x3d\x28"
+			  "\xdd\xb3\xba\x69\x5a\x2e\x6f\x58",
+		.input  = "\xd2\x96\xcd\x94\xc2\xcc\xcf\x8a"
+			  "\x3a\x86\x30\x28\xb5\xe1\xdc\x0a"
+			  "\x75\x86\x60\x2d\x25\x3c\xff\xf9"
+			  "\x1b\x82\x66\xbe\xa6\xd6\x1a\xb1",
+		.ilen   = 32,
+		.result = "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+			  "\x10\x11\x12\x13\x14\x15\x16\x17"
+			  "\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f",
+		.rlen   = 32,
+	}, { /* From NIST SP800-38A */
+		.key	= "\x8e\x73\xb0\xf7\xda\x0e\x64\x52"
+			  "\xc8\x10\xf3\x2b\x80\x90\x79\xe5"
+			  "\x62\xf8\xea\xd2\x52\x2c\x6b\x7b",
+		.klen	= 24,
+		.iv	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f",
+		.input	= "\x4f\x02\x1d\xb2\x43\xbc\x63\x3d"
+			  "\x71\x78\x18\x3a\x9f\xa0\x71\xe8"
+			  "\xb4\xd9\xad\xa9\xad\x7d\xed\xf4"
+			  "\xe5\xe7\x38\x76\x3f\x69\x14\x5a"
+			  "\x57\x1b\x24\x20\x12\xfb\x7a\xe0"
+			  "\x7f\xa9\xba\xac\x3d\xf1\x02\xe0"
+			  "\x08\xb0\xe2\x79\x88\x59\x88\x81"
+			  "\xd9\x20\xa9\xe6\x4f\x56\x15\xcd",
+		.ilen	= 64,
+		.result	= "\x6b\xc1\xbe\xe2\x2e\x40\x9f\x96"
+			  "\xe9\x3d\x7e\x11\x73\x93\x17\x2a"
+			  "\xae\x2d\x8a\x57\x1e\x03\xac\x9c"
+			  "\x9e\xb7\x6f\xac\x45\xaf\x8e\x51"
+			  "\x30\xc8\x1c\x46\xa3\x5c\xe4\x11"
+			  "\xe5\xfb\xc1\x19\x1a\x0a\x52\xef"
+			  "\xf6\x9f\x24\x45\xdf\x4f\x9b\x17"
+			  "\xad\x2b\x41\x7b\xe6\x6c\x37\x10",
+		.rlen	= 64,
+	}, {
+		.key	= "\x60\x3d\xeb\x10\x15\xca\x71\xbe"
+			  "\x2b\x73\xae\xf0\x85\x7d\x77\x81"
+			  "\x1f\x35\x2c\x07\x3b\x61\x08\xd7"
+			  "\x2d\x98\x10\xa3\x09\x14\xdf\xf4",
+		.klen	= 32,
+		.iv	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f",
+		.input	= "\xf5\x8c\x4c\x04\xd6\xe5\xf1\xba"
+			  "\x77\x9e\xab\xfb\x5f\x7b\xfb\xd6"
+			  "\x9c\xfc\x4e\x96\x7e\xdb\x80\x8d"
+			  "\x67\x9f\x77\x7b\xc6\x70\x2c\x7d"
+			  "\x39\xf2\x33\x69\xa9\xd9\xba\xcf"
+			  "\xa5\x30\xe2\x63\x04\x23\x14\x61"
+			  "\xb2\xeb\x05\xe2\xc3\x9b\xe9\xfc"
+			  "\xda\x6c\x19\x07\x8c\x6a\x9d\x1b",
+		.ilen	= 64,
+		.result	= "\x6b\xc1\xbe\xe2\x2e\x40\x9f\x96"
+			  "\xe9\x3d\x7e\x11\x73\x93\x17\x2a"
+			  "\xae\x2d\x8a\x57\x1e\x03\xac\x9c"
+			  "\x9e\xb7\x6f\xac\x45\xaf\x8e\x51"
+			  "\x30\xc8\x1c\x46\xa3\x5c\xe4\x11"
+			  "\xe5\xfb\xc1\x19\x1a\x0a\x52\xef"
+			  "\xf6\x9f\x24\x45\xdf\x4f\x9b\x17"
+			  "\xad\x2b\x41\x7b\xe6\x6c\x37\x10",
+		.rlen	= 64,
+	},
+};
+
+static struct cipher_testvec aes_lrw_enc_tv_template[] = {
+	/* from http://grouper.ieee.org/groups/1619/email/pdf00017.pdf */
+	{ /* LRW-32-AES 1 */
+		.key    = "\x45\x62\xac\x25\xf8\x28\x17\x6d"
+			  "\x4c\x26\x84\x14\xb5\x68\x01\x85"
+			  "\x25\x8e\x2a\x05\xe7\x3e\x9d\x03"
+			  "\xee\x5a\x83\x0c\xcc\x09\x4c\x87",
+		.klen   = 32,
+		.iv     = "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x01",
+		.input  = "\x30\x31\x32\x33\x34\x35\x36\x37"
+			  "\x38\x39\x41\x42\x43\x44\x45\x46",
+		.ilen   = 16,
+		.result = "\xf1\xb2\x73\xcd\x65\xa3\xdf\x5f"
+			  "\xe9\x5d\x48\x92\x54\x63\x4e\xb8",
+		.rlen   = 16,
+	}, { /* LRW-32-AES 2 */
+		.key    = "\x59\x70\x47\x14\xf5\x57\x47\x8c"
+			  "\xd7\x79\xe8\x0f\x54\x88\x79\x44"
+			  "\x0d\x48\xf0\xb7\xb1\x5a\x53\xea"
+			  "\x1c\xaa\x6b\x29\xc2\xca\xfb\xaf",
+		.klen   = 32,
+		.iv     = "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x02",
+		.input  = "\x30\x31\x32\x33\x34\x35\x36\x37"
+			  "\x38\x39\x41\x42\x43\x44\x45\x46",
+		.ilen   = 16,
+		.result = "\x00\xc8\x2b\xae\x95\xbb\xcd\xe5"
+			  "\x27\x4f\x07\x69\xb2\x60\xe1\x36",
+		.rlen   = 16,
+	}, { /* LRW-32-AES 3 */
+		.key    = "\xd8\x2a\x91\x34\xb2\x6a\x56\x50"
+			  "\x30\xfe\x69\xe2\x37\x7f\x98\x47"
+			  "\xcd\xf9\x0b\x16\x0c\x64\x8f\xb6"
+			  "\xb0\x0d\x0d\x1b\xae\x85\x87\x1f",
+		.klen   = 32,
+		.iv     = "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x02\x00\x00\x00\x00",
+		.input  = "\x30\x31\x32\x33\x34\x35\x36\x37"
+			  "\x38\x39\x41\x42\x43\x44\x45\x46",
+		.ilen   = 16,
+		.result = "\x76\x32\x21\x83\xed\x8f\xf1\x82"
+			  "\xf9\x59\x62\x03\x69\x0e\x5e\x01",
+		.rlen   = 16,
+	}, { /* LRW-32-AES 4 */
+		.key    = "\x0f\x6a\xef\xf8\xd3\xd2\xbb\x15"
+			  "\x25\x83\xf7\x3c\x1f\x01\x28\x74"
+			  "\xca\xc6\xbc\x35\x4d\x4a\x65\x54"
+			  "\x90\xae\x61\xcf\x7b\xae\xbd\xcc"
+			  "\xad\xe4\x94\xc5\x4a\x29\xae\x70",
+		.klen   = 40,
+		.iv     = "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x01",
+		.input  = "\x30\x31\x32\x33\x34\x35\x36\x37"
+			  "\x38\x39\x41\x42\x43\x44\x45\x46",
+		.ilen   = 16,
+		.result = "\x9c\x0f\x15\x2f\x55\xa2\xd8\xf0"
+			  "\xd6\x7b\x8f\x9e\x28\x22\xbc\x41",
+		.rlen   = 16,
+	}, { /* LRW-32-AES 5 */
+		.key    = "\x8a\xd4\xee\x10\x2f\xbd\x81\xff"
+			  "\xf8\x86\xce\xac\x93\xc5\xad\xc6"
+			  "\xa0\x19\x07\xc0\x9d\xf7\xbb\xdd"
+			  "\x52\x13\xb2\xb7\xf0\xff\x11\xd8"
+			  "\xd6\x08\xd0\xcd\x2e\xb1\x17\x6f",
+		.klen   = 40,
+		.iv     = "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x02\x00\x00\x00\x00",
+		.input  = "\x30\x31\x32\x33\x34\x35\x36\x37"
+			  "\x38\x39\x41\x42\x43\x44\x45\x46",
+		.ilen   = 16,
+		.result = "\xd4\x27\x6a\x7f\x14\x91\x3d\x65"
+			  "\xc8\x60\x48\x02\x87\xe3\x34\x06",
+		.rlen   = 16,
+	}, { /* LRW-32-AES 6 */
+		.key    = "\xf8\xd4\x76\xff\xd6\x46\xee\x6c"
+			  "\x23\x84\xcb\x1c\x77\xd6\x19\x5d"
+			  "\xfe\xf1\xa9\xf3\x7b\xbc\x8d\x21"
+			  "\xa7\x9c\x21\xf8\xcb\x90\x02\x89"
+			  "\xa8\x45\x34\x8e\xc8\xc5\xb5\xf1"
+			  "\x26\xf5\x0e\x76\xfe\xfd\x1b\x1e",
+		.klen   = 48,
+		.iv     = "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x01",
+		.input  = "\x30\x31\x32\x33\x34\x35\x36\x37"
+			  "\x38\x39\x41\x42\x43\x44\x45\x46",
+		.ilen   = 16,
+		.result = "\xbd\x06\xb8\xe1\xdb\x98\x89\x9e"
+			  "\xc4\x98\xe4\x91\xcf\x1c\x70\x2b",
+		.rlen   = 16,
+	}, { /* LRW-32-AES 7 */
+		.key    = "\xfb\x76\x15\xb2\x3d\x80\x89\x1d"
+			  "\xd4\x70\x98\x0b\xc7\x95\x84\xc8"
+			  "\xb2\xfb\x64\xce\x60\x97\x87\x8d"
+			  "\x17\xfc\xe4\x5a\x49\xe8\x30\xb7"
+			  "\x6e\x78\x17\xe7\x2d\x5e\x12\xd4"
+			  "\x60\x64\x04\x7a\xf1\x2f\x9e\x0c",
+		.klen   = 48,
+		.iv     = "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x02\x00\x00\x00\x00",
+		.input  = "\x30\x31\x32\x33\x34\x35\x36\x37"
+			  "\x38\x39\x41\x42\x43\x44\x45\x46",
+		.ilen   = 16,
+		.result = "\x5b\x90\x8e\xc1\xab\xdd\x67\x5f"
+			  "\x3d\x69\x8a\x95\x53\xc8\x9c\xe5",
+		.rlen   = 16,
+	}, {
+/* http://www.mail-archive.com/stds-p1619@listserv.ieee.org/msg00173.html */
+		.key    = "\xf8\xd4\x76\xff\xd6\x46\xee\x6c"
+			  "\x23\x84\xcb\x1c\x77\xd6\x19\x5d"
+			  "\xfe\xf1\xa9\xf3\x7b\xbc\x8d\x21"
+			  "\xa7\x9c\x21\xf8\xcb\x90\x02\x89"
+			  "\xa8\x45\x34\x8e\xc8\xc5\xb5\xf1"
+			  "\x26\xf5\x0e\x76\xfe\xfd\x1b\x1e",
+		.klen   = 48,
+		.iv     = "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x01",
+		.input  = "\x05\x11\xb7\x18\xab\xc6\x2d\xac"
+			  "\x70\x5d\xf6\x22\x94\xcd\xe5\x6c"
+			  "\x17\x6b\xf6\x1c\xf0\xf3\x6e\xf8"
+			  "\x50\x38\x1f\x71\x49\xb6\x57\xd6"
+			  "\x8f\xcb\x8d\x6b\xe3\xa6\x29\x90"
+			  "\xfe\x2a\x62\x82\xae\x6d\x8b\xf6"
+			  "\xad\x1e\x9e\x20\x5f\x38\xbe\x04"
+			  "\xda\x10\x8e\xed\xa2\xa4\x87\xab"
+			  "\xda\x6b\xb4\x0c\x75\xba\xd3\x7c"
+			  "\xc9\xac\x42\x31\x95\x7c\xc9\x04"
+			  "\xeb\xd5\x6e\x32\x69\x8a\xdb\xa6"
+			  "\x15\xd7\x3f\x4f\x2f\x66\x69\x03"
+			  "\x9c\x1f\x54\x0f\xde\x1f\xf3\x65"
+			  "\x4c\x96\x12\xed\x7c\x92\x03\x01"
+			  "\x6f\xbc\x35\x93\xac\xf1\x27\xf1"
+			  "\xb4\x96\x82\x5a\x5f\xb0\xa0\x50"
+			  "\x89\xa4\x8e\x66\x44\x85\xcc\xfd"
+			  "\x33\x14\x70\xe3\x96\xb2\xc3\xd3"
+			  "\xbb\x54\x5a\x1a\xf9\x74\xa2\xc5"
+			  "\x2d\x64\x75\xdd\xb4\x54\xe6\x74"
+			  "\x8c\xd3\x9d\x9e\x86\xab\x51\x53"
+			  "\xb7\x93\x3e\x6f\xd0\x4e\x2c\x40"
+			  "\xf6\xa8\x2e\x3e\x9d\xf4\x66\xa5"
+			  "\x76\x12\x73\x44\x1a\x56\xd7\x72"
+			  "\x88\xcd\x21\x8c\x4c\x0f\xfe\xda"
+			  "\x95\xe0\x3a\xa6\xa5\x84\x46\xcd"
+			  "\xd5\x3e\x9d\x3a\xe2\x67\xe6\x60"
+			  "\x1a\xe2\x70\x85\x58\xc2\x1b\x09"
+			  "\xe1\xd7\x2c\xca\xad\xa8\x8f\xf9"
+			  "\xac\xb3\x0e\xdb\xca\x2e\xe2\xb8"
+			  "\x51\x71\xd9\x3c\x6c\xf1\x56\xf8"
+			  "\xea\x9c\xf1\xfb\x0c\xe6\xb7\x10"
+			  "\x1c\xf8\xa9\x7c\xe8\x53\x35\xc1"
+			  "\x90\x3e\x76\x4a\x74\xa4\x21\x2c"
+			  "\xf6\x2c\x4e\x0f\x94\x3a\x88\x2e"
+			  "\x41\x09\x6a\x33\x7d\xf6\xdd\x3f"
+			  "\x8d\x23\x31\x74\x84\xeb\x88\x6e"
+			  "\xcc\xb9\xbc\x22\x83\x19\x07\x22"
+			  "\xa5\x2d\xdf\xa5\xf3\x80\x85\x78"
+			  "\x84\x39\x6a\x6d\x6a\x99\x4f\xa5"
+			  "\x15\xfe\x46\xb0\xe4\x6c\xa5\x41"
+			  "\x3c\xce\x8f\x42\x60\x71\xa7\x75"
+			  "\x08\x40\x65\x8a\x82\xbf\xf5\x43"
+			  "\x71\x96\xa9\x4d\x44\x8a\x20\xbe"
+			  "\xfa\x4d\xbb\xc0\x7d\x31\x96\x65"
+			  "\xe7\x75\xe5\x3e\xfd\x92\x3b\xc9"
+			  "\x55\xbb\x16\x7e\xf7\xc2\x8c\xa4"
+			  "\x40\x1d\xe5\xef\x0e\xdf\xe4\x9a"
+			  "\x62\x73\x65\xfd\x46\x63\x25\x3d"
+			  "\x2b\xaf\xe5\x64\xfe\xa5\x5c\xcf"
+			  "\x24\xf3\xb4\xac\x64\xba\xdf\x4b"
+			  "\xc6\x96\x7d\x81\x2d\x8d\x97\xf7"
+			  "\xc5\x68\x77\x84\x32\x2b\xcc\x85"
+			  "\x74\x96\xf0\x12\x77\x61\xb9\xeb"
+			  "\x71\xaa\x82\xcb\x1c\xdb\x89\xc8"
+			  "\xc6\xb5\xe3\x5c\x7d\x39\x07\x24"
+			  "\xda\x39\x87\x45\xc0\x2b\xbb\x01"
+			  "\xac\xbc\x2a\x5c\x7f\xfc\xe8\xce"
+			  "\x6d\x9c\x6f\xed\xd3\xc1\xa1\xd6"
+			  "\xc5\x55\xa9\x66\x2f\xe1\xc8\x32"
+			  "\xa6\x5d\xa4\x3a\x98\x73\xe8\x45"
+			  "\xa4\xc7\xa8\xb4\xf6\x13\x03\xf6"
+			  "\xe9\x2e\xc4\x29\x0f\x84\xdb\xc4"
+			  "\x21\xc4\xc2\x75\x67\x89\x37\x0a",
+		.ilen   = 512,
+		.result = "\x1a\x1d\xa9\x30\xad\xf9\x2f\x9b"
+			  "\xb6\x1d\xae\xef\xf0\x2f\xf8\x5a"
+			  "\x39\x3c\xbf\x2a\xb2\x45\xb2\x23"
+			  "\x1b\x63\x3c\xcf\xaa\xbe\xcf\x4e"
+			  "\xfa\xe8\x29\xc2\x20\x68\x2b\x3c"
+			  "\x2e\x8b\xf7\x6e\x25\xbd\xe3\x3d"
+			  "\x66\x27\xd6\xaf\xd6\x64\x3e\xe3"
+			  "\xe8\x58\x46\x97\x39\x51\x07\xde"
+			  "\xcb\x37\xbc\xa9\xc0\x5f\x75\xc3"
+			  "\x0e\x84\x23\x1d\x16\xd4\x1c\x59"
+			  "\x9c\x1a\x02\x55\xab\x3a\x97\x1d"
+			  "\xdf\xdd\xc7\x06\x51\xd7\x70\xae"
+			  "\x23\xc6\x8c\xf5\x1e\xa0\xe5\x82"
+			  "\xb8\xb2\xbf\x04\xa0\x32\x8e\x68"
+			  "\xeb\xaf\x6e\x2d\x94\x22\x2f\xce"
+			  "\x4c\xb5\x59\xe2\xa2\x2f\xa0\x98"
+			  "\x1a\x97\xc6\xd4\xb5\x00\x59\xf2"
+			  "\x84\x14\x72\xb1\x9a\x6e\xa3\x7f"
+			  "\xea\x20\xe7\xcb\x65\x77\x3a\xdf"
+			  "\xc8\x97\x67\x15\xc2\x2a\x27\xcc"
+			  "\x18\x55\xa1\x24\x0b\x24\x24\xaf"
+			  "\x5b\xec\x68\xb8\xc8\xf5\xba\x63"
+			  "\xff\xed\x89\xce\xd5\x3d\x88\xf3"
+			  "\x25\xef\x05\x7c\x3a\xef\xeb\xd8"
+			  "\x7a\x32\x0d\xd1\x1e\x58\x59\x99"
+			  "\x90\x25\xb5\x26\xb0\xe3\x2b\x6c"
+			  "\x4c\xa9\x8b\x84\x4f\x5e\x01\x50"
+			  "\x41\x30\x58\xc5\x62\x74\x52\x1d"
+			  "\x45\x24\x6a\x42\x64\x4f\x97\x1c"
+			  "\xa8\x66\xb5\x6d\x79\xd4\x0d\x48"
+			  "\xc5\x5f\xf3\x90\x32\xdd\xdd\xe1"
+			  "\xe4\xa9\x9f\xfc\xc3\x52\x5a\x46"
+			  "\xe4\x81\x84\x95\x36\x59\x7a\x6b"
+			  "\xaa\xb3\x60\xad\xce\x9f\x9f\x28"
+			  "\xe0\x01\x75\x22\xc4\x4e\xa9\x62"
+			  "\x5c\x62\x0d\x00\xcb\x13\xe8\x43"
+			  "\x72\xd4\x2d\x53\x46\xb5\xd1\x16"
+			  "\x22\x18\xdf\x34\x33\xf5\xd6\x1c"
+			  "\xb8\x79\x78\x97\x94\xff\x72\x13"
+			  "\x4c\x27\xfc\xcb\xbf\x01\x53\xa6"
+			  "\xb4\x50\x6e\xde\xdf\xb5\x43\xa4"
+			  "\x59\xdf\x52\xf9\x7c\xe0\x11\x6f"
+			  "\x2d\x14\x8e\x24\x61\x2c\xe1\x17"
+			  "\xcc\xce\x51\x0c\x19\x8a\x82\x30"
+			  "\x94\xd5\x3d\x6a\x53\x06\x5e\xbd"
+			  "\xb7\xeb\xfa\xfd\x27\x51\xde\x85"
+			  "\x1e\x86\x53\x11\x53\x94\x00\xee"
+			  "\x2b\x8c\x08\x2a\xbf\xdd\xae\x11"
+			  "\xcb\x1e\xa2\x07\x9a\x80\xcf\x62"
+			  "\x9b\x09\xdc\x95\x3c\x96\x8e\xb1"
+			  "\x09\xbd\xe4\xeb\xdb\xca\x70\x7a"
+			  "\x9e\xfa\x31\x18\x45\x3c\x21\x33"
+			  "\xb0\xb3\x2b\xea\xf3\x71\x2d\xe1"
+			  "\x03\xad\x1b\x48\xd4\x67\x27\xf0"
+			  "\x62\xe4\x3d\xfb\x9b\x08\x76\xe7"
+			  "\xdd\x2b\x01\x39\x04\x5a\x58\x7a"
+			  "\xf7\x11\x90\xec\xbd\x51\x5c\x32"
+			  "\x6b\xd7\x35\x39\x02\x6b\xf2\xa6"
+			  "\xd0\x0d\x07\xe1\x06\xc4\x5b\x7d"
+			  "\xe4\x6a\xd7\xee\x15\x1f\x83\xb4"
+			  "\xa3\xa7\x5e\xc3\x90\xb7\xef\xd3"
+			  "\xb7\x4f\xf8\x92\x4c\xb7\x3c\x29"
+			  "\xcd\x7e\x2b\x5d\x43\xea\x42\xe7"
+			  "\x74\x3f\x7d\x58\x88\x75\xde\x3e",
+		.rlen   = 512,
+	}
+};
+
+static struct cipher_testvec aes_lrw_dec_tv_template[] = {
+	/* from http://grouper.ieee.org/groups/1619/email/pdf00017.pdf */
+	/* same as enc vectors with input and result reversed */
+	{ /* LRW-32-AES 1 */
+		.key    = "\x45\x62\xac\x25\xf8\x28\x17\x6d"
+			  "\x4c\x26\x84\x14\xb5\x68\x01\x85"
+			  "\x25\x8e\x2a\x05\xe7\x3e\x9d\x03"
+			  "\xee\x5a\x83\x0c\xcc\x09\x4c\x87",
+		.klen   = 32,
+		.iv     = "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x01",
+		.input  = "\xf1\xb2\x73\xcd\x65\xa3\xdf\x5f"
+			  "\xe9\x5d\x48\x92\x54\x63\x4e\xb8",
+		.ilen   = 16,
+		.result = "\x30\x31\x32\x33\x34\x35\x36\x37"
+			  "\x38\x39\x41\x42\x43\x44\x45\x46",
+		.rlen   = 16,
+	}, { /* LRW-32-AES 2 */
+		.key    = "\x59\x70\x47\x14\xf5\x57\x47\x8c"
+			  "\xd7\x79\xe8\x0f\x54\x88\x79\x44"
+			  "\x0d\x48\xf0\xb7\xb1\x5a\x53\xea"
+			  "\x1c\xaa\x6b\x29\xc2\xca\xfb\xaf",
+		.klen   = 32,
+		.iv     = "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x02",
+		.input  = "\x00\xc8\x2b\xae\x95\xbb\xcd\xe5"
+			  "\x27\x4f\x07\x69\xb2\x60\xe1\x36",
+		.ilen   = 16,
+		.result  = "\x30\x31\x32\x33\x34\x35\x36\x37"
+			   "\x38\x39\x41\x42\x43\x44\x45\x46",
+		.rlen   = 16,
+	}, { /* LRW-32-AES 3 */
+		.key    = "\xd8\x2a\x91\x34\xb2\x6a\x56\x50"
+			  "\x30\xfe\x69\xe2\x37\x7f\x98\x47"
+			  "\xcd\xf9\x0b\x16\x0c\x64\x8f\xb6"
+			  "\xb0\x0d\x0d\x1b\xae\x85\x87\x1f",
+		.klen   = 32,
+		.iv     = "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x02\x00\x00\x00\x00",
+		.input  = "\x76\x32\x21\x83\xed\x8f\xf1\x82"
+			  "\xf9\x59\x62\x03\x69\x0e\x5e\x01",
+		.ilen   = 16,
+		.result = "\x30\x31\x32\x33\x34\x35\x36\x37"
+			  "\x38\x39\x41\x42\x43\x44\x45\x46",
+		.rlen   = 16,
+	}, { /* LRW-32-AES 4 */
+		.key    = "\x0f\x6a\xef\xf8\xd3\xd2\xbb\x15"
+			  "\x25\x83\xf7\x3c\x1f\x01\x28\x74"
+			  "\xca\xc6\xbc\x35\x4d\x4a\x65\x54"
+			  "\x90\xae\x61\xcf\x7b\xae\xbd\xcc"
+			  "\xad\xe4\x94\xc5\x4a\x29\xae\x70",
+		.klen   = 40,
+		.iv     = "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x01",
+		.input  = "\x9c\x0f\x15\x2f\x55\xa2\xd8\xf0"
+			  "\xd6\x7b\x8f\x9e\x28\x22\xbc\x41",
+		.ilen   = 16,
+		.result = "\x30\x31\x32\x33\x34\x35\x36\x37"
+			  "\x38\x39\x41\x42\x43\x44\x45\x46",
+		.rlen   = 16,
+	}, { /* LRW-32-AES 5 */
+		.key    = "\x8a\xd4\xee\x10\x2f\xbd\x81\xff"
+			  "\xf8\x86\xce\xac\x93\xc5\xad\xc6"
+			  "\xa0\x19\x07\xc0\x9d\xf7\xbb\xdd"
+			  "\x52\x13\xb2\xb7\xf0\xff\x11\xd8"
+			  "\xd6\x08\xd0\xcd\x2e\xb1\x17\x6f",
+		.klen   = 40,
+		.iv     = "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x02\x00\x00\x00\x00",
+		.input  = "\xd4\x27\x6a\x7f\x14\x91\x3d\x65"
+			  "\xc8\x60\x48\x02\x87\xe3\x34\x06",
+		.ilen   = 16,
+		.result = "\x30\x31\x32\x33\x34\x35\x36\x37"
+			  "\x38\x39\x41\x42\x43\x44\x45\x46",
+		.rlen   = 16,
+	}, { /* LRW-32-AES 6 */
+		.key    = "\xf8\xd4\x76\xff\xd6\x46\xee\x6c"
+			  "\x23\x84\xcb\x1c\x77\xd6\x19\x5d"
+			  "\xfe\xf1\xa9\xf3\x7b\xbc\x8d\x21"
+			  "\xa7\x9c\x21\xf8\xcb\x90\x02\x89"
+			  "\xa8\x45\x34\x8e\xc8\xc5\xb5\xf1"
+			  "\x26\xf5\x0e\x76\xfe\xfd\x1b\x1e",
+		.klen   = 48,
+		.iv     = "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x01",
+		.input  = "\xbd\x06\xb8\xe1\xdb\x98\x89\x9e"
+			  "\xc4\x98\xe4\x91\xcf\x1c\x70\x2b",
+		.ilen   = 16,
+		.result = "\x30\x31\x32\x33\x34\x35\x36\x37"
+			  "\x38\x39\x41\x42\x43\x44\x45\x46",
+		.rlen   = 16,
+	}, { /* LRW-32-AES 7 */
+		.key    = "\xfb\x76\x15\xb2\x3d\x80\x89\x1d"
+			  "\xd4\x70\x98\x0b\xc7\x95\x84\xc8"
+			  "\xb2\xfb\x64\xce\x60\x97\x87\x8d"
+			  "\x17\xfc\xe4\x5a\x49\xe8\x30\xb7"
+			  "\x6e\x78\x17\xe7\x2d\x5e\x12\xd4"
+			  "\x60\x64\x04\x7a\xf1\x2f\x9e\x0c",
+		.klen   = 48,
+		.iv     = "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x02\x00\x00\x00\x00",
+		.input  = "\x5b\x90\x8e\xc1\xab\xdd\x67\x5f"
+			  "\x3d\x69\x8a\x95\x53\xc8\x9c\xe5",
+		.ilen   = 16,
+		.result = "\x30\x31\x32\x33\x34\x35\x36\x37"
+			  "\x38\x39\x41\x42\x43\x44\x45\x46",
+		.rlen   = 16,
+	}, {
+/* http://www.mail-archive.com/stds-p1619@listserv.ieee.org/msg00173.html */
+		.key    = "\xf8\xd4\x76\xff\xd6\x46\xee\x6c"
+			  "\x23\x84\xcb\x1c\x77\xd6\x19\x5d"
+			  "\xfe\xf1\xa9\xf3\x7b\xbc\x8d\x21"
+			  "\xa7\x9c\x21\xf8\xcb\x90\x02\x89"
+			  "\xa8\x45\x34\x8e\xc8\xc5\xb5\xf1"
+			  "\x26\xf5\x0e\x76\xfe\xfd\x1b\x1e",
+		.klen   = 48,
+		.iv     = "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x01",
+		.input	= "\x1a\x1d\xa9\x30\xad\xf9\x2f\x9b"
+			  "\xb6\x1d\xae\xef\xf0\x2f\xf8\x5a"
+			  "\x39\x3c\xbf\x2a\xb2\x45\xb2\x23"
+			  "\x1b\x63\x3c\xcf\xaa\xbe\xcf\x4e"
+			  "\xfa\xe8\x29\xc2\x20\x68\x2b\x3c"
+			  "\x2e\x8b\xf7\x6e\x25\xbd\xe3\x3d"
+			  "\x66\x27\xd6\xaf\xd6\x64\x3e\xe3"
+			  "\xe8\x58\x46\x97\x39\x51\x07\xde"
+			  "\xcb\x37\xbc\xa9\xc0\x5f\x75\xc3"
+			  "\x0e\x84\x23\x1d\x16\xd4\x1c\x59"
+			  "\x9c\x1a\x02\x55\xab\x3a\x97\x1d"
+			  "\xdf\xdd\xc7\x06\x51\xd7\x70\xae"
+			  "\x23\xc6\x8c\xf5\x1e\xa0\xe5\x82"
+			  "\xb8\xb2\xbf\x04\xa0\x32\x8e\x68"
+			  "\xeb\xaf\x6e\x2d\x94\x22\x2f\xce"
+			  "\x4c\xb5\x59\xe2\xa2\x2f\xa0\x98"
+			  "\x1a\x97\xc6\xd4\xb5\x00\x59\xf2"
+			  "\x84\x14\x72\xb1\x9a\x6e\xa3\x7f"
+			  "\xea\x20\xe7\xcb\x65\x77\x3a\xdf"
+			  "\xc8\x97\x67\x15\xc2\x2a\x27\xcc"
+			  "\x18\x55\xa1\x24\x0b\x24\x24\xaf"
+			  "\x5b\xec\x68\xb8\xc8\xf5\xba\x63"
+			  "\xff\xed\x89\xce\xd5\x3d\x88\xf3"
+			  "\x25\xef\x05\x7c\x3a\xef\xeb\xd8"
+			  "\x7a\x32\x0d\xd1\x1e\x58\x59\x99"
+			  "\x90\x25\xb5\x26\xb0\xe3\x2b\x6c"
+			  "\x4c\xa9\x8b\x84\x4f\x5e\x01\x50"
+			  "\x41\x30\x58\xc5\x62\x74\x52\x1d"
+			  "\x45\x24\x6a\x42\x64\x4f\x97\x1c"
+			  "\xa8\x66\xb5\x6d\x79\xd4\x0d\x48"
+			  "\xc5\x5f\xf3\x90\x32\xdd\xdd\xe1"
+			  "\xe4\xa9\x9f\xfc\xc3\x52\x5a\x46"
+			  "\xe4\x81\x84\x95\x36\x59\x7a\x6b"
+			  "\xaa\xb3\x60\xad\xce\x9f\x9f\x28"
+			  "\xe0\x01\x75\x22\xc4\x4e\xa9\x62"
+			  "\x5c\x62\x0d\x00\xcb\x13\xe8\x43"
+			  "\x72\xd4\x2d\x53\x46\xb5\xd1\x16"
+			  "\x22\x18\xdf\x34\x33\xf5\xd6\x1c"
+			  "\xb8\x79\x78\x97\x94\xff\x72\x13"
+			  "\x4c\x27\xfc\xcb\xbf\x01\x53\xa6"
+			  "\xb4\x50\x6e\xde\xdf\xb5\x43\xa4"
+			  "\x59\xdf\x52\xf9\x7c\xe0\x11\x6f"
+			  "\x2d\x14\x8e\x24\x61\x2c\xe1\x17"
+			  "\xcc\xce\x51\x0c\x19\x8a\x82\x30"
+			  "\x94\xd5\x3d\x6a\x53\x06\x5e\xbd"
+			  "\xb7\xeb\xfa\xfd\x27\x51\xde\x85"
+			  "\x1e\x86\x53\x11\x53\x94\x00\xee"
+			  "\x2b\x8c\x08\x2a\xbf\xdd\xae\x11"
+			  "\xcb\x1e\xa2\x07\x9a\x80\xcf\x62"
+			  "\x9b\x09\xdc\x95\x3c\x96\x8e\xb1"
+			  "\x09\xbd\xe4\xeb\xdb\xca\x70\x7a"
+			  "\x9e\xfa\x31\x18\x45\x3c\x21\x33"
+			  "\xb0\xb3\x2b\xea\xf3\x71\x2d\xe1"
+			  "\x03\xad\x1b\x48\xd4\x67\x27\xf0"
+			  "\x62\xe4\x3d\xfb\x9b\x08\x76\xe7"
+			  "\xdd\x2b\x01\x39\x04\x5a\x58\x7a"
+			  "\xf7\x11\x90\xec\xbd\x51\x5c\x32"
+			  "\x6b\xd7\x35\x39\x02\x6b\xf2\xa6"
+			  "\xd0\x0d\x07\xe1\x06\xc4\x5b\x7d"
+			  "\xe4\x6a\xd7\xee\x15\x1f\x83\xb4"
+			  "\xa3\xa7\x5e\xc3\x90\xb7\xef\xd3"
+			  "\xb7\x4f\xf8\x92\x4c\xb7\x3c\x29"
+			  "\xcd\x7e\x2b\x5d\x43\xea\x42\xe7"
+			  "\x74\x3f\x7d\x58\x88\x75\xde\x3e",
+		.ilen   = 512,
+		.result	= "\x05\x11\xb7\x18\xab\xc6\x2d\xac"
+			  "\x70\x5d\xf6\x22\x94\xcd\xe5\x6c"
+			  "\x17\x6b\xf6\x1c\xf0\xf3\x6e\xf8"
+			  "\x50\x38\x1f\x71\x49\xb6\x57\xd6"
+			  "\x8f\xcb\x8d\x6b\xe3\xa6\x29\x90"
+			  "\xfe\x2a\x62\x82\xae\x6d\x8b\xf6"
+			  "\xad\x1e\x9e\x20\x5f\x38\xbe\x04"
+			  "\xda\x10\x8e\xed\xa2\xa4\x87\xab"
+			  "\xda\x6b\xb4\x0c\x75\xba\xd3\x7c"
+			  "\xc9\xac\x42\x31\x95\x7c\xc9\x04"
+			  "\xeb\xd5\x6e\x32\x69\x8a\xdb\xa6"
+			  "\x15\xd7\x3f\x4f\x2f\x66\x69\x03"
+			  "\x9c\x1f\x54\x0f\xde\x1f\xf3\x65"
+			  "\x4c\x96\x12\xed\x7c\x92\x03\x01"
+			  "\x6f\xbc\x35\x93\xac\xf1\x27\xf1"
+			  "\xb4\x96\x82\x5a\x5f\xb0\xa0\x50"
+			  "\x89\xa4\x8e\x66\x44\x85\xcc\xfd"
+			  "\x33\x14\x70\xe3\x96\xb2\xc3\xd3"
+			  "\xbb\x54\x5a\x1a\xf9\x74\xa2\xc5"
+			  "\x2d\x64\x75\xdd\xb4\x54\xe6\x74"
+			  "\x8c\xd3\x9d\x9e\x86\xab\x51\x53"
+			  "\xb7\x93\x3e\x6f\xd0\x4e\x2c\x40"
+			  "\xf6\xa8\x2e\x3e\x9d\xf4\x66\xa5"
+			  "\x76\x12\x73\x44\x1a\x56\xd7\x72"
+			  "\x88\xcd\x21\x8c\x4c\x0f\xfe\xda"
+			  "\x95\xe0\x3a\xa6\xa5\x84\x46\xcd"
+			  "\xd5\x3e\x9d\x3a\xe2\x67\xe6\x60"
+			  "\x1a\xe2\x70\x85\x58\xc2\x1b\x09"
+			  "\xe1\xd7\x2c\xca\xad\xa8\x8f\xf9"
+			  "\xac\xb3\x0e\xdb\xca\x2e\xe2\xb8"
+			  "\x51\x71\xd9\x3c\x6c\xf1\x56\xf8"
+			  "\xea\x9c\xf1\xfb\x0c\xe6\xb7\x10"
+			  "\x1c\xf8\xa9\x7c\xe8\x53\x35\xc1"
+			  "\x90\x3e\x76\x4a\x74\xa4\x21\x2c"
+			  "\xf6\x2c\x4e\x0f\x94\x3a\x88\x2e"
+			  "\x41\x09\x6a\x33\x7d\xf6\xdd\x3f"
+			  "\x8d\x23\x31\x74\x84\xeb\x88\x6e"
+			  "\xcc\xb9\xbc\x22\x83\x19\x07\x22"
+			  "\xa5\x2d\xdf\xa5\xf3\x80\x85\x78"
+			  "\x84\x39\x6a\x6d\x6a\x99\x4f\xa5"
+			  "\x15\xfe\x46\xb0\xe4\x6c\xa5\x41"
+			  "\x3c\xce\x8f\x42\x60\x71\xa7\x75"
+			  "\x08\x40\x65\x8a\x82\xbf\xf5\x43"
+			  "\x71\x96\xa9\x4d\x44\x8a\x20\xbe"
+			  "\xfa\x4d\xbb\xc0\x7d\x31\x96\x65"
+			  "\xe7\x75\xe5\x3e\xfd\x92\x3b\xc9"
+			  "\x55\xbb\x16\x7e\xf7\xc2\x8c\xa4"
+			  "\x40\x1d\xe5\xef\x0e\xdf\xe4\x9a"
+			  "\x62\x73\x65\xfd\x46\x63\x25\x3d"
+			  "\x2b\xaf\xe5\x64\xfe\xa5\x5c\xcf"
+			  "\x24\xf3\xb4\xac\x64\xba\xdf\x4b"
+			  "\xc6\x96\x7d\x81\x2d\x8d\x97\xf7"
+			  "\xc5\x68\x77\x84\x32\x2b\xcc\x85"
+			  "\x74\x96\xf0\x12\x77\x61\xb9\xeb"
+			  "\x71\xaa\x82\xcb\x1c\xdb\x89\xc8"
+			  "\xc6\xb5\xe3\x5c\x7d\x39\x07\x24"
+			  "\xda\x39\x87\x45\xc0\x2b\xbb\x01"
+			  "\xac\xbc\x2a\x5c\x7f\xfc\xe8\xce"
+			  "\x6d\x9c\x6f\xed\xd3\xc1\xa1\xd6"
+			  "\xc5\x55\xa9\x66\x2f\xe1\xc8\x32"
+			  "\xa6\x5d\xa4\x3a\x98\x73\xe8\x45"
+			  "\xa4\xc7\xa8\xb4\xf6\x13\x03\xf6"
+			  "\xe9\x2e\xc4\x29\x0f\x84\xdb\xc4"
+			  "\x21\xc4\xc2\x75\x67\x89\x37\x0a",
+		.rlen   = 512,
+	}
+};
+
+static struct cipher_testvec aes_xts_enc_tv_template[] = {
+	/* http://grouper.ieee.org/groups/1619/email/pdf00086.pdf */
+	{ /* XTS-AES 1 */
+		.key    = "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.klen   = 32,
+		.iv     = "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.input  = "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.ilen   = 32,
+		.result = "\x91\x7c\xf6\x9e\xbd\x68\xb2\xec"
+			  "\x9b\x9f\xe9\xa3\xea\xdd\xa6\x92"
+			  "\xcd\x43\xd2\xf5\x95\x98\xed\x85"
+			  "\x8c\x02\xc2\x65\x2f\xbf\x92\x2e",
+		.rlen   = 32,
+	}, { /* XTS-AES 2 */
+		.key    = "\x11\x11\x11\x11\x11\x11\x11\x11"
+			  "\x11\x11\x11\x11\x11\x11\x11\x11"
+			  "\x22\x22\x22\x22\x22\x22\x22\x22"
+			  "\x22\x22\x22\x22\x22\x22\x22\x22",
+		.klen   = 32,
+		.iv     = "\x33\x33\x33\x33\x33\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.input  = "\x44\x44\x44\x44\x44\x44\x44\x44"
+			  "\x44\x44\x44\x44\x44\x44\x44\x44"
+			  "\x44\x44\x44\x44\x44\x44\x44\x44"
+			  "\x44\x44\x44\x44\x44\x44\x44\x44",
+		.ilen   = 32,
+		.result = "\xc4\x54\x18\x5e\x6a\x16\x93\x6e"
+			  "\x39\x33\x40\x38\xac\xef\x83\x8b"
+			  "\xfb\x18\x6f\xff\x74\x80\xad\xc4"
+			  "\x28\x93\x82\xec\xd6\xd3\x94\xf0",
+		.rlen   = 32,
+	}, { /* XTS-AES 3 */
+		.key    = "\xff\xfe\xfd\xfc\xfb\xfa\xf9\xf8"
+			  "\xf7\xf6\xf5\xf4\xf3\xf2\xf1\xf0"
+			  "\x22\x22\x22\x22\x22\x22\x22\x22"
+			  "\x22\x22\x22\x22\x22\x22\x22\x22",
+		.klen   = 32,
+		.iv     = "\x33\x33\x33\x33\x33\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.input  = "\x44\x44\x44\x44\x44\x44\x44\x44"
+			  "\x44\x44\x44\x44\x44\x44\x44\x44"
+			  "\x44\x44\x44\x44\x44\x44\x44\x44"
+			  "\x44\x44\x44\x44\x44\x44\x44\x44",
+		.ilen   = 32,
+		.result = "\xaf\x85\x33\x6b\x59\x7a\xfc\x1a"
+			  "\x90\x0b\x2e\xb2\x1e\xc9\x49\xd2"
+			  "\x92\xdf\x4c\x04\x7e\x0b\x21\x53"
+			  "\x21\x86\xa5\x97\x1a\x22\x7a\x89",
+		.rlen   = 32,
+	}, { /* XTS-AES 4 */
+		.key    = "\x27\x18\x28\x18\x28\x45\x90\x45"
+			  "\x23\x53\x60\x28\x74\x71\x35\x26"
+			  "\x31\x41\x59\x26\x53\x58\x97\x93"
+			  "\x23\x84\x62\x64\x33\x83\x27\x95",
+		.klen   = 32,
+		.iv     = "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.input  = "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+			  "\x10\x11\x12\x13\x14\x15\x16\x17"
+			  "\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
+			  "\x20\x21\x22\x23\x24\x25\x26\x27"
+			  "\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f"
+			  "\x30\x31\x32\x33\x34\x35\x36\x37"
+			  "\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f"
+			  "\x40\x41\x42\x43\x44\x45\x46\x47"
+			  "\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f"
+			  "\x50\x51\x52\x53\x54\x55\x56\x57"
+			  "\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
+			  "\x60\x61\x62\x63\x64\x65\x66\x67"
+			  "\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f"
+			  "\x70\x71\x72\x73\x74\x75\x76\x77"
+			  "\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
+			  "\x80\x81\x82\x83\x84\x85\x86\x87"
+			  "\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
+			  "\x90\x91\x92\x93\x94\x95\x96\x97"
+			  "\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
+			  "\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7"
+			  "\xa8\xa9\xaa\xab\xac\xad\xae\xaf"
+			  "\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7"
+			  "\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
+			  "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7"
+			  "\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf"
+			  "\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7"
+			  "\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
+			  "\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7"
+			  "\xe8\xe9\xea\xeb\xec\xed\xee\xef"
+			  "\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7"
+			  "\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
+			  "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+			  "\x10\x11\x12\x13\x14\x15\x16\x17"
+			  "\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
+			  "\x20\x21\x22\x23\x24\x25\x26\x27"
+			  "\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f"
+			  "\x30\x31\x32\x33\x34\x35\x36\x37"
+			  "\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f"
+			  "\x40\x41\x42\x43\x44\x45\x46\x47"
+			  "\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f"
+			  "\x50\x51\x52\x53\x54\x55\x56\x57"
+			  "\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
+			  "\x60\x61\x62\x63\x64\x65\x66\x67"
+			  "\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f"
+			  "\x70\x71\x72\x73\x74\x75\x76\x77"
+			  "\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
+			  "\x80\x81\x82\x83\x84\x85\x86\x87"
+			  "\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
+			  "\x90\x91\x92\x93\x94\x95\x96\x97"
+			  "\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
+			  "\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7"
+			  "\xa8\xa9\xaa\xab\xac\xad\xae\xaf"
+			  "\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7"
+			  "\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
+			  "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7"
+			  "\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf"
+			  "\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7"
+			  "\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
+			  "\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7"
+			  "\xe8\xe9\xea\xeb\xec\xed\xee\xef"
+			  "\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7"
+			  "\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff",
+		.ilen   = 512,
+		.result = "\x27\xa7\x47\x9b\xef\xa1\xd4\x76"
+			  "\x48\x9f\x30\x8c\xd4\xcf\xa6\xe2"
+			  "\xa9\x6e\x4b\xbe\x32\x08\xff\x25"
+			  "\x28\x7d\xd3\x81\x96\x16\xe8\x9c"
+			  "\xc7\x8c\xf7\xf5\xe5\x43\x44\x5f"
+			  "\x83\x33\xd8\xfa\x7f\x56\x00\x00"
+			  "\x05\x27\x9f\xa5\xd8\xb5\xe4\xad"
+			  "\x40\xe7\x36\xdd\xb4\xd3\x54\x12"
+			  "\x32\x80\x63\xfd\x2a\xab\x53\xe5"
+			  "\xea\x1e\x0a\x9f\x33\x25\x00\xa5"
+			  "\xdf\x94\x87\xd0\x7a\x5c\x92\xcc"
+			  "\x51\x2c\x88\x66\xc7\xe8\x60\xce"
+			  "\x93\xfd\xf1\x66\xa2\x49\x12\xb4"
+			  "\x22\x97\x61\x46\xae\x20\xce\x84"
+			  "\x6b\xb7\xdc\x9b\xa9\x4a\x76\x7a"
+			  "\xae\xf2\x0c\x0d\x61\xad\x02\x65"
+			  "\x5e\xa9\x2d\xc4\xc4\xe4\x1a\x89"
+			  "\x52\xc6\x51\xd3\x31\x74\xbe\x51"
+			  "\xa1\x0c\x42\x11\x10\xe6\xd8\x15"
+			  "\x88\xed\xe8\x21\x03\xa2\x52\xd8"
+			  "\xa7\x50\xe8\x76\x8d\xef\xff\xed"
+			  "\x91\x22\x81\x0a\xae\xb9\x9f\x91"
+			  "\x72\xaf\x82\xb6\x04\xdc\x4b\x8e"
+			  "\x51\xbc\xb0\x82\x35\xa6\xf4\x34"
+			  "\x13\x32\xe4\xca\x60\x48\x2a\x4b"
+			  "\xa1\xa0\x3b\x3e\x65\x00\x8f\xc5"
+			  "\xda\x76\xb7\x0b\xf1\x69\x0d\xb4"
+			  "\xea\xe2\x9c\x5f\x1b\xad\xd0\x3c"
+			  "\x5c\xcf\x2a\x55\xd7\x05\xdd\xcd"
+			  "\x86\xd4\x49\x51\x1c\xeb\x7e\xc3"
+			  "\x0b\xf1\x2b\x1f\xa3\x5b\x91\x3f"
+			  "\x9f\x74\x7a\x8a\xfd\x1b\x13\x0e"
+			  "\x94\xbf\xf9\x4e\xff\xd0\x1a\x91"
+			  "\x73\x5c\xa1\x72\x6a\xcd\x0b\x19"
+			  "\x7c\x4e\x5b\x03\x39\x36\x97\xe1"
+			  "\x26\x82\x6f\xb6\xbb\xde\x8e\xcc"
+			  "\x1e\x08\x29\x85\x16\xe2\xc9\xed"
+			  "\x03\xff\x3c\x1b\x78\x60\xf6\xde"
+			  "\x76\xd4\xce\xcd\x94\xc8\x11\x98"
+			  "\x55\xef\x52\x97\xca\x67\xe9\xf3"
+			  "\xe7\xff\x72\xb1\xe9\x97\x85\xca"
+			  "\x0a\x7e\x77\x20\xc5\xb3\x6d\xc6"
+			  "\xd7\x2c\xac\x95\x74\xc8\xcb\xbc"
+			  "\x2f\x80\x1e\x23\xe5\x6f\xd3\x44"
+			  "\xb0\x7f\x22\x15\x4b\xeb\xa0\xf0"
+			  "\x8c\xe8\x89\x1e\x64\x3e\xd9\x95"
+			  "\xc9\x4d\x9a\x69\xc9\xf1\xb5\xf4"
+			  "\x99\x02\x7a\x78\x57\x2a\xee\xbd"
+			  "\x74\xd2\x0c\xc3\x98\x81\xc2\x13"
+			  "\xee\x77\x0b\x10\x10\xe4\xbe\xa7"
+			  "\x18\x84\x69\x77\xae\x11\x9f\x7a"
+			  "\x02\x3a\xb5\x8c\xca\x0a\xd7\x52"
+			  "\xaf\xe6\x56\xbb\x3c\x17\x25\x6a"
+			  "\x9f\x6e\x9b\xf1\x9f\xdd\x5a\x38"
+			  "\xfc\x82\xbb\xe8\x72\xc5\x53\x9e"
+			  "\xdb\x60\x9e\xf4\xf7\x9c\x20\x3e"
+			  "\xbb\x14\x0f\x2e\x58\x3c\xb2\xad"
+			  "\x15\xb4\xaa\x5b\x65\x50\x16\xa8"
+			  "\x44\x92\x77\xdb\xd4\x77\xef\x2c"
+			  "\x8d\x6c\x01\x7d\xb7\x38\xb1\x8d"
+			  "\xeb\x4a\x42\x7d\x19\x23\xce\x3f"
+			  "\xf2\x62\x73\x57\x79\xa4\x18\xf2"
+			  "\x0a\x28\x2d\xf9\x20\x14\x7b\xea"
+			  "\xbe\x42\x1e\xe5\x31\x9d\x05\x68",
+		.rlen   = 512,
+	}
+};
+
+static struct cipher_testvec aes_xts_dec_tv_template[] = {
+	/* http://grouper.ieee.org/groups/1619/email/pdf00086.pdf */
+	{ /* XTS-AES 1 */
+		.key    = "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.klen   = 32,
+		.iv     = "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.input = "\x91\x7c\xf6\x9e\xbd\x68\xb2\xec"
+			 "\x9b\x9f\xe9\xa3\xea\xdd\xa6\x92"
+			 "\xcd\x43\xd2\xf5\x95\x98\xed\x85"
+			 "\x8c\x02\xc2\x65\x2f\xbf\x92\x2e",
+		.ilen   = 32,
+		.result  = "\x00\x00\x00\x00\x00\x00\x00\x00"
+			   "\x00\x00\x00\x00\x00\x00\x00\x00"
+			   "\x00\x00\x00\x00\x00\x00\x00\x00"
+			   "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.rlen   = 32,
+	}, { /* XTS-AES 2 */
+		.key    = "\x11\x11\x11\x11\x11\x11\x11\x11"
+			  "\x11\x11\x11\x11\x11\x11\x11\x11"
+			  "\x22\x22\x22\x22\x22\x22\x22\x22"
+			  "\x22\x22\x22\x22\x22\x22\x22\x22",
+		.klen   = 32,
+		.iv     = "\x33\x33\x33\x33\x33\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.input  = "\xc4\x54\x18\x5e\x6a\x16\x93\x6e"
+			  "\x39\x33\x40\x38\xac\xef\x83\x8b"
+			  "\xfb\x18\x6f\xff\x74\x80\xad\xc4"
+			  "\x28\x93\x82\xec\xd6\xd3\x94\xf0",
+		.ilen   = 32,
+		.result = "\x44\x44\x44\x44\x44\x44\x44\x44"
+			  "\x44\x44\x44\x44\x44\x44\x44\x44"
+			  "\x44\x44\x44\x44\x44\x44\x44\x44"
+			  "\x44\x44\x44\x44\x44\x44\x44\x44",
+		.rlen   = 32,
+	}, { /* XTS-AES 3 */
+		.key    = "\xff\xfe\xfd\xfc\xfb\xfa\xf9\xf8"
+			  "\xf7\xf6\xf5\xf4\xf3\xf2\xf1\xf0"
+			  "\x22\x22\x22\x22\x22\x22\x22\x22"
+			  "\x22\x22\x22\x22\x22\x22\x22\x22",
+		.klen   = 32,
+		.iv     = "\x33\x33\x33\x33\x33\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.input = "\xaf\x85\x33\x6b\x59\x7a\xfc\x1a"
+			  "\x90\x0b\x2e\xb2\x1e\xc9\x49\xd2"
+			  "\x92\xdf\x4c\x04\x7e\x0b\x21\x53"
+			  "\x21\x86\xa5\x97\x1a\x22\x7a\x89",
+		.ilen   = 32,
+		.result  = "\x44\x44\x44\x44\x44\x44\x44\x44"
+			  "\x44\x44\x44\x44\x44\x44\x44\x44"
+			  "\x44\x44\x44\x44\x44\x44\x44\x44"
+			  "\x44\x44\x44\x44\x44\x44\x44\x44",
+		.rlen   = 32,
+	}, { /* XTS-AES 4 */
+		.key    = "\x27\x18\x28\x18\x28\x45\x90\x45"
+			  "\x23\x53\x60\x28\x74\x71\x35\x26"
+			  "\x31\x41\x59\x26\x53\x58\x97\x93"
+			  "\x23\x84\x62\x64\x33\x83\x27\x95",
+		.klen   = 32,
+		.iv     = "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.input  = "\x27\xa7\x47\x9b\xef\xa1\xd4\x76"
+			  "\x48\x9f\x30\x8c\xd4\xcf\xa6\xe2"
+			  "\xa9\x6e\x4b\xbe\x32\x08\xff\x25"
+			  "\x28\x7d\xd3\x81\x96\x16\xe8\x9c"
+			  "\xc7\x8c\xf7\xf5\xe5\x43\x44\x5f"
+			  "\x83\x33\xd8\xfa\x7f\x56\x00\x00"
+			  "\x05\x27\x9f\xa5\xd8\xb5\xe4\xad"
+			  "\x40\xe7\x36\xdd\xb4\xd3\x54\x12"
+			  "\x32\x80\x63\xfd\x2a\xab\x53\xe5"
+			  "\xea\x1e\x0a\x9f\x33\x25\x00\xa5"
+			  "\xdf\x94\x87\xd0\x7a\x5c\x92\xcc"
+			  "\x51\x2c\x88\x66\xc7\xe8\x60\xce"
+			  "\x93\xfd\xf1\x66\xa2\x49\x12\xb4"
+			  "\x22\x97\x61\x46\xae\x20\xce\x84"
+			  "\x6b\xb7\xdc\x9b\xa9\x4a\x76\x7a"
+			  "\xae\xf2\x0c\x0d\x61\xad\x02\x65"
+			  "\x5e\xa9\x2d\xc4\xc4\xe4\x1a\x89"
+			  "\x52\xc6\x51\xd3\x31\x74\xbe\x51"
+			  "\xa1\x0c\x42\x11\x10\xe6\xd8\x15"
+			  "\x88\xed\xe8\x21\x03\xa2\x52\xd8"
+			  "\xa7\x50\xe8\x76\x8d\xef\xff\xed"
+			  "\x91\x22\x81\x0a\xae\xb9\x9f\x91"
+			  "\x72\xaf\x82\xb6\x04\xdc\x4b\x8e"
+			  "\x51\xbc\xb0\x82\x35\xa6\xf4\x34"
+			  "\x13\x32\xe4\xca\x60\x48\x2a\x4b"
+			  "\xa1\xa0\x3b\x3e\x65\x00\x8f\xc5"
+			  "\xda\x76\xb7\x0b\xf1\x69\x0d\xb4"
+			  "\xea\xe2\x9c\x5f\x1b\xad\xd0\x3c"
+			  "\x5c\xcf\x2a\x55\xd7\x05\xdd\xcd"
+			  "\x86\xd4\x49\x51\x1c\xeb\x7e\xc3"
+			  "\x0b\xf1\x2b\x1f\xa3\x5b\x91\x3f"
+			  "\x9f\x74\x7a\x8a\xfd\x1b\x13\x0e"
+			  "\x94\xbf\xf9\x4e\xff\xd0\x1a\x91"
+			  "\x73\x5c\xa1\x72\x6a\xcd\x0b\x19"
+			  "\x7c\x4e\x5b\x03\x39\x36\x97\xe1"
+			  "\x26\x82\x6f\xb6\xbb\xde\x8e\xcc"
+			  "\x1e\x08\x29\x85\x16\xe2\xc9\xed"
+			  "\x03\xff\x3c\x1b\x78\x60\xf6\xde"
+			  "\x76\xd4\xce\xcd\x94\xc8\x11\x98"
+			  "\x55\xef\x52\x97\xca\x67\xe9\xf3"
+			  "\xe7\xff\x72\xb1\xe9\x97\x85\xca"
+			  "\x0a\x7e\x77\x20\xc5\xb3\x6d\xc6"
+			  "\xd7\x2c\xac\x95\x74\xc8\xcb\xbc"
+			  "\x2f\x80\x1e\x23\xe5\x6f\xd3\x44"
+			  "\xb0\x7f\x22\x15\x4b\xeb\xa0\xf0"
+			  "\x8c\xe8\x89\x1e\x64\x3e\xd9\x95"
+			  "\xc9\x4d\x9a\x69\xc9\xf1\xb5\xf4"
+			  "\x99\x02\x7a\x78\x57\x2a\xee\xbd"
+			  "\x74\xd2\x0c\xc3\x98\x81\xc2\x13"
+			  "\xee\x77\x0b\x10\x10\xe4\xbe\xa7"
+			  "\x18\x84\x69\x77\xae\x11\x9f\x7a"
+			  "\x02\x3a\xb5\x8c\xca\x0a\xd7\x52"
+			  "\xaf\xe6\x56\xbb\x3c\x17\x25\x6a"
+			  "\x9f\x6e\x9b\xf1\x9f\xdd\x5a\x38"
+			  "\xfc\x82\xbb\xe8\x72\xc5\x53\x9e"
+			  "\xdb\x60\x9e\xf4\xf7\x9c\x20\x3e"
+			  "\xbb\x14\x0f\x2e\x58\x3c\xb2\xad"
+			  "\x15\xb4\xaa\x5b\x65\x50\x16\xa8"
+			  "\x44\x92\x77\xdb\xd4\x77\xef\x2c"
+			  "\x8d\x6c\x01\x7d\xb7\x38\xb1\x8d"
+			  "\xeb\x4a\x42\x7d\x19\x23\xce\x3f"
+			  "\xf2\x62\x73\x57\x79\xa4\x18\xf2"
+			  "\x0a\x28\x2d\xf9\x20\x14\x7b\xea"
+			  "\xbe\x42\x1e\xe5\x31\x9d\x05\x68",
+		.ilen   = 512,
+		.result = "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+			  "\x10\x11\x12\x13\x14\x15\x16\x17"
+			  "\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
+			  "\x20\x21\x22\x23\x24\x25\x26\x27"
+			  "\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f"
+			  "\x30\x31\x32\x33\x34\x35\x36\x37"
+			  "\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f"
+			  "\x40\x41\x42\x43\x44\x45\x46\x47"
+			  "\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f"
+			  "\x50\x51\x52\x53\x54\x55\x56\x57"
+			  "\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
+			  "\x60\x61\x62\x63\x64\x65\x66\x67"
+			  "\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f"
+			  "\x70\x71\x72\x73\x74\x75\x76\x77"
+			  "\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
+			  "\x80\x81\x82\x83\x84\x85\x86\x87"
+			  "\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
+			  "\x90\x91\x92\x93\x94\x95\x96\x97"
+			  "\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
+			  "\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7"
+			  "\xa8\xa9\xaa\xab\xac\xad\xae\xaf"
+			  "\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7"
+			  "\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
+			  "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7"
+			  "\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf"
+			  "\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7"
+			  "\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
+			  "\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7"
+			  "\xe8\xe9\xea\xeb\xec\xed\xee\xef"
+			  "\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7"
+			  "\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
+			  "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+			  "\x10\x11\x12\x13\x14\x15\x16\x17"
+			  "\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
+			  "\x20\x21\x22\x23\x24\x25\x26\x27"
+			  "\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f"
+			  "\x30\x31\x32\x33\x34\x35\x36\x37"
+			  "\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f"
+			  "\x40\x41\x42\x43\x44\x45\x46\x47"
+			  "\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f"
+			  "\x50\x51\x52\x53\x54\x55\x56\x57"
+			  "\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
+			  "\x60\x61\x62\x63\x64\x65\x66\x67"
+			  "\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f"
+			  "\x70\x71\x72\x73\x74\x75\x76\x77"
+			  "\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
+			  "\x80\x81\x82\x83\x84\x85\x86\x87"
+			  "\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
+			  "\x90\x91\x92\x93\x94\x95\x96\x97"
+			  "\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
+			  "\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7"
+			  "\xa8\xa9\xaa\xab\xac\xad\xae\xaf"
+			  "\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7"
+			  "\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
+			  "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7"
+			  "\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf"
+			  "\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7"
+			  "\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
+			  "\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7"
+			  "\xe8\xe9\xea\xeb\xec\xed\xee\xef"
+			  "\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7"
+			  "\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff",
+		.rlen   = 512,
+	}
+};
+
+
+static struct cipher_testvec aes_ctr_enc_tv_template[] = {
+	{ /* From RFC 3686 */
+		.key	= "\xae\x68\x52\xf8\x12\x10\x67\xcc"
+			  "\x4b\xf7\xa5\x76\x55\x77\xf3\x9e"
+			  "\x00\x00\x00\x30",
+		.klen	= 20,
+		.iv	= "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.input	= "Single block msg",
+		.ilen	= 16,
+		.result = "\xe4\x09\x5d\x4f\xb7\xa7\xb3\x79"
+			  "\x2d\x61\x75\xa3\x26\x13\x11\xb8",
+		.rlen	= 16,
+	}, {
+		.key	= "\x7e\x24\x06\x78\x17\xfa\xe0\xd7"
+			  "\x43\xd6\xce\x1f\x32\x53\x91\x63"
+			  "\x00\x6c\xb6\xdb",
+		.klen	= 20,
+		.iv	= "\xc0\x54\x3b\x59\xda\x48\xd9\x0b",
+		.input	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+			  "\x10\x11\x12\x13\x14\x15\x16\x17"
+			  "\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f",
+		.ilen	= 32,
+		.result = "\x51\x04\xa1\x06\x16\x8a\x72\xd9"
+			  "\x79\x0d\x41\xee\x8e\xda\xd3\x88"
+			  "\xeb\x2e\x1e\xfc\x46\xda\x57\xc8"
+			  "\xfc\xe6\x30\xdf\x91\x41\xbe\x28",
+		.rlen	= 32,
+	}, {
+		.key	= "\x16\xaf\x5b\x14\x5f\xc9\xf5\x79"
+			  "\xc1\x75\xf9\x3e\x3b\xfb\x0e\xed"
+			  "\x86\x3d\x06\xcc\xfd\xb7\x85\x15"
+			  "\x00\x00\x00\x48",
+		.klen	= 28,
+		.iv	= "\x36\x73\x3c\x14\x7d\x6d\x93\xcb",
+		.input	= "Single block msg",
+		.ilen	= 16,
+		.result	= "\x4b\x55\x38\x4f\xe2\x59\xc9\xc8"
+			  "\x4e\x79\x35\xa0\x03\xcb\xe9\x28",
+		.rlen	= 16,
+	}, {
+		.key	= "\x7c\x5c\xb2\x40\x1b\x3d\xc3\x3c"
+			  "\x19\xe7\x34\x08\x19\xe0\xf6\x9c"
+			  "\x67\x8c\x3d\xb8\xe6\xf6\xa9\x1a"
+			  "\x00\x96\xb0\x3b",
+		.klen	= 28,
+		.iv	= "\x02\x0c\x6e\xad\xc2\xcb\x50\x0d",
+		.input	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+			  "\x10\x11\x12\x13\x14\x15\x16\x17"
+			  "\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f",
+		.ilen	= 32,
+		.result	= "\x45\x32\x43\xfc\x60\x9b\x23\x32"
+			  "\x7e\xdf\xaa\xfa\x71\x31\xcd\x9f"
+			  "\x84\x90\x70\x1c\x5a\xd4\xa7\x9c"
+			  "\xfc\x1f\xe0\xff\x42\xf4\xfb\x00",
+		.rlen	= 32,
+	}, {
+		.key	= "\x77\x6b\xef\xf2\x85\x1d\xb0\x6f"
+			  "\x4c\x8a\x05\x42\xc8\x69\x6f\x6c"
+			  "\x6a\x81\xaf\x1e\xec\x96\xb4\xd3"
+			  "\x7f\xc1\xd6\x89\xe6\xc1\xc1\x04"
+			  "\x00\x00\x00\x60",
+		.klen	= 36,
+		.iv	= "\xdb\x56\x72\xc9\x7a\xa8\xf0\xb2",
+		.input	= "Single block msg",
+		.ilen	= 16,
+		.result = "\x14\x5a\xd0\x1d\xbf\x82\x4e\xc7"
+			  "\x56\x08\x63\xdc\x71\xe3\xe0\xc0",
+		.rlen	= 16,
+	}, {
+		.key	= "\xf6\xd6\x6d\x6b\xd5\x2d\x59\xbb"
+			  "\x07\x96\x36\x58\x79\xef\xf8\x86"
+			  "\xc6\x6d\xd5\x1a\x5b\x6a\x99\x74"
+			  "\x4b\x50\x59\x0c\x87\xa2\x38\x84"
+			  "\x00\xfa\xac\x24",
+		.klen	= 36,
+		.iv	= "\xc1\x58\x5e\xf1\x5a\x43\xd8\x75",
+		.input	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+			  "\x10\x11\x12\x13\x14\x15\x16\x17"
+			  "\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f",
+		.ilen	= 32,
+		.result = "\xf0\x5e\x23\x1b\x38\x94\x61\x2c"
+			  "\x49\xee\x00\x0b\x80\x4e\xb2\xa9"
+			  "\xb8\x30\x6b\x50\x8f\x83\x9d\x6a"
+			  "\x55\x30\x83\x1d\x93\x44\xaf\x1c",
+		.rlen	= 32,
+	}, {
+	// generated using Crypto++
+		.key = "\x00\x01\x02\x03\x04\x05\x06\x07"
+			"\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+			"\x10\x11\x12\x13\x14\x15\x16\x17"
+			"\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
+			"\x00\x00\x00\x00",
+		.klen = 32 + 4,
+		.iv = "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.input =
+			"\x00\x01\x02\x03\x04\x05\x06\x07"
+			"\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+			"\x10\x11\x12\x13\x14\x15\x16\x17"
+			"\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
+			"\x20\x21\x22\x23\x24\x25\x26\x27"
+			"\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f"
+			"\x30\x31\x32\x33\x34\x35\x36\x37"
+			"\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f"
+			"\x40\x41\x42\x43\x44\x45\x46\x47"
+			"\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f"
+			"\x50\x51\x52\x53\x54\x55\x56\x57"
+			"\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
+			"\x60\x61\x62\x63\x64\x65\x66\x67"
+			"\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f"
+			"\x70\x71\x72\x73\x74\x75\x76\x77"
+			"\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
+			"\x80\x81\x82\x83\x84\x85\x86\x87"
+			"\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
+			"\x90\x91\x92\x93\x94\x95\x96\x97"
+			"\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
+			"\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7"
+			"\xa8\xa9\xaa\xab\xac\xad\xae\xaf"
+			"\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7"
+			"\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
+			"\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7"
+			"\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf"
+			"\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7"
+			"\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
+			"\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7"
+			"\xe8\xe9\xea\xeb\xec\xed\xee\xef"
+			"\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7"
+			"\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
+			"\x00\x03\x06\x09\x0c\x0f\x12\x15"
+			"\x18\x1b\x1e\x21\x24\x27\x2a\x2d"
+			"\x30\x33\x36\x39\x3c\x3f\x42\x45"
+			"\x48\x4b\x4e\x51\x54\x57\x5a\x5d"
+			"\x60\x63\x66\x69\x6c\x6f\x72\x75"
+			"\x78\x7b\x7e\x81\x84\x87\x8a\x8d"
+			"\x90\x93\x96\x99\x9c\x9f\xa2\xa5"
+			"\xa8\xab\xae\xb1\xb4\xb7\xba\xbd"
+			"\xc0\xc3\xc6\xc9\xcc\xcf\xd2\xd5"
+			"\xd8\xdb\xde\xe1\xe4\xe7\xea\xed"
+			"\xf0\xf3\xf6\xf9\xfc\xff\x02\x05"
+			"\x08\x0b\x0e\x11\x14\x17\x1a\x1d"
+			"\x20\x23\x26\x29\x2c\x2f\x32\x35"
+			"\x38\x3b\x3e\x41\x44\x47\x4a\x4d"
+			"\x50\x53\x56\x59\x5c\x5f\x62\x65"
+			"\x68\x6b\x6e\x71\x74\x77\x7a\x7d"
+			"\x80\x83\x86\x89\x8c\x8f\x92\x95"
+			"\x98\x9b\x9e\xa1\xa4\xa7\xaa\xad"
+			"\xb0\xb3\xb6\xb9\xbc\xbf\xc2\xc5"
+			"\xc8\xcb\xce\xd1\xd4\xd7\xda\xdd"
+			"\xe0\xe3\xe6\xe9\xec\xef\xf2\xf5"
+			"\xf8\xfb\xfe\x01\x04\x07\x0a\x0d"
+			"\x10\x13\x16\x19\x1c\x1f\x22\x25"
+			"\x28\x2b\x2e\x31\x34\x37\x3a\x3d"
+			"\x40\x43\x46\x49\x4c\x4f\x52\x55"
+			"\x58\x5b\x5e\x61\x64\x67\x6a\x6d"
+			"\x70\x73\x76\x79\x7c\x7f\x82\x85"
+			"\x88\x8b\x8e\x91\x94\x97\x9a\x9d"
+			"\xa0\xa3\xa6\xa9\xac\xaf\xb2\xb5"
+			"\xb8\xbb\xbe\xc1\xc4\xc7\xca\xcd"
+			"\xd0\xd3\xd6\xd9\xdc\xdf\xe2\xe5"
+			"\xe8\xeb\xee\xf1\xf4\xf7\xfa\xfd"
+			"\x00\x05\x0a\x0f\x14\x19\x1e\x23"
+			"\x28\x2d\x32\x37\x3c\x41\x46\x4b"
+			"\x50\x55\x5a\x5f\x64\x69\x6e\x73"
+			"\x78\x7d\x82\x87\x8c\x91\x96\x9b"
+			"\xa0\xa5\xaa\xaf\xb4\xb9\xbe\xc3"
+			"\xc8\xcd\xd2\xd7\xdc\xe1\xe6\xeb"
+			"\xf0\xf5\xfa\xff\x04\x09\x0e\x13"
+			"\x18\x1d\x22\x27\x2c\x31\x36\x3b"
+			"\x40\x45\x4a\x4f\x54\x59\x5e\x63"
+			"\x68\x6d\x72\x77\x7c\x81\x86\x8b"
+			"\x90\x95\x9a\x9f\xa4\xa9\xae\xb3"
+			"\xb8\xbd\xc2\xc7\xcc\xd1\xd6\xdb"
+			"\xe0\xe5\xea\xef\xf4\xf9\xfe\x03"
+			"\x08\x0d\x12\x17\x1c\x21\x26\x2b"
+			"\x30\x35\x3a\x3f\x44\x49\x4e\x53"
+			"\x58\x5d\x62\x67\x6c\x71\x76\x7b"
+			"\x80\x85\x8a\x8f\x94\x99\x9e\xa3"
+			"\xa8\xad\xb2\xb7\xbc\xc1\xc6\xcb"
+			"\xd0\xd5\xda\xdf\xe4\xe9\xee\xf3"
+			"\xf8\xfd\x02\x07\x0c\x11\x16\x1b"
+			"\x20\x25\x2a\x2f\x34\x39\x3e\x43"
+			"\x48\x4d\x52\x57\x5c\x61\x66\x6b"
+			"\x70\x75\x7a\x7f\x84\x89\x8e\x93"
+			"\x98\x9d\xa2\xa7\xac\xb1\xb6\xbb"
+			"\xc0\xc5\xca\xcf\xd4\xd9\xde\xe3"
+			"\xe8\xed\xf2\xf7\xfc\x01\x06\x0b"
+			"\x10\x15\x1a\x1f\x24\x29\x2e\x33"
+			"\x38\x3d\x42\x47\x4c\x51\x56\x5b"
+			"\x60\x65\x6a\x6f\x74\x79\x7e\x83"
+			"\x88\x8d\x92\x97\x9c\xa1\xa6\xab"
+			"\xb0\xb5\xba\xbf\xc4\xc9\xce\xd3"
+			"\xd8\xdd\xe2\xe7\xec\xf1\xf6\xfb"
+			"\x00\x07\x0e\x15\x1c\x23\x2a\x31"
+			"\x38\x3f\x46\x4d\x54\x5b\x62\x69"
+			"\x70\x77\x7e\x85\x8c\x93\x9a\xa1"
+			"\xa8\xaf\xb6\xbd\xc4\xcb\xd2\xd9"
+			"\xe0\xe7\xee\xf5\xfc\x03\x0a\x11"
+			"\x18\x1f\x26\x2d\x34\x3b\x42\x49"
+			"\x50\x57\x5e\x65\x6c\x73\x7a\x81"
+			"\x88\x8f\x96\x9d\xa4\xab\xb2\xb9"
+			"\xc0\xc7\xce\xd5\xdc\xe3\xea\xf1"
+			"\xf8\xff\x06\x0d\x14\x1b\x22\x29"
+			"\x30\x37\x3e\x45\x4c\x53\x5a\x61"
+			"\x68\x6f\x76\x7d\x84\x8b\x92\x99"
+			"\xa0\xa7\xae\xb5\xbc\xc3\xca\xd1"
+			"\xd8\xdf\xe6\xed\xf4\xfb\x02\x09"
+			"\x10\x17\x1e\x25\x2c\x33\x3a\x41"
+			"\x48\x4f\x56\x5d\x64\x6b\x72\x79"
+			"\x80\x87\x8e\x95\x9c\xa3\xaa\xb1"
+			"\xb8\xbf\xc6\xcd\xd4\xdb\xe2\xe9"
+			"\xf0\xf7\xfe\x05\x0c\x13\x1a\x21"
+			"\x28\x2f\x36\x3d\x44\x4b\x52\x59"
+			"\x60\x67\x6e\x75\x7c\x83\x8a\x91"
+			"\x98\x9f\xa6\xad\xb4\xbb\xc2\xc9"
+			"\xd0\xd7\xde\xe5\xec\xf3\xfa\x01"
+			"\x08\x0f\x16\x1d\x24\x2b\x32\x39"
+			"\x40\x47\x4e\x55\x5c\x63\x6a\x71"
+			"\x78\x7f\x86\x8d\x94\x9b\xa2\xa9"
+			"\xb0\xb7\xbe\xc5\xcc\xd3\xda\xe1"
+			"\xe8\xef\xf6\xfd\x04\x0b\x12\x19"
+			"\x20\x27\x2e\x35\x3c\x43\x4a\x51"
+			"\x58\x5f\x66\x6d\x74\x7b\x82\x89"
+			"\x90\x97\x9e\xa5\xac\xb3\xba\xc1"
+			"\xc8\xcf\xd6\xdd\xe4\xeb\xf2\xf9"
+			"\x00\x09\x12\x1b\x24\x2d\x36\x3f"
+			"\x48\x51\x5a\x63\x6c\x75\x7e\x87"
+			"\x90\x99\xa2\xab\xb4\xbd\xc6\xcf"
+			"\xd8\xe1\xea\xf3\xfc\x05\x0e\x17"
+			"\x20\x29\x32\x3b\x44\x4d\x56\x5f"
+			"\x68\x71\x7a\x83\x8c\x95\x9e\xa7"
+			"\xb0\xb9\xc2\xcb\xd4\xdd\xe6\xef"
+			"\xf8\x01\x0a\x13\x1c\x25\x2e\x37"
+			"\x40\x49\x52\x5b\x64\x6d\x76\x7f"
+			"\x88\x91\x9a\xa3\xac\xb5\xbe\xc7"
+			"\xd0\xd9\xe2\xeb\xf4\xfd\x06\x0f"
+			"\x18\x21\x2a\x33\x3c\x45\x4e\x57"
+			"\x60\x69\x72\x7b\x84\x8d\x96\x9f"
+			"\xa8\xb1\xba\xc3\xcc\xd5\xde\xe7"
+			"\xf0\xf9\x02\x0b\x14\x1d\x26\x2f"
+			"\x38\x41\x4a\x53\x5c\x65\x6e\x77"
+			"\x80\x89\x92\x9b\xa4\xad\xb6\xbf"
+			"\xc8\xd1\xda\xe3\xec\xf5\xfe\x07"
+			"\x10\x19\x22\x2b\x34\x3d\x46\x4f"
+			"\x58\x61\x6a\x73\x7c\x85\x8e\x97"
+			"\xa0\xa9\xb2\xbb\xc4\xcd\xd6\xdf"
+			"\xe8\xf1\xfa\x03\x0c\x15\x1e\x27"
+			"\x30\x39\x42\x4b\x54\x5d\x66\x6f"
+			"\x78\x81\x8a\x93\x9c\xa5\xae\xb7"
+			"\xc0\xc9\xd2\xdb\xe4\xed\xf6\xff"
+			"\x08\x11\x1a\x23\x2c\x35\x3e\x47"
+			"\x50\x59\x62\x6b\x74\x7d\x86\x8f"
+			"\x98\xa1\xaa\xb3\xbc\xc5\xce\xd7"
+			"\xe0\xe9\xf2\xfb\x04\x0d\x16\x1f"
+			"\x28\x31\x3a\x43\x4c\x55\x5e\x67"
+			"\x70\x79\x82\x8b\x94\x9d\xa6\xaf"
+			"\xb8\xc1\xca\xd3\xdc\xe5\xee\xf7"
+			"\x00\x0b\x16\x21\x2c\x37\x42\x4d"
+			"\x58\x63\x6e\x79\x84\x8f\x9a\xa5"
+			"\xb0\xbb\xc6\xd1\xdc\xe7\xf2\xfd"
+			"\x08\x13\x1e\x29\x34\x3f\x4a\x55"
+			"\x60\x6b\x76\x81\x8c\x97\xa2\xad"
+			"\xb8\xc3\xce\xd9\xe4\xef\xfa\x05"
+			"\x10\x1b\x26\x31\x3c\x47\x52\x5d"
+			"\x68\x73\x7e\x89\x94\x9f\xaa\xb5"
+			"\xc0\xcb\xd6\xe1\xec\xf7\x02\x0d"
+			"\x18\x23\x2e\x39\x44\x4f\x5a\x65"
+			"\x70\x7b\x86\x91\x9c\xa7\xb2\xbd"
+			"\xc8\xd3\xde\xe9\xf4\xff\x0a\x15"
+			"\x20\x2b\x36\x41\x4c\x57\x62\x6d"
+			"\x78\x83\x8e\x99\xa4\xaf\xba\xc5"
+			"\xd0\xdb\xe6\xf1\xfc\x07\x12\x1d"
+			"\x28\x33\x3e\x49\x54\x5f\x6a\x75"
+			"\x80\x8b\x96\xa1\xac\xb7\xc2\xcd"
+			"\xd8\xe3\xee\xf9\x04\x0f\x1a\x25"
+			"\x30\x3b\x46\x51\x5c\x67\x72\x7d"
+			"\x88\x93\x9e\xa9\xb4\xbf\xca\xd5"
+			"\xe0\xeb\xf6\x01\x0c\x17\x22\x2d"
+			"\x38\x43\x4e\x59\x64\x6f\x7a\x85"
+			"\x90\x9b\xa6\xb1\xbc\xc7\xd2\xdd"
+			"\xe8\xf3\xfe\x09\x14\x1f\x2a\x35"
+			"\x40\x4b\x56\x61\x6c\x77\x82\x8d"
+			"\x98\xa3\xae\xb9\xc4\xcf\xda\xe5"
+			"\xf0\xfb\x06\x11\x1c\x27\x32\x3d"
+			"\x48\x53\x5e\x69\x74\x7f\x8a\x95"
+			"\xa0\xab\xb6\xc1\xcc\xd7\xe2\xed"
+			"\xf8\x03\x0e\x19\x24\x2f\x3a\x45"
+			"\x50\x5b\x66\x71\x7c\x87\x92\x9d"
+			"\xa8\xb3\xbe\xc9\xd4\xdf\xea\xf5"
+			"\x00\x0d\x1a\x27\x34\x41\x4e\x5b"
+			"\x68\x75\x82\x8f\x9c\xa9\xb6\xc3"
+			"\xd0\xdd\xea\xf7\x04\x11\x1e\x2b"
+			"\x38\x45\x52\x5f\x6c\x79\x86\x93"
+			"\xa0\xad\xba\xc7\xd4\xe1\xee\xfb"
+			"\x08\x15\x22\x2f\x3c\x49\x56\x63"
+			"\x70\x7d\x8a\x97\xa4\xb1\xbe\xcb"
+			"\xd8\xe5\xf2\xff\x0c\x19\x26\x33"
+			"\x40\x4d\x5a\x67\x74\x81\x8e\x9b"
+			"\xa8\xb5\xc2\xcf\xdc\xe9\xf6\x03"
+			"\x10\x1d\x2a\x37\x44\x51\x5e\x6b"
+			"\x78\x85\x92\x9f\xac\xb9\xc6\xd3"
+			"\xe0\xed\xfa\x07\x14\x21\x2e\x3b"
+			"\x48\x55\x62\x6f\x7c\x89\x96\xa3"
+			"\xb0\xbd\xca\xd7\xe4\xf1\xfe\x0b"
+			"\x18\x25\x32\x3f\x4c\x59\x66\x73"
+			"\x80\x8d\x9a\xa7\xb4\xc1\xce\xdb"
+			"\xe8\xf5\x02\x0f\x1c\x29\x36\x43"
+			"\x50\x5d\x6a\x77\x84\x91\x9e\xab"
+			"\xb8\xc5\xd2\xdf\xec\xf9\x06\x13"
+			"\x20\x2d\x3a\x47\x54\x61\x6e\x7b"
+			"\x88\x95\xa2\xaf\xbc\xc9\xd6\xe3"
+			"\xf0\xfd\x0a\x17\x24\x31\x3e\x4b"
+			"\x58\x65\x72\x7f\x8c\x99\xa6\xb3"
+			"\xc0\xcd\xda\xe7\xf4\x01\x0e\x1b"
+			"\x28\x35\x42\x4f\x5c\x69\x76\x83"
+			"\x90\x9d\xaa\xb7\xc4\xd1\xde\xeb"
+			"\xf8\x05\x12\x1f\x2c\x39\x46\x53"
+			"\x60\x6d\x7a\x87\x94\xa1\xae\xbb"
+			"\xc8\xd5\xe2\xef\xfc\x09\x16\x23"
+			"\x30\x3d\x4a\x57\x64\x71\x7e\x8b"
+			"\x98\xa5\xb2\xbf\xcc\xd9\xe6\xf3"
+			"\x00\x0f\x1e\x2d\x3c\x4b\x5a\x69"
+			"\x78\x87\x96\xa5\xb4\xc3\xd2\xe1"
+			"\xf0\xff\x0e\x1d\x2c\x3b\x4a\x59"
+			"\x68\x77\x86\x95\xa4\xb3\xc2\xd1"
+			"\xe0\xef\xfe\x0d\x1c\x2b\x3a\x49"
+			"\x58\x67\x76\x85\x94\xa3\xb2\xc1"
+			"\xd0\xdf\xee\xfd\x0c\x1b\x2a\x39"
+			"\x48\x57\x66\x75\x84\x93\xa2\xb1"
+			"\xc0\xcf\xde\xed\xfc\x0b\x1a\x29"
+			"\x38\x47\x56\x65\x74\x83\x92\xa1"
+			"\xb0\xbf\xce\xdd\xec\xfb\x0a\x19"
+			"\x28\x37\x46\x55\x64\x73\x82\x91"
+			"\xa0\xaf\xbe\xcd\xdc\xeb\xfa\x09"
+			"\x18\x27\x36\x45\x54\x63\x72\x81"
+			"\x90\x9f\xae\xbd\xcc\xdb\xea\xf9"
+			"\x08\x17\x26\x35\x44\x53\x62\x71"
+			"\x80\x8f\x9e\xad\xbc\xcb\xda\xe9"
+			"\xf8\x07\x16\x25\x34\x43\x52\x61"
+			"\x70\x7f\x8e\x9d\xac\xbb\xca\xd9"
+			"\xe8\xf7\x06\x15\x24\x33\x42\x51"
+			"\x60\x6f\x7e\x8d\x9c\xab\xba\xc9"
+			"\xd8\xe7\xf6\x05\x14\x23\x32\x41"
+			"\x50\x5f\x6e\x7d\x8c\x9b\xaa\xb9"
+			"\xc8\xd7\xe6\xf5\x04\x13\x22\x31"
+			"\x40\x4f\x5e\x6d\x7c\x8b\x9a\xa9"
+			"\xb8\xc7\xd6\xe5\xf4\x03\x12\x21"
+			"\x30\x3f\x4e\x5d\x6c\x7b\x8a\x99"
+			"\xa8\xb7\xc6\xd5\xe4\xf3\x02\x11"
+			"\x20\x2f\x3e\x4d\x5c\x6b\x7a\x89"
+			"\x98\xa7\xb6\xc5\xd4\xe3\xf2\x01"
+			"\x10\x1f\x2e\x3d\x4c\x5b\x6a\x79"
+			"\x88\x97\xa6\xb5\xc4\xd3\xe2\xf1"
+			"\x00\x11\x22\x33\x44\x55\x66\x77"
+			"\x88\x99\xaa\xbb\xcc\xdd\xee\xff"
+			"\x10\x21\x32\x43\x54\x65\x76\x87"
+			"\x98\xa9\xba\xcb\xdc\xed\xfe\x0f"
+			"\x20\x31\x42\x53\x64\x75\x86\x97"
+			"\xa8\xb9\xca\xdb\xec\xfd\x0e\x1f"
+			"\x30\x41\x52\x63\x74\x85\x96\xa7"
+			"\xb8\xc9\xda\xeb\xfc\x0d\x1e\x2f"
+			"\x40\x51\x62\x73\x84\x95\xa6\xb7"
+			"\xc8\xd9\xea\xfb\x0c\x1d\x2e\x3f"
+			"\x50\x61\x72\x83\x94\xa5\xb6\xc7"
+			"\xd8\xe9\xfa\x0b\x1c\x2d\x3e\x4f"
+			"\x60\x71\x82\x93\xa4\xb5\xc6\xd7"
+			"\xe8\xf9\x0a\x1b\x2c\x3d\x4e\x5f"
+			"\x70\x81\x92\xa3\xb4\xc5\xd6\xe7"
+			"\xf8\x09\x1a\x2b\x3c\x4d\x5e\x6f"
+			"\x80\x91\xa2\xb3\xc4\xd5\xe6\xf7"
+			"\x08\x19\x2a\x3b\x4c\x5d\x6e\x7f"
+			"\x90\xa1\xb2\xc3\xd4\xe5\xf6\x07"
+			"\x18\x29\x3a\x4b\x5c\x6d\x7e\x8f"
+			"\xa0\xb1\xc2\xd3\xe4\xf5\x06\x17"
+			"\x28\x39\x4a\x5b\x6c\x7d\x8e\x9f"
+			"\xb0\xc1\xd2\xe3\xf4\x05\x16\x27"
+			"\x38\x49\x5a\x6b\x7c\x8d\x9e\xaf"
+			"\xc0\xd1\xe2\xf3\x04\x15\x26\x37"
+			"\x48\x59\x6a\x7b\x8c\x9d\xae\xbf"
+			"\xd0\xe1\xf2\x03\x14\x25\x36\x47"
+			"\x58\x69\x7a\x8b\x9c\xad\xbe\xcf"
+			"\xe0\xf1\x02\x13\x24\x35\x46\x57"
+			"\x68\x79\x8a\x9b\xac\xbd\xce\xdf"
+			"\xf0\x01\x12\x23\x34\x45\x56\x67"
+			"\x78\x89\x9a\xab\xbc\xcd\xde\xef"
+			"\x00\x13\x26\x39\x4c\x5f\x72\x85"
+			"\x98\xab\xbe\xd1\xe4\xf7\x0a\x1d"
+			"\x30\x43\x56\x69\x7c\x8f\xa2\xb5"
+			"\xc8\xdb\xee\x01\x14\x27\x3a\x4d"
+			"\x60\x73\x86\x99\xac\xbf\xd2\xe5"
+			"\xf8\x0b\x1e\x31\x44\x57\x6a\x7d"
+			"\x90\xa3\xb6\xc9\xdc\xef\x02\x15"
+			"\x28\x3b\x4e\x61\x74\x87\x9a\xad"
+			"\xc0\xd3\xe6\xf9\x0c\x1f\x32\x45"
+			"\x58\x6b\x7e\x91\xa4\xb7\xca\xdd"
+			"\xf0\x03\x16\x29\x3c\x4f\x62\x75"
+			"\x88\x9b\xae\xc1\xd4\xe7\xfa\x0d"
+			"\x20\x33\x46\x59\x6c\x7f\x92\xa5"
+			"\xb8\xcb\xde\xf1\x04\x17\x2a\x3d"
+			"\x50\x63\x76\x89\x9c\xaf\xc2\xd5"
+			"\xe8\xfb\x0e\x21\x34\x47\x5a\x6d"
+			"\x80\x93\xa6\xb9\xcc\xdf\xf2\x05"
+			"\x18\x2b\x3e\x51\x64\x77\x8a\x9d"
+			"\xb0\xc3\xd6\xe9\xfc\x0f\x22\x35"
+			"\x48\x5b\x6e\x81\x94\xa7\xba\xcd"
+			"\xe0\xf3\x06\x19\x2c\x3f\x52\x65"
+			"\x78\x8b\x9e\xb1\xc4\xd7\xea\xfd"
+			"\x10\x23\x36\x49\x5c\x6f\x82\x95"
+			"\xa8\xbb\xce\xe1\xf4\x07\x1a\x2d"
+			"\x40\x53\x66\x79\x8c\x9f\xb2\xc5"
+			"\xd8\xeb\xfe\x11\x24\x37\x4a\x5d"
+			"\x70\x83\x96\xa9\xbc\xcf\xe2\xf5"
+			"\x08\x1b\x2e\x41\x54\x67\x7a\x8d"
+			"\xa0\xb3\xc6\xd9\xec\xff\x12\x25"
+			"\x38\x4b\x5e\x71\x84\x97\xaa\xbd"
+			"\xd0\xe3\xf6\x09\x1c\x2f\x42\x55"
+			"\x68\x7b\x8e\xa1\xb4\xc7\xda\xed"
+			"\x00\x15\x2a\x3f\x54\x69\x7e\x93"
+			"\xa8\xbd\xd2\xe7\xfc\x11\x26\x3b"
+			"\x50\x65\x7a\x8f\xa4\xb9\xce\xe3"
+			"\xf8\x0d\x22\x37\x4c\x61\x76\x8b"
+			"\xa0\xb5\xca\xdf\xf4\x09\x1e\x33"
+			"\x48\x5d\x72\x87\x9c\xb1\xc6\xdb"
+			"\xf0\x05\x1a\x2f\x44\x59\x6e\x83"
+			"\x98\xad\xc2\xd7\xec\x01\x16\x2b"
+			"\x40\x55\x6a\x7f\x94\xa9\xbe\xd3"
+			"\xe8\xfd\x12\x27\x3c\x51\x66\x7b"
+			"\x90\xa5\xba\xcf\xe4\xf9\x0e\x23"
+			"\x38\x4d\x62\x77\x8c\xa1\xb6\xcb"
+			"\xe0\xf5\x0a\x1f\x34\x49\x5e\x73"
+			"\x88\x9d\xb2\xc7\xdc\xf1\x06\x1b"
+			"\x30\x45\x5a\x6f\x84\x99\xae\xc3"
+			"\xd8\xed\x02\x17\x2c\x41\x56\x6b"
+			"\x80\x95\xaa\xbf\xd4\xe9\xfe\x13"
+			"\x28\x3d\x52\x67\x7c\x91\xa6\xbb"
+			"\xd0\xe5\xfa\x0f\x24\x39\x4e\x63"
+			"\x78\x8d\xa2\xb7\xcc\xe1\xf6\x0b"
+			"\x20\x35\x4a\x5f\x74\x89\x9e\xb3"
+			"\xc8\xdd\xf2\x07\x1c\x31\x46\x5b"
+			"\x70\x85\x9a\xaf\xc4\xd9\xee\x03"
+			"\x18\x2d\x42\x57\x6c\x81\x96\xab"
+			"\xc0\xd5\xea\xff\x14\x29\x3e\x53"
+			"\x68\x7d\x92\xa7\xbc\xd1\xe6\xfb"
+			"\x10\x25\x3a\x4f\x64\x79\x8e\xa3"
+			"\xb8\xcd\xe2\xf7\x0c\x21\x36\x4b"
+			"\x60\x75\x8a\x9f\xb4\xc9\xde\xf3"
+			"\x08\x1d\x32\x47\x5c\x71\x86\x9b"
+			"\xb0\xc5\xda\xef\x04\x19\x2e\x43"
+			"\x58\x6d\x82\x97\xac\xc1\xd6\xeb"
+			"\x00\x17\x2e\x45\x5c\x73\x8a\xa1"
+			"\xb8\xcf\xe6\xfd\x14\x2b\x42\x59"
+			"\x70\x87\x9e\xb5\xcc\xe3\xfa\x11"
+			"\x28\x3f\x56\x6d\x84\x9b\xb2\xc9"
+			"\xe0\xf7\x0e\x25\x3c\x53\x6a\x81"
+			"\x98\xaf\xc6\xdd\xf4\x0b\x22\x39"
+			"\x50\x67\x7e\x95\xac\xc3\xda\xf1"
+			"\x08\x1f\x36\x4d\x64\x7b\x92\xa9"
+			"\xc0\xd7\xee\x05\x1c\x33\x4a\x61"
+			"\x78\x8f\xa6\xbd\xd4\xeb\x02\x19"
+			"\x30\x47\x5e\x75\x8c\xa3\xba\xd1"
+			"\xe8\xff\x16\x2d\x44\x5b\x72\x89"
+			"\xa0\xb7\xce\xe5\xfc\x13\x2a\x41"
+			"\x58\x6f\x86\x9d\xb4\xcb\xe2\xf9"
+			"\x10\x27\x3e\x55\x6c\x83\x9a\xb1"
+			"\xc8\xdf\xf6\x0d\x24\x3b\x52\x69"
+			"\x80\x97\xae\xc5\xdc\xf3\x0a\x21"
+			"\x38\x4f\x66\x7d\x94\xab\xc2\xd9"
+			"\xf0\x07\x1e\x35\x4c\x63\x7a\x91"
+			"\xa8\xbf\xd6\xed\x04\x1b\x32\x49"
+			"\x60\x77\x8e\xa5\xbc\xd3\xea\x01"
+			"\x18\x2f\x46\x5d\x74\x8b\xa2\xb9"
+			"\xd0\xe7\xfe\x15\x2c\x43\x5a\x71"
+			"\x88\x9f\xb6\xcd\xe4\xfb\x12\x29"
+			"\x40\x57\x6e\x85\x9c\xb3\xca\xe1"
+			"\xf8\x0f\x26\x3d\x54\x6b\x82\x99"
+			"\xb0\xc7\xde\xf5\x0c\x23\x3a\x51"
+			"\x68\x7f\x96\xad\xc4\xdb\xf2\x09"
+			"\x20\x37\x4e\x65\x7c\x93\xaa\xc1"
+			"\xd8\xef\x06\x1d\x34\x4b\x62\x79"
+			"\x90\xa7\xbe\xd5\xec\x03\x1a\x31"
+			"\x48\x5f\x76\x8d\xa4\xbb\xd2\xe9"
+			"\x00\x19\x32\x4b\x64\x7d\x96\xaf"
+			"\xc8\xe1\xfa\x13\x2c\x45\x5e\x77"
+			"\x90\xa9\xc2\xdb\xf4\x0d\x26\x3f"
+			"\x58\x71\x8a\xa3\xbc\xd5\xee\x07"
+			"\x20\x39\x52\x6b\x84\x9d\xb6\xcf"
+			"\xe8\x01\x1a\x33\x4c\x65\x7e\x97"
+			"\xb0\xc9\xe2\xfb\x14\x2d\x46\x5f"
+			"\x78\x91\xaa\xc3\xdc\xf5\x0e\x27"
+			"\x40\x59\x72\x8b\xa4\xbd\xd6\xef"
+			"\x08\x21\x3a\x53\x6c\x85\x9e\xb7"
+			"\xd0\xe9\x02\x1b\x34\x4d\x66\x7f"
+			"\x98\xb1\xca\xe3\xfc\x15\x2e\x47"
+			"\x60\x79\x92\xab\xc4\xdd\xf6\x0f"
+			"\x28\x41\x5a\x73\x8c\xa5\xbe\xd7"
+			"\xf0\x09\x22\x3b\x54\x6d\x86\x9f"
+			"\xb8\xd1\xea\x03\x1c\x35\x4e\x67"
+			"\x80\x99\xb2\xcb\xe4\xfd\x16\x2f"
+			"\x48\x61\x7a\x93\xac\xc5\xde\xf7"
+			"\x10\x29\x42\x5b\x74\x8d\xa6\xbf"
+			"\xd8\xf1\x0a\x23\x3c\x55\x6e\x87"
+			"\xa0\xb9\xd2\xeb\x04\x1d\x36\x4f"
+			"\x68\x81\x9a\xb3\xcc\xe5\xfe\x17"
+			"\x30\x49\x62\x7b\x94\xad\xc6\xdf"
+			"\xf8\x11\x2a\x43\x5c\x75\x8e\xa7"
+			"\xc0\xd9\xf2\x0b\x24\x3d\x56\x6f"
+			"\x88\xa1\xba\xd3\xec\x05\x1e\x37"
+			"\x50\x69\x82\x9b\xb4\xcd\xe6\xff"
+			"\x18\x31\x4a\x63\x7c\x95\xae\xc7"
+			"\xe0\xf9\x12\x2b\x44\x5d\x76\x8f"
+			"\xa8\xc1\xda\xf3\x0c\x25\x3e\x57"
+			"\x70\x89\xa2\xbb\xd4\xed\x06\x1f"
+			"\x38\x51\x6a\x83\x9c\xb5\xce\xe7"
+			"\x00\x1b\x36\x51\x6c\x87\xa2\xbd"
+			"\xd8\xf3\x0e\x29\x44\x5f\x7a\x95"
+			"\xb0\xcb\xe6\x01\x1c\x37\x52\x6d"
+			"\x88\xa3\xbe\xd9\xf4\x0f\x2a\x45"
+			"\x60\x7b\x96\xb1\xcc\xe7\x02\x1d"
+			"\x38\x53\x6e\x89\xa4\xbf\xda\xf5"
+			"\x10\x2b\x46\x61\x7c\x97\xb2\xcd"
+			"\xe8\x03\x1e\x39\x54\x6f\x8a\xa5"
+			"\xc0\xdb\xf6\x11\x2c\x47\x62\x7d"
+			"\x98\xb3\xce\xe9\x04\x1f\x3a\x55"
+			"\x70\x8b\xa6\xc1\xdc\xf7\x12\x2d"
+			"\x48\x63\x7e\x99\xb4\xcf\xea\x05"
+			"\x20\x3b\x56\x71\x8c\xa7\xc2\xdd"
+			"\xf8\x13\x2e\x49\x64\x7f\x9a\xb5"
+			"\xd0\xeb\x06\x21\x3c\x57\x72\x8d"
+			"\xa8\xc3\xde\xf9\x14\x2f\x4a\x65"
+			"\x80\x9b\xb6\xd1\xec\x07\x22\x3d"
+			"\x58\x73\x8e\xa9\xc4\xdf\xfa\x15"
+			"\x30\x4b\x66\x81\x9c\xb7\xd2\xed"
+			"\x08\x23\x3e\x59\x74\x8f\xaa\xc5"
+			"\xe0\xfb\x16\x31\x4c\x67\x82\x9d"
+			"\xb8\xd3\xee\x09\x24\x3f\x5a\x75"
+			"\x90\xab\xc6\xe1\xfc\x17\x32\x4d"
+			"\x68\x83\x9e\xb9\xd4\xef\x0a\x25"
+			"\x40\x5b\x76\x91\xac\xc7\xe2\xfd"
+			"\x18\x33\x4e\x69\x84\x9f\xba\xd5"
+			"\xf0\x0b\x26\x41\x5c\x77\x92\xad"
+			"\xc8\xe3\xfe\x19\x34\x4f\x6a\x85"
+			"\xa0\xbb\xd6\xf1\x0c\x27\x42\x5d"
+			"\x78\x93\xae\xc9\xe4\xff\x1a\x35"
+			"\x50\x6b\x86\xa1\xbc\xd7\xf2\x0d"
+			"\x28\x43\x5e\x79\x94\xaf\xca\xe5"
+			"\x00\x1d\x3a\x57\x74\x91\xae\xcb"
+			"\xe8\x05\x22\x3f\x5c\x79\x96\xb3"
+			"\xd0\xed\x0a\x27\x44\x61\x7e\x9b"
+			"\xb8\xd5\xf2\x0f\x2c\x49\x66\x83"
+			"\xa0\xbd\xda\xf7\x14\x31\x4e\x6b"
+			"\x88\xa5\xc2\xdf\xfc\x19\x36\x53"
+			"\x70\x8d\xaa\xc7\xe4\x01\x1e\x3b"
+			"\x58\x75\x92\xaf\xcc\xe9\x06\x23"
+			"\x40\x5d\x7a\x97\xb4\xd1\xee\x0b"
+			"\x28\x45\x62\x7f\x9c\xb9\xd6\xf3"
+			"\x10\x2d\x4a\x67\x84\xa1\xbe\xdb"
+			"\xf8\x15\x32\x4f\x6c\x89\xa6\xc3"
+			"\xe0\xfd\x1a\x37\x54\x71\x8e\xab"
+			"\xc8\xe5\x02\x1f\x3c\x59\x76\x93"
+			"\xb0\xcd\xea\x07\x24\x41\x5e\x7b"
+			"\x98\xb5\xd2\xef\x0c\x29\x46\x63"
+			"\x80\x9d\xba\xd7\xf4\x11\x2e\x4b"
+			"\x68\x85\xa2\xbf\xdc\xf9\x16\x33"
+			"\x50\x6d\x8a\xa7\xc4\xe1\xfe\x1b"
+			"\x38\x55\x72\x8f\xac\xc9\xe6\x03"
+			"\x20\x3d\x5a\x77\x94\xb1\xce\xeb"
+			"\x08\x25\x42\x5f\x7c\x99\xb6\xd3"
+			"\xf0\x0d\x2a\x47\x64\x81\x9e\xbb"
+			"\xd8\xf5\x12\x2f\x4c\x69\x86\xa3"
+			"\xc0\xdd\xfa\x17\x34\x51\x6e\x8b"
+			"\xa8\xc5\xe2\xff\x1c\x39\x56\x73"
+			"\x90\xad\xca\xe7\x04\x21\x3e\x5b"
+			"\x78\x95\xb2\xcf\xec\x09\x26\x43"
+			"\x60\x7d\x9a\xb7\xd4\xf1\x0e\x2b"
+			"\x48\x65\x82\x9f\xbc\xd9\xf6\x13"
+			"\x30\x4d\x6a\x87\xa4\xc1\xde\xfb"
+			"\x18\x35\x52\x6f\x8c\xa9\xc6\xe3"
+			"\x00\x1f\x3e\x5d\x7c\x9b\xba\xd9"
+			"\xf8\x17\x36\x55\x74\x93\xb2\xd1"
+			"\xf0\x0f\x2e\x4d\x6c\x8b\xaa\xc9"
+			"\xe8\x07\x26\x45\x64\x83\xa2\xc1"
+			"\xe0\xff\x1e\x3d\x5c\x7b\x9a\xb9"
+			"\xd8\xf7\x16\x35\x54\x73\x92\xb1"
+			"\xd0\xef\x0e\x2d\x4c\x6b\x8a\xa9"
+			"\xc8\xe7\x06\x25\x44\x63\x82\xa1"
+			"\xc0\xdf\xfe\x1d\x3c\x5b\x7a\x99"
+			"\xb8\xd7\xf6\x15\x34\x53\x72\x91"
+			"\xb0\xcf\xee\x0d\x2c\x4b\x6a\x89"
+			"\xa8\xc7\xe6\x05\x24\x43\x62\x81"
+			"\xa0\xbf\xde\xfd\x1c\x3b\x5a\x79"
+			"\x98\xb7\xd6\xf5\x14\x33\x52\x71"
+			"\x90\xaf\xce\xed\x0c\x2b\x4a\x69"
+			"\x88\xa7\xc6\xe5\x04\x23\x42\x61"
+			"\x80\x9f\xbe\xdd\xfc\x1b\x3a\x59"
+			"\x78\x97\xb6\xd5\xf4\x13\x32\x51"
+			"\x70\x8f\xae\xcd\xec\x0b\x2a\x49"
+			"\x68\x87\xa6\xc5\xe4\x03\x22\x41"
+			"\x60\x7f\x9e\xbd\xdc\xfb\x1a\x39"
+			"\x58\x77\x96\xb5\xd4\xf3\x12\x31"
+			"\x50\x6f\x8e\xad\xcc\xeb\x0a\x29"
+			"\x48\x67\x86\xa5\xc4\xe3\x02\x21"
+			"\x40\x5f\x7e\x9d\xbc\xdb\xfa\x19"
+			"\x38\x57\x76\x95\xb4\xd3\xf2\x11"
+			"\x30\x4f\x6e\x8d\xac\xcb\xea\x09"
+			"\x28\x47\x66\x85\xa4\xc3\xe2\x01"
+			"\x20\x3f\x5e\x7d\x9c\xbb\xda\xf9"
+			"\x18\x37\x56\x75\x94\xb3\xd2\xf1"
+			"\x10\x2f\x4e\x6d\x8c\xab\xca\xe9"
+			"\x08\x27\x46\x65\x84\xa3\xc2\xe1"
+			"\x00\x21\x42\x63",
+		.ilen = 4100,
+		.result =
+			"\xf0\x5c\x74\xad\x4e\xbc\x99\xe2"
+			"\xae\xff\x91\x3a\x44\xcf\x38\x32"
+			"\x1e\xad\xa7\xcd\xa1\x39\x95\xaa"
+			"\x10\xb1\xb3\x2e\x04\x31\x8f\x86"
+			"\xf2\x62\x74\x70\x0c\xa4\x46\x08"
+			"\xa8\xb7\x99\xa8\xe9\xd2\x73\x79"
+			"\x7e\x6e\xd4\x8f\x1e\xc7\x8e\x31"
+			"\x0b\xfa\x4b\xce\xfd\xf3\x57\x71"
+			"\xe9\x46\x03\xa5\x3d\x34\x00\xe2"
+			"\x18\xff\x75\x6d\x06\x2d\x00\xab"
+			"\xb9\x3e\x6c\x59\xc5\x84\x06\xb5"
+			"\x8b\xd0\x89\x9c\x4a\x79\x16\xc6"
+			"\x3d\x74\x54\xfa\x44\xcd\x23\x26"
+			"\x5c\xcf\x7e\x28\x92\x32\xbf\xdf"
+			"\xa7\x20\x3c\x74\x58\x2a\x9a\xde"
+			"\x61\x00\x1c\x4f\xff\x59\xc4\x22"
+			"\xac\x3c\xd0\xe8\x6c\xf9\x97\x1b"
+			"\x58\x9b\xad\x71\xe8\xa9\xb5\x0d"
+			"\xee\x2f\x04\x1f\x7f\xbc\x99\xee"
+			"\x84\xff\x42\x60\xdc\x3a\x18\xa5"
+			"\x81\xf9\xef\xdc\x7a\x0f\x65\x41"
+			"\x2f\xa3\xd3\xf9\xc2\xcb\xc0\x4d"
+			"\x8f\xd3\x76\x96\xad\x49\x6d\x38"
+			"\x3d\x39\x0b\x6c\x80\xb7\x54\x69"
+			"\xf0\x2c\x90\x02\x29\x0d\x1c\x12"
+			"\xad\x55\xc3\x8b\x68\xd9\xcc\xb3"
+			"\xb2\x64\x33\x90\x5e\xca\x4b\xe2"
+			"\xfb\x75\xdc\x63\xf7\x9f\x82\x74"
+			"\xf0\xc9\xaa\x7f\xe9\x2a\x9b\x33"
+			"\xbc\x88\x00\x7f\xca\xb2\x1f\x14"
+			"\xdb\xc5\x8e\x7b\x11\x3c\x3e\x08"
+			"\xf3\x83\xe8\xe0\x94\x86\x2e\x92"
+			"\x78\x6b\x01\xc9\xc7\x83\xba\x21"
+			"\x6a\x25\x15\x33\x4e\x45\x08\xec"
+			"\x35\xdb\xe0\x6e\x31\x51\x79\xa9"
+			"\x42\x44\x65\xc1\xa0\xf1\xf9\x2a"
+			"\x70\xd5\xb6\xc6\xc1\x8c\x39\xfc"
+			"\x25\xa6\x55\xd9\xdd\x2d\x4c\xec"
+			"\x49\xc6\xeb\x0e\xa8\x25\x2a\x16"
+			"\x1b\x66\x84\xda\xe2\x92\xe5\xc0"
+			"\xc8\x53\x07\xaf\x80\x84\xec\xfd"
+			"\xcd\xd1\x6e\xcd\x6f\x6a\xf5\x36"
+			"\xc5\x15\xe5\x25\x7d\x77\xd1\x1a"
+			"\x93\x36\xa9\xcf\x7c\xa4\x54\x4a"
+			"\x06\x51\x48\x4e\xf6\x59\x87\xd2"
+			"\x04\x02\xef\xd3\x44\xde\x76\x31"
+			"\xb3\x34\x17\x1b\x9d\x66\x11\x9f"
+			"\x1e\xcc\x17\xe9\xc7\x3c\x1b\xe7"
+			"\xcb\x50\x08\xfc\xdc\x2b\x24\xdb"
+			"\x65\x83\xd0\x3b\xe3\x30\xea\x94"
+			"\x6c\xe7\xe8\x35\x32\xc7\xdb\x64"
+			"\xb4\x01\xab\x36\x2c\x77\x13\xaf"
+			"\xf8\x2b\x88\x3f\x54\x39\xc4\x44"
+			"\xfe\xef\x6f\x68\x34\xbe\x0f\x05"
+			"\x16\x6d\xf6\x0a\x30\xe7\xe3\xed"
+			"\xc4\xde\x3c\x1b\x13\xd8\xdb\xfe"
+			"\x41\x62\xe5\x28\xd4\x8d\xa3\xc7"
+			"\x93\x97\xc6\x48\x45\x1d\x9f\x83"
+			"\xdf\x4b\x40\x3e\x42\x25\x87\x80"
+			"\x4c\x7d\xa8\xd4\x98\x23\x95\x75"
+			"\x41\x8c\xda\x41\x9b\xd4\xa7\x06"
+			"\xb5\xf1\x71\x09\x53\xbe\xca\xbf"
+			"\x32\x03\xed\xf0\x50\x1c\x56\x39"
+			"\x5b\xa4\x75\x18\xf7\x9b\x58\xef"
+			"\x53\xfc\x2a\x38\x23\x15\x75\xcd"
+			"\x45\xe5\x5a\x82\x55\xba\x21\xfa"
+			"\xd4\xbd\xc6\x94\x7c\xc5\x80\x12"
+			"\xf7\x4b\x32\xc4\x9a\x82\xd8\x28"
+			"\x8f\xd9\xc2\x0f\x60\x03\xbe\x5e"
+			"\x21\xd6\x5f\x58\xbf\x5c\xb1\x32"
+			"\x82\x8d\xa9\xe5\xf2\x66\x1a\xc0"
+			"\xa0\xbc\x58\x2f\x71\xf5\x2f\xed"
+			"\xd1\x26\xb9\xd8\x49\x5a\x07\x19"
+			"\x01\x7c\x59\xb0\xf8\xa4\xb7\xd3"
+			"\x7b\x1a\x8c\x38\xf4\x50\xa4\x59"
+			"\xb0\xcc\x41\x0b\x88\x7f\xe5\x31"
+			"\xb3\x42\xba\xa2\x7e\xd4\x32\x71"
+			"\x45\x87\x48\xa9\xc2\xf2\x89\xb3"
+			"\xe4\xa7\x7e\x52\x15\x61\xfa\xfe"
+			"\xc9\xdd\x81\xeb\x13\xab\xab\xc3"
+			"\x98\x59\xd8\x16\x3d\x14\x7a\x1c"
+			"\x3c\x41\x9a\x16\x16\x9b\xd2\xd2"
+			"\x69\x3a\x29\x23\xac\x86\x32\xa5"
+			"\x48\x9c\x9e\xf3\x47\x77\x81\x70"
+			"\x24\xe8\x85\xd2\xf5\xb5\xfa\xff"
+			"\x59\x6a\xd3\x50\x59\x43\x59\xde"
+			"\xd9\xf1\x55\xa5\x0c\xc3\x1a\x1a"
+			"\x18\x34\x0d\x1a\x63\x33\xed\x10"
+			"\xe0\x1d\x2a\x18\xd2\xc0\x54\xa8"
+			"\xca\xb5\x9a\xd3\xdd\xca\x45\x84"
+			"\x50\xe7\x0f\xfe\xa4\x99\x5a\xbe"
+			"\x43\x2d\x9a\xcb\x92\x3f\x5a\x1d"
+			"\x85\xd8\xc9\xdf\x68\xc9\x12\x80"
+			"\x56\x0c\xdc\x00\xdc\x3a\x7d\x9d"
+			"\xa3\xa2\xe8\x4d\xbf\xf9\x70\xa0"
+			"\xa4\x13\x4f\x6b\xaf\x0a\x89\x7f"
+			"\xda\xf0\xbf\x9b\xc8\x1d\xe5\xf8"
+			"\x2e\x8b\x07\xb5\x73\x1b\xcc\xa2"
+			"\xa6\xad\x30\xbc\x78\x3c\x5b\x10"
+			"\xfa\x5e\x62\x2d\x9e\x64\xb3\x33"
+			"\xce\xf9\x1f\x86\xe7\x8b\xa2\xb8"
+			"\xe8\x99\x57\x8c\x11\xed\x66\xd9"
+			"\x3c\x72\xb9\xc3\xe6\x4e\x17\x3a"
+			"\x6a\xcb\x42\x24\x06\xed\x3e\x4e"
+			"\xa3\xe8\x6a\x94\xda\x0d\x4e\xd5"
+			"\x14\x19\xcf\xb6\x26\xd8\x2e\xcc"
+			"\x64\x76\x38\x49\x4d\xfe\x30\x6d"
+			"\xe4\xc8\x8c\x7b\xc4\xe0\x35\xba"
+			"\x22\x6e\x76\xe1\x1a\xf2\x53\xc3"
+			"\x28\xa2\x82\x1f\x61\x69\xad\xc1"
+			"\x7b\x28\x4b\x1e\x6c\x85\x95\x9b"
+			"\x51\xb5\x17\x7f\x12\x69\x8c\x24"
+			"\xd5\xc7\x5a\x5a\x11\x54\xff\x5a"
+			"\xf7\x16\xc3\x91\xa6\xf0\xdc\x0a"
+			"\xb6\xa7\x4a\x0d\x7a\x58\xfe\xa5"
+			"\xf5\xcb\x8f\x7b\x0e\xea\x57\xe7"
+			"\xbd\x79\xd6\x1c\x88\x23\x6c\xf2"
+			"\x4d\x29\x77\x53\x35\x6a\x00\x8d"
+			"\xcd\xa3\x58\xbe\x77\x99\x18\xf8"
+			"\xe6\xe1\x8f\xe9\x37\x8f\xe3\xe2"
+			"\x5a\x8a\x93\x25\xaf\xf3\x78\x80"
+			"\xbe\xa6\x1b\xc6\xac\x8b\x1c\x91"
+			"\x58\xe1\x9f\x89\x35\x9d\x1d\x21"
+			"\x29\x9f\xf4\x99\x02\x27\x0f\xa8"
+			"\x4f\x79\x94\x2b\x33\x2c\xda\xa2"
+			"\x26\x39\x83\x94\xef\x27\xd8\x53"
+			"\x8f\x66\x0d\xe4\x41\x7d\x34\xcd"
+			"\x43\x7c\x95\x0a\x53\xef\x66\xda"
+			"\x7e\x9b\xf3\x93\xaf\xd0\x73\x71"
+			"\xba\x40\x9b\x74\xf8\xd7\xd7\x41"
+			"\x6d\xaf\x72\x9c\x8d\x21\x87\x3c"
+			"\xfd\x0a\x90\xa9\x47\x96\x9e\xd3"
+			"\x88\xee\x73\xcf\x66\x2f\x52\x56"
+			"\x6d\xa9\x80\x4c\xe2\x6f\x62\x88"
+			"\x3f\x0e\x54\x17\x48\x80\x5d\xd3"
+			"\xc3\xda\x25\x3d\xa1\xc8\xcb\x9f"
+			"\x9b\x70\xb3\xa1\xeb\x04\x52\xa1"
+			"\xf2\x22\x0f\xfc\xc8\x18\xfa\xf9"
+			"\x85\x9c\xf1\xac\xeb\x0c\x02\x46"
+			"\x75\xd2\xf5\x2c\xe3\xd2\x59\x94"
+			"\x12\xf3\x3c\xfc\xd7\x92\xfa\x36"
+			"\xba\x61\x34\x38\x7c\xda\x48\x3e"
+			"\x08\xc9\x39\x23\x5e\x02\x2c\x1a"
+			"\x18\x7e\xb4\xd9\xfd\x9e\x40\x02"
+			"\xb1\x33\x37\x32\xe7\xde\xd6\xd0"
+			"\x7c\x58\x65\x4b\xf8\x34\x27\x9c"
+			"\x44\xb4\xbd\xe9\xe9\x4c\x78\x7d"
+			"\x4b\x9f\xce\xb1\xcd\x47\xa5\x37"
+			"\xe5\x6d\xbd\xb9\x43\x94\x0a\xd4"
+			"\xd6\xf9\x04\x5f\xb5\x66\x6c\x1a"
+			"\x35\x12\xe3\x36\x28\x27\x36\x58"
+			"\x01\x2b\x79\xe4\xba\x6d\x10\x7d"
+			"\x65\xdf\x84\x95\xf4\xd5\xb6\x8f"
+			"\x2b\x9f\x96\x00\x86\x60\xf0\x21"
+			"\x76\xa8\x6a\x8c\x28\x1c\xb3\x6b"
+			"\x97\xd7\xb6\x53\x2a\xcc\xab\x40"
+			"\x9d\x62\x79\x58\x52\xe6\x65\xb7"
+			"\xab\x55\x67\x9c\x89\x7c\x03\xb0"
+			"\x73\x59\xc5\x81\xf5\x18\x17\x5c"
+			"\x89\xf3\x78\x35\x44\x62\x78\x72"
+			"\xd0\x96\xeb\x31\xe7\x87\x77\x14"
+			"\x99\x51\xf2\x59\x26\x9e\xb5\xa6"
+			"\x45\xfe\x6e\xbd\x07\x4c\x94\x5a"
+			"\xa5\x7d\xfc\xf1\x2b\x77\xe2\xfe"
+			"\x17\xd4\x84\xa0\xac\xb5\xc7\xda"
+			"\xa9\x1a\xb6\xf3\x74\x11\xb4\x9d"
+			"\xfb\x79\x2e\x04\x2d\x50\x28\x83"
+			"\xbf\xc6\x52\xd3\x34\xd6\xe8\x7a"
+			"\xb6\xea\xe7\xa8\x6c\x15\x1e\x2c"
+			"\x57\xbc\x48\x4e\x5f\x5c\xb6\x92"
+			"\xd2\x49\x77\x81\x6d\x90\x70\xae"
+			"\x98\xa1\x03\x0d\x6b\xb9\x77\x14"
+			"\xf1\x4e\x23\xd3\xf8\x68\xbd\xc2"
+			"\xfe\x04\xb7\x5c\xc5\x17\x60\x8f"
+			"\x65\x54\xa4\x7a\x42\xdc\x18\x0d"
+			"\xb5\xcf\x0f\xd3\xc7\x91\x66\x1b"
+			"\x45\x42\x27\x75\x50\xe5\xee\xb8"
+			"\x7f\x33\x2c\xba\x4a\x92\x4d\x2c"
+			"\x3c\xe3\x0d\x80\x01\xba\x0d\x29"
+			"\xd8\x3c\xe9\x13\x16\x57\xe6\xea"
+			"\x94\x52\xe7\x00\x4d\x30\xb0\x0f"
+			"\x35\xb8\xb8\xa7\xb1\xb5\x3b\x44"
+			"\xe1\x2f\xfd\x88\xed\x43\xe7\x52"
+			"\x10\x93\xb3\x8a\x30\x6b\x0a\xf7"
+			"\x23\xc6\x50\x9d\x4a\xb0\xde\xc3"
+			"\xdc\x9b\x2f\x01\x56\x36\x09\xc5"
+			"\x2f\x6b\xfe\xf1\xd8\x27\x45\x03"
+			"\x30\x5e\x5c\x5b\xb4\x62\x0e\x1a"
+			"\xa9\x21\x2b\x92\x94\x87\x62\x57"
+			"\x4c\x10\x74\x1a\xf1\x0a\xc5\x84"
+			"\x3b\x9e\x72\x02\xd7\xcc\x09\x56"
+			"\xbd\x54\xc1\xf0\xc3\xe3\xb3\xf8"
+			"\xd2\x0d\x61\xcb\xef\xce\x0d\x05"
+			"\xb0\x98\xd9\x8e\x4f\xf9\xbc\x93"
+			"\xa6\xea\xc8\xcf\x10\x53\x4b\xf1"
+			"\xec\xfc\x89\xf9\x64\xb0\x22\xbf"
+			"\x9e\x55\x46\x9f\x7c\x50\x8e\x84"
+			"\x54\x20\x98\xd7\x6c\x40\x1e\xdb"
+			"\x69\x34\x78\x61\x24\x21\x9c\x8a"
+			"\xb3\x62\x31\x8b\x6e\xf5\x2a\x35"
+			"\x86\x13\xb1\x6c\x64\x2e\x41\xa5"
+			"\x05\xf2\x42\xba\xd2\x3a\x0d\x8e"
+			"\x8a\x59\x94\x3c\xcf\x36\x27\x82"
+			"\xc2\x45\xee\x58\xcd\x88\xb4\xec"
+			"\xde\xb2\x96\x0a\xaf\x38\x6f\x88"
+			"\xd7\xd8\xe1\xdf\xb9\x96\xa9\x0a"
+			"\xb1\x95\x28\x86\x20\xe9\x17\x49"
+			"\xa2\x29\x38\xaa\xa5\xe9\x6e\xf1"
+			"\x19\x27\xc0\xd5\x2a\x22\xc3\x0b"
+			"\xdb\x7c\x73\x10\xb9\xba\x89\x76"
+			"\x54\xae\x7d\x71\xb3\x93\xf6\x32"
+			"\xe6\x47\x43\x55\xac\xa0\x0d\xc2"
+			"\x93\x27\x4a\x8e\x0e\x74\x15\xc7"
+			"\x0b\x85\xd9\x0c\xa9\x30\x7a\x3e"
+			"\xea\x8f\x85\x6d\x3a\x12\x4f\x72"
+			"\x69\x58\x7a\x80\xbb\xb5\x97\xf3"
+			"\xcf\x70\xd2\x5d\xdd\x4d\x21\x79"
+			"\x54\x4d\xe4\x05\xe8\xbd\xc2\x62"
+			"\xb1\x3b\x77\x1c\xd6\x5c\xf3\xa0"
+			"\x79\x00\xa8\x6c\x29\xd9\x18\x24"
+			"\x36\xa2\x46\xc0\x96\x65\x7f\xbd"
+			"\x2a\xed\x36\x16\x0c\xaa\x9f\xf4"
+			"\xc5\xb4\xe2\x12\xed\x69\xed\x4f"
+			"\x26\x2c\x39\x52\x89\x98\xe7\x2c"
+			"\x99\xa4\x9e\xa3\x9b\x99\x46\x7a"
+			"\x3a\xdc\xa8\x59\xa3\xdb\xc3\x3b"
+			"\x95\x0d\x3b\x09\x6e\xee\x83\x5d"
+			"\x32\x4d\xed\xab\xfa\x98\x14\x4e"
+			"\xc3\x15\x45\x53\x61\xc4\x93\xbd"
+			"\x90\xf4\x99\x95\x4c\xe6\x76\x92"
+			"\x29\x90\x46\x30\x92\x69\x7d\x13"
+			"\xf2\xa5\xcd\x69\x49\x44\xb2\x0f"
+			"\x63\x40\x36\x5f\x09\xe2\x78\xf8"
+			"\x91\xe3\xe2\xfa\x10\xf7\xc8\x24"
+			"\xa8\x89\x32\x5c\x37\x25\x1d\xb2"
+			"\xea\x17\x8a\x0a\xa9\x64\xc3\x7c"
+			"\x3c\x7c\xbd\xc6\x79\x34\xe7\xe2"
+			"\x85\x8e\xbf\xf8\xde\x92\xa0\xae"
+			"\x20\xc4\xf6\xbb\x1f\x38\x19\x0e"
+			"\xe8\x79\x9c\xa1\x23\xe9\x54\x7e"
+			"\x37\x2f\xe2\x94\x32\xaf\xa0\x23"
+			"\x49\xe4\xc0\xb3\xac\x00\x8f\x36"
+			"\x05\xc4\xa6\x96\xec\x05\x98\x4f"
+			"\x96\x67\x57\x1f\x20\x86\x1b\x2d"
+			"\x69\xe4\x29\x93\x66\x5f\xaf\x6b"
+			"\x88\x26\x2c\x67\x02\x4b\x52\xd0"
+			"\x83\x7a\x43\x1f\xc0\x71\x15\x25"
+			"\x77\x65\x08\x60\x11\x76\x4c\x8d"
+			"\xed\xa9\x27\xc6\xb1\x2a\x2c\x6a"
+			"\x4a\x97\xf5\xc6\xb7\x70\x42\xd3"
+			"\x03\xd1\x24\x95\xec\x6d\xab\x38"
+			"\x72\xce\xe2\x8b\x33\xd7\x51\x09"
+			"\xdc\x45\xe0\x09\x96\x32\xf3\xc4"
+			"\x84\xdc\x73\x73\x2d\x1b\x11\x98"
+			"\xc5\x0e\x69\x28\x94\xc7\xb5\x4d"
+			"\xc8\x8a\xd0\xaa\x13\x2e\x18\x74"
+			"\xdd\xd1\x1e\xf3\x90\xe8\xfc\x9a"
+			"\x72\x4a\x0e\xd1\xe4\xfb\x0d\x96"
+			"\xd1\x0c\x79\x85\x1b\x1c\xfe\xe1"
+			"\x62\x8f\x7a\x73\x32\xab\xc8\x18"
+			"\x69\xe3\x34\x30\xdf\x13\xa6\xe5"
+			"\xe8\x0e\x67\x7f\x81\x11\xb4\x60"
+			"\xc7\xbd\x79\x65\x50\xdc\xc4\x5b"
+			"\xde\x39\xa4\x01\x72\x63\xf3\xd1"
+			"\x64\x4e\xdf\xfc\x27\x92\x37\x0d"
+			"\x57\xcd\x11\x4f\x11\x04\x8e\x1d"
+			"\x16\xf7\xcd\x92\x9a\x99\x30\x14"
+			"\xf1\x7c\x67\x1b\x1f\x41\x0b\xe8"
+			"\x32\xe8\xb8\xc1\x4f\x54\x86\x4f"
+			"\xe5\x79\x81\x73\xcd\x43\x59\x68"
+			"\x73\x02\x3b\x78\x21\x72\x43\x00"
+			"\x49\x17\xf7\x00\xaf\x68\x24\x53"
+			"\x05\x0a\xc3\x33\xe0\x33\x3f\x69"
+			"\xd2\x84\x2f\x0b\xed\xde\x04\xf4"
+			"\x11\x94\x13\x69\x51\x09\x28\xde"
+			"\x57\x5c\xef\xdc\x9a\x49\x1c\x17"
+			"\x97\xf3\x96\xc1\x7f\x5d\x2e\x7d"
+			"\x55\xb8\xb3\x02\x09\xb3\x1f\xe7"
+			"\xc9\x8d\xa3\x36\x34\x8a\x77\x13"
+			"\x30\x63\x4c\xa5\xcd\xc3\xe0\x7e"
+			"\x05\xa1\x7b\x0c\xcb\x74\x47\x31"
+			"\x62\x03\x43\xf1\x87\xb4\xb0\x85"
+			"\x87\x8e\x4b\x25\xc7\xcf\xae\x4b"
+			"\x36\x46\x3e\x62\xbc\x6f\xeb\x5f"
+			"\x73\xac\xe6\x07\xee\xc1\xa1\xd6"
+			"\xc4\xab\xc9\xd6\x89\x45\xe1\xf1"
+			"\x04\x4e\x1a\x6f\xbb\x4f\x3a\xa3"
+			"\xa0\xcb\xa3\x0a\xd8\x71\x35\x55"
+			"\xe4\xbc\x2e\x04\x06\xe6\xff\x5b"
+			"\x1c\xc0\x11\x7c\xc5\x17\xf3\x38"
+			"\xcf\xe9\xba\x0f\x0e\xef\x02\xc2"
+			"\x8d\xc6\xbc\x4b\x67\x20\x95\xd7"
+			"\x2c\x45\x5b\x86\x44\x8c\x6f\x2e"
+			"\x7e\x9f\x1c\x77\xba\x6b\x0e\xa3"
+			"\x69\xdc\xab\x24\x57\x60\x47\xc1"
+			"\xd1\xa5\x9d\x23\xe6\xb1\x37\xfe"
+			"\x93\xd2\x4c\x46\xf9\x0c\xc6\xfb"
+			"\xd6\x9d\x99\x69\xab\x7a\x07\x0c"
+			"\x65\xe7\xc4\x08\x96\xe2\xa5\x01"
+			"\x3f\x46\x07\x05\x7e\xe8\x9a\x90"
+			"\x50\xdc\xe9\x7a\xea\xa1\x39\x6e"
+			"\x66\xe4\x6f\xa5\x5f\xb2\xd9\x5b"
+			"\xf5\xdb\x2a\x32\xf0\x11\x6f\x7c"
+			"\x26\x10\x8f\x3d\x80\xe9\x58\xf7"
+			"\xe0\xa8\x57\xf8\xdb\x0e\xce\x99"
+			"\x63\x19\x3d\xd5\xec\x1b\x77\x69"
+			"\x98\xf6\xe4\x5f\x67\x17\x4b\x09"
+			"\x85\x62\x82\x70\x18\xe2\x9a\x78"
+			"\xe2\x62\xbd\xb4\xf1\x42\xc6\xfb"
+			"\x08\xd0\xbd\xeb\x4e\x09\xf2\xc8"
+			"\x1e\xdc\x3d\x32\x21\x56\x9c\x4f"
+			"\x35\xf3\x61\x06\x72\x84\xc4\x32"
+			"\xf2\xf1\xfa\x0b\x2f\xc3\xdb\x02"
+			"\x04\xc2\xde\x57\x64\x60\x8d\xcf"
+			"\xcb\x86\x5d\x97\x3e\xb1\x9c\x01"
+			"\xd6\x28\x8f\x99\xbc\x46\xeb\x05"
+			"\xaf\x7e\xb8\x21\x2a\x56\x85\x1c"
+			"\xb3\x71\xa0\xde\xca\x96\xf1\x78"
+			"\x49\xa2\x99\x81\x80\x5c\x01\xf5"
+			"\xa0\xa2\x56\x63\xe2\x70\x07\xa5"
+			"\x95\xd6\x85\xeb\x36\x9e\xa9\x51"
+			"\x66\x56\x5f\x1d\x02\x19\xe2\xf6"
+			"\x4f\x73\x38\x09\x75\x64\x48\xe0"
+			"\xf1\x7e\x0e\xe8\x9d\xf9\xed\x94"
+			"\xfe\x16\x26\x62\x49\x74\xf4\xb0"
+			"\xd4\xa9\x6c\xb0\xfd\x53\xe9\x81"
+			"\xe0\x7a\xbf\xcf\xb5\xc4\x01\x81"
+			"\x79\x99\x77\x01\x3b\xe9\xa2\xb6"
+			"\xe6\x6a\x8a\x9e\x56\x1c\x8d\x1e"
+			"\x8f\x06\x55\x2c\x6c\xdc\x92\x87"
+			"\x64\x3b\x4b\x19\xa1\x13\x64\x1d"
+			"\x4a\xe9\xc0\x00\xb8\x95\xef\x6b"
+			"\x1a\x86\x6d\x37\x52\x02\xc2\xe0"
+			"\xc8\xbb\x42\x0c\x02\x21\x4a\xc9"
+			"\xef\xa0\x54\xe4\x5e\x16\x53\x81"
+			"\x70\x62\x10\xaf\xde\xb8\xb5\xd3"
+			"\xe8\x5e\x6c\xc3\x8a\x3e\x18\x07"
+			"\xf2\x2f\x7d\xa7\xe1\x3d\x4e\xb4"
+			"\x26\xa7\xa3\x93\x86\xb2\x04\x1e"
+			"\x53\x5d\x86\xd6\xde\x65\xca\xe3"
+			"\x4e\xc1\xcf\xef\xc8\x70\x1b\x83"
+			"\x13\xdd\x18\x8b\x0d\x76\xd2\xf6"
+			"\x37\x7a\x93\x7a\x50\x11\x9f\x96"
+			"\x86\x25\xfd\xac\xdc\xbe\x18\x93"
+			"\x19\x6b\xec\x58\x4f\xb9\x75\xa7"
+			"\xdd\x3f\x2f\xec\xc8\x5a\x84\xab"
+			"\xd5\xe4\x8a\x07\xf6\x4d\x23\xd6"
+			"\x03\xfb\x03\x6a\xea\x66\xbf\xd4"
+			"\xb1\x34\xfb\x78\xe9\x55\xdc\x7c"
+			"\x3d\x9c\xe5\x9a\xac\xc3\x7a\x80"
+			"\x24\x6d\xa0\xef\x25\x7c\xb7\xea"
+			"\xce\x4d\x5f\x18\x60\xce\x87\x22"
+			"\x66\x2f\xd5\xdd\xdd\x02\x21\x75"
+			"\x82\xa0\x1f\x58\xc6\xd3\x62\xf7"
+			"\x32\xd8\xaf\x1e\x07\x77\x51\x96"
+			"\xd5\x6b\x1e\x7e\x80\x02\xe8\x67"
+			"\xea\x17\x0b\x10\xd2\x3f\x28\x25"
+			"\x4f\x05\x77\x02\x14\x69\xf0\x2c"
+			"\xbe\x0c\xf1\x74\x30\xd1\xb9\x9b"
+			"\xfc\x8c\xbb\x04\x16\xd9\xba\xc3"
+			"\xbc\x91\x8a\xc4\x30\xa4\xb0\x12"
+			"\x4c\x21\x87\xcb\xc9\x1d\x16\x96"
+			"\x07\x6f\x23\x54\xb9\x6f\x79\xe5"
+			"\x64\xc0\x64\xda\xb1\xae\xdd\x60"
+			"\x6c\x1a\x9d\xd3\x04\x8e\x45\xb0"
+			"\x92\x61\xd0\x48\x81\xed\x5e\x1d"
+			"\xa0\xc9\xa4\x33\xc7\x13\x51\x5d"
+			"\x7f\x83\x73\xb6\x70\x18\x65\x3e"
+			"\x2f\x0e\x7a\x12\x39\x98\xab\xd8"
+			"\x7e\x6f\xa3\xd1\xba\x56\xad\xbd"
+			"\xf0\x03\x01\x1c\x85\x35\x9f\xeb"
+			"\x19\x63\xa1\xaf\xfe\x2d\x35\x50"
+			"\x39\xa0\x65\x7c\x95\x7e\x6b\xfe"
+			"\xc1\xac\x07\x7c\x98\x4f\xbe\x57"
+			"\xa7\x22\xec\xe2\x7e\x29\x09\x53"
+			"\xe8\xbf\xb4\x7e\x3f\x8f\xfc\x14"
+			"\xce\x54\xf9\x18\x58\xb5\xff\x44"
+			"\x05\x9d\xce\x1b\xb6\x82\x23\xc8"
+			"\x2e\xbc\x69\xbb\x4a\x29\x0f\x65"
+			"\x94\xf0\x63\x06\x0e\xef\x8c\xbd"
+			"\xff\xfd\xb0\x21\x6e\x57\x05\x75"
+			"\xda\xd5\xc4\xeb\x8d\x32\xf7\x50"
+			"\xd3\x6f\x22\xed\x5f\x8e\xa2\x5b"
+			"\x80\x8c\xc8\x78\x40\x24\x4b\x89"
+			"\x30\xce\x7a\x97\x0e\xc4\xaf\xef"
+			"\x9b\xb4\xcd\x66\x74\x14\x04\x2b"
+			"\xf7\xce\x0b\x1c\x6e\xc2\x78\x8c"
+			"\xca\xc5\xd0\x1c\x95\x4a\x91\x2d"
+			"\xa7\x20\xeb\x86\x52\xb7\x67\xd8"
+			"\x0c\xd6\x04\x14\xde\x51\x74\x75"
+			"\xe7\x11\xb4\x87\xa3\x3d\x2d\xad"
+			"\x4f\xef\xa0\x0f\x70\x00\x6d\x13"
+			"\x19\x1d\x41\x50\xe9\xd8\xf0\x32"
+			"\x71\xbc\xd3\x11\xf2\xac\xbe\xaf"
+			"\x75\x46\x65\x4e\x07\x34\x37\xa3"
+			"\x89\xfe\x75\xd4\x70\x4c\xc6\x3f"
+			"\x69\x24\x0e\x38\x67\x43\x8c\xde"
+			"\x06\xb5\xb8\xe7\xc4\xf0\x41\x8f"
+			"\xf0\xbd\x2f\x0b\xb9\x18\xf8\xde"
+			"\x64\xb1\xdb\xee\x00\x50\x77\xe1"
+			"\xc7\xff\xa6\xfa\xdd\x70\xf4\xe3"
+			"\x93\xe9\x77\x35\x3d\x4b\x2f\x2b"
+			"\x6d\x55\xf0\xfc\x88\x54\x4e\x89"
+			"\xc1\x8a\x23\x31\x2d\x14\x2a\xb8"
+			"\x1b\x15\xdd\x9e\x6e\x7b\xda\x05"
+			"\x91\x7d\x62\x64\x96\x72\xde\xfc"
+			"\xc1\xec\xf0\x23\x51\x6f\xdb\x5b"
+			"\x1d\x08\x57\xce\x09\xb8\xf6\xcd"
+			"\x8d\x95\xf2\x20\xbf\x0f\x20\x57"
+			"\x98\x81\x84\x4f\x15\x5c\x76\xe7"
+			"\x3e\x0a\x3a\x6c\xc4\x8a\xbe\x78"
+			"\x74\x77\xc3\x09\x4b\x5d\x48\xe4"
+			"\xc8\xcb\x0b\xea\x17\x28\xcf\xcf"
+			"\x31\x32\x44\xa4\xe5\x0e\x1a\x98"
+			"\x94\xc4\xf0\xff\xae\x3e\x44\xe8"
+			"\xa5\xb3\xb5\x37\x2f\xe8\xaf\x6f"
+			"\x28\xc1\x37\x5f\x31\xd2\xb9\x33"
+			"\xb1\xb2\x52\x94\x75\x2c\x29\x59"
+			"\x06\xc2\x25\xe8\x71\x65\x4e\xed"
+			"\xc0\x9c\xb1\xbb\x25\xdc\x6c\xe7"
+			"\x4b\xa5\x7a\x54\x7a\x60\xff\x7a"
+			"\xe0\x50\x40\x96\x35\x63\xe4\x0b"
+			"\x76\xbd\xa4\x65\x00\x1b\x57\x88"
+			"\xae\xed\x39\x88\x42\x11\x3c\xed"
+			"\x85\x67\x7d\xb9\x68\x82\xe9\x43"
+			"\x3c\x47\x53\xfa\xe8\xf8\x9f\x1f"
+			"\x9f\xef\x0f\xf7\x30\xd9\x30\x0e"
+			"\xb9\x9f\x69\x18\x2f\x7e\xf8\xf8"
+			"\xf8\x8c\x0f\xd4\x02\x4d\xea\xcd"
+			"\x0a\x9c\x6f\x71\x6d\x5a\x4c\x60"
+			"\xce\x20\x56\x32\xc6\xc5\x99\x1f"
+			"\x09\xe6\x4e\x18\x1a\x15\x13\xa8"
+			"\x7d\xb1\x6b\xc0\xb2\x6d\xf8\x26"
+			"\x66\xf8\x3d\x18\x74\x70\x66\x7a"
+			"\x34\x17\xde\xba\x47\xf1\x06\x18"
+			"\xcb\xaf\xeb\x4a\x1e\x8f\xa7\x77"
+			"\xe0\x3b\x78\x62\x66\xc9\x10\xea"
+			"\x1f\xb7\x29\x0a\x45\xa1\x1d\x1e"
+			"\x1d\xe2\x65\x61\x50\x9c\xd7\x05"
+			"\xf2\x0b\x5b\x12\x61\x02\xc8\xe5"
+			"\x63\x4f\x20\x0c\x07\x17\x33\x5e"
+			"\x03\x9a\x53\x0f\x2e\x55\xfe\x50"
+			"\x43\x7d\xd0\xb6\x7e\x5a\xda\xae"
+			"\x58\xef\x15\xa9\x83\xd9\x46\xb1"
+			"\x42\xaa\xf5\x02\x6c\xce\x92\x06"
+			"\x1b\xdb\x66\x45\x91\x79\xc2\x2d"
+			"\xe6\x53\xd3\x14\xfd\xbb\x44\x63"
+			"\xc6\xd7\x3d\x7a\x0c\x75\x78\x9d"
+			"\x5c\xa6\x39\xb3\xe5\x63\xca\x8b"
+			"\xfe\xd3\xef\x60\x83\xf6\x8e\x70"
+			"\xb6\x67\xc7\x77\xed\x23\xef\x4c"
+			"\xf0\xed\x2d\x07\x59\x6f\xc1\x01"
+			"\x34\x37\x08\xab\xd9\x1f\x09\xb1"
+			"\xce\x5b\x17\xff\x74\xf8\x9c\xd5"
+			"\x2c\x56\x39\x79\x0f\x69\x44\x75"
+			"\x58\x27\x01\xc4\xbf\xa7\xa1\x1d"
+			"\x90\x17\x77\x86\x5a\x3f\xd9\xd1"
+			"\x0e\xa0\x10\xf8\xec\x1e\xa5\x7f"
+			"\x5e\x36\xd1\xe3\x04\x2c\x70\xf7"
+			"\x8e\xc0\x98\x2f\x6c\x94\x2b\x41"
+			"\xb7\x60\x00\xb7\x2e\xb8\x02\x8d"
+			"\xb8\xb0\xd3\x86\xba\x1d\xd7\x90"
+			"\xd6\xb6\xe1\xfc\xd7\xd8\x28\x06"
+			"\x63\x9b\xce\x61\x24\x79\xc0\x70"
+			"\x52\xd0\xb6\xd4\x28\x95\x24\x87"
+			"\x03\x1f\xb7\x9a\xda\xa3\xfb\x52"
+			"\x5b\x68\xe7\x4c\x8c\x24\xe1\x42"
+			"\xf7\xd5\xfd\xad\x06\x32\x9f\xba"
+			"\xc1\xfc\xdd\xc6\xfc\xfc\xb3\x38"
+			"\x74\x56\x58\x40\x02\x37\x52\x2c"
+			"\x55\xcc\xb3\x9e\x7a\xe9\xd4\x38"
+			"\x41\x5e\x0c\x35\xe2\x11\xd1\x13"
+			"\xf8\xb7\x8d\x72\x6b\x22\x2a\xb0"
+			"\xdb\x08\xba\x35\xb9\x3f\xc8\xd3"
+			"\x24\x90\xec\x58\xd2\x09\xc7\x2d"
+			"\xed\x38\x80\x36\x72\x43\x27\x49"
+			"\x4a\x80\x8a\xa2\xe8\xd3\xda\x30"
+			"\x7d\xb6\x82\x37\x86\x92\x86\x3e"
+			"\x08\xb2\x28\x5a\x55\x44\x24\x7d"
+			"\x40\x48\x8a\xb6\x89\x58\x08\xa0"
+			"\xd6\x6d\x3a\x17\xbf\xf6\x54\xa2"
+			"\xf5\xd3\x8c\x0f\x78\x12\x57\x8b"
+			"\xd5\xc2\xfd\x58\x5b\x7f\x38\xe3"
+			"\xcc\xb7\x7c\x48\xb3\x20\xe8\x81"
+			"\x14\x32\x45\x05\xe0\xdb\x9f\x75"
+			"\x85\xb4\x6a\xfc\x95\xe3\x54\x22"
+			"\x12\xee\x30\xfe\xd8\x30\xef\x34"
+			"\x50\xab\x46\x30\x98\x2f\xb7\xc0"
+			"\x15\xa2\x83\xb6\xf2\x06\x21\xa2"
+			"\xc3\x26\x37\x14\xd1\x4d\xb5\x10"
+			"\x52\x76\x4d\x6a\xee\xb5\x2b\x15"
+			"\xb7\xf9\x51\xe8\x2a\xaf\xc7\xfa"
+			"\x77\xaf\xb0\x05\x4d\xd1\x68\x8e"
+			"\x74\x05\x9f\x9d\x93\xa5\x3e\x7f"
+			"\x4e\x5f\x9d\xcb\x09\xc7\x83\xe3"
+			"\x02\x9d\x27\x1f\xef\x85\x05\x8d"
+			"\xec\x55\x88\x0f\x0d\x7c\x4c\xe8"
+			"\xa1\x75\xa0\xd8\x06\x47\x14\xef"
+			"\xaa\x61\xcf\x26\x15\xad\xd8\xa3"
+			"\xaa\x75\xf2\x78\x4a\x5a\x61\xdf"
+			"\x8b\xc7\x04\xbc\xb2\x32\xd2\x7e"
+			"\x42\xee\xb4\x2f\x51\xff\x7b\x2e"
+			"\xd3\x02\xe8\xdc\x5d\x0d\x50\xdc"
+			"\xae\xb7\x46\xf9\xa8\xe6\xd0\x16"
+			"\xcc\xe6\x2c\x81\xc7\xad\xe9\xf0"
+			"\x05\x72\x6d\x3d\x0a\x7a\xa9\x02"
+			"\xac\x82\x93\x6e\xb6\x1c\x28\xfc"
+			"\x44\x12\xfb\x73\x77\xd4\x13\x39"
+			"\x29\x88\x8a\xf3\x5c\xa6\x36\xa0"
+			"\x2a\xed\x7e\xb1\x1d\xd6\x4c\x6b"
+			"\x41\x01\x18\x5d\x5d\x07\x97\xa6"
+			"\x4b\xef\x31\x18\xea\xac\xb1\x84"
+			"\x21\xed\xda\x86",
+		.rlen = 4100,
+	},
+};
+
+static struct cipher_testvec aes_ctr_dec_tv_template[] = {
+	{ /* From RFC 3686 */
+		.key	= "\xae\x68\x52\xf8\x12\x10\x67\xcc"
+			  "\x4b\xf7\xa5\x76\x55\x77\xf3\x9e"
+			  "\x00\x00\x00\x30",
+		.klen	= 20,
+		.iv	= "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.input	= "\xe4\x09\x5d\x4f\xb7\xa7\xb3\x79"
+			  "\x2d\x61\x75\xa3\x26\x13\x11\xb8",
+		.ilen	= 16,
+		.result	= "Single block msg",
+		.rlen	= 16,
+	}, {
+		.key	= "\x7e\x24\x06\x78\x17\xfa\xe0\xd7"
+			  "\x43\xd6\xce\x1f\x32\x53\x91\x63"
+			  "\x00\x6c\xb6\xdb",
+		.klen	= 20,
+		.iv	= "\xc0\x54\x3b\x59\xda\x48\xd9\x0b",
+		.input	= "\x51\x04\xa1\x06\x16\x8a\x72\xd9"
+			  "\x79\x0d\x41\xee\x8e\xda\xd3\x88"
+			  "\xeb\x2e\x1e\xfc\x46\xda\x57\xc8"
+			  "\xfc\xe6\x30\xdf\x91\x41\xbe\x28",
+		.ilen	= 32,
+		.result	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+			  "\x10\x11\x12\x13\x14\x15\x16\x17"
+			  "\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f",
+		.rlen	= 32,
+	}, {
+		.key	= "\x16\xaf\x5b\x14\x5f\xc9\xf5\x79"
+			  "\xc1\x75\xf9\x3e\x3b\xfb\x0e\xed"
+			  "\x86\x3d\x06\xcc\xfd\xb7\x85\x15"
+			  "\x00\x00\x00\x48",
+		.klen	= 28,
+		.iv	= "\x36\x73\x3c\x14\x7d\x6d\x93\xcb",
+		.input	= "\x4b\x55\x38\x4f\xe2\x59\xc9\xc8"
+			  "\x4e\x79\x35\xa0\x03\xcb\xe9\x28",
+		.ilen	= 16,
+		.result	= "Single block msg",
+		.rlen	= 16,
+	}, {
+		.key	= "\x7c\x5c\xb2\x40\x1b\x3d\xc3\x3c"
+			  "\x19\xe7\x34\x08\x19\xe0\xf6\x9c"
+			  "\x67\x8c\x3d\xb8\xe6\xf6\xa9\x1a"
+			  "\x00\x96\xb0\x3b",
+		.klen	= 28,
+		.iv	= "\x02\x0c\x6e\xad\xc2\xcb\x50\x0d",
+		.input	= "\x45\x32\x43\xfc\x60\x9b\x23\x32"
+			  "\x7e\xdf\xaa\xfa\x71\x31\xcd\x9f"
+			  "\x84\x90\x70\x1c\x5a\xd4\xa7\x9c"
+			  "\xfc\x1f\xe0\xff\x42\xf4\xfb\x00",
+		.ilen	= 32,
+		.result	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+			  "\x10\x11\x12\x13\x14\x15\x16\x17"
+			  "\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f",
+		.rlen	= 32,
+	}, { 
+		.key	= "\x77\x6b\xef\xf2\x85\x1d\xb0\x6f"
+			  "\x4c\x8a\x05\x42\xc8\x69\x6f\x6c"
+			  "\x6a\x81\xaf\x1e\xec\x96\xb4\xd3"
+			  "\x7f\xc1\xd6\x89\xe6\xc1\xc1\x04"
+			  "\x00\x00\x00\x60",
+		.klen	= 36,
+		.iv	= "\xdb\x56\x72\xc9\x7a\xa8\xf0\xb2",
+		.input	= "\x14\x5a\xd0\x1d\xbf\x82\x4e\xc7"
+			  "\x56\x08\x63\xdc\x71\xe3\xe0\xc0",
+		.ilen	= 16,
+		.result	= "Single block msg",
+		.rlen	= 16,
+	}, {
+		.key	= "\xf6\xd6\x6d\x6b\xd5\x2d\x59\xbb"
+			  "\x07\x96\x36\x58\x79\xef\xf8\x86"
+			  "\xc6\x6d\xd5\x1a\x5b\x6a\x99\x74"
+			  "\x4b\x50\x59\x0c\x87\xa2\x38\x84"
+			  "\x00\xfa\xac\x24",
+		.klen	= 36,
+		.iv	= "\xc1\x58\x5e\xf1\x5a\x43\xd8\x75",
+		.input	= "\xf0\x5e\x23\x1b\x38\x94\x61\x2c"
+			  "\x49\xee\x00\x0b\x80\x4e\xb2\xa9"
+			  "\xb8\x30\x6b\x50\x8f\x83\x9d\x6a"
+			  "\x55\x30\x83\x1d\x93\x44\xaf\x1c",
+		.ilen	= 32,
+		.result	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+			  "\x10\x11\x12\x13\x14\x15\x16\x17"
+			  "\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f",
+		.rlen	= 32,
+	},
+};
+
+static struct aead_testvec aes_gcm_enc_tv_template[] = {
+	{ /* From McGrew & Viega - http://citeseer.ist.psu.edu/656989.html */
+		.key    = zeroed_string,
+		.klen	= 16,
+		.result	= "\x58\xe2\xfc\xce\xfa\x7e\x30\x61"
+			  "\x36\x7f\x1d\x57\xa4\xe7\x45\x5a",
+		.rlen	= 16,
+	}, {
+		.key    = zeroed_string,
+		.klen	= 16,
+		.input  = zeroed_string,
+		.ilen	= 16,
+		.result = "\x03\x88\xda\xce\x60\xb6\xa3\x92"
+			  "\xf3\x28\xc2\xb9\x71\xb2\xfe\x78"
+			  "\xab\x6e\x47\xd4\x2c\xec\x13\xbd"
+			  "\xf5\x3a\x67\xb2\x12\x57\xbd\xdf",
+		.rlen	= 32,
+	}, {
+		.key	= "\xfe\xff\xe9\x92\x86\x65\x73\x1c"
+			  "\x6d\x6a\x8f\x94\x67\x30\x83\x08",
+		.klen	= 16,
+		.iv	= "\xca\xfe\xba\xbe\xfa\xce\xdb\xad"
+			  "\xde\xca\xf8\x88",
+		.input	= "\xd9\x31\x32\x25\xf8\x84\x06\xe5"
+			  "\xa5\x59\x09\xc5\xaf\xf5\x26\x9a"
+			  "\x86\xa7\xa9\x53\x15\x34\xf7\xda"
+			  "\x2e\x4c\x30\x3d\x8a\x31\x8a\x72"
+			  "\x1c\x3c\x0c\x95\x95\x68\x09\x53"
+			  "\x2f\xcf\x0e\x24\x49\xa6\xb5\x25"
+			  "\xb1\x6a\xed\xf5\xaa\x0d\xe6\x57"
+			  "\xba\x63\x7b\x39\x1a\xaf\xd2\x55",
+		.ilen	= 64,
+		.result = "\x42\x83\x1e\xc2\x21\x77\x74\x24"
+			  "\x4b\x72\x21\xb7\x84\xd0\xd4\x9c"
+			  "\xe3\xaa\x21\x2f\x2c\x02\xa4\xe0"
+			  "\x35\xc1\x7e\x23\x29\xac\xa1\x2e"
+			  "\x21\xd5\x14\xb2\x54\x66\x93\x1c"
+			  "\x7d\x8f\x6a\x5a\xac\x84\xaa\x05"
+			  "\x1b\xa3\x0b\x39\x6a\x0a\xac\x97"
+			  "\x3d\x58\xe0\x91\x47\x3f\x59\x85"
+			  "\x4d\x5c\x2a\xf3\x27\xcd\x64\xa6"
+			  "\x2c\xf3\x5a\xbd\x2b\xa6\xfa\xb4",
+		.rlen	= 80,
+	}, {
+		.key	= "\xfe\xff\xe9\x92\x86\x65\x73\x1c"
+			  "\x6d\x6a\x8f\x94\x67\x30\x83\x08",
+		.klen	= 16,
+		.iv	= "\xca\xfe\xba\xbe\xfa\xce\xdb\xad"
+			  "\xde\xca\xf8\x88",
+		.input	= "\xd9\x31\x32\x25\xf8\x84\x06\xe5"
+			  "\xa5\x59\x09\xc5\xaf\xf5\x26\x9a"
+			  "\x86\xa7\xa9\x53\x15\x34\xf7\xda"
+			  "\x2e\x4c\x30\x3d\x8a\x31\x8a\x72"
+			  "\x1c\x3c\x0c\x95\x95\x68\x09\x53"
+			  "\x2f\xcf\x0e\x24\x49\xa6\xb5\x25"
+			  "\xb1\x6a\xed\xf5\xaa\x0d\xe6\x57"
+			  "\xba\x63\x7b\x39",
+		.ilen	= 60,
+		.assoc	= "\xfe\xed\xfa\xce\xde\xad\xbe\xef"
+			  "\xfe\xed\xfa\xce\xde\xad\xbe\xef"
+			  "\xab\xad\xda\xd2",
+		.alen	= 20,
+		.result = "\x42\x83\x1e\xc2\x21\x77\x74\x24"
+			  "\x4b\x72\x21\xb7\x84\xd0\xd4\x9c"
+			  "\xe3\xaa\x21\x2f\x2c\x02\xa4\xe0"
+			  "\x35\xc1\x7e\x23\x29\xac\xa1\x2e"
+			  "\x21\xd5\x14\xb2\x54\x66\x93\x1c"
+			  "\x7d\x8f\x6a\x5a\xac\x84\xaa\x05"
+			  "\x1b\xa3\x0b\x39\x6a\x0a\xac\x97"
+			  "\x3d\x58\xe0\x91"
+			  "\x5b\xc9\x4f\xbc\x32\x21\xa5\xdb"
+			  "\x94\xfa\xe9\x5a\xe7\x12\x1a\x47",
+		.rlen	= 76,
+	}, {
+		.key    = zeroed_string,
+		.klen	= 24,
+		.result	= "\xcd\x33\xb2\x8a\xc7\x73\xf7\x4b"
+			  "\xa0\x0e\xd1\xf3\x12\x57\x24\x35",
+		.rlen	= 16,
+	}, {
+		.key    = zeroed_string,
+		.klen	= 24,
+		.input  = zeroed_string,
+		.ilen	= 16,
+		.result = "\x98\xe7\x24\x7c\x07\xf0\xfe\x41"
+			  "\x1c\x26\x7e\x43\x84\xb0\xf6\x00"
+			  "\x2f\xf5\x8d\x80\x03\x39\x27\xab"
+			  "\x8e\xf4\xd4\x58\x75\x14\xf0\xfb",
+		.rlen	= 32,
+	}, {
+		.key	= "\xfe\xff\xe9\x92\x86\x65\x73\x1c"
+			  "\x6d\x6a\x8f\x94\x67\x30\x83\x08"
+			  "\xfe\xff\xe9\x92\x86\x65\x73\x1c",
+		.klen	= 24,
+		.iv	= "\xca\xfe\xba\xbe\xfa\xce\xdb\xad"
+			  "\xde\xca\xf8\x88",
+		.input	= "\xd9\x31\x32\x25\xf8\x84\x06\xe5"
+			  "\xa5\x59\x09\xc5\xaf\xf5\x26\x9a"
+			  "\x86\xa7\xa9\x53\x15\x34\xf7\xda"
+			  "\x2e\x4c\x30\x3d\x8a\x31\x8a\x72"
+			  "\x1c\x3c\x0c\x95\x95\x68\x09\x53"
+			  "\x2f\xcf\x0e\x24\x49\xa6\xb5\x25"
+			  "\xb1\x6a\xed\xf5\xaa\x0d\xe6\x57"
+			  "\xba\x63\x7b\x39\x1a\xaf\xd2\x55",
+		.ilen	= 64,
+		.result = "\x39\x80\xca\x0b\x3c\x00\xe8\x41"
+			  "\xeb\x06\xfa\xc4\x87\x2a\x27\x57"
+			  "\x85\x9e\x1c\xea\xa6\xef\xd9\x84"
+			  "\x62\x85\x93\xb4\x0c\xa1\xe1\x9c"
+			  "\x7d\x77\x3d\x00\xc1\x44\xc5\x25"
+			  "\xac\x61\x9d\x18\xc8\x4a\x3f\x47"
+			  "\x18\xe2\x44\x8b\x2f\xe3\x24\xd9"
+			  "\xcc\xda\x27\x10\xac\xad\xe2\x56"
+			  "\x99\x24\xa7\xc8\x58\x73\x36\xbf"
+			  "\xb1\x18\x02\x4d\xb8\x67\x4a\x14",
+		.rlen	= 80,
+	}, {
+		.key	= "\xfe\xff\xe9\x92\x86\x65\x73\x1c"
+			  "\x6d\x6a\x8f\x94\x67\x30\x83\x08"
+			  "\xfe\xff\xe9\x92\x86\x65\x73\x1c",
+		.klen	= 24,
+		.iv	= "\xca\xfe\xba\xbe\xfa\xce\xdb\xad"
+			  "\xde\xca\xf8\x88",
+		.input	= "\xd9\x31\x32\x25\xf8\x84\x06\xe5"
+			  "\xa5\x59\x09\xc5\xaf\xf5\x26\x9a"
+			  "\x86\xa7\xa9\x53\x15\x34\xf7\xda"
+			  "\x2e\x4c\x30\x3d\x8a\x31\x8a\x72"
+			  "\x1c\x3c\x0c\x95\x95\x68\x09\x53"
+			  "\x2f\xcf\x0e\x24\x49\xa6\xb5\x25"
+			  "\xb1\x6a\xed\xf5\xaa\x0d\xe6\x57"
+			  "\xba\x63\x7b\x39",
+		.ilen	= 60,
+		.assoc	= "\xfe\xed\xfa\xce\xde\xad\xbe\xef"
+			  "\xfe\xed\xfa\xce\xde\xad\xbe\xef"
+			  "\xab\xad\xda\xd2",
+		.alen	= 20,
+		.result = "\x39\x80\xca\x0b\x3c\x00\xe8\x41"
+			  "\xeb\x06\xfa\xc4\x87\x2a\x27\x57"
+			  "\x85\x9e\x1c\xea\xa6\xef\xd9\x84"
+			  "\x62\x85\x93\xb4\x0c\xa1\xe1\x9c"
+			  "\x7d\x77\x3d\x00\xc1\x44\xc5\x25"
+			  "\xac\x61\x9d\x18\xc8\x4a\x3f\x47"
+			  "\x18\xe2\x44\x8b\x2f\xe3\x24\xd9"
+			  "\xcc\xda\x27\x10"
+			  "\x25\x19\x49\x8e\x80\xf1\x47\x8f"
+			  "\x37\xba\x55\xbd\x6d\x27\x61\x8c",
+		.rlen	= 76,
+		.np	= 2,
+		.tap	= { 32, 28 },
+		.anp	= 2,
+		.atap	= { 8, 12 }
+	}, {
+		.key    = zeroed_string,
+		.klen	= 32,
+		.result	= "\x53\x0f\x8a\xfb\xc7\x45\x36\xb9"
+			  "\xa9\x63\xb4\xf1\xc4\xcb\x73\x8b",
+		.rlen	= 16,
+	}
+};
+
+static struct aead_testvec aes_gcm_dec_tv_template[] = {
+	{ /* From McGrew & Viega - http://citeseer.ist.psu.edu/656989.html */
+		.key    = zeroed_string,
+		.klen	= 32,
+		.input	= "\xce\xa7\x40\x3d\x4d\x60\x6b\x6e"
+			  "\x07\x4e\xc5\xd3\xba\xf3\x9d\x18"
+			  "\xd0\xd1\xc8\xa7\x99\x99\x6b\xf0"
+			  "\x26\x5b\x98\xb5\xd4\x8a\xb9\x19",
+		.ilen	= 32,
+		.result  = zeroed_string,
+		.rlen	= 16,
+	}, {
+		.key	= "\xfe\xff\xe9\x92\x86\x65\x73\x1c"
+			  "\x6d\x6a\x8f\x94\x67\x30\x83\x08"
+			  "\xfe\xff\xe9\x92\x86\x65\x73\x1c"
+			  "\x6d\x6a\x8f\x94\x67\x30\x83\x08",
+		.klen	= 32,
+		.iv	= "\xca\xfe\xba\xbe\xfa\xce\xdb\xad"
+			  "\xde\xca\xf8\x88",
+		.input	= "\x52\x2d\xc1\xf0\x99\x56\x7d\x07"
+			  "\xf4\x7f\x37\xa3\x2a\x84\x42\x7d"
+			  "\x64\x3a\x8c\xdc\xbf\xe5\xc0\xc9"
+			  "\x75\x98\xa2\xbd\x25\x55\xd1\xaa"
+			  "\x8c\xb0\x8e\x48\x59\x0d\xbb\x3d"
+			  "\xa7\xb0\x8b\x10\x56\x82\x88\x38"
+			  "\xc5\xf6\x1e\x63\x93\xba\x7a\x0a"
+			  "\xbc\xc9\xf6\x62\x89\x80\x15\xad"
+			  "\xb0\x94\xda\xc5\xd9\x34\x71\xbd"
+			  "\xec\x1a\x50\x22\x70\xe3\xcc\x6c",
+		.ilen	= 80,
+		.result = "\xd9\x31\x32\x25\xf8\x84\x06\xe5"
+			  "\xa5\x59\x09\xc5\xaf\xf5\x26\x9a"
+			  "\x86\xa7\xa9\x53\x15\x34\xf7\xda"
+			  "\x2e\x4c\x30\x3d\x8a\x31\x8a\x72"
+			  "\x1c\x3c\x0c\x95\x95\x68\x09\x53"
+			  "\x2f\xcf\x0e\x24\x49\xa6\xb5\x25"
+			  "\xb1\x6a\xed\xf5\xaa\x0d\xe6\x57"
+			  "\xba\x63\x7b\x39\x1a\xaf\xd2\x55",
+		.rlen	= 64,
+	}, {
+		.key	= "\xfe\xff\xe9\x92\x86\x65\x73\x1c"
+			  "\x6d\x6a\x8f\x94\x67\x30\x83\x08"
+			  "\xfe\xff\xe9\x92\x86\x65\x73\x1c"
+			  "\x6d\x6a\x8f\x94\x67\x30\x83\x08",
+		.klen	= 32,
+		.iv	= "\xca\xfe\xba\xbe\xfa\xce\xdb\xad"
+			  "\xde\xca\xf8\x88",
+		.input	= "\x52\x2d\xc1\xf0\x99\x56\x7d\x07"
+			  "\xf4\x7f\x37\xa3\x2a\x84\x42\x7d"
+			  "\x64\x3a\x8c\xdc\xbf\xe5\xc0\xc9"
+			  "\x75\x98\xa2\xbd\x25\x55\xd1\xaa"
+			  "\x8c\xb0\x8e\x48\x59\x0d\xbb\x3d"
+			  "\xa7\xb0\x8b\x10\x56\x82\x88\x38"
+			  "\xc5\xf6\x1e\x63\x93\xba\x7a\x0a"
+			  "\xbc\xc9\xf6\x62"
+			  "\x76\xfc\x6e\xce\x0f\x4e\x17\x68"
+			  "\xcd\xdf\x88\x53\xbb\x2d\x55\x1b",
+		.ilen	= 76,
+		.assoc	= "\xfe\xed\xfa\xce\xde\xad\xbe\xef"
+			  "\xfe\xed\xfa\xce\xde\xad\xbe\xef"
+			  "\xab\xad\xda\xd2",
+		.alen	= 20,
+		.result = "\xd9\x31\x32\x25\xf8\x84\x06\xe5"
+			  "\xa5\x59\x09\xc5\xaf\xf5\x26\x9a"
+			  "\x86\xa7\xa9\x53\x15\x34\xf7\xda"
+			  "\x2e\x4c\x30\x3d\x8a\x31\x8a\x72"
+			  "\x1c\x3c\x0c\x95\x95\x68\x09\x53"
+			  "\x2f\xcf\x0e\x24\x49\xa6\xb5\x25"
+			  "\xb1\x6a\xed\xf5\xaa\x0d\xe6\x57"
+			  "\xba\x63\x7b\x39",
+		.rlen	= 60,
+		.np     = 2,
+		.tap    = { 48, 28 },
+		.anp	= 3,
+		.atap	= { 8, 8, 4 }
+	}, {
+		.key	= "\xfe\xff\xe9\x92\x86\x65\x73\x1c"
+			  "\x6d\x6a\x8f\x94\x67\x30\x83\x08",
+		.klen	= 16,
+		.iv	= "\xca\xfe\xba\xbe\xfa\xce\xdb\xad"
+			  "\xde\xca\xf8\x88",
+		.input	= "\x42\x83\x1e\xc2\x21\x77\x74\x24"
+			  "\x4b\x72\x21\xb7\x84\xd0\xd4\x9c"
+			  "\xe3\xaa\x21\x2f\x2c\x02\xa4\xe0"
+			  "\x35\xc1\x7e\x23\x29\xac\xa1\x2e"
+			  "\x21\xd5\x14\xb2\x54\x66\x93\x1c"
+			  "\x7d\x8f\x6a\x5a\xac\x84\xaa\x05"
+			  "\x1b\xa3\x0b\x39\x6a\x0a\xac\x97"
+			  "\x3d\x58\xe0\x91\x47\x3f\x59\x85"
+			  "\x4d\x5c\x2a\xf3\x27\xcd\x64\xa6"
+			  "\x2c\xf3\x5a\xbd\x2b\xa6\xfa\xb4",
+		.ilen	= 80,
+		.result = "\xd9\x31\x32\x25\xf8\x84\x06\xe5"
+			  "\xa5\x59\x09\xc5\xaf\xf5\x26\x9a"
+			  "\x86\xa7\xa9\x53\x15\x34\xf7\xda"
+			  "\x2e\x4c\x30\x3d\x8a\x31\x8a\x72"
+			  "\x1c\x3c\x0c\x95\x95\x68\x09\x53"
+			  "\x2f\xcf\x0e\x24\x49\xa6\xb5\x25"
+			  "\xb1\x6a\xed\xf5\xaa\x0d\xe6\x57"
+			  "\xba\x63\x7b\x39\x1a\xaf\xd2\x55",
+		.rlen	= 64,
+	}, {
+		.key	= "\xfe\xff\xe9\x92\x86\x65\x73\x1c"
+			  "\x6d\x6a\x8f\x94\x67\x30\x83\x08",
+		.klen	= 16,
+		.iv	= "\xca\xfe\xba\xbe\xfa\xce\xdb\xad"
+			  "\xde\xca\xf8\x88",
+		.input	= "\x42\x83\x1e\xc2\x21\x77\x74\x24"
+			  "\x4b\x72\x21\xb7\x84\xd0\xd4\x9c"
+			  "\xe3\xaa\x21\x2f\x2c\x02\xa4\xe0"
+			  "\x35\xc1\x7e\x23\x29\xac\xa1\x2e"
+			  "\x21\xd5\x14\xb2\x54\x66\x93\x1c"
+			  "\x7d\x8f\x6a\x5a\xac\x84\xaa\x05"
+			  "\x1b\xa3\x0b\x39\x6a\x0a\xac\x97"
+			  "\x3d\x58\xe0\x91"
+			  "\x5b\xc9\x4f\xbc\x32\x21\xa5\xdb"
+			  "\x94\xfa\xe9\x5a\xe7\x12\x1a\x47",
+		.ilen	= 76,
+		.assoc	= "\xfe\xed\xfa\xce\xde\xad\xbe\xef"
+			  "\xfe\xed\xfa\xce\xde\xad\xbe\xef"
+			  "\xab\xad\xda\xd2",
+		.alen	= 20,
+		.result = "\xd9\x31\x32\x25\xf8\x84\x06\xe5"
+			  "\xa5\x59\x09\xc5\xaf\xf5\x26\x9a"
+			  "\x86\xa7\xa9\x53\x15\x34\xf7\xda"
+			  "\x2e\x4c\x30\x3d\x8a\x31\x8a\x72"
+			  "\x1c\x3c\x0c\x95\x95\x68\x09\x53"
+			  "\x2f\xcf\x0e\x24\x49\xa6\xb5\x25"
+			  "\xb1\x6a\xed\xf5\xaa\x0d\xe6\x57"
+			  "\xba\x63\x7b\x39",
+		.rlen	= 60,
+	}, {
+		.key    = zeroed_string,
+		.klen	= 24,
+		.input	= "\x98\xe7\x24\x7c\x07\xf0\xfe\x41"
+			  "\x1c\x26\x7e\x43\x84\xb0\xf6\x00"
+			  "\x2f\xf5\x8d\x80\x03\x39\x27\xab"
+			  "\x8e\xf4\xd4\x58\x75\x14\xf0\xfb",
+		.ilen	= 32,
+		.result  = zeroed_string,
+		.rlen	= 16,
+	}, {
+		.key	= "\xfe\xff\xe9\x92\x86\x65\x73\x1c"
+			  "\x6d\x6a\x8f\x94\x67\x30\x83\x08"
+			  "\xfe\xff\xe9\x92\x86\x65\x73\x1c",
+		.klen	= 24,
+		.iv	= "\xca\xfe\xba\xbe\xfa\xce\xdb\xad"
+			  "\xde\xca\xf8\x88",
+		.input	= "\x39\x80\xca\x0b\x3c\x00\xe8\x41"
+			  "\xeb\x06\xfa\xc4\x87\x2a\x27\x57"
+			  "\x85\x9e\x1c\xea\xa6\xef\xd9\x84"
+			  "\x62\x85\x93\xb4\x0c\xa1\xe1\x9c"
+			  "\x7d\x77\x3d\x00\xc1\x44\xc5\x25"
+			  "\xac\x61\x9d\x18\xc8\x4a\x3f\x47"
+			  "\x18\xe2\x44\x8b\x2f\xe3\x24\xd9"
+			  "\xcc\xda\x27\x10\xac\xad\xe2\x56"
+			  "\x99\x24\xa7\xc8\x58\x73\x36\xbf"
+			  "\xb1\x18\x02\x4d\xb8\x67\x4a\x14",
+		.ilen	= 80,
+		.result = "\xd9\x31\x32\x25\xf8\x84\x06\xe5"
+			  "\xa5\x59\x09\xc5\xaf\xf5\x26\x9a"
+			  "\x86\xa7\xa9\x53\x15\x34\xf7\xda"
+			  "\x2e\x4c\x30\x3d\x8a\x31\x8a\x72"
+			  "\x1c\x3c\x0c\x95\x95\x68\x09\x53"
+			  "\x2f\xcf\x0e\x24\x49\xa6\xb5\x25"
+			  "\xb1\x6a\xed\xf5\xaa\x0d\xe6\x57"
+			  "\xba\x63\x7b\x39\x1a\xaf\xd2\x55",
+		.rlen	= 64,
+	}, {
+		.key	= "\xfe\xff\xe9\x92\x86\x65\x73\x1c"
+			  "\x6d\x6a\x8f\x94\x67\x30\x83\x08"
+			  "\xfe\xff\xe9\x92\x86\x65\x73\x1c",
+		.klen	= 24,
+		.iv	= "\xca\xfe\xba\xbe\xfa\xce\xdb\xad"
+			  "\xde\xca\xf8\x88",
+		.input	= "\x39\x80\xca\x0b\x3c\x00\xe8\x41"
+			  "\xeb\x06\xfa\xc4\x87\x2a\x27\x57"
+			  "\x85\x9e\x1c\xea\xa6\xef\xd9\x84"
+			  "\x62\x85\x93\xb4\x0c\xa1\xe1\x9c"
+			  "\x7d\x77\x3d\x00\xc1\x44\xc5\x25"
+			  "\xac\x61\x9d\x18\xc8\x4a\x3f\x47"
+			  "\x18\xe2\x44\x8b\x2f\xe3\x24\xd9"
+			  "\xcc\xda\x27\x10"
+			  "\x25\x19\x49\x8e\x80\xf1\x47\x8f"
+			  "\x37\xba\x55\xbd\x6d\x27\x61\x8c",
+		.ilen	= 76,
+		.assoc	= "\xfe\xed\xfa\xce\xde\xad\xbe\xef"
+			  "\xfe\xed\xfa\xce\xde\xad\xbe\xef"
+			  "\xab\xad\xda\xd2",
+		.alen	= 20,
+		.result = "\xd9\x31\x32\x25\xf8\x84\x06\xe5"
+			  "\xa5\x59\x09\xc5\xaf\xf5\x26\x9a"
+			  "\x86\xa7\xa9\x53\x15\x34\xf7\xda"
+			  "\x2e\x4c\x30\x3d\x8a\x31\x8a\x72"
+			  "\x1c\x3c\x0c\x95\x95\x68\x09\x53"
+			  "\x2f\xcf\x0e\x24\x49\xa6\xb5\x25"
+			  "\xb1\x6a\xed\xf5\xaa\x0d\xe6\x57"
+			  "\xba\x63\x7b\x39",
+		.rlen	= 60,
+	}
+};
+
+static struct aead_testvec aes_ccm_enc_tv_template[] = {
+	{ /* From RFC 3610 */
+		.key	= "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7"
+			  "\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf",
+		.klen	= 16,
+		.iv	= "\x01\x00\x00\x00\x03\x02\x01\x00"
+			  "\xa0\xa1\xa2\xa3\xa4\xa5\x00\x00",
+		.assoc	= "\x00\x01\x02\x03\x04\x05\x06\x07",
+		.alen	= 8,
+		.input	= "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+			  "\x10\x11\x12\x13\x14\x15\x16\x17"
+			  "\x18\x19\x1a\x1b\x1c\x1d\x1e",
+		.ilen	= 23,
+		.result	= "\x58\x8c\x97\x9a\x61\xc6\x63\xd2"
+			  "\xf0\x66\xd0\xc2\xc0\xf9\x89\x80"
+			  "\x6d\x5f\x6b\x61\xda\xc3\x84\x17"
+			  "\xe8\xd1\x2c\xfd\xf9\x26\xe0",
+		.rlen	= 31,
+	}, {
+		.key	= "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7"
+			  "\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf",
+		.klen	= 16,
+		.iv	= "\x01\x00\x00\x00\x07\x06\x05\x04"
+			  "\xa0\xa1\xa2\xa3\xa4\xa5\x00\x00",
+		.assoc	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b",
+		.alen	= 12,
+		.input	= "\x0c\x0d\x0e\x0f\x10\x11\x12\x13"
+			  "\x14\x15\x16\x17\x18\x19\x1a\x1b"
+			  "\x1c\x1d\x1e\x1f",
+		.ilen	= 20,
+		.result	= "\xdc\xf1\xfb\x7b\x5d\x9e\x23\xfb"
+			  "\x9d\x4e\x13\x12\x53\x65\x8a\xd8"
+			  "\x6e\xbd\xca\x3e\x51\xe8\x3f\x07"
+			  "\x7d\x9c\x2d\x93",
+		.rlen	= 28,
+	}, {
+		.key	= "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7"
+			  "\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf",
+		.klen	= 16,
+		.iv	= "\x01\x00\x00\x00\x0b\x0a\x09\x08"
+			  "\xa0\xa1\xa2\xa3\xa4\xa5\x00\x00",
+		.assoc	= "\x00\x01\x02\x03\x04\x05\x06\x07",
+		.alen	= 8,
+		.input	= "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+			  "\x10\x11\x12\x13\x14\x15\x16\x17"
+			  "\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
+			  "\x20",
+		.ilen	= 25,
+		.result	= "\x82\x53\x1a\x60\xcc\x24\x94\x5a"
+			  "\x4b\x82\x79\x18\x1a\xb5\xc8\x4d"
+			  "\xf2\x1c\xe7\xf9\xb7\x3f\x42\xe1"
+			  "\x97\xea\x9c\x07\xe5\x6b\x5e\xb1"
+			  "\x7e\x5f\x4e",
+		.rlen	= 35,
+	}, {
+		.key	= "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7"
+			  "\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf",
+		.klen	= 16,
+		.iv	= "\x01\x00\x00\x00\x0c\x0b\x0a\x09"
+			  "\xa0\xa1\xa2\xa3\xa4\xa5\x00\x00",
+		.assoc	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b",
+		.alen	= 12,
+		.input	= "\x0c\x0d\x0e\x0f\x10\x11\x12\x13"
+			  "\x14\x15\x16\x17\x18\x19\x1a\x1b"
+			  "\x1c\x1d\x1e",
+		.ilen	= 19,
+		.result	= "\x07\x34\x25\x94\x15\x77\x85\x15"
+			  "\x2b\x07\x40\x98\x33\x0a\xbb\x14"
+			  "\x1b\x94\x7b\x56\x6a\xa9\x40\x6b"
+			  "\x4d\x99\x99\x88\xdd",
+		.rlen	= 29,
+	}, {
+		.key	= "\xd7\x82\x8d\x13\xb2\xb0\xbd\xc3"
+			  "\x25\xa7\x62\x36\xdf\x93\xcc\x6b",
+		.klen	= 16,
+		.iv	= "\x01\x00\x33\x56\x8e\xf7\xb2\x63"
+			  "\x3c\x96\x96\x76\x6c\xfa\x00\x00",
+		.assoc	= "\x63\x01\x8f\x76\xdc\x8a\x1b\xcb",
+		.alen	= 8,
+		.input	= "\x90\x20\xea\x6f\x91\xbd\xd8\x5a"
+			  "\xfa\x00\x39\xba\x4b\xaf\xf9\xbf"
+			  "\xb7\x9c\x70\x28\x94\x9c\xd0\xec",
+		.ilen	= 24,
+		.result	= "\x4c\xcb\x1e\x7c\xa9\x81\xbe\xfa"
+			  "\xa0\x72\x6c\x55\xd3\x78\x06\x12"
+			  "\x98\xc8\x5c\x92\x81\x4a\xbc\x33"
+			  "\xc5\x2e\xe8\x1d\x7d\x77\xc0\x8a",
+		.rlen	= 32,
+	}, {
+		.key	= "\xd7\x82\x8d\x13\xb2\xb0\xbd\xc3"
+			  "\x25\xa7\x62\x36\xdf\x93\xcc\x6b",
+		.klen	= 16,
+		.iv	= "\x01\x00\xd5\x60\x91\x2d\x3f\x70"
+			  "\x3c\x96\x96\x76\x6c\xfa\x00\x00",
+		.assoc	= "\xcd\x90\x44\xd2\xb7\x1f\xdb\x81"
+			  "\x20\xea\x60\xc0",
+		.alen	= 12,
+		.input	= "\x64\x35\xac\xba\xfb\x11\xa8\x2e"
+			  "\x2f\x07\x1d\x7c\xa4\xa5\xeb\xd9"
+			  "\x3a\x80\x3b\xa8\x7f",
+		.ilen	= 21,
+		.result	= "\x00\x97\x69\xec\xab\xdf\x48\x62"
+			  "\x55\x94\xc5\x92\x51\xe6\x03\x57"
+			  "\x22\x67\x5e\x04\xc8\x47\x09\x9e"
+			  "\x5a\xe0\x70\x45\x51",
+		.rlen	= 29,
+	}, {
+		.key	= "\xd7\x82\x8d\x13\xb2\xb0\xbd\xc3"
+			  "\x25\xa7\x62\x36\xdf\x93\xcc\x6b",
+		.klen	= 16,
+		.iv	= "\x01\x00\x42\xff\xf8\xf1\x95\x1c"
+			  "\x3c\x96\x96\x76\x6c\xfa\x00\x00",
+		.assoc	= "\xd8\x5b\xc7\xe6\x9f\x94\x4f\xb8",
+		.alen	= 8,
+		.input	= "\x8a\x19\xb9\x50\xbc\xf7\x1a\x01"
+			  "\x8e\x5e\x67\x01\xc9\x17\x87\x65"
+			  "\x98\x09\xd6\x7d\xbe\xdd\x18",
+		.ilen	= 23,
+		.result	= "\xbc\x21\x8d\xaa\x94\x74\x27\xb6"
+			  "\xdb\x38\x6a\x99\xac\x1a\xef\x23"
+			  "\xad\xe0\xb5\x29\x39\xcb\x6a\x63"
+			  "\x7c\xf9\xbe\xc2\x40\x88\x97\xc6"
+			  "\xba",
+		.rlen	= 33,
+	},
+};
+
+static struct aead_testvec aes_ccm_dec_tv_template[] = {
+	{ /* From RFC 3610 */
+		.key	= "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7"
+			  "\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf",
+		.klen	= 16,
+		.iv	= "\x01\x00\x00\x00\x03\x02\x01\x00"
+			  "\xa0\xa1\xa2\xa3\xa4\xa5\x00\x00",
+		.assoc	= "\x00\x01\x02\x03\x04\x05\x06\x07",
+		.alen	= 8,
+		.input	= "\x58\x8c\x97\x9a\x61\xc6\x63\xd2"
+			  "\xf0\x66\xd0\xc2\xc0\xf9\x89\x80"
+			  "\x6d\x5f\x6b\x61\xda\xc3\x84\x17"
+			  "\xe8\xd1\x2c\xfd\xf9\x26\xe0",
+		.ilen	= 31,
+		.result	= "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+			  "\x10\x11\x12\x13\x14\x15\x16\x17"
+			  "\x18\x19\x1a\x1b\x1c\x1d\x1e",
+		.rlen	= 23,
+	}, {
+		.key	= "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7"
+			  "\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf",
+		.klen	= 16,
+		.iv	= "\x01\x00\x00\x00\x07\x06\x05\x04"
+			  "\xa0\xa1\xa2\xa3\xa4\xa5\x00\x00",
+		.assoc	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b",
+		.alen	= 12,
+		.input	= "\xdc\xf1\xfb\x7b\x5d\x9e\x23\xfb"
+			  "\x9d\x4e\x13\x12\x53\x65\x8a\xd8"
+			  "\x6e\xbd\xca\x3e\x51\xe8\x3f\x07"
+			  "\x7d\x9c\x2d\x93",
+		.ilen	= 28,
+		.result	= "\x0c\x0d\x0e\x0f\x10\x11\x12\x13"
+			  "\x14\x15\x16\x17\x18\x19\x1a\x1b"
+			  "\x1c\x1d\x1e\x1f",
+		.rlen	= 20,
+	}, {
+		.key	= "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7"
+			  "\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf",
+		.klen	= 16,
+		.iv	= "\x01\x00\x00\x00\x0b\x0a\x09\x08"
+			  "\xa0\xa1\xa2\xa3\xa4\xa5\x00\x00",
+		.assoc	= "\x00\x01\x02\x03\x04\x05\x06\x07",
+		.alen	= 8,
+		.input	= "\x82\x53\x1a\x60\xcc\x24\x94\x5a"
+			  "\x4b\x82\x79\x18\x1a\xb5\xc8\x4d"
+			  "\xf2\x1c\xe7\xf9\xb7\x3f\x42\xe1"
+			  "\x97\xea\x9c\x07\xe5\x6b\x5e\xb1"
+			  "\x7e\x5f\x4e",
+		.ilen	= 35,
+		.result	= "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+			  "\x10\x11\x12\x13\x14\x15\x16\x17"
+			  "\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
+			  "\x20",
+		.rlen	= 25,
+	}, {
+		.key	= "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7"
+			  "\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf",
+		.klen	= 16,
+		.iv	= "\x01\x00\x00\x00\x0c\x0b\x0a\x09"
+			  "\xa0\xa1\xa2\xa3\xa4\xa5\x00\x00",
+		.assoc	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b",
+		.alen	= 12,
+		.input	= "\x07\x34\x25\x94\x15\x77\x85\x15"
+			  "\x2b\x07\x40\x98\x33\x0a\xbb\x14"
+			  "\x1b\x94\x7b\x56\x6a\xa9\x40\x6b"
+			  "\x4d\x99\x99\x88\xdd",
+		.ilen	= 29,
+		.result	= "\x0c\x0d\x0e\x0f\x10\x11\x12\x13"
+			  "\x14\x15\x16\x17\x18\x19\x1a\x1b"
+			  "\x1c\x1d\x1e",
+		.rlen	= 19,
+	}, {
+		.key	= "\xd7\x82\x8d\x13\xb2\xb0\xbd\xc3"
+			  "\x25\xa7\x62\x36\xdf\x93\xcc\x6b",
+		.klen	= 16,
+		.iv	= "\x01\x00\x33\x56\x8e\xf7\xb2\x63"
+			  "\x3c\x96\x96\x76\x6c\xfa\x00\x00",
+		.assoc	= "\x63\x01\x8f\x76\xdc\x8a\x1b\xcb",
+		.alen	= 8,
+		.input	= "\x4c\xcb\x1e\x7c\xa9\x81\xbe\xfa"
+			  "\xa0\x72\x6c\x55\xd3\x78\x06\x12"
+			  "\x98\xc8\x5c\x92\x81\x4a\xbc\x33"
+			  "\xc5\x2e\xe8\x1d\x7d\x77\xc0\x8a",
+		.ilen	= 32,
+		.result	= "\x90\x20\xea\x6f\x91\xbd\xd8\x5a"
+			  "\xfa\x00\x39\xba\x4b\xaf\xf9\xbf"
+			  "\xb7\x9c\x70\x28\x94\x9c\xd0\xec",
+		.rlen	= 24,
+	}, {
+		.key	= "\xd7\x82\x8d\x13\xb2\xb0\xbd\xc3"
+			  "\x25\xa7\x62\x36\xdf\x93\xcc\x6b",
+		.klen	= 16,
+		.iv	= "\x01\x00\xd5\x60\x91\x2d\x3f\x70"
+			  "\x3c\x96\x96\x76\x6c\xfa\x00\x00",
+		.assoc	= "\xcd\x90\x44\xd2\xb7\x1f\xdb\x81"
+			  "\x20\xea\x60\xc0",
+		.alen	= 12,
+		.input	= "\x00\x97\x69\xec\xab\xdf\x48\x62"
+			  "\x55\x94\xc5\x92\x51\xe6\x03\x57"
+			  "\x22\x67\x5e\x04\xc8\x47\x09\x9e"
+			  "\x5a\xe0\x70\x45\x51",
+		.ilen	= 29,
+		.result	= "\x64\x35\xac\xba\xfb\x11\xa8\x2e"
+			  "\x2f\x07\x1d\x7c\xa4\xa5\xeb\xd9"
+			  "\x3a\x80\x3b\xa8\x7f",
+		.rlen	= 21,
+	}, {
+		.key	= "\xd7\x82\x8d\x13\xb2\xb0\xbd\xc3"
+			  "\x25\xa7\x62\x36\xdf\x93\xcc\x6b",
+		.klen	= 16,
+		.iv	= "\x01\x00\x42\xff\xf8\xf1\x95\x1c"
+			  "\x3c\x96\x96\x76\x6c\xfa\x00\x00",
+		.assoc	= "\xd8\x5b\xc7\xe6\x9f\x94\x4f\xb8",
+		.alen	= 8,
+		.input	= "\xbc\x21\x8d\xaa\x94\x74\x27\xb6"
+			  "\xdb\x38\x6a\x99\xac\x1a\xef\x23"
+			  "\xad\xe0\xb5\x29\x39\xcb\x6a\x63"
+			  "\x7c\xf9\xbe\xc2\x40\x88\x97\xc6"
+			  "\xba",
+		.ilen	= 33,
+		.result	= "\x8a\x19\xb9\x50\xbc\xf7\x1a\x01"
+			  "\x8e\x5e\x67\x01\xc9\x17\x87\x65"
+			  "\x98\x09\xd6\x7d\xbe\xdd\x18",
+		.rlen	= 23,
+	},
+};
+
+/* Cast5 test vectors from RFC 2144 */
+#define CAST5_ENC_TEST_VECTORS	3
+#define CAST5_DEC_TEST_VECTORS	3
+
+static struct cipher_testvec cast5_enc_tv_template[] = {
+	{
+		.key	= "\x01\x23\x45\x67\x12\x34\x56\x78"
+			  "\x23\x45\x67\x89\x34\x56\x78\x9a",
+		.klen	= 16,
+		.input	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.ilen	= 8,
+		.result	= "\x23\x8b\x4f\xe5\x84\x7e\x44\xb2",
+		.rlen	= 8,
+	}, {
+		.key	= "\x01\x23\x45\x67\x12\x34\x56\x78"
+			  "\x23\x45",
+		.klen	= 10,
+		.input	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.ilen	= 8,
+		.result	= "\xeb\x6a\x71\x1a\x2c\x02\x27\x1b",
+		.rlen	= 8,
+	}, {
+		.key	= "\x01\x23\x45\x67\x12",
+		.klen	= 5,
+		.input	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.ilen	= 8,
+		.result	= "\x7a\xc8\x16\xd1\x6e\x9b\x30\x2e",
+		.rlen	= 8,
+	},
+};
+
+static struct cipher_testvec cast5_dec_tv_template[] = {
+	{
+		.key	= "\x01\x23\x45\x67\x12\x34\x56\x78"
+			  "\x23\x45\x67\x89\x34\x56\x78\x9a",
+		.klen	= 16,
+		.input	= "\x23\x8b\x4f\xe5\x84\x7e\x44\xb2",
+		.ilen	= 8,
+		.result	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.rlen	= 8,
+	}, {
+		.key	= "\x01\x23\x45\x67\x12\x34\x56\x78"
+			  "\x23\x45",
+		.klen	= 10,
+		.input	= "\xeb\x6a\x71\x1a\x2c\x02\x27\x1b",
+		.ilen	= 8,
+		.result	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.rlen	= 8,
+	}, {
+		.key	= "\x01\x23\x45\x67\x12",
+		.klen	= 5,
+		.input	= "\x7a\xc8\x16\xd1\x6e\x9b\x30\x2e",
+		.ilen	= 8,
+		.result	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.rlen	= 8,
+	},
+};
+
+/*
+ * ARC4 test vectors from OpenSSL
+ */
+#define ARC4_ENC_TEST_VECTORS	7
+#define ARC4_DEC_TEST_VECTORS	7
+
+static struct cipher_testvec arc4_enc_tv_template[] = {
+	{
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.klen	= 8,
+		.input	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.ilen	= 8,
+		.result	= "\x75\xb7\x87\x80\x99\xe0\xc5\x96",
+		.rlen	= 8,
+	}, {
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.klen	= 8,
+		.input	= "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.ilen	= 8,
+		.result	= "\x74\x94\xc2\xe7\x10\x4b\x08\x79",
+		.rlen	= 8,
+	}, {
+		.key	= "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.klen	= 8,
+		.input	= "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.ilen	= 8,
+		.result	= "\xde\x18\x89\x41\xa3\x37\x5d\x3a",
+		.rlen	= 8,
+	}, {
+		.key	= "\xef\x01\x23\x45",
+		.klen	= 4,
+		.input	= "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00",
+		.ilen	= 20,
+		.result	= "\xd6\xa1\x41\xa7\xec\x3c\x38\xdf"
+			  "\xbd\x61\x5a\x11\x62\xe1\xc7\xba"
+			  "\x36\xb6\x78\x58",
+		.rlen	= 20,
+	}, {
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.klen	= 8,
+		.input	= "\x12\x34\x56\x78\x9A\xBC\xDE\xF0"
+			  "\x12\x34\x56\x78\x9A\xBC\xDE\xF0"
+			  "\x12\x34\x56\x78\x9A\xBC\xDE\xF0"
+			  "\x12\x34\x56\x78",
+		.ilen	= 28,
+		.result	= "\x66\xa0\x94\x9f\x8a\xf7\xd6\x89"
+			  "\x1f\x7f\x83\x2b\xa8\x33\xc0\x0c"
+			  "\x89\x2e\xbe\x30\x14\x3c\xe2\x87"
+			  "\x40\x01\x1e\xcf",
+		.rlen	= 28,
+	}, {
+		.key	= "\xef\x01\x23\x45",
+		.klen	= 4,
+		.input	= "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00",
+		.ilen	= 10,
+		.result	= "\xd6\xa1\x41\xa7\xec\x3c\x38\xdf"
+			  "\xbd\x61",
+		.rlen	= 10,
+	}, {
+		.key	= "\x01\x23\x45\x67\x89\xAB\xCD\xEF"
+			"\x00\x00\x00\x00\x00\x00\x00\x00",
+		.klen	= 16,
+		.input	= "\x01\x23\x45\x67\x89\xAB\xCD\xEF",
+		.ilen	= 8,
+		.result	= "\x69\x72\x36\x59\x1B\x52\x42\xB1",
+		.rlen	= 8,
+	},
+};
+
+static struct cipher_testvec arc4_dec_tv_template[] = {
+	{
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.klen	= 8,
+		.input	= "\x75\xb7\x87\x80\x99\xe0\xc5\x96",
+		.ilen	= 8,
+		.result	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.rlen	= 8,
+	}, {
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.klen	= 8,
+		.input	= "\x74\x94\xc2\xe7\x10\x4b\x08\x79",
+		.ilen	= 8,
+		.result	= "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.rlen	= 8,
+	}, {
+		.key	= "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.klen	= 8,
+		.input	= "\xde\x18\x89\x41\xa3\x37\x5d\x3a",
+		.ilen	= 8,
+		.result	= "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.rlen	= 8,
+	}, {
+		.key	= "\xef\x01\x23\x45",
+		.klen	= 4,
+		.input	= "\xd6\xa1\x41\xa7\xec\x3c\x38\xdf"
+			  "\xbd\x61\x5a\x11\x62\xe1\xc7\xba"
+			  "\x36\xb6\x78\x58",
+		.ilen	= 20,
+		.result	= "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00",
+		.rlen	= 20,
+	}, {
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef",
+		.klen	= 8,
+		.input	= "\x66\xa0\x94\x9f\x8a\xf7\xd6\x89"
+			  "\x1f\x7f\x83\x2b\xa8\x33\xc0\x0c"
+			  "\x89\x2e\xbe\x30\x14\x3c\xe2\x87"
+			  "\x40\x01\x1e\xcf",
+		.ilen	= 28,
+		.result	= "\x12\x34\x56\x78\x9A\xBC\xDE\xF0"
+			  "\x12\x34\x56\x78\x9A\xBC\xDE\xF0"
+			  "\x12\x34\x56\x78\x9A\xBC\xDE\xF0"
+			  "\x12\x34\x56\x78",
+		.rlen	= 28,
+	}, {
+		.key	= "\xef\x01\x23\x45",
+		.klen	= 4,
+		.input	= "\xd6\xa1\x41\xa7\xec\x3c\x38\xdf"
+			  "\xbd\x61",
+		.ilen	= 10,
+		.result	= "\x00\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00",
+		.rlen	= 10,
+	}, {
+		.key	= "\x01\x23\x45\x67\x89\xAB\xCD\xEF"
+			"\x00\x00\x00\x00\x00\x00\x00\x00",
+		.klen	= 16,
+		.input	= "\x69\x72\x36\x59\x1B\x52\x42\xB1",
+		.ilen	= 8,
+		.result	= "\x01\x23\x45\x67\x89\xAB\xCD\xEF",
+		.rlen	= 8,
+	},
+};
+
+/*
+ * TEA test vectors
+ */
+#define TEA_ENC_TEST_VECTORS	4
+#define TEA_DEC_TEST_VECTORS	4
+
+static struct cipher_testvec tea_enc_tv_template[] = {
+	{
+		.key    = zeroed_string,
+		.klen	= 16,
+		.input  = zeroed_string,
+		.ilen	= 8,
+		.result	= "\x0a\x3a\xea\x41\x40\xa9\xba\x94",
+		.rlen	= 8,
+	}, {
+		.key	= "\x2b\x02\x05\x68\x06\x14\x49\x76"
+			  "\x77\x5d\x0e\x26\x6c\x28\x78\x43",
+		.klen	= 16,
+		.input	= "\x74\x65\x73\x74\x20\x6d\x65\x2e",
+		.ilen	= 8,
+		.result	= "\x77\x5d\x2a\x6a\xf6\xce\x92\x09",
+		.rlen	= 8,
+	}, {
+		.key	= "\x09\x65\x43\x11\x66\x44\x39\x25"
+			  "\x51\x3a\x16\x10\x0a\x08\x12\x6e",
+		.klen	= 16,
+		.input	= "\x6c\x6f\x6e\x67\x65\x72\x5f\x74"
+			  "\x65\x73\x74\x5f\x76\x65\x63\x74",
+		.ilen	= 16,
+		.result	= "\xbe\x7a\xbb\x81\x95\x2d\x1f\x1e"
+			  "\xdd\x89\xa1\x25\x04\x21\xdf\x95",
+		.rlen	= 16,
+	}, {
+		.key	= "\x4d\x76\x32\x17\x05\x3f\x75\x2c"
+			  "\x5d\x04\x16\x36\x15\x72\x63\x2f",
+		.klen	= 16,
+		.input	= "\x54\x65\x61\x20\x69\x73\x20\x67"
+			  "\x6f\x6f\x64\x20\x66\x6f\x72\x20"
+			  "\x79\x6f\x75\x21\x21\x21\x20\x72"
+			  "\x65\x61\x6c\x6c\x79\x21\x21\x21",
+		.ilen	= 32,
+		.result	= "\xe0\x4d\x5d\x3c\xb7\x8c\x36\x47"
+			  "\x94\x18\x95\x91\xa9\xfc\x49\xf8"
+			  "\x44\xd1\x2d\xc2\x99\xb8\x08\x2a"
+			  "\x07\x89\x73\xc2\x45\x92\xc6\x90",
+		.rlen	= 32,
+	}
+};
+
+static struct cipher_testvec tea_dec_tv_template[] = {
+	{
+		.key    = zeroed_string,
+		.klen	= 16,
+		.input	= "\x0a\x3a\xea\x41\x40\xa9\xba\x94",
+		.ilen	= 8,
+		.result = zeroed_string,
+		.rlen	= 8,
+	}, {
+		.key	= "\x2b\x02\x05\x68\x06\x14\x49\x76"
+			  "\x77\x5d\x0e\x26\x6c\x28\x78\x43",
+		.klen	= 16,
+		.input	= "\x77\x5d\x2a\x6a\xf6\xce\x92\x09",
+		.ilen	= 8,
+		.result	= "\x74\x65\x73\x74\x20\x6d\x65\x2e",
+		.rlen	= 8,
+	}, {
+		.key	= "\x09\x65\x43\x11\x66\x44\x39\x25"
+			  "\x51\x3a\x16\x10\x0a\x08\x12\x6e",
+		.klen	= 16,
+		.input	= "\xbe\x7a\xbb\x81\x95\x2d\x1f\x1e"
+			  "\xdd\x89\xa1\x25\x04\x21\xdf\x95",
+		.ilen   = 16,
+		.result	= "\x6c\x6f\x6e\x67\x65\x72\x5f\x74"
+			  "\x65\x73\x74\x5f\x76\x65\x63\x74",
+		.rlen	= 16,
+	}, {
+		.key	= "\x4d\x76\x32\x17\x05\x3f\x75\x2c"
+			  "\x5d\x04\x16\x36\x15\x72\x63\x2f",
+		.klen	= 16,
+		.input	= "\xe0\x4d\x5d\x3c\xb7\x8c\x36\x47"
+			  "\x94\x18\x95\x91\xa9\xfc\x49\xf8"
+			  "\x44\xd1\x2d\xc2\x99\xb8\x08\x2a"
+			  "\x07\x89\x73\xc2\x45\x92\xc6\x90",
+		.ilen	= 32,
+		.result	= "\x54\x65\x61\x20\x69\x73\x20\x67"
+			  "\x6f\x6f\x64\x20\x66\x6f\x72\x20"
+			  "\x79\x6f\x75\x21\x21\x21\x20\x72"
+			  "\x65\x61\x6c\x6c\x79\x21\x21\x21",
+		.rlen	= 32,
+	}
+};
+
+/*
+ * XTEA test vectors
+ */
+#define XTEA_ENC_TEST_VECTORS	4
+#define XTEA_DEC_TEST_VECTORS	4
+
+static struct cipher_testvec xtea_enc_tv_template[] = {
+	{
+		.key    = zeroed_string,
+		.klen	= 16,
+		.input  = zeroed_string,
+		.ilen	= 8,
+		.result	= "\xd8\xd4\xe9\xde\xd9\x1e\x13\xf7",
+		.rlen	= 8,
+	}, {
+		.key	= "\x2b\x02\x05\x68\x06\x14\x49\x76"
+			  "\x77\x5d\x0e\x26\x6c\x28\x78\x43",
+		.klen	= 16,
+		.input	= "\x74\x65\x73\x74\x20\x6d\x65\x2e",
+		.ilen	= 8,
+		.result	= "\x94\xeb\xc8\x96\x84\x6a\x49\xa8",
+		.rlen	= 8,
+	}, {
+		.key	= "\x09\x65\x43\x11\x66\x44\x39\x25"
+			  "\x51\x3a\x16\x10\x0a\x08\x12\x6e",
+		.klen	= 16,
+		.input	= "\x6c\x6f\x6e\x67\x65\x72\x5f\x74"
+			  "\x65\x73\x74\x5f\x76\x65\x63\x74",
+		.ilen	= 16,
+		.result	= "\x3e\xce\xae\x22\x60\x56\xa8\x9d"
+			  "\x77\x4d\xd4\xb4\x87\x24\xe3\x9a",
+		.rlen	= 16,
+	}, {
+		.key	= "\x4d\x76\x32\x17\x05\x3f\x75\x2c"
+			  "\x5d\x04\x16\x36\x15\x72\x63\x2f",
+		.klen	= 16,
+		.input	= "\x54\x65\x61\x20\x69\x73\x20\x67"
+			  "\x6f\x6f\x64\x20\x66\x6f\x72\x20"
+			  "\x79\x6f\x75\x21\x21\x21\x20\x72"
+			  "\x65\x61\x6c\x6c\x79\x21\x21\x21",
+		.ilen	= 32,
+		.result	= "\x99\x81\x9f\x5d\x6f\x4b\x31\x3a"
+			  "\x86\xff\x6f\xd0\xe3\x87\x70\x07"
+			  "\x4d\xb8\xcf\xf3\x99\x50\xb3\xd4"
+			  "\x73\xa2\xfa\xc9\x16\x59\x5d\x81",
+		.rlen	= 32,
+	}
+};
+
+static struct cipher_testvec xtea_dec_tv_template[] = {
+	{
+		.key    = zeroed_string,
+		.klen	= 16,
+		.input	= "\xd8\xd4\xe9\xde\xd9\x1e\x13\xf7",
+		.ilen	= 8,
+		.result = zeroed_string,
+		.rlen	= 8,
+	}, {
+		.key	= "\x2b\x02\x05\x68\x06\x14\x49\x76"
+			  "\x77\x5d\x0e\x26\x6c\x28\x78\x43",
+		.klen	= 16,
+		.input	= "\x94\xeb\xc8\x96\x84\x6a\x49\xa8",
+		.ilen	= 8,
+		.result	= "\x74\x65\x73\x74\x20\x6d\x65\x2e",
+		.rlen	= 8,
+	}, {
+		.key	= "\x09\x65\x43\x11\x66\x44\x39\x25"
+			  "\x51\x3a\x16\x10\x0a\x08\x12\x6e",
+		.klen	= 16,
+		.input	= "\x3e\xce\xae\x22\x60\x56\xa8\x9d"
+			  "\x77\x4d\xd4\xb4\x87\x24\xe3\x9a",
+		.ilen	= 16,
+		.result	= "\x6c\x6f\x6e\x67\x65\x72\x5f\x74"
+			  "\x65\x73\x74\x5f\x76\x65\x63\x74",
+		.rlen	= 16,
+	}, {
+		.key	= "\x4d\x76\x32\x17\x05\x3f\x75\x2c"
+			  "\x5d\x04\x16\x36\x15\x72\x63\x2f",
+		.klen	= 16,
+		.input	= "\x99\x81\x9f\x5d\x6f\x4b\x31\x3a"
+			  "\x86\xff\x6f\xd0\xe3\x87\x70\x07"
+			  "\x4d\xb8\xcf\xf3\x99\x50\xb3\xd4"
+			  "\x73\xa2\xfa\xc9\x16\x59\x5d\x81",
+		.ilen	= 32,
+		.result	= "\x54\x65\x61\x20\x69\x73\x20\x67"
+			  "\x6f\x6f\x64\x20\x66\x6f\x72\x20"
+			  "\x79\x6f\x75\x21\x21\x21\x20\x72"
+			  "\x65\x61\x6c\x6c\x79\x21\x21\x21",
+		.rlen	= 32,
+	}
+};
+
+/*
+ * KHAZAD test vectors.
+ */
+#define KHAZAD_ENC_TEST_VECTORS 5
+#define KHAZAD_DEC_TEST_VECTORS 5
+
+static struct cipher_testvec khazad_enc_tv_template[] = {
+	{
+		.key	= "\x80\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.klen	= 16,
+		.input	= "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.ilen	= 8,
+		.result	= "\x49\xa4\xce\x32\xac\x19\x0e\x3f",
+		.rlen	= 8,
+	}, {
+		.key	= "\x38\x38\x38\x38\x38\x38\x38\x38"
+			  "\x38\x38\x38\x38\x38\x38\x38\x38",
+		.klen	= 16,
+		.input	= "\x38\x38\x38\x38\x38\x38\x38\x38",
+		.ilen	= 8,
+		.result	= "\x7e\x82\x12\xa1\xd9\x5b\xe4\xf9",
+		.rlen	= 8,
+	}, {
+		.key	= "\xa2\xa2\xa2\xa2\xa2\xa2\xa2\xa2"
+			"\xa2\xa2\xa2\xa2\xa2\xa2\xa2\xa2",
+		.klen	= 16,
+		.input	= "\xa2\xa2\xa2\xa2\xa2\xa2\xa2\xa2",
+		.ilen	= 8,
+		.result	= "\xaa\xbe\xc1\x95\xc5\x94\x1a\x9c",
+		.rlen	= 8,
+	}, {
+		.key	= "\x2f\x2f\x2f\x2f\x2f\x2f\x2f\x2f"
+			"\x2f\x2f\x2f\x2f\x2f\x2f\x2f\x2f",
+		.klen	= 16,
+		.input	= "\x2f\x2f\x2f\x2f\x2f\x2f\x2f\x2f",
+		.ilen	= 8,
+		.result = "\x04\x74\xf5\x70\x50\x16\xd3\xb8",
+		.rlen	= 8,
+	}, {
+		.key	= "\x2f\x2f\x2f\x2f\x2f\x2f\x2f\x2f"
+			"\x2f\x2f\x2f\x2f\x2f\x2f\x2f\x2f",
+		.klen	= 16,
+		.input	= "\x2f\x2f\x2f\x2f\x2f\x2f\x2f\x2f"
+			"\x2f\x2f\x2f\x2f\x2f\x2f\x2f\x2f",
+		.ilen	= 16,
+		.result = "\x04\x74\xf5\x70\x50\x16\xd3\xb8"
+			"\x04\x74\xf5\x70\x50\x16\xd3\xb8",
+		.rlen	= 16,
+	},
+};
+
+static struct cipher_testvec khazad_dec_tv_template[] = {
+	{
+		.key	= "\x80\x00\x00\x00\x00\x00\x00\x00"
+			  "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.klen	= 16,
+		.input	= "\x49\xa4\xce\x32\xac\x19\x0e\x3f",
+		.ilen	= 8,
+		.result	= "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.rlen	= 8,
+	}, {
+		.key	= "\x38\x38\x38\x38\x38\x38\x38\x38"
+			  "\x38\x38\x38\x38\x38\x38\x38\x38",
+		.klen	= 16,
+		.input	= "\x7e\x82\x12\xa1\xd9\x5b\xe4\xf9",
+		.ilen	= 8,
+		.result	= "\x38\x38\x38\x38\x38\x38\x38\x38",
+		.rlen	= 8,
+	}, {
+		.key	= "\xa2\xa2\xa2\xa2\xa2\xa2\xa2\xa2"
+			"\xa2\xa2\xa2\xa2\xa2\xa2\xa2\xa2",
+		.klen	= 16,
+		.input	= "\xaa\xbe\xc1\x95\xc5\x94\x1a\x9c",
+		.ilen	= 8,
+		.result	= "\xa2\xa2\xa2\xa2\xa2\xa2\xa2\xa2",
+		.rlen	= 8,
+	}, {
+		.key	= "\x2f\x2f\x2f\x2f\x2f\x2f\x2f\x2f"
+			"\x2f\x2f\x2f\x2f\x2f\x2f\x2f\x2f",
+		.klen	= 16,
+		.input  = "\x04\x74\xf5\x70\x50\x16\xd3\xb8",
+		.ilen	= 8,
+		.result	= "\x2f\x2f\x2f\x2f\x2f\x2f\x2f\x2f",
+		.rlen	= 8,
+	}, {
+		.key	= "\x2f\x2f\x2f\x2f\x2f\x2f\x2f\x2f"
+			"\x2f\x2f\x2f\x2f\x2f\x2f\x2f\x2f",
+		.klen	= 16,
+		.input  = "\x04\x74\xf5\x70\x50\x16\xd3\xb8"
+			"\x04\x74\xf5\x70\x50\x16\xd3\xb8",
+		.ilen	= 16,
+		.result	= "\x2f\x2f\x2f\x2f\x2f\x2f\x2f\x2f"
+			"\x2f\x2f\x2f\x2f\x2f\x2f\x2f\x2f",
+		.rlen	= 16,
+	},
+};
+
+/*
+ * Anubis test vectors.
+ */
+
+#define ANUBIS_ENC_TEST_VECTORS			5
+#define ANUBIS_DEC_TEST_VECTORS			5
+#define ANUBIS_CBC_ENC_TEST_VECTORS		2
+#define ANUBIS_CBC_DEC_TEST_VECTORS		2
+
+static struct cipher_testvec anubis_enc_tv_template[] = {
+	{
+		.key	= "\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe"
+			  "\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe",
+		.klen	= 16,
+		.input	= "\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe"
+			  "\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe",
+		.ilen	= 16,
+		.result	= "\x6d\xc5\xda\xa2\x26\x7d\x62\x6f"
+			  "\x08\xb7\x52\x8e\x6e\x6e\x86\x90",
+		.rlen	= 16,
+	}, {
+
+		.key	= "\x03\x03\x03\x03\x03\x03\x03\x03"
+			  "\x03\x03\x03\x03\x03\x03\x03\x03"
+			  "\x03\x03\x03\x03",
+		.klen	= 20,
+		.input	= "\x03\x03\x03\x03\x03\x03\x03\x03"
+			  "\x03\x03\x03\x03\x03\x03\x03\x03",
+		.ilen	= 16,
+		.result	= "\xdb\xf1\x42\xf4\xd1\x8a\xc7\x49"
+			  "\x87\x41\x6f\x82\x0a\x98\x64\xae",
+		.rlen	= 16,
+	}, {
+		.key	= "\x24\x24\x24\x24\x24\x24\x24\x24"
+			  "\x24\x24\x24\x24\x24\x24\x24\x24"
+			  "\x24\x24\x24\x24\x24\x24\x24\x24"
+			  "\x24\x24\x24\x24",
+		.klen	= 28,
+		.input	= "\x24\x24\x24\x24\x24\x24\x24\x24"
+			  "\x24\x24\x24\x24\x24\x24\x24\x24",
+		.ilen	= 16,
+		.result	= "\xfd\x1b\x4a\xe3\xbf\xf0\xad\x3d"
+			  "\x06\xd3\x61\x27\xfd\x13\x9e\xde",
+		.rlen	= 16,
+	}, {
+		.key	= "\x25\x25\x25\x25\x25\x25\x25\x25"
+			  "\x25\x25\x25\x25\x25\x25\x25\x25"
+			  "\x25\x25\x25\x25\x25\x25\x25\x25"
+			  "\x25\x25\x25\x25\x25\x25\x25\x25",
+		.klen	= 32,
+		.input	= "\x25\x25\x25\x25\x25\x25\x25\x25"
+			  "\x25\x25\x25\x25\x25\x25\x25\x25",
+		.ilen	= 16,
+		.result	= "\x1a\x91\xfb\x2b\xb7\x78\x6b\xc4"
+			"\x17\xd9\xff\x40\x3b\x0e\xe5\xfe",
+		.rlen	= 16,
+	}, {
+		.key	= "\x35\x35\x35\x35\x35\x35\x35\x35"
+			  "\x35\x35\x35\x35\x35\x35\x35\x35"
+			  "\x35\x35\x35\x35\x35\x35\x35\x35"
+			  "\x35\x35\x35\x35\x35\x35\x35\x35"
+			  "\x35\x35\x35\x35\x35\x35\x35\x35",
+		.klen	= 40,
+		.input	= "\x35\x35\x35\x35\x35\x35\x35\x35"
+			  "\x35\x35\x35\x35\x35\x35\x35\x35",
+		.ilen	= 16,
+		.result = "\xa5\x2c\x85\x6f\x9c\xba\xa0\x97"
+			  "\x9e\xc6\x84\x0f\x17\x21\x07\xee",
+		.rlen	= 16,
+	},
+};
+
+static struct cipher_testvec anubis_dec_tv_template[] = {
+	{
+		.key	= "\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe"
+			  "\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe",
+		.klen	= 16,
+		.input	= "\x6d\xc5\xda\xa2\x26\x7d\x62\x6f"
+			  "\x08\xb7\x52\x8e\x6e\x6e\x86\x90",
+		.ilen	= 16,
+		.result	= "\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe"
+			  "\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe",
+		.rlen	= 16,
+	}, {
+
+		.key	= "\x03\x03\x03\x03\x03\x03\x03\x03"
+			  "\x03\x03\x03\x03\x03\x03\x03\x03"
+			  "\x03\x03\x03\x03",
+		.klen	= 20,
+		.input	= "\xdb\xf1\x42\xf4\xd1\x8a\xc7\x49"
+			  "\x87\x41\x6f\x82\x0a\x98\x64\xae",
+		.ilen	= 16,
+		.result	= "\x03\x03\x03\x03\x03\x03\x03\x03"
+			  "\x03\x03\x03\x03\x03\x03\x03\x03",
+		.rlen	= 16,
+	}, {
+		.key	= "\x24\x24\x24\x24\x24\x24\x24\x24"
+			  "\x24\x24\x24\x24\x24\x24\x24\x24"
+			  "\x24\x24\x24\x24\x24\x24\x24\x24"
+			  "\x24\x24\x24\x24",
+		.klen	= 28,
+		.input	= "\xfd\x1b\x4a\xe3\xbf\xf0\xad\x3d"
+			  "\x06\xd3\x61\x27\xfd\x13\x9e\xde",
+		.ilen	= 16,
+		.result	= "\x24\x24\x24\x24\x24\x24\x24\x24"
+			  "\x24\x24\x24\x24\x24\x24\x24\x24",
+		.rlen	= 16,
+	}, {
+		.key	= "\x25\x25\x25\x25\x25\x25\x25\x25"
+			  "\x25\x25\x25\x25\x25\x25\x25\x25"
+			  "\x25\x25\x25\x25\x25\x25\x25\x25"
+			  "\x25\x25\x25\x25\x25\x25\x25\x25",
+		.klen	= 32,
+		.input	= "\x1a\x91\xfb\x2b\xb7\x78\x6b\xc4"
+			"\x17\xd9\xff\x40\x3b\x0e\xe5\xfe",
+		.ilen	= 16,
+		.result	= "\x25\x25\x25\x25\x25\x25\x25\x25"
+			  "\x25\x25\x25\x25\x25\x25\x25\x25",
+		.rlen	= 16,
+	}, {
+		.key	= "\x35\x35\x35\x35\x35\x35\x35\x35"
+			  "\x35\x35\x35\x35\x35\x35\x35\x35"
+			  "\x35\x35\x35\x35\x35\x35\x35\x35"
+			  "\x35\x35\x35\x35\x35\x35\x35\x35"
+			  "\x35\x35\x35\x35\x35\x35\x35\x35",
+		.input = "\xa5\x2c\x85\x6f\x9c\xba\xa0\x97"
+			 "\x9e\xc6\x84\x0f\x17\x21\x07\xee",
+		.klen	= 40,
+		.ilen	= 16,
+		.result	= "\x35\x35\x35\x35\x35\x35\x35\x35"
+			  "\x35\x35\x35\x35\x35\x35\x35\x35",
+		.rlen	= 16,
+	},
+};
+
+static struct cipher_testvec anubis_cbc_enc_tv_template[] = {
+	{
+		.key	= "\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe"
+			  "\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe",
+		.klen	= 16,
+		.input	= "\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe"
+			  "\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe"
+			  "\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe"
+			  "\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe",
+		.ilen	= 32,
+		.result	= "\x6d\xc5\xda\xa2\x26\x7d\x62\x6f"
+			  "\x08\xb7\x52\x8e\x6e\x6e\x86\x90"
+			  "\x86\xd8\xb5\x6f\x98\x5e\x8a\x66"
+			  "\x4f\x1f\x78\xa1\xbb\x37\xf1\xbe",
+		.rlen	= 32,
+	}, {
+		.key	= "\x35\x35\x35\x35\x35\x35\x35\x35"
+			  "\x35\x35\x35\x35\x35\x35\x35\x35"
+			  "\x35\x35\x35\x35\x35\x35\x35\x35"
+			  "\x35\x35\x35\x35\x35\x35\x35\x35"
+			  "\x35\x35\x35\x35\x35\x35\x35\x35",
+		.klen	= 40,
+		.input	= "\x35\x35\x35\x35\x35\x35\x35\x35"
+			  "\x35\x35\x35\x35\x35\x35\x35\x35"
+			  "\x35\x35\x35\x35\x35\x35\x35\x35"
+			  "\x35\x35\x35\x35\x35\x35\x35\x35",
+		.ilen	= 32,
+		.result = "\xa5\x2c\x85\x6f\x9c\xba\xa0\x97"
+			  "\x9e\xc6\x84\x0f\x17\x21\x07\xee"
+			  "\xa2\xbc\x06\x98\xc6\x4b\xda\x75"
+			  "\x2e\xaa\xbe\x58\xce\x01\x5b\xc7",
+		.rlen	= 32,
+	},
+};
+
+static struct cipher_testvec anubis_cbc_dec_tv_template[] = {
+	{
+		.key	= "\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe"
+			  "\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe",
+		.klen	= 16,
+		.input	= "\x6d\xc5\xda\xa2\x26\x7d\x62\x6f"
+			  "\x08\xb7\x52\x8e\x6e\x6e\x86\x90"
+			  "\x86\xd8\xb5\x6f\x98\x5e\x8a\x66"
+			  "\x4f\x1f\x78\xa1\xbb\x37\xf1\xbe",
+		.ilen	= 32,
+		.result	= "\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe"
+			  "\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe"
+			  "\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe"
+			  "\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe",
+		.rlen	= 32,
+	}, {
+		.key	= "\x35\x35\x35\x35\x35\x35\x35\x35"
+			  "\x35\x35\x35\x35\x35\x35\x35\x35"
+			  "\x35\x35\x35\x35\x35\x35\x35\x35"
+			  "\x35\x35\x35\x35\x35\x35\x35\x35"
+			  "\x35\x35\x35\x35\x35\x35\x35\x35",
+		.klen	= 40,
+		.input = "\xa5\x2c\x85\x6f\x9c\xba\xa0\x97"
+			  "\x9e\xc6\x84\x0f\x17\x21\x07\xee"
+			  "\xa2\xbc\x06\x98\xc6\x4b\xda\x75"
+			  "\x2e\xaa\xbe\x58\xce\x01\x5b\xc7",
+		.ilen	= 32,
+		.result	= "\x35\x35\x35\x35\x35\x35\x35\x35"
+			  "\x35\x35\x35\x35\x35\x35\x35\x35"
+			  "\x35\x35\x35\x35\x35\x35\x35\x35"
+			  "\x35\x35\x35\x35\x35\x35\x35\x35",
+		.rlen	= 32,
+	},
+};
+
+/* 
+ * XETA test vectors 
+ */
+#define XETA_ENC_TEST_VECTORS	4
+#define XETA_DEC_TEST_VECTORS	4
+
+static struct cipher_testvec xeta_enc_tv_template[] = {
+	{
+		.key    = zeroed_string,
+		.klen	= 16,
+		.input  = zeroed_string,
+		.ilen	= 8,
+		.result	= "\xaa\x22\x96\xe5\x6c\x61\xf3\x45",
+		.rlen	= 8,
+	}, {
+		.key	= "\x2b\x02\x05\x68\x06\x14\x49\x76"
+			  "\x77\x5d\x0e\x26\x6c\x28\x78\x43",
+		.klen	= 16,
+		.input	= "\x74\x65\x73\x74\x20\x6d\x65\x2e",
+		.ilen	= 8,
+		.result	= "\x82\x3e\xeb\x35\xdc\xdd\xd9\xc3",
+		.rlen	= 8,
+	}, {
+		.key	= "\x09\x65\x43\x11\x66\x44\x39\x25"
+			  "\x51\x3a\x16\x10\x0a\x08\x12\x6e",
+		.klen	= 16,
+		.input	= "\x6c\x6f\x6e\x67\x65\x72\x5f\x74"
+			  "\x65\x73\x74\x5f\x76\x65\x63\x74",
+		.ilen	= 16,
+		.result	= "\xe2\x04\xdb\xf2\x89\x85\x9e\xea"
+			  "\x61\x35\xaa\xed\xb5\xcb\x71\x2c",
+		.rlen	= 16,
+	}, {
+		.key	= "\x4d\x76\x32\x17\x05\x3f\x75\x2c"
+			  "\x5d\x04\x16\x36\x15\x72\x63\x2f",
+		.klen	= 16,
+		.input	= "\x54\x65\x61\x20\x69\x73\x20\x67"
+			  "\x6f\x6f\x64\x20\x66\x6f\x72\x20"
+			  "\x79\x6f\x75\x21\x21\x21\x20\x72"
+			  "\x65\x61\x6c\x6c\x79\x21\x21\x21",
+		.ilen	= 32,
+		.result	= "\x0b\x03\xcd\x8a\xbe\x95\xfd\xb1"
+			  "\xc1\x44\x91\x0b\xa5\xc9\x1b\xb4"
+			  "\xa9\xda\x1e\x9e\xb1\x3e\x2a\x8f"
+			  "\xea\xa5\x6a\x85\xd1\xf4\xa8\xa5",
+		.rlen	= 32,
+	}
+};
+
+static struct cipher_testvec xeta_dec_tv_template[] = {
+	{
+		.key    = zeroed_string,
+		.klen	= 16,
+		.input	= "\xaa\x22\x96\xe5\x6c\x61\xf3\x45",
+		.ilen	= 8,
+		.result = zeroed_string,
+		.rlen	= 8,
+	}, {
+		.key	= "\x2b\x02\x05\x68\x06\x14\x49\x76"
+			  "\x77\x5d\x0e\x26\x6c\x28\x78\x43",
+		.klen	= 16,
+		.input	= "\x82\x3e\xeb\x35\xdc\xdd\xd9\xc3",
+		.ilen	= 8,
+		.result	= "\x74\x65\x73\x74\x20\x6d\x65\x2e",
+		.rlen	= 8,
+	}, {
+		.key	= "\x09\x65\x43\x11\x66\x44\x39\x25"
+			  "\x51\x3a\x16\x10\x0a\x08\x12\x6e",
+		.klen	= 16,
+		.input	= "\xe2\x04\xdb\xf2\x89\x85\x9e\xea"
+			  "\x61\x35\xaa\xed\xb5\xcb\x71\x2c",
+		.ilen	= 16,
+		.result	= "\x6c\x6f\x6e\x67\x65\x72\x5f\x74"
+			  "\x65\x73\x74\x5f\x76\x65\x63\x74",
+		.rlen	= 16,
+	}, {
+		.key	= "\x4d\x76\x32\x17\x05\x3f\x75\x2c"
+			  "\x5d\x04\x16\x36\x15\x72\x63\x2f",
+		.klen	= 16,
+		.input	= "\x0b\x03\xcd\x8a\xbe\x95\xfd\xb1"
+			  "\xc1\x44\x91\x0b\xa5\xc9\x1b\xb4"
+			  "\xa9\xda\x1e\x9e\xb1\x3e\x2a\x8f"
+			  "\xea\xa5\x6a\x85\xd1\xf4\xa8\xa5",
+		.ilen	= 32,
+		.result	= "\x54\x65\x61\x20\x69\x73\x20\x67"
+			  "\x6f\x6f\x64\x20\x66\x6f\x72\x20"
+			  "\x79\x6f\x75\x21\x21\x21\x20\x72"
+			  "\x65\x61\x6c\x6c\x79\x21\x21\x21",
+		.rlen	= 32,
+	}
+};
+
+/* 
+ * FCrypt test vectors 
+ */
+#define FCRYPT_ENC_TEST_VECTORS	ARRAY_SIZE(fcrypt_pcbc_enc_tv_template)
+#define FCRYPT_DEC_TEST_VECTORS	ARRAY_SIZE(fcrypt_pcbc_dec_tv_template)
+
+static struct cipher_testvec fcrypt_pcbc_enc_tv_template[] = {
+	{ /* http://www.openafs.org/pipermail/openafs-devel/2000-December/005320.html */
+		.key	= "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.klen	= 8,
+		.iv	= "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.input	= "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.ilen	= 8,
+		.result	= "\x0E\x09\x00\xC7\x3E\xF7\xED\x41",
+		.rlen	= 8,
+	}, {
+		.key	= "\x11\x44\x77\xAA\xDD\x00\x33\x66",
+		.klen	= 8,
+		.iv	= "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.input	= "\x12\x34\x56\x78\x9A\xBC\xDE\xF0",
+		.ilen	= 8,
+		.result	= "\xD8\xED\x78\x74\x77\xEC\x06\x80",
+		.rlen	= 8,
+	}, { /* From Arla */
+		.key	= "\xf0\xe1\xd2\xc3\xb4\xa5\x96\x87",
+		.klen	= 8,
+		.iv	= "\xfe\xdc\xba\x98\x76\x54\x32\x10",
+		.input	= "The quick brown fox jumps over the lazy dogs.\0\0",
+		.ilen	= 48,
+		.result	= "\x00\xf0\x0e\x11\x75\xe6\x23\x82"
+			  "\xee\xac\x98\x62\x44\x51\xe4\x84"
+			  "\xc3\x59\xd8\xaa\x64\x60\xae\xf7"
+			  "\xd2\xd9\x13\x79\x72\xa3\x45\x03"
+			  "\x23\xb5\x62\xd7\x0c\xf5\x27\xd1"
+			  "\xf8\x91\x3c\xac\x44\x22\x92\xef",
+		.rlen	= 48,
+	}, {
+		.key	= "\xfe\xdc\xba\x98\x76\x54\x32\x10",
+		.klen	= 8,
+		.iv	= "\xf0\xe1\xd2\xc3\xb4\xa5\x96\x87",
+		.input	= "The quick brown fox jumps over the lazy dogs.\0\0",
+		.ilen	= 48,
+		.result	= "\xca\x90\xf5\x9d\xcb\xd4\xd2\x3c"
+			  "\x01\x88\x7f\x3e\x31\x6e\x62\x9d"
+			  "\xd8\xe0\x57\xa3\x06\x3a\x42\x58"
+			  "\x2a\x28\xfe\x72\x52\x2f\xdd\xe0"
+			  "\x19\x89\x09\x1c\x2a\x8e\x8c\x94"
+			  "\xfc\xc7\x68\xe4\x88\xaa\xde\x0f",
+		.rlen	= 48,
+	}, { /* split-page version */
+		.key	= "\xfe\xdc\xba\x98\x76\x54\x32\x10",
+		.klen	= 8,
+		.iv	= "\xf0\xe1\xd2\xc3\xb4\xa5\x96\x87",
+		.input	= "The quick brown fox jumps over the lazy dogs.\0\0",
+		.ilen	= 48,
+		.result	= "\xca\x90\xf5\x9d\xcb\xd4\xd2\x3c"
+			  "\x01\x88\x7f\x3e\x31\x6e\x62\x9d"
+			  "\xd8\xe0\x57\xa3\x06\x3a\x42\x58"
+			  "\x2a\x28\xfe\x72\x52\x2f\xdd\xe0"
+			  "\x19\x89\x09\x1c\x2a\x8e\x8c\x94"
+			  "\xfc\xc7\x68\xe4\x88\xaa\xde\x0f",
+		.rlen	= 48,
+		.np	= 2,
+		.tap	= { 20, 28 },
+	}
+};
+
+static struct cipher_testvec fcrypt_pcbc_dec_tv_template[] = {
+	{ /* http://www.openafs.org/pipermail/openafs-devel/2000-December/005320.html */
+		.key	= "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.klen	= 8,
+		.iv	= "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.input	= "\x0E\x09\x00\xC7\x3E\xF7\xED\x41",
+		.ilen	= 8,
+		.result	= "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.rlen	= 8,
+	}, {
+		.key	= "\x11\x44\x77\xAA\xDD\x00\x33\x66",
+		.klen	= 8,
+		.iv	= "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.input	= "\xD8\xED\x78\x74\x77\xEC\x06\x80",
+		.ilen	= 8,
+		.result	= "\x12\x34\x56\x78\x9A\xBC\xDE\xF0",
+		.rlen	= 8,
+	}, { /* From Arla */
+		.key	= "\xf0\xe1\xd2\xc3\xb4\xa5\x96\x87",
+		.klen	= 8,
+		.iv	= "\xfe\xdc\xba\x98\x76\x54\x32\x10",
+		.input	= "\x00\xf0\x0e\x11\x75\xe6\x23\x82"
+			  "\xee\xac\x98\x62\x44\x51\xe4\x84"
+			  "\xc3\x59\xd8\xaa\x64\x60\xae\xf7"
+			  "\xd2\xd9\x13\x79\x72\xa3\x45\x03"
+			  "\x23\xb5\x62\xd7\x0c\xf5\x27\xd1"
+			  "\xf8\x91\x3c\xac\x44\x22\x92\xef",
+		.ilen	= 48,
+		.result	= "The quick brown fox jumps over the lazy dogs.\0\0",
+		.rlen	= 48,
+	}, {
+		.key	= "\xfe\xdc\xba\x98\x76\x54\x32\x10",
+		.klen	= 8,
+		.iv	= "\xf0\xe1\xd2\xc3\xb4\xa5\x96\x87",
+		.input	= "\xca\x90\xf5\x9d\xcb\xd4\xd2\x3c"
+			  "\x01\x88\x7f\x3e\x31\x6e\x62\x9d"
+			  "\xd8\xe0\x57\xa3\x06\x3a\x42\x58"
+			  "\x2a\x28\xfe\x72\x52\x2f\xdd\xe0"
+			  "\x19\x89\x09\x1c\x2a\x8e\x8c\x94"
+			  "\xfc\xc7\x68\xe4\x88\xaa\xde\x0f",
+		.ilen	= 48,
+		.result	= "The quick brown fox jumps over the lazy dogs.\0\0",
+		.rlen	= 48,
+	}, { /* split-page version */
+		.key	= "\xfe\xdc\xba\x98\x76\x54\x32\x10",
+		.klen	= 8,
+		.iv	= "\xf0\xe1\xd2\xc3\xb4\xa5\x96\x87",
+		.input	= "\xca\x90\xf5\x9d\xcb\xd4\xd2\x3c"
+			  "\x01\x88\x7f\x3e\x31\x6e\x62\x9d"
+			  "\xd8\xe0\x57\xa3\x06\x3a\x42\x58"
+			  "\x2a\x28\xfe\x72\x52\x2f\xdd\xe0"
+			  "\x19\x89\x09\x1c\x2a\x8e\x8c\x94"
+			  "\xfc\xc7\x68\xe4\x88\xaa\xde\x0f",
+		.ilen	= 48,
+		.result	= "The quick brown fox jumps over the lazy dogs.\0\0",
+		.rlen	= 48,
+		.np	= 2,
+		.tap	= { 20, 28 },
+	}
+};
+
+/*
+ * CAMELLIA test vectors.
+ */
+#define CAMELLIA_ENC_TEST_VECTORS 3
+#define CAMELLIA_DEC_TEST_VECTORS 3
+#define CAMELLIA_CBC_ENC_TEST_VECTORS 2
+#define CAMELLIA_CBC_DEC_TEST_VECTORS 2
+
+static struct cipher_testvec camellia_enc_tv_template[] = {
+	{
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef"
+			  "\xfe\xdc\xba\x98\x76\x54\x32\x10",
+		.klen	= 16,
+		.input	= "\x01\x23\x45\x67\x89\xab\xcd\xef"
+			  "\xfe\xdc\xba\x98\x76\x54\x32\x10",
+		.ilen	= 16,
+		.result	= "\x67\x67\x31\x38\x54\x96\x69\x73"
+			  "\x08\x57\x06\x56\x48\xea\xbe\x43",
+		.rlen	= 16,
+	}, {
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef"
+			  "\xfe\xdc\xba\x98\x76\x54\x32\x10"
+			  "\x00\x11\x22\x33\x44\x55\x66\x77",
+		.klen	= 24,
+		.input	= "\x01\x23\x45\x67\x89\xab\xcd\xef"
+			  "\xfe\xdc\xba\x98\x76\x54\x32\x10",
+		.ilen	= 16,
+		.result	= "\xb4\x99\x34\x01\xb3\xe9\x96\xf8"
+			  "\x4e\xe5\xce\xe7\xd7\x9b\x09\xb9",
+		.rlen	= 16,
+	}, {
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef"
+			  "\xfe\xdc\xba\x98\x76\x54\x32\x10"
+			  "\x00\x11\x22\x33\x44\x55\x66\x77"
+			  "\x88\x99\xaa\xbb\xcc\xdd\xee\xff",
+		.klen	= 32,
+		.input	= "\x01\x23\x45\x67\x89\xab\xcd\xef"
+			  "\xfe\xdc\xba\x98\x76\x54\x32\x10",
+		.ilen	= 16,
+		.result	= "\x9a\xcc\x23\x7d\xff\x16\xd7\x6c"
+			  "\x20\xef\x7c\x91\x9e\x3a\x75\x09",
+		.rlen	= 16,
+	},
+};
+
+static struct cipher_testvec camellia_dec_tv_template[] = {
+	{
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef"
+			  "\xfe\xdc\xba\x98\x76\x54\x32\x10",
+		.klen	= 16,
+		.input	= "\x67\x67\x31\x38\x54\x96\x69\x73"
+			  "\x08\x57\x06\x56\x48\xea\xbe\x43",
+		.ilen	= 16,
+		.result	= "\x01\x23\x45\x67\x89\xab\xcd\xef"
+			  "\xfe\xdc\xba\x98\x76\x54\x32\x10",
+		.rlen	= 16,
+	}, {
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef"
+			  "\xfe\xdc\xba\x98\x76\x54\x32\x10"
+			  "\x00\x11\x22\x33\x44\x55\x66\x77",
+		.klen	= 24,
+		.input	= "\xb4\x99\x34\x01\xb3\xe9\x96\xf8"
+			  "\x4e\xe5\xce\xe7\xd7\x9b\x09\xb9",
+		.ilen	= 16,
+		.result	= "\x01\x23\x45\x67\x89\xab\xcd\xef"
+			  "\xfe\xdc\xba\x98\x76\x54\x32\x10",
+		.rlen	= 16,
+	}, {
+		.key	= "\x01\x23\x45\x67\x89\xab\xcd\xef"
+			  "\xfe\xdc\xba\x98\x76\x54\x32\x10"
+			  "\x00\x11\x22\x33\x44\x55\x66\x77"
+			  "\x88\x99\xaa\xbb\xcc\xdd\xee\xff",
+		.klen	= 32,
+		.input	= "\x9a\xcc\x23\x7d\xff\x16\xd7\x6c"
+			  "\x20\xef\x7c\x91\x9e\x3a\x75\x09",
+		.ilen	= 16,
+		.result	= "\x01\x23\x45\x67\x89\xab\xcd\xef"
+			  "\xfe\xdc\xba\x98\x76\x54\x32\x10",
+		.rlen	= 16,
+	},
+};
+
+static struct cipher_testvec camellia_cbc_enc_tv_template[] = {
+	{
+		.key    = "\x06\xa9\x21\x40\x36\xb8\xa1\x5b"
+			  "\x51\x2e\x03\xd5\x34\x12\x00\x06",
+		.klen   = 16,
+		.iv	= "\x3d\xaf\xba\x42\x9d\x9e\xb4\x30"
+			  "\xb4\x22\xda\x80\x2c\x9f\xac\x41",
+		.input	= "Single block msg",
+		.ilen   = 16,
+		.result = "\xea\x32\x12\x76\x3b\x50\x10\xe7"
+			  "\x18\xf6\xfd\x5d\xf6\x8f\x13\x51",
+		.rlen   = 16,
+	}, {
+		.key    = "\xc2\x86\x69\x6d\x88\x7c\x9a\xa0"
+			  "\x61\x1b\xbb\x3e\x20\x25\xa4\x5a",
+		.klen   = 16,
+		.iv     = "\x56\x2e\x17\x99\x6d\x09\x3d\x28"
+			  "\xdd\xb3\xba\x69\x5a\x2e\x6f\x58",
+		.input  = "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+			  "\x10\x11\x12\x13\x14\x15\x16\x17"
+			  "\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f",
+		.ilen   = 32,
+		.result = "\xa5\xdf\x6e\x50\xda\x70\x6c\x01"
+			  "\x4a\xab\xf3\xf2\xd6\xfc\x6c\xfd"
+			  "\x19\xb4\x3e\x57\x1c\x02\x5e\xa0"
+			  "\x15\x78\xe0\x5e\xf2\xcb\x87\x16",
+		.rlen   = 32,
+	},
+};
+
+static struct cipher_testvec camellia_cbc_dec_tv_template[] = {
+	{
+		.key    = "\x06\xa9\x21\x40\x36\xb8\xa1\x5b"
+			  "\x51\x2e\x03\xd5\x34\x12\x00\x06",
+		.klen   = 16,
+		.iv	= "\x3d\xaf\xba\x42\x9d\x9e\xb4\x30"
+			  "\xb4\x22\xda\x80\x2c\x9f\xac\x41",
+		.input	= "\xea\x32\x12\x76\x3b\x50\x10\xe7"
+			  "\x18\xf6\xfd\x5d\xf6\x8f\x13\x51",
+		.ilen   = 16,
+		.result = "Single block msg",
+		.rlen   = 16,
+	}, {
+		.key    = "\xc2\x86\x69\x6d\x88\x7c\x9a\xa0"
+			  "\x61\x1b\xbb\x3e\x20\x25\xa4\x5a",
+		.klen   = 16,
+		.iv     = "\x56\x2e\x17\x99\x6d\x09\x3d\x28"
+			  "\xdd\xb3\xba\x69\x5a\x2e\x6f\x58",
+		.input = "\xa5\xdf\x6e\x50\xda\x70\x6c\x01"
+			  "\x4a\xab\xf3\xf2\xd6\xfc\x6c\xfd"
+			  "\x19\xb4\x3e\x57\x1c\x02\x5e\xa0"
+			  "\x15\x78\xe0\x5e\xf2\xcb\x87\x16",
+		.ilen   = 32,
+		.result = "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+			  "\x10\x11\x12\x13\x14\x15\x16\x17"
+			  "\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f",
+		.rlen   = 32,
+	},
+};
+
+/*
+ * SEED test vectors
+ */
+#define SEED_ENC_TEST_VECTORS	4
+#define SEED_DEC_TEST_VECTORS	4
+
+static struct cipher_testvec seed_enc_tv_template[] = {
+	{
+		.key    = zeroed_string,
+		.klen	= 16,
+		.input  = "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f",
+		.ilen	= 16,
+		.result	= "\x5e\xba\xc6\xe0\x05\x4e\x16\x68"
+			  "\x19\xaf\xf1\xcc\x6d\x34\x6c\xdb",
+		.rlen	= 16,
+	}, {
+		.key	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f",
+		.klen	= 16,
+		.input	= zeroed_string,
+		.ilen	= 16,
+		.result	= "\xc1\x1f\x22\xf2\x01\x40\x50\x50"
+			  "\x84\x48\x35\x97\xe4\x37\x0f\x43",
+		.rlen	= 16,
+	}, {
+		.key	= "\x47\x06\x48\x08\x51\xe6\x1b\xe8"
+			  "\x5d\x74\xbf\xb3\xfd\x95\x61\x85",
+		.klen	= 16,
+		.input	= "\x83\xa2\xf8\xa2\x88\x64\x1f\xb9"
+			  "\xa4\xe9\xa5\xcc\x2f\x13\x1c\x7d",
+		.ilen	= 16,
+		.result	= "\xee\x54\xd1\x3e\xbc\xae\x70\x6d"
+			  "\x22\x6b\xc3\x14\x2c\xd4\x0d\x4a",
+		.rlen	= 16,
+	}, {
+		.key	= "\x28\xdb\xc3\xbc\x49\xff\xd8\x7d"
+			  "\xcf\xa5\x09\xb1\x1d\x42\x2b\xe7",
+		.klen	= 16,
+		.input	= "\xb4\x1e\x6b\xe2\xeb\xa8\x4a\x14"
+			  "\x8e\x2e\xed\x84\x59\x3c\x5e\xc7",
+		.ilen	= 16,
+		.result	= "\x9b\x9b\x7b\xfc\xd1\x81\x3c\xb9"
+			  "\x5d\x0b\x36\x18\xf4\x0f\x51\x22",
+		.rlen	= 16,
+	}
+};
+
+static struct cipher_testvec seed_dec_tv_template[] = {
+	{
+		.key    = zeroed_string,
+		.klen	= 16,
+		.input	= "\x5e\xba\xc6\xe0\x05\x4e\x16\x68"
+			  "\x19\xaf\xf1\xcc\x6d\x34\x6c\xdb",
+		.ilen	= 16,
+		.result	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f",
+		.rlen	= 16,
+	}, {
+		.key	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			  "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f",
+		.klen	= 16,
+		.input	= "\xc1\x1f\x22\xf2\x01\x40\x50\x50"
+			  "\x84\x48\x35\x97\xe4\x37\x0f\x43",
+		.ilen	= 16,
+		.result	= zeroed_string,
+		.rlen	= 16,
+	}, {
+		.key	= "\x47\x06\x48\x08\x51\xe6\x1b\xe8"
+			  "\x5d\x74\xbf\xb3\xfd\x95\x61\x85",
+		.klen	= 16,
+		.input	= "\xee\x54\xd1\x3e\xbc\xae\x70\x6d"
+			  "\x22\x6b\xc3\x14\x2c\xd4\x0d\x4a",
+		.ilen	= 16,
+		.result	= "\x83\xa2\xf8\xa2\x88\x64\x1f\xb9"
+			  "\xa4\xe9\xa5\xcc\x2f\x13\x1c\x7d",
+		.rlen	= 16,
+	}, {
+		.key	= "\x28\xdb\xc3\xbc\x49\xff\xd8\x7d"
+			  "\xcf\xa5\x09\xb1\x1d\x42\x2b\xe7",
+		.klen	= 16,
+		.input	= "\x9b\x9b\x7b\xfc\xd1\x81\x3c\xb9"
+			  "\x5d\x0b\x36\x18\xf4\x0f\x51\x22",
+		.ilen	= 16,
+		.result	= "\xb4\x1e\x6b\xe2\xeb\xa8\x4a\x14"
+			  "\x8e\x2e\xed\x84\x59\x3c\x5e\xc7",
+		.rlen	= 16,
+	}
+};
+
+#define SALSA20_STREAM_ENC_TEST_VECTORS 5
+static struct cipher_testvec salsa20_stream_enc_tv_template[] = {
+	/*
+	* Testvectors from verified.test-vectors submitted to ECRYPT.
+	* They are truncated to size 39, 64, 111, 129 to test a variety
+	* of input length.
+	*/
+	{ /* Set 3, vector 0 */
+		.key	= "\x00\x01\x02\x03\x04\x05\x06\x07"
+			"\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F",
+		.klen	= 16,
+		.iv     = "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.input	= "\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00",
+		.ilen	= 39,
+		.result	= "\x2D\xD5\xC3\xF7\xBA\x2B\x20\xF7"
+			 "\x68\x02\x41\x0C\x68\x86\x88\x89"
+			 "\x5A\xD8\xC1\xBD\x4E\xA6\xC9\xB1"
+			 "\x40\xFB\x9B\x90\xE2\x10\x49\xBF"
+			 "\x58\x3F\x52\x79\x70\xEB\xC1",
+		.rlen	= 39,
+	}, { /* Set 5, vector 0 */
+		.key	= "\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00",
+		.klen	= 16,
+		.iv     = "\x80\x00\x00\x00\x00\x00\x00\x00",
+		.input	= "\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00",
+		.ilen	= 64,
+		.result	= "\xB6\x6C\x1E\x44\x46\xDD\x95\x57"
+			 "\xE5\x78\xE2\x23\xB0\xB7\x68\x01"
+			 "\x7B\x23\xB2\x67\xBB\x02\x34\xAE"
+			 "\x46\x26\xBF\x44\x3F\x21\x97\x76"
+			 "\x43\x6F\xB1\x9F\xD0\xE8\x86\x6F"
+			 "\xCD\x0D\xE9\xA9\x53\x8F\x4A\x09"
+			 "\xCA\x9A\xC0\x73\x2E\x30\xBC\xF9"
+			 "\x8E\x4F\x13\xE4\xB9\xE2\x01\xD9",
+		.rlen	= 64,
+	}, { /* Set 3, vector 27 */
+		.key	= "\x1B\x1C\x1D\x1E\x1F\x20\x21\x22"
+			"\x23\x24\x25\x26\x27\x28\x29\x2A"
+			"\x2B\x2C\x2D\x2E\x2F\x30\x31\x32"
+			"\x33\x34\x35\x36\x37\x38\x39\x3A",
+		.klen	= 32,
+		.iv     = "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.input	= "\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00",
+		.ilen	= 111,
+		.result	= "\xAE\x39\x50\x8E\xAC\x9A\xEC\xE7"
+			 "\xBF\x97\xBB\x20\xB9\xDE\xE4\x1F"
+			 "\x87\xD9\x47\xF8\x28\x91\x35\x98"
+			 "\xDB\x72\xCC\x23\x29\x48\x56\x5E"
+			 "\x83\x7E\x0B\xF3\x7D\x5D\x38\x7B"
+			 "\x2D\x71\x02\xB4\x3B\xB5\xD8\x23"
+			 "\xB0\x4A\xDF\x3C\xEC\xB6\xD9\x3B"
+			 "\x9B\xA7\x52\xBE\xC5\xD4\x50\x59"
+			 "\x15\x14\xB4\x0E\x40\xE6\x53\xD1"
+			 "\x83\x9C\x5B\xA0\x92\x29\x6B\x5E"
+			 "\x96\x5B\x1E\x2F\xD3\xAC\xC1\x92"
+			 "\xB1\x41\x3F\x19\x2F\xC4\x3B\xC6"
+			 "\x95\x46\x45\x54\xE9\x75\x03\x08"
+			 "\x44\xAF\xE5\x8A\x81\x12\x09",
+		.rlen	= 111,
+	}, { /* Set 5, vector 27 */
+		.key	= "\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00",
+		.klen	= 32,
+		.iv     = "\x00\x00\x00\x10\x00\x00\x00\x00",
+		.input	= "\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00",
+		.ilen	= 129,
+		.result	= "\xD2\xDB\x1A\x5C\xF1\xC1\xAC\xDB"
+			 "\xE8\x1A\x7A\x43\x40\xEF\x53\x43"
+			 "\x5E\x7F\x4B\x1A\x50\x52\x3F\x8D"
+			 "\x28\x3D\xCF\x85\x1D\x69\x6E\x60"
+			 "\xF2\xDE\x74\x56\x18\x1B\x84\x10"
+			 "\xD4\x62\xBA\x60\x50\xF0\x61\xF2"
+			 "\x1C\x78\x7F\xC1\x24\x34\xAF\x58"
+			 "\xBF\x2C\x59\xCA\x90\x77\xF3\xB0"
+			 "\x5B\x4A\xDF\x89\xCE\x2C\x2F\xFC"
+			 "\x67\xF0\xE3\x45\xE8\xB3\xB3\x75"
+			 "\xA0\x95\x71\xA1\x29\x39\x94\xCA"
+			 "\x45\x2F\xBD\xCB\x10\xB6\xBE\x9F"
+			 "\x8E\xF9\xB2\x01\x0A\x5A\x0A\xB7"
+			 "\x6B\x9D\x70\x8E\x4B\xD6\x2F\xCD"
+			 "\x2E\x40\x48\x75\xE9\xE2\x21\x45"
+			 "\x0B\xC9\xB6\xB5\x66\xBC\x9A\x59"
+			 "\x5A",
+		.rlen	= 129,
+	}, { /* large test vector generated using Crypto++ */
+		.key =  "\x00\x01\x02\x03\x04\x05\x06\x07"
+			"\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+			"\x10\x11\x12\x13\x14\x15\x16\x17"
+			"\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f",
+		.klen = 32,
+		.iv =	"\x00\x00\x00\x00\x00\x00\x00\x00"
+			"\x00\x00\x00\x00\x00\x00\x00\x00",
+		.input =
+			"\x00\x01\x02\x03\x04\x05\x06\x07"
+			"\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+			"\x10\x11\x12\x13\x14\x15\x16\x17"
+			"\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
+			"\x20\x21\x22\x23\x24\x25\x26\x27"
+			"\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f"
+			"\x30\x31\x32\x33\x34\x35\x36\x37"
+			"\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f"
+			"\x40\x41\x42\x43\x44\x45\x46\x47"
+			"\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f"
+			"\x50\x51\x52\x53\x54\x55\x56\x57"
+			"\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
+			"\x60\x61\x62\x63\x64\x65\x66\x67"
+			"\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f"
+			"\x70\x71\x72\x73\x74\x75\x76\x77"
+			"\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
+			"\x80\x81\x82\x83\x84\x85\x86\x87"
+			"\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
+			"\x90\x91\x92\x93\x94\x95\x96\x97"
+			"\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
+			"\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7"
+			"\xa8\xa9\xaa\xab\xac\xad\xae\xaf"
+			"\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7"
+			"\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
+			"\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7"
+			"\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf"
+			"\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7"
+			"\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
+			"\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7"
+			"\xe8\xe9\xea\xeb\xec\xed\xee\xef"
+			"\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7"
+			"\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
+			"\x00\x03\x06\x09\x0c\x0f\x12\x15"
+			"\x18\x1b\x1e\x21\x24\x27\x2a\x2d"
+			"\x30\x33\x36\x39\x3c\x3f\x42\x45"
+			"\x48\x4b\x4e\x51\x54\x57\x5a\x5d"
+			"\x60\x63\x66\x69\x6c\x6f\x72\x75"
+			"\x78\x7b\x7e\x81\x84\x87\x8a\x8d"
+			"\x90\x93\x96\x99\x9c\x9f\xa2\xa5"
+			"\xa8\xab\xae\xb1\xb4\xb7\xba\xbd"
+			"\xc0\xc3\xc6\xc9\xcc\xcf\xd2\xd5"
+			"\xd8\xdb\xde\xe1\xe4\xe7\xea\xed"
+			"\xf0\xf3\xf6\xf9\xfc\xff\x02\x05"
+			"\x08\x0b\x0e\x11\x14\x17\x1a\x1d"
+			"\x20\x23\x26\x29\x2c\x2f\x32\x35"
+			"\x38\x3b\x3e\x41\x44\x47\x4a\x4d"
+			"\x50\x53\x56\x59\x5c\x5f\x62\x65"
+			"\x68\x6b\x6e\x71\x74\x77\x7a\x7d"
+			"\x80\x83\x86\x89\x8c\x8f\x92\x95"
+			"\x98\x9b\x9e\xa1\xa4\xa7\xaa\xad"
+			"\xb0\xb3\xb6\xb9\xbc\xbf\xc2\xc5"
+			"\xc8\xcb\xce\xd1\xd4\xd7\xda\xdd"
+			"\xe0\xe3\xe6\xe9\xec\xef\xf2\xf5"
+			"\xf8\xfb\xfe\x01\x04\x07\x0a\x0d"
+			"\x10\x13\x16\x19\x1c\x1f\x22\x25"
+			"\x28\x2b\x2e\x31\x34\x37\x3a\x3d"
+			"\x40\x43\x46\x49\x4c\x4f\x52\x55"
+			"\x58\x5b\x5e\x61\x64\x67\x6a\x6d"
+			"\x70\x73\x76\x79\x7c\x7f\x82\x85"
+			"\x88\x8b\x8e\x91\x94\x97\x9a\x9d"
+			"\xa0\xa3\xa6\xa9\xac\xaf\xb2\xb5"
+			"\xb8\xbb\xbe\xc1\xc4\xc7\xca\xcd"
+			"\xd0\xd3\xd6\xd9\xdc\xdf\xe2\xe5"
+			"\xe8\xeb\xee\xf1\xf4\xf7\xfa\xfd"
+			"\x00\x05\x0a\x0f\x14\x19\x1e\x23"
+			"\x28\x2d\x32\x37\x3c\x41\x46\x4b"
+			"\x50\x55\x5a\x5f\x64\x69\x6e\x73"
+			"\x78\x7d\x82\x87\x8c\x91\x96\x9b"
+			"\xa0\xa5\xaa\xaf\xb4\xb9\xbe\xc3"
+			"\xc8\xcd\xd2\xd7\xdc\xe1\xe6\xeb"
+			"\xf0\xf5\xfa\xff\x04\x09\x0e\x13"
+			"\x18\x1d\x22\x27\x2c\x31\x36\x3b"
+			"\x40\x45\x4a\x4f\x54\x59\x5e\x63"
+			"\x68\x6d\x72\x77\x7c\x81\x86\x8b"
+			"\x90\x95\x9a\x9f\xa4\xa9\xae\xb3"
+			"\xb8\xbd\xc2\xc7\xcc\xd1\xd6\xdb"
+			"\xe0\xe5\xea\xef\xf4\xf9\xfe\x03"
+			"\x08\x0d\x12\x17\x1c\x21\x26\x2b"
+			"\x30\x35\x3a\x3f\x44\x49\x4e\x53"
+			"\x58\x5d\x62\x67\x6c\x71\x76\x7b"
+			"\x80\x85\x8a\x8f\x94\x99\x9e\xa3"
+			"\xa8\xad\xb2\xb7\xbc\xc1\xc6\xcb"
+			"\xd0\xd5\xda\xdf\xe4\xe9\xee\xf3"
+			"\xf8\xfd\x02\x07\x0c\x11\x16\x1b"
+			"\x20\x25\x2a\x2f\x34\x39\x3e\x43"
+			"\x48\x4d\x52\x57\x5c\x61\x66\x6b"
+			"\x70\x75\x7a\x7f\x84\x89\x8e\x93"
+			"\x98\x9d\xa2\xa7\xac\xb1\xb6\xbb"
+			"\xc0\xc5\xca\xcf\xd4\xd9\xde\xe3"
+			"\xe8\xed\xf2\xf7\xfc\x01\x06\x0b"
+			"\x10\x15\x1a\x1f\x24\x29\x2e\x33"
+			"\x38\x3d\x42\x47\x4c\x51\x56\x5b"
+			"\x60\x65\x6a\x6f\x74\x79\x7e\x83"
+			"\x88\x8d\x92\x97\x9c\xa1\xa6\xab"
+			"\xb0\xb5\xba\xbf\xc4\xc9\xce\xd3"
+			"\xd8\xdd\xe2\xe7\xec\xf1\xf6\xfb"
+			"\x00\x07\x0e\x15\x1c\x23\x2a\x31"
+			"\x38\x3f\x46\x4d\x54\x5b\x62\x69"
+			"\x70\x77\x7e\x85\x8c\x93\x9a\xa1"
+			"\xa8\xaf\xb6\xbd\xc4\xcb\xd2\xd9"
+			"\xe0\xe7\xee\xf5\xfc\x03\x0a\x11"
+			"\x18\x1f\x26\x2d\x34\x3b\x42\x49"
+			"\x50\x57\x5e\x65\x6c\x73\x7a\x81"
+			"\x88\x8f\x96\x9d\xa4\xab\xb2\xb9"
+			"\xc0\xc7\xce\xd5\xdc\xe3\xea\xf1"
+			"\xf8\xff\x06\x0d\x14\x1b\x22\x29"
+			"\x30\x37\x3e\x45\x4c\x53\x5a\x61"
+			"\x68\x6f\x76\x7d\x84\x8b\x92\x99"
+			"\xa0\xa7\xae\xb5\xbc\xc3\xca\xd1"
+			"\xd8\xdf\xe6\xed\xf4\xfb\x02\x09"
+			"\x10\x17\x1e\x25\x2c\x33\x3a\x41"
+			"\x48\x4f\x56\x5d\x64\x6b\x72\x79"
+			"\x80\x87\x8e\x95\x9c\xa3\xaa\xb1"
+			"\xb8\xbf\xc6\xcd\xd4\xdb\xe2\xe9"
+			"\xf0\xf7\xfe\x05\x0c\x13\x1a\x21"
+			"\x28\x2f\x36\x3d\x44\x4b\x52\x59"
+			"\x60\x67\x6e\x75\x7c\x83\x8a\x91"
+			"\x98\x9f\xa6\xad\xb4\xbb\xc2\xc9"
+			"\xd0\xd7\xde\xe5\xec\xf3\xfa\x01"
+			"\x08\x0f\x16\x1d\x24\x2b\x32\x39"
+			"\x40\x47\x4e\x55\x5c\x63\x6a\x71"
+			"\x78\x7f\x86\x8d\x94\x9b\xa2\xa9"
+			"\xb0\xb7\xbe\xc5\xcc\xd3\xda\xe1"
+			"\xe8\xef\xf6\xfd\x04\x0b\x12\x19"
+			"\x20\x27\x2e\x35\x3c\x43\x4a\x51"
+			"\x58\x5f\x66\x6d\x74\x7b\x82\x89"
+			"\x90\x97\x9e\xa5\xac\xb3\xba\xc1"
+			"\xc8\xcf\xd6\xdd\xe4\xeb\xf2\xf9"
+			"\x00\x09\x12\x1b\x24\x2d\x36\x3f"
+			"\x48\x51\x5a\x63\x6c\x75\x7e\x87"
+			"\x90\x99\xa2\xab\xb4\xbd\xc6\xcf"
+			"\xd8\xe1\xea\xf3\xfc\x05\x0e\x17"
+			"\x20\x29\x32\x3b\x44\x4d\x56\x5f"
+			"\x68\x71\x7a\x83\x8c\x95\x9e\xa7"
+			"\xb0\xb9\xc2\xcb\xd4\xdd\xe6\xef"
+			"\xf8\x01\x0a\x13\x1c\x25\x2e\x37"
+			"\x40\x49\x52\x5b\x64\x6d\x76\x7f"
+			"\x88\x91\x9a\xa3\xac\xb5\xbe\xc7"
+			"\xd0\xd9\xe2\xeb\xf4\xfd\x06\x0f"
+			"\x18\x21\x2a\x33\x3c\x45\x4e\x57"
+			"\x60\x69\x72\x7b\x84\x8d\x96\x9f"
+			"\xa8\xb1\xba\xc3\xcc\xd5\xde\xe7"
+			"\xf0\xf9\x02\x0b\x14\x1d\x26\x2f"
+			"\x38\x41\x4a\x53\x5c\x65\x6e\x77"
+			"\x80\x89\x92\x9b\xa4\xad\xb6\xbf"
+			"\xc8\xd1\xda\xe3\xec\xf5\xfe\x07"
+			"\x10\x19\x22\x2b\x34\x3d\x46\x4f"
+			"\x58\x61\x6a\x73\x7c\x85\x8e\x97"
+			"\xa0\xa9\xb2\xbb\xc4\xcd\xd6\xdf"
+			"\xe8\xf1\xfa\x03\x0c\x15\x1e\x27"
+			"\x30\x39\x42\x4b\x54\x5d\x66\x6f"
+			"\x78\x81\x8a\x93\x9c\xa5\xae\xb7"
+			"\xc0\xc9\xd2\xdb\xe4\xed\xf6\xff"
+			"\x08\x11\x1a\x23\x2c\x35\x3e\x47"
+			"\x50\x59\x62\x6b\x74\x7d\x86\x8f"
+			"\x98\xa1\xaa\xb3\xbc\xc5\xce\xd7"
+			"\xe0\xe9\xf2\xfb\x04\x0d\x16\x1f"
+			"\x28\x31\x3a\x43\x4c\x55\x5e\x67"
+			"\x70\x79\x82\x8b\x94\x9d\xa6\xaf"
+			"\xb8\xc1\xca\xd3\xdc\xe5\xee\xf7"
+			"\x00\x0b\x16\x21\x2c\x37\x42\x4d"
+			"\x58\x63\x6e\x79\x84\x8f\x9a\xa5"
+			"\xb0\xbb\xc6\xd1\xdc\xe7\xf2\xfd"
+			"\x08\x13\x1e\x29\x34\x3f\x4a\x55"
+			"\x60\x6b\x76\x81\x8c\x97\xa2\xad"
+			"\xb8\xc3\xce\xd9\xe4\xef\xfa\x05"
+			"\x10\x1b\x26\x31\x3c\x47\x52\x5d"
+			"\x68\x73\x7e\x89\x94\x9f\xaa\xb5"
+			"\xc0\xcb\xd6\xe1\xec\xf7\x02\x0d"
+			"\x18\x23\x2e\x39\x44\x4f\x5a\x65"
+			"\x70\x7b\x86\x91\x9c\xa7\xb2\xbd"
+			"\xc8\xd3\xde\xe9\xf4\xff\x0a\x15"
+			"\x20\x2b\x36\x41\x4c\x57\x62\x6d"
+			"\x78\x83\x8e\x99\xa4\xaf\xba\xc5"
+			"\xd0\xdb\xe6\xf1\xfc\x07\x12\x1d"
+			"\x28\x33\x3e\x49\x54\x5f\x6a\x75"
+			"\x80\x8b\x96\xa1\xac\xb7\xc2\xcd"
+			"\xd8\xe3\xee\xf9\x04\x0f\x1a\x25"
+			"\x30\x3b\x46\x51\x5c\x67\x72\x7d"
+			"\x88\x93\x9e\xa9\xb4\xbf\xca\xd5"
+			"\xe0\xeb\xf6\x01\x0c\x17\x22\x2d"
+			"\x38\x43\x4e\x59\x64\x6f\x7a\x85"
+			"\x90\x9b\xa6\xb1\xbc\xc7\xd2\xdd"
+			"\xe8\xf3\xfe\x09\x14\x1f\x2a\x35"
+			"\x40\x4b\x56\x61\x6c\x77\x82\x8d"
+			"\x98\xa3\xae\xb9\xc4\xcf\xda\xe5"
+			"\xf0\xfb\x06\x11\x1c\x27\x32\x3d"
+			"\x48\x53\x5e\x69\x74\x7f\x8a\x95"
+			"\xa0\xab\xb6\xc1\xcc\xd7\xe2\xed"
+			"\xf8\x03\x0e\x19\x24\x2f\x3a\x45"
+			"\x50\x5b\x66\x71\x7c\x87\x92\x9d"
+			"\xa8\xb3\xbe\xc9\xd4\xdf\xea\xf5"
+			"\x00\x0d\x1a\x27\x34\x41\x4e\x5b"
+			"\x68\x75\x82\x8f\x9c\xa9\xb6\xc3"
+			"\xd0\xdd\xea\xf7\x04\x11\x1e\x2b"
+			"\x38\x45\x52\x5f\x6c\x79\x86\x93"
+			"\xa0\xad\xba\xc7\xd4\xe1\xee\xfb"
+			"\x08\x15\x22\x2f\x3c\x49\x56\x63"
+			"\x70\x7d\x8a\x97\xa4\xb1\xbe\xcb"
+			"\xd8\xe5\xf2\xff\x0c\x19\x26\x33"
+			"\x40\x4d\x5a\x67\x74\x81\x8e\x9b"
+			"\xa8\xb5\xc2\xcf\xdc\xe9\xf6\x03"
+			"\x10\x1d\x2a\x37\x44\x51\x5e\x6b"
+			"\x78\x85\x92\x9f\xac\xb9\xc6\xd3"
+			"\xe0\xed\xfa\x07\x14\x21\x2e\x3b"
+			"\x48\x55\x62\x6f\x7c\x89\x96\xa3"
+			"\xb0\xbd\xca\xd7\xe4\xf1\xfe\x0b"
+			"\x18\x25\x32\x3f\x4c\x59\x66\x73"
+			"\x80\x8d\x9a\xa7\xb4\xc1\xce\xdb"
+			"\xe8\xf5\x02\x0f\x1c\x29\x36\x43"
+			"\x50\x5d\x6a\x77\x84\x91\x9e\xab"
+			"\xb8\xc5\xd2\xdf\xec\xf9\x06\x13"
+			"\x20\x2d\x3a\x47\x54\x61\x6e\x7b"
+			"\x88\x95\xa2\xaf\xbc\xc9\xd6\xe3"
+			"\xf0\xfd\x0a\x17\x24\x31\x3e\x4b"
+			"\x58\x65\x72\x7f\x8c\x99\xa6\xb3"
+			"\xc0\xcd\xda\xe7\xf4\x01\x0e\x1b"
+			"\x28\x35\x42\x4f\x5c\x69\x76\x83"
+			"\x90\x9d\xaa\xb7\xc4\xd1\xde\xeb"
+			"\xf8\x05\x12\x1f\x2c\x39\x46\x53"
+			"\x60\x6d\x7a\x87\x94\xa1\xae\xbb"
+			"\xc8\xd5\xe2\xef\xfc\x09\x16\x23"
+			"\x30\x3d\x4a\x57\x64\x71\x7e\x8b"
+			"\x98\xa5\xb2\xbf\xcc\xd9\xe6\xf3"
+			"\x00\x0f\x1e\x2d\x3c\x4b\x5a\x69"
+			"\x78\x87\x96\xa5\xb4\xc3\xd2\xe1"
+			"\xf0\xff\x0e\x1d\x2c\x3b\x4a\x59"
+			"\x68\x77\x86\x95\xa4\xb3\xc2\xd1"
+			"\xe0\xef\xfe\x0d\x1c\x2b\x3a\x49"
+			"\x58\x67\x76\x85\x94\xa3\xb2\xc1"
+			"\xd0\xdf\xee\xfd\x0c\x1b\x2a\x39"
+			"\x48\x57\x66\x75\x84\x93\xa2\xb1"
+			"\xc0\xcf\xde\xed\xfc\x0b\x1a\x29"
+			"\x38\x47\x56\x65\x74\x83\x92\xa1"
+			"\xb0\xbf\xce\xdd\xec\xfb\x0a\x19"
+			"\x28\x37\x46\x55\x64\x73\x82\x91"
+			"\xa0\xaf\xbe\xcd\xdc\xeb\xfa\x09"
+			"\x18\x27\x36\x45\x54\x63\x72\x81"
+			"\x90\x9f\xae\xbd\xcc\xdb\xea\xf9"
+			"\x08\x17\x26\x35\x44\x53\x62\x71"
+			"\x80\x8f\x9e\xad\xbc\xcb\xda\xe9"
+			"\xf8\x07\x16\x25\x34\x43\x52\x61"
+			"\x70\x7f\x8e\x9d\xac\xbb\xca\xd9"
+			"\xe8\xf7\x06\x15\x24\x33\x42\x51"
+			"\x60\x6f\x7e\x8d\x9c\xab\xba\xc9"
+			"\xd8\xe7\xf6\x05\x14\x23\x32\x41"
+			"\x50\x5f\x6e\x7d\x8c\x9b\xaa\xb9"
+			"\xc8\xd7\xe6\xf5\x04\x13\x22\x31"
+			"\x40\x4f\x5e\x6d\x7c\x8b\x9a\xa9"
+			"\xb8\xc7\xd6\xe5\xf4\x03\x12\x21"
+			"\x30\x3f\x4e\x5d\x6c\x7b\x8a\x99"
+			"\xa8\xb7\xc6\xd5\xe4\xf3\x02\x11"
+			"\x20\x2f\x3e\x4d\x5c\x6b\x7a\x89"
+			"\x98\xa7\xb6\xc5\xd4\xe3\xf2\x01"
+			"\x10\x1f\x2e\x3d\x4c\x5b\x6a\x79"
+			"\x88\x97\xa6\xb5\xc4\xd3\xe2\xf1"
+			"\x00\x11\x22\x33\x44\x55\x66\x77"
+			"\x88\x99\xaa\xbb\xcc\xdd\xee\xff"
+			"\x10\x21\x32\x43\x54\x65\x76\x87"
+			"\x98\xa9\xba\xcb\xdc\xed\xfe\x0f"
+			"\x20\x31\x42\x53\x64\x75\x86\x97"
+			"\xa8\xb9\xca\xdb\xec\xfd\x0e\x1f"
+			"\x30\x41\x52\x63\x74\x85\x96\xa7"
+			"\xb8\xc9\xda\xeb\xfc\x0d\x1e\x2f"
+			"\x40\x51\x62\x73\x84\x95\xa6\xb7"
+			"\xc8\xd9\xea\xfb\x0c\x1d\x2e\x3f"
+			"\x50\x61\x72\x83\x94\xa5\xb6\xc7"
+			"\xd8\xe9\xfa\x0b\x1c\x2d\x3e\x4f"
+			"\x60\x71\x82\x93\xa4\xb5\xc6\xd7"
+			"\xe8\xf9\x0a\x1b\x2c\x3d\x4e\x5f"
+			"\x70\x81\x92\xa3\xb4\xc5\xd6\xe7"
+			"\xf8\x09\x1a\x2b\x3c\x4d\x5e\x6f"
+			"\x80\x91\xa2\xb3\xc4\xd5\xe6\xf7"
+			"\x08\x19\x2a\x3b\x4c\x5d\x6e\x7f"
+			"\x90\xa1\xb2\xc3\xd4\xe5\xf6\x07"
+			"\x18\x29\x3a\x4b\x5c\x6d\x7e\x8f"
+			"\xa0\xb1\xc2\xd3\xe4\xf5\x06\x17"
+			"\x28\x39\x4a\x5b\x6c\x7d\x8e\x9f"
+			"\xb0\xc1\xd2\xe3\xf4\x05\x16\x27"
+			"\x38\x49\x5a\x6b\x7c\x8d\x9e\xaf"
+			"\xc0\xd1\xe2\xf3\x04\x15\x26\x37"
+			"\x48\x59\x6a\x7b\x8c\x9d\xae\xbf"
+			"\xd0\xe1\xf2\x03\x14\x25\x36\x47"
+			"\x58\x69\x7a\x8b\x9c\xad\xbe\xcf"
+			"\xe0\xf1\x02\x13\x24\x35\x46\x57"
+			"\x68\x79\x8a\x9b\xac\xbd\xce\xdf"
+			"\xf0\x01\x12\x23\x34\x45\x56\x67"
+			"\x78\x89\x9a\xab\xbc\xcd\xde\xef"
+			"\x00\x13\x26\x39\x4c\x5f\x72\x85"
+			"\x98\xab\xbe\xd1\xe4\xf7\x0a\x1d"
+			"\x30\x43\x56\x69\x7c\x8f\xa2\xb5"
+			"\xc8\xdb\xee\x01\x14\x27\x3a\x4d"
+			"\x60\x73\x86\x99\xac\xbf\xd2\xe5"
+			"\xf8\x0b\x1e\x31\x44\x57\x6a\x7d"
+			"\x90\xa3\xb6\xc9\xdc\xef\x02\x15"
+			"\x28\x3b\x4e\x61\x74\x87\x9a\xad"
+			"\xc0\xd3\xe6\xf9\x0c\x1f\x32\x45"
+			"\x58\x6b\x7e\x91\xa4\xb7\xca\xdd"
+			"\xf0\x03\x16\x29\x3c\x4f\x62\x75"
+			"\x88\x9b\xae\xc1\xd4\xe7\xfa\x0d"
+			"\x20\x33\x46\x59\x6c\x7f\x92\xa5"
+			"\xb8\xcb\xde\xf1\x04\x17\x2a\x3d"
+			"\x50\x63\x76\x89\x9c\xaf\xc2\xd5"
+			"\xe8\xfb\x0e\x21\x34\x47\x5a\x6d"
+			"\x80\x93\xa6\xb9\xcc\xdf\xf2\x05"
+			"\x18\x2b\x3e\x51\x64\x77\x8a\x9d"
+			"\xb0\xc3\xd6\xe9\xfc\x0f\x22\x35"
+			"\x48\x5b\x6e\x81\x94\xa7\xba\xcd"
+			"\xe0\xf3\x06\x19\x2c\x3f\x52\x65"
+			"\x78\x8b\x9e\xb1\xc4\xd7\xea\xfd"
+			"\x10\x23\x36\x49\x5c\x6f\x82\x95"
+			"\xa8\xbb\xce\xe1\xf4\x07\x1a\x2d"
+			"\x40\x53\x66\x79\x8c\x9f\xb2\xc5"
+			"\xd8\xeb\xfe\x11\x24\x37\x4a\x5d"
+			"\x70\x83\x96\xa9\xbc\xcf\xe2\xf5"
+			"\x08\x1b\x2e\x41\x54\x67\x7a\x8d"
+			"\xa0\xb3\xc6\xd9\xec\xff\x12\x25"
+			"\x38\x4b\x5e\x71\x84\x97\xaa\xbd"
+			"\xd0\xe3\xf6\x09\x1c\x2f\x42\x55"
+			"\x68\x7b\x8e\xa1\xb4\xc7\xda\xed"
+			"\x00\x15\x2a\x3f\x54\x69\x7e\x93"
+			"\xa8\xbd\xd2\xe7\xfc\x11\x26\x3b"
+			"\x50\x65\x7a\x8f\xa4\xb9\xce\xe3"
+			"\xf8\x0d\x22\x37\x4c\x61\x76\x8b"
+			"\xa0\xb5\xca\xdf\xf4\x09\x1e\x33"
+			"\x48\x5d\x72\x87\x9c\xb1\xc6\xdb"
+			"\xf0\x05\x1a\x2f\x44\x59\x6e\x83"
+			"\x98\xad\xc2\xd7\xec\x01\x16\x2b"
+			"\x40\x55\x6a\x7f\x94\xa9\xbe\xd3"
+			"\xe8\xfd\x12\x27\x3c\x51\x66\x7b"
+			"\x90\xa5\xba\xcf\xe4\xf9\x0e\x23"
+			"\x38\x4d\x62\x77\x8c\xa1\xb6\xcb"
+			"\xe0\xf5\x0a\x1f\x34\x49\x5e\x73"
+			"\x88\x9d\xb2\xc7\xdc\xf1\x06\x1b"
+			"\x30\x45\x5a\x6f\x84\x99\xae\xc3"
+			"\xd8\xed\x02\x17\x2c\x41\x56\x6b"
+			"\x80\x95\xaa\xbf\xd4\xe9\xfe\x13"
+			"\x28\x3d\x52\x67\x7c\x91\xa6\xbb"
+			"\xd0\xe5\xfa\x0f\x24\x39\x4e\x63"
+			"\x78\x8d\xa2\xb7\xcc\xe1\xf6\x0b"
+			"\x20\x35\x4a\x5f\x74\x89\x9e\xb3"
+			"\xc8\xdd\xf2\x07\x1c\x31\x46\x5b"
+			"\x70\x85\x9a\xaf\xc4\xd9\xee\x03"
+			"\x18\x2d\x42\x57\x6c\x81\x96\xab"
+			"\xc0\xd5\xea\xff\x14\x29\x3e\x53"
+			"\x68\x7d\x92\xa7\xbc\xd1\xe6\xfb"
+			"\x10\x25\x3a\x4f\x64\x79\x8e\xa3"
+			"\xb8\xcd\xe2\xf7\x0c\x21\x36\x4b"
+			"\x60\x75\x8a\x9f\xb4\xc9\xde\xf3"
+			"\x08\x1d\x32\x47\x5c\x71\x86\x9b"
+			"\xb0\xc5\xda\xef\x04\x19\x2e\x43"
+			"\x58\x6d\x82\x97\xac\xc1\xd6\xeb"
+			"\x00\x17\x2e\x45\x5c\x73\x8a\xa1"
+			"\xb8\xcf\xe6\xfd\x14\x2b\x42\x59"
+			"\x70\x87\x9e\xb5\xcc\xe3\xfa\x11"
+			"\x28\x3f\x56\x6d\x84\x9b\xb2\xc9"
+			"\xe0\xf7\x0e\x25\x3c\x53\x6a\x81"
+			"\x98\xaf\xc6\xdd\xf4\x0b\x22\x39"
+			"\x50\x67\x7e\x95\xac\xc3\xda\xf1"
+			"\x08\x1f\x36\x4d\x64\x7b\x92\xa9"
+			"\xc0\xd7\xee\x05\x1c\x33\x4a\x61"
+			"\x78\x8f\xa6\xbd\xd4\xeb\x02\x19"
+			"\x30\x47\x5e\x75\x8c\xa3\xba\xd1"
+			"\xe8\xff\x16\x2d\x44\x5b\x72\x89"
+			"\xa0\xb7\xce\xe5\xfc\x13\x2a\x41"
+			"\x58\x6f\x86\x9d\xb4\xcb\xe2\xf9"
+			"\x10\x27\x3e\x55\x6c\x83\x9a\xb1"
+			"\xc8\xdf\xf6\x0d\x24\x3b\x52\x69"
+			"\x80\x97\xae\xc5\xdc\xf3\x0a\x21"
+			"\x38\x4f\x66\x7d\x94\xab\xc2\xd9"
+			"\xf0\x07\x1e\x35\x4c\x63\x7a\x91"
+			"\xa8\xbf\xd6\xed\x04\x1b\x32\x49"
+			"\x60\x77\x8e\xa5\xbc\xd3\xea\x01"
+			"\x18\x2f\x46\x5d\x74\x8b\xa2\xb9"
+			"\xd0\xe7\xfe\x15\x2c\x43\x5a\x71"
+			"\x88\x9f\xb6\xcd\xe4\xfb\x12\x29"
+			"\x40\x57\x6e\x85\x9c\xb3\xca\xe1"
+			"\xf8\x0f\x26\x3d\x54\x6b\x82\x99"
+			"\xb0\xc7\xde\xf5\x0c\x23\x3a\x51"
+			"\x68\x7f\x96\xad\xc4\xdb\xf2\x09"
+			"\x20\x37\x4e\x65\x7c\x93\xaa\xc1"
+			"\xd8\xef\x06\x1d\x34\x4b\x62\x79"
+			"\x90\xa7\xbe\xd5\xec\x03\x1a\x31"
+			"\x48\x5f\x76\x8d\xa4\xbb\xd2\xe9"
+			"\x00\x19\x32\x4b\x64\x7d\x96\xaf"
+			"\xc8\xe1\xfa\x13\x2c\x45\x5e\x77"
+			"\x90\xa9\xc2\xdb\xf4\x0d\x26\x3f"
+			"\x58\x71\x8a\xa3\xbc\xd5\xee\x07"
+			"\x20\x39\x52\x6b\x84\x9d\xb6\xcf"
+			"\xe8\x01\x1a\x33\x4c\x65\x7e\x97"
+			"\xb0\xc9\xe2\xfb\x14\x2d\x46\x5f"
+			"\x78\x91\xaa\xc3\xdc\xf5\x0e\x27"
+			"\x40\x59\x72\x8b\xa4\xbd\xd6\xef"
+			"\x08\x21\x3a\x53\x6c\x85\x9e\xb7"
+			"\xd0\xe9\x02\x1b\x34\x4d\x66\x7f"
+			"\x98\xb1\xca\xe3\xfc\x15\x2e\x47"
+			"\x60\x79\x92\xab\xc4\xdd\xf6\x0f"
+			"\x28\x41\x5a\x73\x8c\xa5\xbe\xd7"
+			"\xf0\x09\x22\x3b\x54\x6d\x86\x9f"
+			"\xb8\xd1\xea\x03\x1c\x35\x4e\x67"
+			"\x80\x99\xb2\xcb\xe4\xfd\x16\x2f"
+			"\x48\x61\x7a\x93\xac\xc5\xde\xf7"
+			"\x10\x29\x42\x5b\x74\x8d\xa6\xbf"
+			"\xd8\xf1\x0a\x23\x3c\x55\x6e\x87"
+			"\xa0\xb9\xd2\xeb\x04\x1d\x36\x4f"
+			"\x68\x81\x9a\xb3\xcc\xe5\xfe\x17"
+			"\x30\x49\x62\x7b\x94\xad\xc6\xdf"
+			"\xf8\x11\x2a\x43\x5c\x75\x8e\xa7"
+			"\xc0\xd9\xf2\x0b\x24\x3d\x56\x6f"
+			"\x88\xa1\xba\xd3\xec\x05\x1e\x37"
+			"\x50\x69\x82\x9b\xb4\xcd\xe6\xff"
+			"\x18\x31\x4a\x63\x7c\x95\xae\xc7"
+			"\xe0\xf9\x12\x2b\x44\x5d\x76\x8f"
+			"\xa8\xc1\xda\xf3\x0c\x25\x3e\x57"
+			"\x70\x89\xa2\xbb\xd4\xed\x06\x1f"
+			"\x38\x51\x6a\x83\x9c\xb5\xce\xe7"
+			"\x00\x1b\x36\x51\x6c\x87\xa2\xbd"
+			"\xd8\xf3\x0e\x29\x44\x5f\x7a\x95"
+			"\xb0\xcb\xe6\x01\x1c\x37\x52\x6d"
+			"\x88\xa3\xbe\xd9\xf4\x0f\x2a\x45"
+			"\x60\x7b\x96\xb1\xcc\xe7\x02\x1d"
+			"\x38\x53\x6e\x89\xa4\xbf\xda\xf5"
+			"\x10\x2b\x46\x61\x7c\x97\xb2\xcd"
+			"\xe8\x03\x1e\x39\x54\x6f\x8a\xa5"
+			"\xc0\xdb\xf6\x11\x2c\x47\x62\x7d"
+			"\x98\xb3\xce\xe9\x04\x1f\x3a\x55"
+			"\x70\x8b\xa6\xc1\xdc\xf7\x12\x2d"
+			"\x48\x63\x7e\x99\xb4\xcf\xea\x05"
+			"\x20\x3b\x56\x71\x8c\xa7\xc2\xdd"
+			"\xf8\x13\x2e\x49\x64\x7f\x9a\xb5"
+			"\xd0\xeb\x06\x21\x3c\x57\x72\x8d"
+			"\xa8\xc3\xde\xf9\x14\x2f\x4a\x65"
+			"\x80\x9b\xb6\xd1\xec\x07\x22\x3d"
+			"\x58\x73\x8e\xa9\xc4\xdf\xfa\x15"
+			"\x30\x4b\x66\x81\x9c\xb7\xd2\xed"
+			"\x08\x23\x3e\x59\x74\x8f\xaa\xc5"
+			"\xe0\xfb\x16\x31\x4c\x67\x82\x9d"
+			"\xb8\xd3\xee\x09\x24\x3f\x5a\x75"
+			"\x90\xab\xc6\xe1\xfc\x17\x32\x4d"
+			"\x68\x83\x9e\xb9\xd4\xef\x0a\x25"
+			"\x40\x5b\x76\x91\xac\xc7\xe2\xfd"
+			"\x18\x33\x4e\x69\x84\x9f\xba\xd5"
+			"\xf0\x0b\x26\x41\x5c\x77\x92\xad"
+			"\xc8\xe3\xfe\x19\x34\x4f\x6a\x85"
+			"\xa0\xbb\xd6\xf1\x0c\x27\x42\x5d"
+			"\x78\x93\xae\xc9\xe4\xff\x1a\x35"
+			"\x50\x6b\x86\xa1\xbc\xd7\xf2\x0d"
+			"\x28\x43\x5e\x79\x94\xaf\xca\xe5"
+			"\x00\x1d\x3a\x57\x74\x91\xae\xcb"
+			"\xe8\x05\x22\x3f\x5c\x79\x96\xb3"
+			"\xd0\xed\x0a\x27\x44\x61\x7e\x9b"
+			"\xb8\xd5\xf2\x0f\x2c\x49\x66\x83"
+			"\xa0\xbd\xda\xf7\x14\x31\x4e\x6b"
+			"\x88\xa5\xc2\xdf\xfc\x19\x36\x53"
+			"\x70\x8d\xaa\xc7\xe4\x01\x1e\x3b"
+			"\x58\x75\x92\xaf\xcc\xe9\x06\x23"
+			"\x40\x5d\x7a\x97\xb4\xd1\xee\x0b"
+			"\x28\x45\x62\x7f\x9c\xb9\xd6\xf3"
+			"\x10\x2d\x4a\x67\x84\xa1\xbe\xdb"
+			"\xf8\x15\x32\x4f\x6c\x89\xa6\xc3"
+			"\xe0\xfd\x1a\x37\x54\x71\x8e\xab"
+			"\xc8\xe5\x02\x1f\x3c\x59\x76\x93"
+			"\xb0\xcd\xea\x07\x24\x41\x5e\x7b"
+			"\x98\xb5\xd2\xef\x0c\x29\x46\x63"
+			"\x80\x9d\xba\xd7\xf4\x11\x2e\x4b"
+			"\x68\x85\xa2\xbf\xdc\xf9\x16\x33"
+			"\x50\x6d\x8a\xa7\xc4\xe1\xfe\x1b"
+			"\x38\x55\x72\x8f\xac\xc9\xe6\x03"
+			"\x20\x3d\x5a\x77\x94\xb1\xce\xeb"
+			"\x08\x25\x42\x5f\x7c\x99\xb6\xd3"
+			"\xf0\x0d\x2a\x47\x64\x81\x9e\xbb"
+			"\xd8\xf5\x12\x2f\x4c\x69\x86\xa3"
+			"\xc0\xdd\xfa\x17\x34\x51\x6e\x8b"
+			"\xa8\xc5\xe2\xff\x1c\x39\x56\x73"
+			"\x90\xad\xca\xe7\x04\x21\x3e\x5b"
+			"\x78\x95\xb2\xcf\xec\x09\x26\x43"
+			"\x60\x7d\x9a\xb7\xd4\xf1\x0e\x2b"
+			"\x48\x65\x82\x9f\xbc\xd9\xf6\x13"
+			"\x30\x4d\x6a\x87\xa4\xc1\xde\xfb"
+			"\x18\x35\x52\x6f\x8c\xa9\xc6\xe3"
+			"\x00\x1f\x3e\x5d\x7c\x9b\xba\xd9"
+			"\xf8\x17\x36\x55\x74\x93\xb2\xd1"
+			"\xf0\x0f\x2e\x4d\x6c\x8b\xaa\xc9"
+			"\xe8\x07\x26\x45\x64\x83\xa2\xc1"
+			"\xe0\xff\x1e\x3d\x5c\x7b\x9a\xb9"
+			"\xd8\xf7\x16\x35\x54\x73\x92\xb1"
+			"\xd0\xef\x0e\x2d\x4c\x6b\x8a\xa9"
+			"\xc8\xe7\x06\x25\x44\x63\x82\xa1"
+			"\xc0\xdf\xfe\x1d\x3c\x5b\x7a\x99"
+			"\xb8\xd7\xf6\x15\x34\x53\x72\x91"
+			"\xb0\xcf\xee\x0d\x2c\x4b\x6a\x89"
+			"\xa8\xc7\xe6\x05\x24\x43\x62\x81"
+			"\xa0\xbf\xde\xfd\x1c\x3b\x5a\x79"
+			"\x98\xb7\xd6\xf5\x14\x33\x52\x71"
+			"\x90\xaf\xce\xed\x0c\x2b\x4a\x69"
+			"\x88\xa7\xc6\xe5\x04\x23\x42\x61"
+			"\x80\x9f\xbe\xdd\xfc\x1b\x3a\x59"
+			"\x78\x97\xb6\xd5\xf4\x13\x32\x51"
+			"\x70\x8f\xae\xcd\xec\x0b\x2a\x49"
+			"\x68\x87\xa6\xc5\xe4\x03\x22\x41"
+			"\x60\x7f\x9e\xbd\xdc\xfb\x1a\x39"
+			"\x58\x77\x96\xb5\xd4\xf3\x12\x31"
+			"\x50\x6f\x8e\xad\xcc\xeb\x0a\x29"
+			"\x48\x67\x86\xa5\xc4\xe3\x02\x21"
+			"\x40\x5f\x7e\x9d\xbc\xdb\xfa\x19"
+			"\x38\x57\x76\x95\xb4\xd3\xf2\x11"
+			"\x30\x4f\x6e\x8d\xac\xcb\xea\x09"
+			"\x28\x47\x66\x85\xa4\xc3\xe2\x01"
+			"\x20\x3f\x5e\x7d\x9c\xbb\xda\xf9"
+			"\x18\x37\x56\x75\x94\xb3\xd2\xf1"
+			"\x10\x2f\x4e\x6d\x8c\xab\xca\xe9"
+			"\x08\x27\x46\x65\x84\xa3\xc2\xe1"
+			"\x00\x21\x42\x63",
+		.ilen = 4100,
+		.result =
+			"\xb5\x81\xf5\x64\x18\x73\xe3\xf0"
+			"\x4c\x13\xf2\x77\x18\x60\x65\x5e"
+			"\x29\x01\xce\x98\x55\x53\xf9\x0c"
+			"\x2a\x08\xd5\x09\xb3\x57\x55\x56"
+			"\xc5\xe9\x56\x90\xcb\x6a\xa3\xc0"
+			"\xff\xc4\x79\xb4\xd2\x97\x5d\xc4"
+			"\x43\xd1\xfe\x94\x7b\x88\x06\x5a"
+			"\xb2\x9e\x2c\xfc\x44\x03\xb7\x90"
+			"\xa0\xc1\xba\x6a\x33\xb8\xc7\xb2"
+			"\x9d\xe1\x12\x4f\xc0\x64\xd4\x01"
+			"\xfe\x8c\x7a\x66\xf7\xe6\x5a\x91"
+			"\xbb\xde\x56\x86\xab\x65\x21\x30"
+			"\x00\x84\x65\x24\xa5\x7d\x85\xb4"
+			"\xe3\x17\xed\x3a\xb7\x6f\xb4\x0b"
+			"\x0b\xaf\x15\xae\x5a\x8f\xf2\x0c"
+			"\x2f\x27\xf4\x09\xd8\xd2\x96\xb7"
+			"\x71\xf2\xc5\x99\x4d\x7e\x7f\x75"
+			"\x77\x89\x30\x8b\x59\xdb\xa2\xb2"
+			"\xa0\xf3\x19\x39\x2b\xc5\x7e\x3f"
+			"\x4f\xd9\xd3\x56\x28\x97\x44\xdc"
+			"\xc0\x8b\x77\x24\xd9\x52\xe7\xc5"
+			"\xaf\xf6\x7d\x59\xb2\x44\x05\x1d"
+			"\xb1\xb0\x11\xa5\x0f\xec\x33\xe1"
+			"\x6d\x1b\x4e\x1f\xff\x57\x91\xb4"
+			"\x5b\x9a\x96\xc5\x53\xbc\xae\x20"
+			"\x3c\xbb\x14\xe2\xe8\x22\x33\xc1"
+			"\x5e\x76\x9e\x46\x99\xf6\x2a\x15"
+			"\xc6\x97\x02\xa0\x66\x43\xd1\xa6"
+			"\x31\xa6\x9f\xfb\xf4\xd3\x69\xe5"
+			"\xcd\x76\x95\xb8\x7a\x82\x7f\x21"
+			"\x45\xff\x3f\xce\x55\xf6\x95\x10"
+			"\x08\x77\x10\x43\xc6\xf3\x09\xe5"
+			"\x68\xe7\x3c\xad\x00\x52\x45\x0d"
+			"\xfe\x2d\xc6\xc2\x94\x8c\x12\x1d"
+			"\xe6\x25\xae\x98\x12\x8e\x19\x9c"
+			"\x81\x68\xb1\x11\xf6\x69\xda\xe3"
+			"\x62\x08\x18\x7a\x25\x49\x28\xac"
+			"\xba\x71\x12\x0b\xe4\xa2\xe5\xc7"
+			"\x5d\x8e\xec\x49\x40\x21\xbf\x5a"
+			"\x98\xf3\x02\x68\x55\x03\x7f\x8a"
+			"\xe5\x94\x0c\x32\x5c\x07\x82\x63"
+			"\xaf\x6f\x91\x40\x84\x8e\x52\x25"
+			"\xd0\xb0\x29\x53\x05\xe2\x50\x7a"
+			"\x34\xeb\xc9\x46\x20\xa8\x3d\xde"
+			"\x7f\x16\x5f\x36\xc5\x2e\xdc\xd1"
+			"\x15\x47\xc7\x50\x40\x6d\x91\xc5"
+			"\xe7\x93\x95\x1a\xd3\x57\xbc\x52"
+			"\x33\xee\x14\x19\x22\x52\x89\xa7"
+			"\x4a\x25\x56\x77\x4b\xca\xcf\x0a"
+			"\xe1\xf5\x35\x85\x30\x7e\x59\x4a"
+			"\xbd\x14\x5b\xdf\xe3\x46\xcb\xac"
+			"\x1f\x6c\x96\x0e\xf4\x81\xd1\x99"
+			"\xca\x88\x63\x3d\x02\x58\x6b\xa9"
+			"\xe5\x9f\xb3\x00\xb2\x54\xc6\x74"
+			"\x1c\xbf\x46\xab\x97\xcc\xf8\x54"
+			"\x04\x07\x08\x52\xe6\xc0\xda\x93"
+			"\x74\x7d\x93\x99\x5d\x78\x68\xa6"
+			"\x2e\x6b\xd3\x6a\x69\xcc\x12\x6b"
+			"\xd4\xc7\xa5\xc6\xe7\xf6\x03\x04"
+			"\x5d\xcd\x61\x5e\x17\x40\xdc\xd1"
+			"\x5c\xf5\x08\xdf\x5c\x90\x85\xa4"
+			"\xaf\xf6\x78\xbb\x0d\xf1\xf4\xa4"
+			"\x54\x26\x72\x9e\x61\xfa\x86\xcf"
+			"\xe8\x9e\xa1\xe0\xc7\x48\x23\xae"
+			"\x5a\x90\xae\x75\x0a\x74\x18\x89"
+			"\x05\xb1\x92\xb2\x7f\xd0\x1b\xa6"
+			"\x62\x07\x25\x01\xc7\xc2\x4f\xf9"
+			"\xe8\xfe\x63\x95\x80\x07\xb4\x26"
+			"\xcc\xd1\x26\xb6\xc4\x3f\x9e\xcb"
+			"\x8e\x3b\x2e\x44\x16\xd3\x10\x9a"
+			"\x95\x08\xeb\xc8\xcb\xeb\xbf\x6f"
+			"\x0b\xcd\x1f\xc8\xca\x86\xaa\xec"
+			"\x33\xe6\x69\xf4\x45\x25\x86\x3a"
+			"\x22\x94\x4f\x00\x23\x6a\x44\xc2"
+			"\x49\x97\x33\xab\x36\x14\x0a\x70"
+			"\x24\xc3\xbe\x04\x3b\x79\xa0\xf9"
+			"\xb8\xe7\x76\x29\x22\x83\xd7\xf2"
+			"\x94\xf4\x41\x49\xba\x5f\x7b\x07"
+			"\xb5\xfb\xdb\x03\x1a\x9f\xb6\x4c"
+			"\xc2\x2e\x37\x40\x49\xc3\x38\x16"
+			"\xe2\x4f\x77\x82\xb0\x68\x4c\x71"
+			"\x1d\x57\x61\x9c\xd9\x4e\x54\x99"
+			"\x47\x13\x28\x73\x3c\xbb\x00\x90"
+			"\xf3\x4d\xc9\x0e\xfd\xe7\xb1\x71"
+			"\xd3\x15\x79\xbf\xcc\x26\x2f\xbd"
+			"\xad\x6c\x50\x69\x6c\x3e\x6d\x80"
+			"\x9a\xea\x78\xaf\x19\xb2\x0d\x4d"
+			"\xad\x04\x07\xae\x22\x90\x4a\x93"
+			"\x32\x0e\x36\x9b\x1b\x46\xba\x3b"
+			"\xb4\xac\xc6\xd1\xa2\x31\x53\x3b"
+			"\x2a\x3d\x45\xfe\x03\x61\x10\x85"
+			"\x17\x69\xa6\x78\xcc\x6c\x87\x49"
+			"\x53\xf9\x80\x10\xde\x80\xa2\x41"
+			"\x6a\xc3\x32\x02\xad\x6d\x3c\x56"
+			"\x00\x71\x51\x06\xa7\xbd\xfb\xef"
+			"\x3c\xb5\x9f\xfc\x48\x7d\x53\x7c"
+			"\x66\xb0\x49\x23\xc4\x47\x10\x0e"
+			"\xe5\x6c\x74\x13\xe6\xc5\x3f\xaa"
+			"\xde\xff\x07\x44\xdd\x56\x1b\xad"
+			"\x09\x77\xfb\x5b\x12\xb8\x0d\x38"
+			"\x17\x37\x35\x7b\x9b\xbc\xfe\xd4"
+			"\x7e\x8b\xda\x7e\x5b\x04\xa7\x22"
+			"\xa7\x31\xa1\x20\x86\xc7\x1b\x99"
+			"\xdb\xd1\x89\xf4\x94\xa3\x53\x69"
+			"\x8d\xe7\xe8\x74\x11\x8d\x74\xd6"
+			"\x07\x37\x91\x9f\xfd\x67\x50\x3a"
+			"\xc9\xe1\xf4\x36\xd5\xa0\x47\xd1"
+			"\xf9\xe5\x39\xa3\x31\xac\x07\x36"
+			"\x23\xf8\x66\x18\x14\x28\x34\x0f"
+			"\xb8\xd0\xe7\x29\xb3\x04\x4b\x55"
+			"\x01\x41\xb2\x75\x8d\xcb\x96\x85"
+			"\x3a\xfb\xab\x2b\x9e\xfa\x58\x20"
+			"\x44\x1f\xc0\x14\x22\x75\x61\xe8"
+			"\xaa\x19\xcf\xf1\x82\x56\xf4\xd7"
+			"\x78\x7b\x3d\x5f\xb3\x9e\x0b\x8a"
+			"\x57\x50\xdb\x17\x41\x65\x4d\xa3"
+			"\x02\xc9\x9c\x9c\x53\xfb\x39\x39"
+			"\x9b\x1d\x72\x24\xda\xb7\x39\xbe"
+			"\x13\x3b\xfa\x29\xda\x9e\x54\x64"
+			"\x6e\xba\xd8\xa1\xcb\xb3\x36\xfa"
+			"\xcb\x47\x85\xe9\x61\x38\xbc\xbe"
+			"\xc5\x00\x38\x2a\x54\xf7\xc4\xb9"
+			"\xb3\xd3\x7b\xa0\xa0\xf8\x72\x7f"
+			"\x8c\x8e\x82\x0e\xc6\x1c\x75\x9d"
+			"\xca\x8e\x61\x87\xde\xad\x80\xd2"
+			"\xf5\xf9\x80\xef\x15\x75\xaf\xf5"
+			"\x80\xfb\xff\x6d\x1e\x25\xb7\x40"
+			"\x61\x6a\x39\x5a\x6a\xb5\x31\xab"
+			"\x97\x8a\x19\x89\x44\x40\xc0\xa6"
+			"\xb4\x4e\x30\x32\x7b\x13\xe7\x67"
+			"\xa9\x8b\x57\x04\xc2\x01\xa6\xf4"
+			"\x28\x99\xad\x2c\x76\xa3\x78\xc2"
+			"\x4a\xe6\xca\x5c\x50\x6a\xc1\xb0"
+			"\x62\x4b\x10\x8e\x7c\x17\x43\xb3"
+			"\x17\x66\x1c\x3e\x8d\x69\xf0\x5a"
+			"\x71\xf5\x97\xdc\xd1\x45\xdd\x28"
+			"\xf3\x5d\xdf\x53\x7b\x11\xe5\xbc"
+			"\x4c\xdb\x1b\x51\x6b\xe9\xfb\x3d"
+			"\xc1\xc3\x2c\xb9\x71\xf5\xb6\xb2"
+			"\x13\x36\x79\x80\x53\xe8\xd3\xa6"
+			"\x0a\xaf\xfd\x56\x97\xf7\x40\x8e"
+			"\x45\xce\xf8\xb0\x9e\x5c\x33\x82"
+			"\xb0\x44\x56\xfc\x05\x09\xe9\x2a"
+			"\xac\x26\x80\x14\x1d\xc8\x3a\x35"
+			"\x4c\x82\x97\xfd\x76\xb7\xa9\x0a"
+			"\x35\x58\x79\x8e\x0f\x66\xea\xaf"
+			"\x51\x6c\x09\xa9\x6e\x9b\xcb\x9a"
+			"\x31\x47\xa0\x2f\x7c\x71\xb4\x4a"
+			"\x11\xaa\x8c\x66\xc5\x64\xe6\x3a"
+			"\x54\xda\x24\x6a\xc4\x41\x65\x46"
+			"\x82\xa0\x0a\x0f\x5f\xfb\x25\xd0"
+			"\x2c\x91\xa7\xee\xc4\x81\x07\x86"
+			"\x75\x5e\x33\x69\x97\xe4\x2c\xa8"
+			"\x9d\x9f\x0b\x6a\xbe\xad\x98\xda"
+			"\x6d\x94\x41\xda\x2c\x1e\x89\xc4"
+			"\xc2\xaf\x1e\x00\x05\x0b\x83\x60"
+			"\xbd\x43\xea\x15\x23\x7f\xb9\xac"
+			"\xee\x4f\x2c\xaf\x2a\xf3\xdf\xd0"
+			"\xf3\x19\x31\xbb\x4a\x74\x84\x17"
+			"\x52\x32\x2c\x7d\x61\xe4\xcb\xeb"
+			"\x80\x38\x15\x52\xcb\x6f\xea\xe5"
+			"\x73\x9c\xd9\x24\x69\xc6\x95\x32"
+			"\x21\xc8\x11\xe4\xdc\x36\xd7\x93"
+			"\x38\x66\xfb\xb2\x7f\x3a\xb9\xaf"
+			"\x31\xdd\x93\x75\x78\x8a\x2c\x94"
+			"\x87\x1a\x58\xec\x9e\x7d\x4d\xba"
+			"\xe1\xe5\x4d\xfc\xbc\xa4\x2a\x14"
+			"\xef\xcc\xa7\xec\xab\x43\x09\x18"
+			"\xd3\xab\x68\xd1\x07\x99\x44\x47"
+			"\xd6\x83\x85\x3b\x30\xea\xa9\x6b"
+			"\x63\xea\xc4\x07\xfb\x43\x2f\xa4"
+			"\xaa\xb0\xab\x03\x89\xce\x3f\x8c"
+			"\x02\x7c\x86\x54\xbc\x88\xaf\x75"
+			"\xd2\xdc\x63\x17\xd3\x26\xf6\x96"
+			"\xa9\x3c\xf1\x61\x8c\x11\x18\xcc"
+			"\xd6\xea\x5b\xe2\xcd\xf0\xf1\xb2"
+			"\xe5\x35\x90\x1f\x85\x4c\x76\x5b"
+			"\x66\xce\x44\xa4\x32\x9f\xe6\x7b"
+			"\x71\x6e\x9f\x58\x15\x67\x72\x87"
+			"\x64\x8e\x3a\x44\x45\xd4\x76\xfa"
+			"\xc2\xf6\xef\x85\x05\x18\x7a\x9b"
+			"\xba\x41\x54\xac\xf0\xfc\x59\x12"
+			"\x3f\xdf\xa0\xe5\x8a\x65\xfd\x3a"
+			"\x62\x8d\x83\x2c\x03\xbe\x05\x76"
+			"\x2e\x53\x49\x97\x94\x33\xae\x40"
+			"\x81\x15\xdb\x6e\xad\xaa\xf5\x4b"
+			"\xe3\x98\x70\xdf\xe0\x7c\xcd\xdb"
+			"\x02\xd4\x7d\x2f\xc1\xe6\xb4\xf3"
+			"\xd7\x0d\x7a\xd9\x23\x9e\x87\x2d"
+			"\xce\x87\xad\xcc\x72\x05\x00\x29"
+			"\xdc\x73\x7f\x64\xc1\x15\x0e\xc2"
+			"\xdf\xa7\x5f\xeb\x41\xa1\xcd\xef"
+			"\x5c\x50\x79\x2a\x56\x56\x71\x8c"
+			"\xac\xc0\x79\x50\x69\xca\x59\x32"
+			"\x65\xf2\x54\xe4\x52\x38\x76\xd1"
+			"\x5e\xde\x26\x9e\xfb\x75\x2e\x11"
+			"\xb5\x10\xf4\x17\x73\xf5\x89\xc7"
+			"\x4f\x43\x5c\x8e\x7c\xb9\x05\x52"
+			"\x24\x40\x99\xfe\x9b\x85\x0b\x6c"
+			"\x22\x3e\x8b\xae\x86\xa1\xd2\x79"
+			"\x05\x68\x6b\xab\xe3\x41\x49\xed"
+			"\x15\xa1\x8d\x40\x2d\x61\xdf\x1a"
+			"\x59\xc9\x26\x8b\xef\x30\x4c\x88"
+			"\x4b\x10\xf8\x8d\xa6\x92\x9f\x4b"
+			"\xf3\xc4\x53\x0b\x89\x5d\x28\x92"
+			"\xcf\x78\xb2\xc0\x5d\xed\x7e\xfc"
+			"\xc0\x12\x23\x5f\x5a\x78\x86\x43"
+			"\x6e\x27\xf7\x5a\xa7\x6a\xed\x19"
+			"\x04\xf0\xb3\x12\xd1\xbd\x0e\x89"
+			"\x6e\xbc\x96\xa8\xd8\x49\x39\x9f"
+			"\x7e\x67\xf0\x2e\x3e\x01\xa9\xba"
+			"\xec\x8b\x62\x8e\xcb\x4a\x70\x43"
+			"\xc7\xc2\xc4\xca\x82\x03\x73\xe9"
+			"\x11\xdf\xcf\x54\xea\xc9\xb0\x95"
+			"\x51\xc0\x13\x3d\x92\x05\xfa\xf4"
+			"\xa9\x34\xc8\xce\x6c\x3d\x54\xcc"
+			"\xc4\xaf\xf1\xdc\x11\x44\x26\xa2"
+			"\xaf\xf1\x85\x75\x7d\x03\x61\x68"
+			"\x4e\x78\xc6\x92\x7d\x86\x7d\x77"
+			"\xdc\x71\x72\xdb\xc6\xae\xa1\xcb"
+			"\x70\x9a\x0b\x19\xbe\x4a\x6c\x2a"
+			"\xe2\xba\x6c\x64\x9a\x13\x28\xdf"
+			"\x85\x75\xe6\x43\xf6\x87\x08\x68"
+			"\x6e\xba\x6e\x79\x9f\x04\xbc\x23"
+			"\x50\xf6\x33\x5c\x1f\x24\x25\xbe"
+			"\x33\x47\x80\x45\x56\xa3\xa7\xd7"
+			"\x7a\xb1\x34\x0b\x90\x3c\x9c\xad"
+			"\x44\x5f\x9e\x0e\x9d\xd4\xbd\x93"
+			"\x5e\xfa\x3c\xe0\xb0\xd9\xed\xf3"
+			"\xd6\x2e\xff\x24\xd8\x71\x6c\xed"
+			"\xaf\x55\xeb\x22\xac\x93\x68\x32"
+			"\x05\x5b\x47\xdd\xc6\x4a\xcb\xc7"
+			"\x10\xe1\x3c\x92\x1a\xf3\x23\x78"
+			"\x2b\xa1\xd2\x80\xf4\x12\xb1\x20"
+			"\x8f\xff\x26\x35\xdd\xfb\xc7\x4e"
+			"\x78\xf1\x2d\x50\x12\x77\xa8\x60"
+			"\x7c\x0f\xf5\x16\x2f\x63\x70\x2a"
+			"\xc0\x96\x80\x4e\x0a\xb4\x93\x35"
+			"\x5d\x1d\x3f\x56\xf7\x2f\xbb\x90"
+			"\x11\x16\x8f\xa2\xec\x47\xbe\xac"
+			"\x56\x01\x26\x56\xb1\x8c\xb2\x10"
+			"\xf9\x1a\xca\xf5\xd1\xb7\x39\x20"
+			"\x63\xf1\x69\x20\x4f\x13\x12\x1f"
+			"\x5b\x65\xfc\x98\xf7\xc4\x7a\xbe"
+			"\xf7\x26\x4d\x2b\x84\x7b\x42\xad"
+			"\xd8\x7a\x0a\xb4\xd8\x74\xbf\xc1"
+			"\xf0\x6e\xb4\x29\xa3\xbb\xca\x46"
+			"\x67\x70\x6a\x2d\xce\x0e\xa2\x8a"
+			"\xa9\x87\xbf\x05\xc4\xc1\x04\xa3"
+			"\xab\xd4\x45\x43\x8c\xb6\x02\xb0"
+			"\x41\xc8\xfc\x44\x3d\x59\xaa\x2e"
+			"\x44\x21\x2a\x8d\x88\x9d\x57\xf4"
+			"\xa0\x02\x77\xb8\xa6\xa0\xe6\x75"
+			"\x5c\x82\x65\x3e\x03\x5c\x29\x8f"
+			"\x38\x55\xab\x33\x26\xef\x9f\x43"
+			"\x52\xfd\x68\xaf\x36\xb4\xbb\x9a"
+			"\x58\x09\x09\x1b\xc3\x65\x46\x46"
+			"\x1d\xa7\x94\x18\x23\x50\x2c\xca"
+			"\x2c\x55\x19\x97\x01\x9d\x93\x3b"
+			"\x63\x86\xf2\x03\x67\x45\xd2\x72"
+			"\x28\x52\x6c\xf4\xe3\x1c\xb5\x11"
+			"\x13\xf1\xeb\x21\xc7\xd9\x56\x82"
+			"\x2b\x82\x39\xbd\x69\x54\xed\x62"
+			"\xc3\xe2\xde\x73\xd4\x6a\x12\xae"
+			"\x13\x21\x7f\x4b\x5b\xfc\xbf\xe8"
+			"\x2b\xbe\x56\xba\x68\x8b\x9a\xb1"
+			"\x6e\xfa\xbf\x7e\x5a\x4b\xf1\xac"
+			"\x98\x65\x85\xd1\x93\x53\xd3\x7b"
+			"\x09\xdd\x4b\x10\x6d\x84\xb0\x13"
+			"\x65\xbd\xcf\x52\x09\xc4\x85\xe2"
+			"\x84\x74\x15\x65\xb7\xf7\x51\xaf"
+			"\x55\xad\xa4\xd1\x22\x54\x70\x94"
+			"\xa0\x1c\x90\x41\xfd\x99\xd7\x5a"
+			"\x31\xef\xaa\x25\xd0\x7f\x4f\xea"
+			"\x1d\x55\x42\xe5\x49\xb0\xd0\x46"
+			"\x62\x36\x43\xb2\x82\x15\x75\x50"
+			"\xa4\x72\xeb\x54\x27\x1f\x8a\xe4"
+			"\x7d\xe9\x66\xc5\xf1\x53\xa4\xd1"
+			"\x0c\xeb\xb8\xf8\xbc\xd4\xe2\xe7"
+			"\xe1\xf8\x4b\xcb\xa9\xa1\xaf\x15"
+			"\x83\xcb\x72\xd0\x33\x79\x00\x2d"
+			"\x9f\xd7\xf1\x2e\x1e\x10\xe4\x45"
+			"\xc0\x75\x3a\x39\xea\x68\xf7\x5d"
+			"\x1b\x73\x8f\xe9\x8e\x0f\x72\x47"
+			"\xae\x35\x0a\x31\x7a\x14\x4d\x4a"
+			"\x6f\x47\xf7\x7e\x91\x6e\x74\x8b"
+			"\x26\x47\xf9\xc3\xf9\xde\x70\xf5"
+			"\x61\xab\xa9\x27\x9f\x82\xe4\x9c"
+			"\x89\x91\x3f\x2e\x6a\xfd\xb5\x49"
+			"\xe9\xfd\x59\x14\x36\x49\x40\x6d"
+			"\x32\xd8\x85\x42\xf3\xa5\xdf\x0c"
+			"\xa8\x27\xd7\x54\xe2\x63\x2f\xf2"
+			"\x7e\x8b\x8b\xe7\xf1\x9a\x95\x35"
+			"\x43\xdc\x3a\xe4\xb6\xf4\xd0\xdf"
+			"\x9c\xcb\x94\xf3\x21\xa0\x77\x50"
+			"\xe2\xc6\xc4\xc6\x5f\x09\x64\x5b"
+			"\x92\x90\xd8\xe1\xd1\xed\x4b\x42"
+			"\xd7\x37\xaf\x65\x3d\x11\x39\xb6"
+			"\x24\x8a\x60\xae\xd6\x1e\xbf\x0e"
+			"\x0d\xd7\xdc\x96\x0e\x65\x75\x4e"
+			"\x29\x06\x9d\xa4\x51\x3a\x10\x63"
+			"\x8f\x17\x07\xd5\x8e\x3c\xf4\x28"
+			"\x00\x5a\x5b\x05\x19\xd8\xc0\x6c"
+			"\xe5\x15\xe4\x9c\x9d\x71\x9d\x5e"
+			"\x94\x29\x1a\xa7\x80\xfa\x0e\x33"
+			"\x03\xdd\xb7\x3e\x9a\xa9\x26\x18"
+			"\x37\xa9\x64\x08\x4d\x94\x5a\x88"
+			"\xca\x35\xce\x81\x02\xe3\x1f\x1b"
+			"\x89\x1a\x77\x85\xe3\x41\x6d\x32"
+			"\x42\x19\x23\x7d\xc8\x73\xee\x25"
+			"\x85\x0d\xf8\x31\x25\x79\x1b\x6f"
+			"\x79\x25\xd2\xd8\xd4\x23\xfd\xf7"
+			"\x82\x36\x6a\x0c\x46\x22\x15\xe9"
+			"\xff\x72\x41\x91\x91\x7d\x3a\xb7"
+			"\xdd\x65\x99\x70\xf6\x8d\x84\xf8"
+			"\x67\x15\x20\x11\xd6\xb2\x55\x7b"
+			"\xdb\x87\xee\xef\x55\x89\x2a\x59"
+			"\x2b\x07\x8f\x43\x8a\x59\x3c\x01"
+			"\x8b\x65\x54\xa1\x66\xd5\x38\xbd"
+			"\xc6\x30\xa9\xcc\x49\xb6\xa8\x1b"
+			"\xb8\xc0\x0e\xe3\x45\x28\xe2\xff"
+			"\x41\x9f\x7e\x7c\xd1\xae\x9e\x25"
+			"\x3f\x4c\x7c\x7c\xf4\xa8\x26\x4d"
+			"\x5c\xfd\x4b\x27\x18\xf9\x61\x76"
+			"\x48\xba\x0c\x6b\xa9\x4d\xfc\xf5"
+			"\x3b\x35\x7e\x2f\x4a\xa9\xc2\x9a"
+			"\xae\xab\x86\x09\x89\xc9\xc2\x40"
+			"\x39\x2c\x81\xb3\xb8\x17\x67\xc2"
+			"\x0d\x32\x4a\x3a\x67\x81\xd7\x1a"
+			"\x34\x52\xc5\xdb\x0a\xf5\x63\x39"
+			"\xea\x1f\xe1\x7c\xa1\x9e\xc1\x35"
+			"\xe3\xb1\x18\x45\x67\xf9\x22\x38"
+			"\x95\xd9\x34\x34\x86\xc6\x41\x94"
+			"\x15\xf9\x5b\x41\xa6\x87\x8b\xf8"
+			"\xd5\xe1\x1b\xe2\x5b\xf3\x86\x10"
+			"\xff\xe6\xae\x69\x76\xbc\x0d\xb4"
+			"\x09\x90\x0c\xa2\x65\x0c\xad\x74"
+			"\xf5\xd7\xff\xda\xc1\xce\x85\xbe"
+			"\x00\xa7\xff\x4d\x2f\x65\xd3\x8c"
+			"\x86\x2d\x05\xe8\xed\x3e\x6b\x8b"
+			"\x0f\x3d\x83\x8c\xf1\x1d\x5b\x96"
+			"\x2e\xb1\x9c\xc2\x98\xe1\x70\xb9"
+			"\xba\x5c\x8a\x43\xd6\x34\xa7\x2d"
+			"\xc9\x92\xae\xf2\xa5\x7b\x05\x49"
+			"\xa7\x33\x34\x86\xca\xe4\x96\x23"
+			"\x76\x5b\xf2\xc6\xf1\x51\x28\x42"
+			"\x7b\xcc\x76\x8f\xfa\xa2\xad\x31"
+			"\xd4\xd6\x7a\x6d\x25\x25\x54\xe4"
+			"\x3f\x50\x59\xe1\x5c\x05\xb7\x27"
+			"\x48\xbf\x07\xec\x1b\x13\xbe\x2b"
+			"\xa1\x57\x2b\xd5\xab\xd7\xd0\x4c"
+			"\x1e\xcb\x71\x9b\xc5\x90\x85\xd3"
+			"\xde\x59\xec\x71\xeb\x89\xbb\xd0"
+			"\x09\x50\xe1\x16\x3f\xfd\x1c\x34"
+			"\xc3\x1c\xa1\x10\x77\x53\x98\xef"
+			"\xf2\xfd\xa5\x01\x59\xc2\x9b\x26"
+			"\xc7\x42\xd9\x49\xda\x58\x2b\x6e"
+			"\x9f\x53\x19\x76\x7e\xd9\xc9\x0e"
+			"\x68\xc8\x7f\x51\x22\x42\xef\x49"
+			"\xa4\x55\xb6\x36\xac\x09\xc7\x31"
+			"\x88\x15\x4b\x2e\x8f\x3a\x08\xf7"
+			"\xd8\xf7\xa8\xc5\xa9\x33\xa6\x45"
+			"\xe4\xc4\x94\x76\xf3\x0d\x8f\x7e"
+			"\xc8\xf6\xbc\x23\x0a\xb6\x4c\xd3"
+			"\x6a\xcd\x36\xc2\x90\x5c\x5c\x3c"
+			"\x65\x7b\xc2\xd6\xcc\xe6\x0d\x87"
+			"\x73\x2e\x71\x79\x16\x06\x63\x28"
+			"\x09\x15\xd8\x89\x38\x38\x3d\xb5"
+			"\x42\x1c\x08\x24\xf7\x2a\xd2\x9d"
+			"\xc8\xca\xef\xf9\x27\xd8\x07\x86"
+			"\xf7\x43\x0b\x55\x15\x3f\x9f\x83"
+			"\xef\xdc\x49\x9d\x2a\xc1\x54\x62"
+			"\xbd\x9b\x66\x55\x9f\xb7\x12\xf3"
+			"\x1b\x4d\x9d\x2a\x5c\xed\x87\x75"
+			"\x87\x26\xec\x61\x2c\xb4\x0f\x89"
+			"\xb0\xfb\x2e\x68\x5d\x15\xc7\x8d"
+			"\x2e\xc0\xd9\xec\xaf\x4f\xd2\x25"
+			"\x29\xe8\xd2\x26\x2b\x67\xe9\xfc"
+			"\x2b\xa8\x67\x96\x12\x1f\x5b\x96"
+			"\xc6\x14\x53\xaf\x44\xea\xd6\xe2"
+			"\x94\x98\xe4\x12\x93\x4c\x92\xe0"
+			"\x18\xa5\x8d\x2d\xe4\x71\x3c\x47"
+			"\x4c\xf7\xe6\x47\x9e\xc0\x68\xdf"
+			"\xd4\xf5\x5a\x74\xb1\x2b\x29\x03"
+			"\x19\x07\xaf\x90\x62\x5c\x68\x98"
+			"\x48\x16\x11\x02\x9d\xee\xb4\x9b"
+			"\xe5\x42\x7f\x08\xfd\x16\x32\x0b"
+			"\xd0\xb3\xfa\x2b\xb7\x99\xf9\x29"
+			"\xcd\x20\x45\x9f\xb3\x1a\x5d\xa2"
+			"\xaf\x4d\xe0\xbd\x42\x0d\xbc\x74"
+			"\x99\x9c\x8e\x53\x1a\xb4\x3e\xbd"
+			"\xa2\x9a\x2d\xf7\xf8\x39\x0f\x67"
+			"\x63\xfc\x6b\xc0\xaf\xb3\x4b\x4f"
+			"\x55\xc4\xcf\xa7\xc8\x04\x11\x3e"
+			"\x14\x32\xbb\x1b\x38\x77\xd6\x7f"
+			"\x54\x4c\xdf\x75\xf3\x07\x2d\x33"
+			"\x9b\xa8\x20\xe1\x7b\x12\xb5\xf3"
+			"\xef\x2f\xce\x72\xe5\x24\x60\xc1"
+			"\x30\xe2\xab\xa1\x8e\x11\x09\xa8"
+			"\x21\x33\x44\xfe\x7f\x35\x32\x93"
+			"\x39\xa7\xad\x8b\x79\x06\xb2\xcb"
+			"\x4e\xa9\x5f\xc7\xba\x74\x29\xec"
+			"\x93\xa0\x4e\x54\x93\xc0\xbc\x55"
+			"\x64\xf0\x48\xe5\x57\x99\xee\x75"
+			"\xd6\x79\x0f\x66\xb7\xc6\x57\x76"
+			"\xf7\xb7\xf3\x9c\xc5\x60\xe8\x7f"
+			"\x83\x76\xd6\x0e\xaa\xe6\x90\x39"
+			"\x1d\xa6\x32\x6a\x34\xe3\x55\xf8"
+			"\x58\xa0\x58\x7d\x33\xe0\x22\x39"
+			"\x44\x64\x87\x86\x5a\x2f\xa7\x7e"
+			"\x0f\x38\xea\xb0\x30\xcc\x61\xa5"
+			"\x6a\x32\xae\x1e\xf7\xe9\xd0\xa9"
+			"\x0c\x32\x4b\xb5\x49\x28\xab\x85"
+			"\x2f\x8e\x01\x36\x38\x52\xd0\xba"
+			"\xd6\x02\x78\xf8\x0e\x3e\x9c\x8b"
+			"\x6b\x45\x99\x3f\x5c\xfe\x58\xf1"
+			"\x5c\x94\x04\xe1\xf5\x18\x6d\x51"
+			"\xb2\x5d\x18\x20\xb6\xc2\x9a\x42"
+			"\x1d\xb3\xab\x3c\xb6\x3a\x13\x03"
+			"\xb2\x46\x82\x4f\xfc\x64\xbc\x4f"
+			"\xca\xfa\x9c\xc0\xd5\xa7\xbd\x11"
+			"\xb7\xe4\x5a\xf6\x6f\x4d\x4d\x54"
+			"\xea\xa4\x98\x66\xd4\x22\x3b\xd3"
+			"\x8f\x34\x47\xd9\x7c\xf4\x72\x3b"
+			"\x4d\x02\x77\xf6\xd6\xdd\x08\x0a"
+			"\x81\xe1\x86\x89\x3e\x56\x10\x3c"
+			"\xba\xd7\x81\x8c\x08\xbc\x8b\xe2"
+			"\x53\xec\xa7\x89\xee\xc8\x56\xb5"
+			"\x36\x2c\xb2\x03\xba\x99\xdd\x7c"
+			"\x48\xa0\xb0\xbc\x91\x33\xe9\xa8"
+			"\xcb\xcd\xcf\x59\x5f\x1f\x15\xe2"
+			"\x56\xf5\x4e\x01\x35\x27\x45\x77"
+			"\x47\xc8\xbc\xcb\x7e\x39\xc1\x97"
+			"\x28\xd3\x84\xfc\x2c\x3e\xc8\xad"
+			"\x9c\xf8\x8a\x61\x9c\x28\xaa\xc5"
+			"\x99\x20\x43\x85\x9d\xa5\xe2\x8b"
+			"\xb8\xae\xeb\xd0\x32\x0d\x52\x78"
+			"\x09\x56\x3f\xc7\xd8\x7e\x26\xfc"
+			"\x37\xfb\x6f\x04\xfc\xfa\x92\x10"
+			"\xac\xf8\x3e\x21\xdc\x8c\x21\x16"
+			"\x7d\x67\x6e\xf6\xcd\xda\xb6\x98"
+			"\x23\xab\x23\x3c\xb2\x10\xa0\x53"
+			"\x5a\x56\x9f\xc5\xd0\xff\xbb\xe4"
+			"\x98\x3c\x69\x1e\xdb\x38\x8f\x7e"
+			"\x0f\xd2\x98\x88\x81\x8b\x45\x67"
+			"\xea\x33\xf1\xeb\xe9\x97\x55\x2e"
+			"\xd9\xaa\xeb\x5a\xec\xda\xe1\x68"
+			"\xa8\x9d\x3c\x84\x7c\x05\x3d\x62"
+			"\x87\x8f\x03\x21\x28\x95\x0c\x89"
+			"\x25\x22\x4a\xb0\x93\xa9\x50\xa2"
+			"\x2f\x57\x6e\x18\x42\x19\x54\x0c"
+			"\x55\x67\xc6\x11\x49\xf4\x5c\xd2"
+			"\xe9\x3d\xdd\x8b\x48\x71\x21\x00"
+			"\xc3\x9a\x6c\x85\x74\x28\x83\x4a"
+			"\x1b\x31\x05\xe1\x06\x92\xe7\xda"
+			"\x85\x73\x78\x45\x20\x7f\xae\x13"
+			"\x7c\x33\x06\x22\xf4\x83\xf9\x35"
+			"\x3f\x6c\x71\xa8\x4e\x48\xbe\x9b"
+			"\xce\x8a\xba\xda\xbe\x28\x08\xf7"
+			"\xe2\x14\x8c\x71\xea\x72\xf9\x33"
+			"\xf2\x88\x3f\xd7\xbb\x69\x6c\x29"
+			"\x19\xdc\x84\xce\x1f\x12\x4f\xc8"
+			"\xaf\xa5\x04\xba\x5a\xab\xb0\xd9"
+			"\x14\x1f\x6c\x68\x98\x39\x89\x7a"
+			"\xd9\xd8\x2f\xdf\xa8\x47\x4a\x25"
+			"\xe2\xfb\x33\xf4\x59\x78\xe1\x68"
+			"\x85\xcf\xfe\x59\x20\xd4\x05\x1d"
+			"\x80\x99\xae\xbc\xca\xae\x0f\x2f"
+			"\x65\x43\x34\x8e\x7e\xac\xd3\x93"
+			"\x2f\xac\x6d\x14\x3d\x02\x07\x70"
+			"\x9d\xa4\xf3\x1b\x5c\x36\xfc\x01"
+			"\x73\x34\x85\x0c\x6c\xd6\xf1\xbd"
+			"\x3f\xdf\xee\xf5\xd9\xba\x56\xef"
+			"\xf4\x9b\x6b\xee\x9f\x5a\x78\x6d"
+			"\x32\x19\xf4\xf7\xf8\x4c\x69\x0b"
+			"\x4b\xbc\xbb\xb7\xf2\x85\xaf\x70"
+			"\x75\x24\x6c\x54\xa7\x0e\x4d\x1d"
+			"\x01\xbf\x08\xac\xcf\x7f\x2c\xe3"
+			"\x14\x89\x5e\x70\x5a\x99\x92\xcd"
+			"\x01\x84\xc8\xd2\xab\xe5\x4f\x58"
+			"\xe7\x0f\x2f\x0e\xff\x68\xea\xfd"
+			"\x15\xb3\x17\xe6\xb0\xe7\x85\xd8"
+			"\x23\x2e\x05\xc7\xc9\xc4\x46\x1f"
+			"\xe1\x9e\x49\x20\x23\x24\x4d\x7e"
+			"\x29\x65\xff\xf4\xb6\xfd\x1a\x85"
+			"\xc4\x16\xec\xfc\xea\x7b\xd6\x2c"
+			"\x43\xf8\xb7\xbf\x79\xc0\x85\xcd"
+			"\xef\xe1\x98\xd3\xa5\xf7\x90\x8c"
+			"\xe9\x7f\x80\x6b\xd2\xac\x4c\x30"
+			"\xa7\xc6\x61\x6c\xd2\xf9\x2c\xff"
+			"\x30\xbc\x22\x81\x7d\x93\x12\xe4"
+			"\x0a\xcd\xaf\xdd\xe8\xab\x0a\x1e"
+			"\x13\xa4\x27\xc3\x5f\xf7\x4b\xbb"
+			"\x37\x09\x4b\x91\x6f\x92\x4f\xaf"
+			"\x52\xee\xdf\xef\x09\x6f\xf7\x5c"
+			"\x6e\x12\x17\x72\x63\x57\xc7\xba"
+			"\x3b\x6b\x38\x32\x73\x1b\x9c\x80"
+			"\xc1\x7a\xc6\xcf\xcd\x35\xc0\x6b"
+			"\x31\x1a\x6b\xe9\xd8\x2c\x29\x3f"
+			"\x96\xfb\xb6\xcd\x13\x91\x3b\xc2"
+			"\xd2\xa3\x31\x8d\xa4\xcd\x57\xcd"
+			"\x13\x3d\x64\xfd\x06\xce\xe6\xdc"
+			"\x0c\x24\x43\x31\x40\x57\xf1\x72"
+			"\x17\xe3\x3a\x63\x6d\x35\xcf\x5d"
+			"\x97\x40\x59\xdd\xf7\x3c\x02\xf7"
+			"\x1c\x7e\x05\xbb\xa9\x0d\x01\xb1"
+			"\x8e\xc0\x30\xa9\x53\x24\xc9\x89"
+			"\x84\x6d\xaa\xd0\xcd\x91\xc2\x4d"
+			"\x91\xb0\x89\xe2\xbf\x83\x44\xaa"
+			"\x28\x72\x23\xa0\xc2\xad\xad\x1c"
+			"\xfc\x3f\x09\x7a\x0b\xdc\xc5\x1b"
+			"\x87\x13\xc6\x5b\x59\x8d\xf2\xc8"
+			"\xaf\xdf\x11\x95",
+		.rlen = 4100,
+	},
+};
+
+/*
+ * CTS (Cipher Text Stealing) mode tests
+ */
+#define CTS_MODE_ENC_TEST_VECTORS 6
+#define CTS_MODE_DEC_TEST_VECTORS 6
+static struct cipher_testvec cts_mode_enc_tv_template[] = {
+	{ /* from rfc3962 */
+		.klen	= 16,
+		.key    = "\x63\x68\x69\x63\x6b\x65\x6e\x20"
+			  "\x74\x65\x72\x69\x79\x61\x6b\x69",
+		.ilen	= 17,
+		.input  = "\x49\x20\x77\x6f\x75\x6c\x64\x20"
+			  "\x6c\x69\x6b\x65\x20\x74\x68\x65"
+			  "\x20",
+		.rlen	= 17,
+		.result	= "\xc6\x35\x35\x68\xf2\xbf\x8c\xb4"
+			  "\xd8\xa5\x80\x36\x2d\xa7\xff\x7f"
+			  "\x97",
+	}, {
+		.klen	= 16,
+		.key    = "\x63\x68\x69\x63\x6b\x65\x6e\x20"
+			  "\x74\x65\x72\x69\x79\x61\x6b\x69",
+		.ilen   = 31,
+		.input  = "\x49\x20\x77\x6f\x75\x6c\x64\x20"
+			  "\x6c\x69\x6b\x65\x20\x74\x68\x65"
+			  "\x20\x47\x65\x6e\x65\x72\x61\x6c"
+			  "\x20\x47\x61\x75\x27\x73\x20",
+		.rlen   = 31,
+		.result = "\xfc\x00\x78\x3e\x0e\xfd\xb2\xc1"
+			  "\xd4\x45\xd4\xc8\xef\xf7\xed\x22"
+			  "\x97\x68\x72\x68\xd6\xec\xcc\xc0"
+			  "\xc0\x7b\x25\xe2\x5e\xcf\xe5",
+	}, {
+		.klen	= 16,
+		.key    = "\x63\x68\x69\x63\x6b\x65\x6e\x20"
+			  "\x74\x65\x72\x69\x79\x61\x6b\x69",
+		.ilen   = 32,
+		.input  = "\x49\x20\x77\x6f\x75\x6c\x64\x20"
+			  "\x6c\x69\x6b\x65\x20\x74\x68\x65"
+			  "\x20\x47\x65\x6e\x65\x72\x61\x6c"
+			  "\x20\x47\x61\x75\x27\x73\x20\x43",
+		.rlen   = 32,
+		.result = "\x39\x31\x25\x23\xa7\x86\x62\xd5"
+			  "\xbe\x7f\xcb\xcc\x98\xeb\xf5\xa8"
+			  "\x97\x68\x72\x68\xd6\xec\xcc\xc0"
+			  "\xc0\x7b\x25\xe2\x5e\xcf\xe5\x84",
+	}, {
+		.klen	= 16,
+		.key    = "\x63\x68\x69\x63\x6b\x65\x6e\x20"
+			  "\x74\x65\x72\x69\x79\x61\x6b\x69",
+		.ilen   = 47,
+		.input  = "\x49\x20\x77\x6f\x75\x6c\x64\x20"
+			  "\x6c\x69\x6b\x65\x20\x74\x68\x65"
+			  "\x20\x47\x65\x6e\x65\x72\x61\x6c"
+			  "\x20\x47\x61\x75\x27\x73\x20\x43"
+			  "\x68\x69\x63\x6b\x65\x6e\x2c\x20"
+			  "\x70\x6c\x65\x61\x73\x65\x2c",
+		.rlen   = 47,
+		.result = "\x97\x68\x72\x68\xd6\xec\xcc\xc0"
+			  "\xc0\x7b\x25\xe2\x5e\xcf\xe5\x84"
+			  "\xb3\xff\xfd\x94\x0c\x16\xa1\x8c"
+			  "\x1b\x55\x49\xd2\xf8\x38\x02\x9e"
+			  "\x39\x31\x25\x23\xa7\x86\x62\xd5"
+			  "\xbe\x7f\xcb\xcc\x98\xeb\xf5",
+	}, {
+		.klen	= 16,
+		.key    = "\x63\x68\x69\x63\x6b\x65\x6e\x20"
+			  "\x74\x65\x72\x69\x79\x61\x6b\x69",
+		.ilen   = 48,
+		.input  = "\x49\x20\x77\x6f\x75\x6c\x64\x20"
+			  "\x6c\x69\x6b\x65\x20\x74\x68\x65"
+			  "\x20\x47\x65\x6e\x65\x72\x61\x6c"
+			  "\x20\x47\x61\x75\x27\x73\x20\x43"
+			  "\x68\x69\x63\x6b\x65\x6e\x2c\x20"
+			  "\x70\x6c\x65\x61\x73\x65\x2c\x20",
+		.rlen   = 48,
+		.result = "\x97\x68\x72\x68\xd6\xec\xcc\xc0"
+			  "\xc0\x7b\x25\xe2\x5e\xcf\xe5\x84"
+			  "\x9d\xad\x8b\xbb\x96\xc4\xcd\xc0"
+			  "\x3b\xc1\x03\xe1\xa1\x94\xbb\xd8"
+			  "\x39\x31\x25\x23\xa7\x86\x62\xd5"
+			  "\xbe\x7f\xcb\xcc\x98\xeb\xf5\xa8",
+	}, {
+		.klen	= 16,
+		.key    = "\x63\x68\x69\x63\x6b\x65\x6e\x20"
+			  "\x74\x65\x72\x69\x79\x61\x6b\x69",
+		.ilen   = 64,
+		.input  = "\x49\x20\x77\x6f\x75\x6c\x64\x20"
+			  "\x6c\x69\x6b\x65\x20\x74\x68\x65"
+			  "\x20\x47\x65\x6e\x65\x72\x61\x6c"
+			  "\x20\x47\x61\x75\x27\x73\x20\x43"
+			  "\x68\x69\x63\x6b\x65\x6e\x2c\x20"
+			  "\x70\x6c\x65\x61\x73\x65\x2c\x20"
+			  "\x61\x6e\x64\x20\x77\x6f\x6e\x74"
+			  "\x6f\x6e\x20\x73\x6f\x75\x70\x2e",
+		.rlen   = 64,
+		.result = "\x97\x68\x72\x68\xd6\xec\xcc\xc0"
+			  "\xc0\x7b\x25\xe2\x5e\xcf\xe5\x84"
+			  "\x39\x31\x25\x23\xa7\x86\x62\xd5"
+			  "\xbe\x7f\xcb\xcc\x98\xeb\xf5\xa8"
+			  "\x48\x07\xef\xe8\x36\xee\x89\xa5"
+			  "\x26\x73\x0d\xbc\x2f\x7b\xc8\x40"
+			  "\x9d\xad\x8b\xbb\x96\xc4\xcd\xc0"
+			  "\x3b\xc1\x03\xe1\xa1\x94\xbb\xd8",
+	}
+};
+
+static struct cipher_testvec cts_mode_dec_tv_template[] = {
+	{ /* from rfc3962 */
+		.klen	= 16,
+		.key    = "\x63\x68\x69\x63\x6b\x65\x6e\x20"
+			  "\x74\x65\x72\x69\x79\x61\x6b\x69",
+		.rlen	= 17,
+		.result = "\x49\x20\x77\x6f\x75\x6c\x64\x20"
+			  "\x6c\x69\x6b\x65\x20\x74\x68\x65"
+			  "\x20",
+		.ilen	= 17,
+		.input	= "\xc6\x35\x35\x68\xf2\xbf\x8c\xb4"
+			  "\xd8\xa5\x80\x36\x2d\xa7\xff\x7f"
+			  "\x97",
+	}, {
+		.klen	= 16,
+		.key    = "\x63\x68\x69\x63\x6b\x65\x6e\x20"
+			  "\x74\x65\x72\x69\x79\x61\x6b\x69",
+		.rlen   = 31,
+		.result = "\x49\x20\x77\x6f\x75\x6c\x64\x20"
+			  "\x6c\x69\x6b\x65\x20\x74\x68\x65"
+			  "\x20\x47\x65\x6e\x65\x72\x61\x6c"
+			  "\x20\x47\x61\x75\x27\x73\x20",
+		.ilen   = 31,
+		.input  = "\xfc\x00\x78\x3e\x0e\xfd\xb2\xc1"
+			  "\xd4\x45\xd4\xc8\xef\xf7\xed\x22"
+			  "\x97\x68\x72\x68\xd6\xec\xcc\xc0"
+			  "\xc0\x7b\x25\xe2\x5e\xcf\xe5",
+	}, {
+		.klen	= 16,
+		.key    = "\x63\x68\x69\x63\x6b\x65\x6e\x20"
+			  "\x74\x65\x72\x69\x79\x61\x6b\x69",
+		.rlen   = 32,
+		.result = "\x49\x20\x77\x6f\x75\x6c\x64\x20"
+			  "\x6c\x69\x6b\x65\x20\x74\x68\x65"
+			  "\x20\x47\x65\x6e\x65\x72\x61\x6c"
+			  "\x20\x47\x61\x75\x27\x73\x20\x43",
+		.ilen   = 32,
+		.input  = "\x39\x31\x25\x23\xa7\x86\x62\xd5"
+			  "\xbe\x7f\xcb\xcc\x98\xeb\xf5\xa8"
+			  "\x97\x68\x72\x68\xd6\xec\xcc\xc0"
+			  "\xc0\x7b\x25\xe2\x5e\xcf\xe5\x84",
+	}, {
+		.klen	= 16,
+		.key    = "\x63\x68\x69\x63\x6b\x65\x6e\x20"
+			  "\x74\x65\x72\x69\x79\x61\x6b\x69",
+		.rlen   = 47,
+		.result = "\x49\x20\x77\x6f\x75\x6c\x64\x20"
+			  "\x6c\x69\x6b\x65\x20\x74\x68\x65"
+			  "\x20\x47\x65\x6e\x65\x72\x61\x6c"
+			  "\x20\x47\x61\x75\x27\x73\x20\x43"
+			  "\x68\x69\x63\x6b\x65\x6e\x2c\x20"
+			  "\x70\x6c\x65\x61\x73\x65\x2c",
+		.ilen   = 47,
+		.input  = "\x97\x68\x72\x68\xd6\xec\xcc\xc0"
+			  "\xc0\x7b\x25\xe2\x5e\xcf\xe5\x84"
+			  "\xb3\xff\xfd\x94\x0c\x16\xa1\x8c"
+			  "\x1b\x55\x49\xd2\xf8\x38\x02\x9e"
+			  "\x39\x31\x25\x23\xa7\x86\x62\xd5"
+			  "\xbe\x7f\xcb\xcc\x98\xeb\xf5",
+	}, {
+		.klen	= 16,
+		.key    = "\x63\x68\x69\x63\x6b\x65\x6e\x20"
+			  "\x74\x65\x72\x69\x79\x61\x6b\x69",
+		.rlen   = 48,
+		.result = "\x49\x20\x77\x6f\x75\x6c\x64\x20"
+			  "\x6c\x69\x6b\x65\x20\x74\x68\x65"
+			  "\x20\x47\x65\x6e\x65\x72\x61\x6c"
+			  "\x20\x47\x61\x75\x27\x73\x20\x43"
+			  "\x68\x69\x63\x6b\x65\x6e\x2c\x20"
+			  "\x70\x6c\x65\x61\x73\x65\x2c\x20",
+		.ilen   = 48,
+		.input  = "\x97\x68\x72\x68\xd6\xec\xcc\xc0"
+			  "\xc0\x7b\x25\xe2\x5e\xcf\xe5\x84"
+			  "\x9d\xad\x8b\xbb\x96\xc4\xcd\xc0"
+			  "\x3b\xc1\x03\xe1\xa1\x94\xbb\xd8"
+			  "\x39\x31\x25\x23\xa7\x86\x62\xd5"
+			  "\xbe\x7f\xcb\xcc\x98\xeb\xf5\xa8",
+	}, {
+		.klen	= 16,
+		.key    = "\x63\x68\x69\x63\x6b\x65\x6e\x20"
+			  "\x74\x65\x72\x69\x79\x61\x6b\x69",
+		.rlen   = 64,
+		.result = "\x49\x20\x77\x6f\x75\x6c\x64\x20"
+			  "\x6c\x69\x6b\x65\x20\x74\x68\x65"
+			  "\x20\x47\x65\x6e\x65\x72\x61\x6c"
+			  "\x20\x47\x61\x75\x27\x73\x20\x43"
+			  "\x68\x69\x63\x6b\x65\x6e\x2c\x20"
+			  "\x70\x6c\x65\x61\x73\x65\x2c\x20"
+			  "\x61\x6e\x64\x20\x77\x6f\x6e\x74"
+			  "\x6f\x6e\x20\x73\x6f\x75\x70\x2e",
+		.ilen   = 64,
+		.input  = "\x97\x68\x72\x68\xd6\xec\xcc\xc0"
+			  "\xc0\x7b\x25\xe2\x5e\xcf\xe5\x84"
+			  "\x39\x31\x25\x23\xa7\x86\x62\xd5"
+			  "\xbe\x7f\xcb\xcc\x98\xeb\xf5\xa8"
+			  "\x48\x07\xef\xe8\x36\xee\x89\xa5"
+			  "\x26\x73\x0d\xbc\x2f\x7b\xc8\x40"
+			  "\x9d\xad\x8b\xbb\x96\xc4\xcd\xc0"
+			  "\x3b\xc1\x03\xe1\xa1\x94\xbb\xd8",
+	}
+};
+
+/*
+ * Compression stuff.
+ */
+#define COMP_BUF_SIZE           512
+
+struct comp_testvec {
+	int inlen, outlen;
+	char input[COMP_BUF_SIZE];
+	char output[COMP_BUF_SIZE];
+};
+
+/*
+ * Deflate test vectors (null-terminated strings).
+ * Params: winbits=11, Z_DEFAULT_COMPRESSION, MAX_MEM_LEVEL.
+ */
+#define DEFLATE_COMP_TEST_VECTORS 2
+#define DEFLATE_DECOMP_TEST_VECTORS 2
+
+static struct comp_testvec deflate_comp_tv_template[] = {
+	{
+		.inlen	= 70,
+		.outlen	= 38,
+		.input	= "Join us now and share the software "
+			"Join us now and share the software ",
+		.output	= "\xf3\xca\xcf\xcc\x53\x28\x2d\x56"
+			  "\xc8\xcb\x2f\x57\x48\xcc\x4b\x51"
+			  "\x28\xce\x48\x2c\x4a\x55\x28\xc9"
+			  "\x48\x55\x28\xce\x4f\x2b\x29\x07"
+			  "\x71\xbc\x08\x2b\x01\x00",
+	}, {
+		.inlen	= 191,
+		.outlen	= 122,
+		.input	= "This document describes a compression method based on the DEFLATE"
+			"compression algorithm.  This document defines the application of "
+			"the DEFLATE algorithm to the IP Payload Compression Protocol.",
+		.output	= "\x5d\x8d\x31\x0e\xc2\x30\x10\x04"
+			  "\xbf\xb2\x2f\xc8\x1f\x10\x04\x09"
+			  "\x89\xc2\x85\x3f\x70\xb1\x2f\xf8"
+			  "\x24\xdb\x67\xd9\x47\xc1\xef\x49"
+			  "\x68\x12\x51\xae\x76\x67\xd6\x27"
+			  "\x19\x88\x1a\xde\x85\xab\x21\xf2"
+			  "\x08\x5d\x16\x1e\x20\x04\x2d\xad"
+			  "\xf3\x18\xa2\x15\x85\x2d\x69\xc4"
+			  "\x42\x83\x23\xb6\x6c\x89\x71\x9b"
+			  "\xef\xcf\x8b\x9f\xcf\x33\xca\x2f"
+			  "\xed\x62\xa9\x4c\x80\xff\x13\xaf"
+			  "\x52\x37\xed\x0e\x52\x6b\x59\x02"
+			  "\xd9\x4e\xe8\x7a\x76\x1d\x02\x98"
+			  "\xfe\x8a\x87\x83\xa3\x4f\x56\x8a"
+			  "\xb8\x9e\x8e\x5c\x57\xd3\xa0\x79"
+			  "\xfa\x02",
+	},
+};
+
+static struct comp_testvec deflate_decomp_tv_template[] = {
+	{
+		.inlen	= 122,
+		.outlen	= 191,
+		.input	= "\x5d\x8d\x31\x0e\xc2\x30\x10\x04"
+			  "\xbf\xb2\x2f\xc8\x1f\x10\x04\x09"
+			  "\x89\xc2\x85\x3f\x70\xb1\x2f\xf8"
+			  "\x24\xdb\x67\xd9\x47\xc1\xef\x49"
+			  "\x68\x12\x51\xae\x76\x67\xd6\x27"
+			  "\x19\x88\x1a\xde\x85\xab\x21\xf2"
+			  "\x08\x5d\x16\x1e\x20\x04\x2d\xad"
+			  "\xf3\x18\xa2\x15\x85\x2d\x69\xc4"
+			  "\x42\x83\x23\xb6\x6c\x89\x71\x9b"
+			  "\xef\xcf\x8b\x9f\xcf\x33\xca\x2f"
+			  "\xed\x62\xa9\x4c\x80\xff\x13\xaf"
+			  "\x52\x37\xed\x0e\x52\x6b\x59\x02"
+			  "\xd9\x4e\xe8\x7a\x76\x1d\x02\x98"
+			  "\xfe\x8a\x87\x83\xa3\x4f\x56\x8a"
+			  "\xb8\x9e\x8e\x5c\x57\xd3\xa0\x79"
+			  "\xfa\x02",
+		.output	= "This document describes a compression method based on the DEFLATE"
+			"compression algorithm.  This document defines the application of "
+			"the DEFLATE algorithm to the IP Payload Compression Protocol.",
+	}, {
+		.inlen	= 38,
+		.outlen	= 70,
+		.input	= "\xf3\xca\xcf\xcc\x53\x28\x2d\x56"
+			  "\xc8\xcb\x2f\x57\x48\xcc\x4b\x51"
+			  "\x28\xce\x48\x2c\x4a\x55\x28\xc9"
+			  "\x48\x55\x28\xce\x4f\x2b\x29\x07"
+			  "\x71\xbc\x08\x2b\x01\x00",
+		.output	= "Join us now and share the software "
+			"Join us now and share the software ",
+	},
+};
+
+/*
+ * LZO test vectors (null-terminated strings).
+ */
+#define LZO_COMP_TEST_VECTORS 2
+#define LZO_DECOMP_TEST_VECTORS 2
+
+static struct comp_testvec lzo_comp_tv_template[] = {
+	{
+		.inlen	= 70,
+		.outlen	= 46,
+		.input	= "Join us now and share the software "
+			"Join us now and share the software ",
+		.output	= "\x00\x0d\x4a\x6f\x69\x6e\x20\x75"
+			"\x73\x20\x6e\x6f\x77\x20\x61\x6e"
+			"\x64\x20\x73\x68\x61\x72\x65\x20"
+			"\x74\x68\x65\x20\x73\x6f\x66\x74"
+			"\x77\x70\x01\x01\x4a\x6f\x69\x6e"
+			"\x3d\x88\x00\x11\x00\x00",
+	}, {
+		.inlen	= 159,
+		.outlen	= 133,
+		.input	= "This document describes a compression method based on the LZO "
+			"compression algorithm.  This document defines the application of "
+			"the LZO algorithm used in UBIFS.",
+		.output	= "\x00\x2b\x54\x68\x69\x73\x20\x64"
+			  "\x6f\x63\x75\x6d\x65\x6e\x74\x20"
+			  "\x64\x65\x73\x63\x72\x69\x62\x65"
+			  "\x73\x20\x61\x20\x63\x6f\x6d\x70"
+			  "\x72\x65\x73\x73\x69\x6f\x6e\x20"
+			  "\x6d\x65\x74\x68\x6f\x64\x20\x62"
+			  "\x61\x73\x65\x64\x20\x6f\x6e\x20"
+			  "\x74\x68\x65\x20\x4c\x5a\x4f\x2b"
+			  "\x8c\x00\x0d\x61\x6c\x67\x6f\x72"
+			  "\x69\x74\x68\x6d\x2e\x20\x20\x54"
+			  "\x68\x69\x73\x2a\x54\x01\x02\x66"
+			  "\x69\x6e\x65\x73\x94\x06\x05\x61"
+			  "\x70\x70\x6c\x69\x63\x61\x74\x76"
+			  "\x0a\x6f\x66\x88\x02\x60\x09\x27"
+			  "\xf0\x00\x0c\x20\x75\x73\x65\x64"
+			  "\x20\x69\x6e\x20\x55\x42\x49\x46"
+			  "\x53\x2e\x11\x00\x00",
+	},
+};
+
+static struct comp_testvec lzo_decomp_tv_template[] = {
+	{
+		.inlen	= 133,
+		.outlen	= 159,
+		.input	= "\x00\x2b\x54\x68\x69\x73\x20\x64"
+			  "\x6f\x63\x75\x6d\x65\x6e\x74\x20"
+			  "\x64\x65\x73\x63\x72\x69\x62\x65"
+			  "\x73\x20\x61\x20\x63\x6f\x6d\x70"
+			  "\x72\x65\x73\x73\x69\x6f\x6e\x20"
+			  "\x6d\x65\x74\x68\x6f\x64\x20\x62"
+			  "\x61\x73\x65\x64\x20\x6f\x6e\x20"
+			  "\x74\x68\x65\x20\x4c\x5a\x4f\x2b"
+			  "\x8c\x00\x0d\x61\x6c\x67\x6f\x72"
+			  "\x69\x74\x68\x6d\x2e\x20\x20\x54"
+			  "\x68\x69\x73\x2a\x54\x01\x02\x66"
+			  "\x69\x6e\x65\x73\x94\x06\x05\x61"
+			  "\x70\x70\x6c\x69\x63\x61\x74\x76"
+			  "\x0a\x6f\x66\x88\x02\x60\x09\x27"
+			  "\xf0\x00\x0c\x20\x75\x73\x65\x64"
+			  "\x20\x69\x6e\x20\x55\x42\x49\x46"
+			  "\x53\x2e\x11\x00\x00",
+		.output	= "This document describes a compression method based on the LZO "
+			"compression algorithm.  This document defines the application of "
+			"the LZO algorithm used in UBIFS.",
+	}, {
+		.inlen	= 46,
+		.outlen	= 70,
+		.input	= "\x00\x0d\x4a\x6f\x69\x6e\x20\x75"
+			  "\x73\x20\x6e\x6f\x77\x20\x61\x6e"
+			  "\x64\x20\x73\x68\x61\x72\x65\x20"
+			  "\x74\x68\x65\x20\x73\x6f\x66\x74"
+			  "\x77\x70\x01\x01\x4a\x6f\x69\x6e"
+			  "\x3d\x88\x00\x11\x00\x00",
+		.output	= "Join us now and share the software "
+			"Join us now and share the software ",
+	},
+};
+
+/*
+ * Michael MIC test vectors from IEEE 802.11i
+ */
+#define MICHAEL_MIC_TEST_VECTORS 6
+
+static struct hash_testvec michael_mic_tv_template[] = {
+	{
+		.key = "\x00\x00\x00\x00\x00\x00\x00\x00",
+		.ksize = 8,
+		.plaintext = zeroed_string,
+		.psize = 0,
+		.digest = "\x82\x92\x5c\x1c\xa1\xd1\x30\xb8",
+	},
+	{
+		.key = "\x82\x92\x5c\x1c\xa1\xd1\x30\xb8",
+		.ksize = 8,
+		.plaintext = "M",
+		.psize = 1,
+		.digest = "\x43\x47\x21\xca\x40\x63\x9b\x3f",
+	},
+	{
+		.key = "\x43\x47\x21\xca\x40\x63\x9b\x3f",
+		.ksize = 8,
+		.plaintext = "Mi",
+		.psize = 2,
+		.digest = "\xe8\xf9\xbe\xca\xe9\x7e\x5d\x29",
+	},
+	{
+		.key = "\xe8\xf9\xbe\xca\xe9\x7e\x5d\x29",
+		.ksize = 8,
+		.plaintext = "Mic",
+		.psize = 3,
+		.digest = "\x90\x03\x8f\xc6\xcf\x13\xc1\xdb",
+	},
+	{
+		.key = "\x90\x03\x8f\xc6\xcf\x13\xc1\xdb",
+		.ksize = 8,
+		.plaintext = "Mich",
+		.psize = 4,
+		.digest = "\xd5\x5e\x10\x05\x10\x12\x89\x86",
+	},
+	{
+		.key = "\xd5\x5e\x10\x05\x10\x12\x89\x86",
+		.ksize = 8,
+		.plaintext = "Michael",
+		.psize = 7,
+		.digest = "\x0a\x94\x2b\x12\x4e\xca\xa5\x46",
+	}
+};
+
+/*
+ * CRC32C test vectors
+ */
+#define CRC32C_TEST_VECTORS 14
+
+static struct hash_testvec crc32c_tv_template[] = {
+	{
+		.psize = 0,
+		.digest = "\x00\x00\x00\x00",
+	},
+	{
+		.key = "\x87\xa9\xcb\xed",
+		.ksize = 4,
+		.psize = 0,
+		.digest = "\x78\x56\x34\x12",
+	},
+	{
+		.key = "\xff\xff\xff\xff",
+		.ksize = 4,
+		.plaintext = "\x01\x02\x03\x04\x05\x06\x07\x08"
+			     "\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
+			     "\x11\x12\x13\x14\x15\x16\x17\x18"
+			     "\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
+			     "\x21\x22\x23\x24\x25\x26\x27\x28",
+		.psize = 40,
+		.digest = "\x7f\x15\x2c\x0e",
+	},
+	{
+		.key = "\xff\xff\xff\xff",
+		.ksize = 4,
+		.plaintext = "\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
+			     "\x31\x32\x33\x34\x35\x36\x37\x38"
+			     "\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
+			     "\x41\x42\x43\x44\x45\x46\x47\x48"
+			     "\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50",
+		.psize = 40,
+		.digest = "\xf6\xeb\x80\xe9",
+	},
+	{
+		.key = "\xff\xff\xff\xff",
+		.ksize = 4,
+		.plaintext = "\x51\x52\x53\x54\x55\x56\x57\x58"
+			     "\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
+			     "\x61\x62\x63\x64\x65\x66\x67\x68"
+			     "\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
+			     "\x71\x72\x73\x74\x75\x76\x77\x78",
+		.psize = 40,
+		.digest = "\xed\xbd\x74\xde",
+	},
+	{
+		.key = "\xff\xff\xff\xff",
+		.ksize = 4,
+		.plaintext = "\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
+			     "\x81\x82\x83\x84\x85\x86\x87\x88"
+			     "\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
+			     "\x91\x92\x93\x94\x95\x96\x97\x98"
+			     "\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0",
+		.psize = 40,
+		.digest = "\x62\xc8\x79\xd5",
+	},
+	{
+		.key = "\xff\xff\xff\xff",
+		.ksize = 4,
+		.plaintext = "\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8"
+			     "\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
+			     "\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8"
+			     "\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
+			     "\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8",
+		.psize = 40,
+		.digest = "\xd0\x9a\x97\xba",
+	},
+	{
+		.key = "\xff\xff\xff\xff",
+		.ksize = 4,
+		.plaintext = "\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
+			     "\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8"
+			     "\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
+			     "\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8"
+			     "\xe9\xea\xeb\xec\xed\xee\xef\xf0",
+		.psize = 40,
+		.digest = "\x13\xd9\x29\x2b",
+	},
+	{
+		.key = "\x80\xea\xd3\xf1",
+		.ksize = 4,
+		.plaintext = "\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
+			     "\x31\x32\x33\x34\x35\x36\x37\x38"
+			     "\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
+			     "\x41\x42\x43\x44\x45\x46\x47\x48"
+			     "\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50",
+		.psize = 40,
+		.digest = "\x0c\xb5\xe2\xa2",
+	},
+	{
+		.key = "\xf3\x4a\x1d\x5d",
+		.ksize = 4,
+		.plaintext = "\x51\x52\x53\x54\x55\x56\x57\x58"
+			     "\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
+			     "\x61\x62\x63\x64\x65\x66\x67\x68"
+			     "\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
+			     "\x71\x72\x73\x74\x75\x76\x77\x78",
+		.psize = 40,
+		.digest = "\xd1\x7f\xfb\xa6",
+	},
+	{
+		.key = "\x2e\x80\x04\x59",
+		.ksize = 4,
+		.plaintext = "\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
+			     "\x81\x82\x83\x84\x85\x86\x87\x88"
+			     "\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
+			     "\x91\x92\x93\x94\x95\x96\x97\x98"
+			     "\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0",
+		.psize = 40,
+		.digest = "\x59\x33\xe6\x7a",
+	},
+	{
+		.key = "\xa6\xcc\x19\x85",
+		.ksize = 4,
+		.plaintext = "\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8"
+			     "\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
+			     "\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8"
+			     "\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
+			     "\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8",
+		.psize = 40,
+		.digest = "\xbe\x03\x01\xd2",
+	},
+	{
+		.key = "\x41\xfc\xfe\x2d",
+		.ksize = 4,
+		.plaintext = "\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
+			     "\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8"
+			     "\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
+			     "\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8"
+			     "\xe9\xea\xeb\xec\xed\xee\xef\xf0",
+		.psize = 40,
+		.digest = "\x75\xd3\xc5\x24",
+	},
+	{
+		.key = "\xff\xff\xff\xff",
+		.ksize = 4,
+		.plaintext = "\x01\x02\x03\x04\x05\x06\x07\x08"
+			     "\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
+			     "\x11\x12\x13\x14\x15\x16\x17\x18"
+			     "\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
+			     "\x21\x22\x23\x24\x25\x26\x27\x28"
+			     "\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
+			     "\x31\x32\x33\x34\x35\x36\x37\x38"
+			     "\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
+			     "\x41\x42\x43\x44\x45\x46\x47\x48"
+			     "\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
+			     "\x51\x52\x53\x54\x55\x56\x57\x58"
+			     "\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
+			     "\x61\x62\x63\x64\x65\x66\x67\x68"
+			     "\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
+			     "\x71\x72\x73\x74\x75\x76\x77\x78"
+			     "\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
+			     "\x81\x82\x83\x84\x85\x86\x87\x88"
+			     "\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
+			     "\x91\x92\x93\x94\x95\x96\x97\x98"
+			     "\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
+			     "\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8"
+			     "\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
+			     "\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8"
+			     "\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
+			     "\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8"
+			     "\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
+			     "\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8"
+			     "\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
+			     "\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8"
+			     "\xe9\xea\xeb\xec\xed\xee\xef\xf0",
+		.psize = 240,
+		.digest = "\x75\xd3\xc5\x24",
+		.np = 2,
+		.tap = { 31, 209 }
+	},
+};
+
+/*
+ * Cipher speed tests
+ */
+static u8 speed_template_8[] = {8, 0};
+static u8 speed_template_24[] = {24, 0};
+static u8 speed_template_8_32[] = {8, 32, 0};
+static u8 speed_template_16_32[] = {16, 32, 0};
+static u8 speed_template_16_24_32[] = {16, 24, 32, 0};
+static u8 speed_template_32_40_48[] = {32, 40, 48, 0};
+static u8 speed_template_32_48_64[] = {32, 48, 64, 0};
+
+/*
+ * Digest speed tests
+ */
+static struct hash_speed generic_hash_speed_template[] = {
+	{ .blen = 16,	.plen = 16, },
+	{ .blen = 64,	.plen = 16, },
+	{ .blen = 64,	.plen = 64, },
+	{ .blen = 256,	.plen = 16, },
+	{ .blen = 256,	.plen = 64, },
+	{ .blen = 256,	.plen = 256, },
+	{ .blen = 1024,	.plen = 16, },
+	{ .blen = 1024,	.plen = 256, },
+	{ .blen = 1024,	.plen = 1024, },
+	{ .blen = 2048,	.plen = 16, },
+	{ .blen = 2048,	.plen = 256, },
+	{ .blen = 2048,	.plen = 1024, },
+	{ .blen = 2048,	.plen = 2048, },
+	{ .blen = 4096,	.plen = 16, },
+	{ .blen = 4096,	.plen = 256, },
+	{ .blen = 4096,	.plen = 1024, },
+	{ .blen = 4096,	.plen = 4096, },
+	{ .blen = 8192,	.plen = 16, },
+	{ .blen = 8192,	.plen = 256, },
+	{ .blen = 8192,	.plen = 1024, },
+	{ .blen = 8192,	.plen = 4096, },
+	{ .blen = 8192,	.plen = 8192, },
+
+	/* End marker */
+	{  .blen = 0,	.plen = 0, }
+};
+
+#endif	/* _CRYPTO_TCRYPT_H */
diff -Naur pico_2.6.28/drivers/ipa/crypto/tpicocrypto.c ipa_2.6.28/drivers/ipa/crypto/tpicocrypto.c
--- pico_2.6.28/drivers/ipa/crypto/tpicocrypto.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/ipa/crypto/tpicocrypto.c	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,2250 @@
+/*
+ * Quick & dirty crypto testing module.
+ * Based on tcrypt and modified to test the PicoCrypto sub-system
+ *
+ * Author: Dean Jenkins <djenkins@mvista.com>
+ *
+ * 2008 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+/*
+ * Copyright (c) 2002 James Morris <jmorris@intercode.com.au>
+ * Copyright (c) 2002 Jean-Francois Dive <jef@linuxbe.org>
+ * Copyright (c) 2007 Nokia Siemens Networks
+ */
+
+#include <crypto/hash.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/scatterlist.h>
+#include <linux/string.h>
+#include <linux/crypto.h>
+#include <linux/moduleparam.h>
+#include <linux/jiffies.h>
+#include <linux/timex.h>
+#include <linux/interrupt.h>
+#include <linux/rtnetlink.h>
+#include <crypto/authenc.h>
+#include "tcrypt.h"
+
+/*
+ * Need to kmalloc() memory for testing.
+ */
+#define TVMEMSIZE	16384
+#define XBUFSIZE	32768
+
+/*
+ * Indexes into the xbuf to simulate cross-page access.
+ */
+#define IDX1		32
+#define IDX2		32400
+#define IDX3		1
+#define IDX4		8193
+#define IDX5		22222
+#define IDX6		17101
+#define IDX7		27333
+#define IDX8		3000
+
+/*
+* Used by test_cipher()
+*/
+#define ENCRYPT 1
+#define DECRYPT 0
+
+struct tcrypt_result {
+	struct completion completion;
+	int err;
+};
+
+static unsigned int IDX[8] = { IDX1, IDX2, IDX3, IDX4, IDX5, IDX6, IDX7, IDX8 };
+
+/*
+ * Used by test_cipher_speed()
+ */
+static unsigned int sec;
+
+static int mode;
+static char *xbuf;
+static char *axbuf;
+static char *tvmem;
+
+static char *check[] = {
+	"des", "md5", "des3_ede", "rot13", "sha1", "sha224", "sha256",
+	"blowfish", "twofish", "serpent", "sha384", "sha512", "md4", "aes",
+	"cast6", "arc4", "michael_mic", "deflate", "crc32c", "tea", "xtea",
+	"khazad", "wp512", "wp384", "wp256", "tnepres", "xeta",  "fcrypt",
+	"camellia", "seed", "salsa20", "rmd128", "rmd160", "rmd256", "rmd320",
+	"lzo", "cts", NULL
+};
+
+static void hexdump(unsigned char *buf, unsigned int len)
+{
+	print_hex_dump(KERN_CONT, "", DUMP_PREFIX_OFFSET,
+			16, 1,
+			buf, len, false);
+}
+
+static void tcrypt_complete(struct crypto_async_request *req, int err)
+{
+	struct tcrypt_result *res = req->data;
+
+	printk( KERN_INFO "COMPLETE called... err = %d\n", err );
+
+	if (err == -EINPROGRESS)
+		return;
+
+	res->err = err;
+	complete(&res->completion);
+}
+
+static void test_hash(char *algo, struct hash_testvec *template,
+		      unsigned int tcount)
+{
+	unsigned int i, j, k, temp;
+	struct scatterlist sg[8];
+	char result[64];
+	struct crypto_ahash *tfm;
+	struct ahash_request *req;
+	struct tcrypt_result tresult;
+	int ret;
+	void *hash_buff;
+
+	printk("\ntesting %s\n", algo);
+
+	init_completion(&tresult.completion);
+
+	tfm = crypto_alloc_ahash(algo, 0, 0);
+	if (IS_ERR(tfm)) {
+		printk("failed to load transform for %s: %ld\n", algo,
+		       PTR_ERR(tfm));
+		return;
+	}
+
+	req = ahash_request_alloc(tfm, GFP_KERNEL);
+	if (!req) {
+		printk(KERN_ERR "failed to allocate request for %s\n", algo);
+		goto out_noreq;
+	}
+	ahash_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+				   tcrypt_complete, &tresult);
+
+	for (i = 0; i < tcount; i++) {
+		printk("test %u:\n", i + 1);
+		memset(result, 0, 64);
+
+		hash_buff = kzalloc(template[i].psize, GFP_KERNEL);
+		if (!hash_buff)
+			continue;
+
+		memcpy(hash_buff, template[i].plaintext, template[i].psize);
+		sg_init_one(&sg[0], hash_buff, template[i].psize);
+
+		if (template[i].ksize) {
+			crypto_ahash_clear_flags(tfm, ~0);
+			ret = crypto_ahash_setkey(tfm, template[i].key,
+						  template[i].ksize);
+			if (ret) {
+				printk("setkey() failed ret=%d\n", ret);
+				kfree(hash_buff);
+				goto out;
+			}
+		}
+
+		ahash_request_set_crypt(req, sg, result, template[i].psize);
+		ret = crypto_ahash_digest(req);
+		switch (ret) {
+		case 0:
+			break;
+		case -EINPROGRESS:
+		case -EBUSY:
+			ret = wait_for_completion_interruptible(
+				&tresult.completion);
+			if (!ret && !(ret = tresult.err)) {
+				INIT_COMPLETION(tresult.completion);
+				break;
+			}
+			/* fall through */
+		default:
+			printk("digest () failed ret=%d\n", ret);
+			kfree(hash_buff);
+			goto out;
+		}
+
+		hexdump(result, crypto_ahash_digestsize(tfm));
+		printk("%s\n",
+		       memcmp(result, template[i].digest,
+			      crypto_ahash_digestsize(tfm)) ?
+		       "fail" : "pass");
+		kfree(hash_buff);
+	}
+
+	printk("testing %s across pages\n", algo);
+
+	/* setup the dummy buffer first */
+	memset(xbuf, 0, XBUFSIZE);
+
+	j = 0;
+	for (i = 0; i < tcount; i++) {
+		if (template[i].np) {
+			j++;
+			printk("test %u:\n", j);
+			memset(result, 0, 64);
+
+			temp = 0;
+			sg_init_table(sg, template[i].np);
+			for (k = 0; k < template[i].np; k++) {
+				memcpy(&xbuf[IDX[k]],
+				       template[i].plaintext + temp,
+				       template[i].tap[k]);
+				temp += template[i].tap[k];
+				sg_set_buf(&sg[k], &xbuf[IDX[k]],
+					    template[i].tap[k]);
+			}
+
+			if (template[i].ksize) {
+				crypto_ahash_clear_flags(tfm, ~0);
+				ret = crypto_ahash_setkey(tfm, template[i].key,
+							  template[i].ksize);
+
+				if (ret) {
+					printk("setkey() failed ret=%d\n", ret);
+					goto out;
+				}
+			}
+
+			ahash_request_set_crypt(req, sg, result,
+						template[i].psize);
+			ret = crypto_ahash_digest(req);
+			switch (ret) {
+			case 0:
+				break;
+			case -EINPROGRESS:
+			case -EBUSY:
+				ret = wait_for_completion_interruptible(
+					&tresult.completion);
+				if (!ret && !(ret = tresult.err)) {
+					INIT_COMPLETION(tresult.completion);
+					break;
+				}
+				/* fall through */
+			default:
+				printk("digest () failed ret=%d\n", ret);
+				goto out;
+			}
+
+			hexdump(result, crypto_ahash_digestsize(tfm));
+			printk("%s\n",
+			       memcmp(result, template[i].digest,
+				      crypto_ahash_digestsize(tfm)) ?
+			       "fail" : "pass");
+		}
+	}
+
+out:
+	ahash_request_free(req);
+out_noreq:
+	crypto_free_ahash(tfm);
+}
+
+
+/* added by MontaVista to test authenc */
+static void test_authenc(char *algo, int enc, struct authenc_testvec *template,
+		      unsigned int tcount)
+{
+	unsigned int ret, i, j;
+	char *q;
+	struct crypto_aead *tfm;
+	struct aead_request *req;
+	struct scatterlist sg[8];	/* probably don't need 8 */
+	struct scatterlist asg[8];
+	const char *e;
+	struct tcrypt_result result;
+	unsigned int authsize;
+	void *input;
+	void *assoc;
+	char iv[MAX_IVLEN];
+
+	if (enc == ENCRYPT)
+		e = "encryption";
+	else
+		e = "decryption";
+
+	printk(KERN_INFO "\ntesting %s %s\n", algo, e);
+
+	/* dynamically initialise completion function information */
+	init_completion(&result.completion);
+
+	tfm = crypto_alloc_aead( algo, 0, 0 );
+
+	if (IS_ERR(tfm)) {
+		printk(KERN_INFO "failed to load transform for %s: %ld\n",
+		       algo, PTR_ERR(tfm));
+		return;
+	}
+
+	req = aead_request_alloc(tfm, GFP_KERNEL);
+	if (!req) {
+		printk(KERN_INFO "failed to allocate request for %s\n", algo);
+		goto out;
+	}
+
+	/* register the callback function "tcrypt_complete" */
+	aead_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+				  tcrypt_complete, &result);
+
+	for (i = 0, j = 0; i < tcount; i++) {
+		if (!template[i].np) {
+			printk(KERN_INFO "test %u (%d bit enckey, %d bit authkey):\n",
+			       ++j, template[i].enckeylen * 8, template[i].authkeylen * 8 );
+
+			/* some tepmplates have no input data but they will
+			 * touch input
+			 */
+
+			/*
+			 * Create memory for input ilen and rlen data
+			 */ 
+			input = kzalloc(template[i].ilen + template[i].rlen, GFP_KERNEL);
+			if (!input)
+				continue;
+
+			/*
+			 * Create memory for assoicated data
+			 */ 
+			assoc = kzalloc(template[i].alen, GFP_KERNEL);
+			if (!assoc) {
+				kfree(input);
+				continue;
+			}
+
+			/* copy the input data into the input memory */
+			memcpy(input, template[i].input, template[i].ilen);
+
+			/* copy the assoicated data into the input memory */
+			memcpy(assoc, template[i].assoc, template[i].alen);
+
+			/* copy any initial values into the iv memory */
+			if (template[i].iv) {
+				memcpy(iv, template[i].iv, MAX_IVLEN);
+			}
+
+			crypto_aead_clear_flags(tfm, ~0);
+
+
+			/* combine encryption and auth keys using rtattr */
+			/* code from esp4.c */
+			{
+				struct crypto_authenc_key_param *param;
+				struct rtattr *rta;
+				char *key;
+				char *p;
+				unsigned int total_keylen;
+
+				/* alloc some memory to hold the combined keys */
+				total_keylen = template[i].authkeylen +
+					template[i].enckeylen + RTA_SPACE( sizeof(*param) );
+				key = kzalloc( total_keylen, GFP_KERNEL );
+				if ( key == NULL ) {
+					goto next_one;
+				}
+
+				p = key;	/* point to key memory */
+				rta = (void *)p;	/* overlay struct rtattr */
+				rta->rta_type = CRYPTO_AUTHENC_KEYA_PARAM;
+				rta->rta_len = RTA_LENGTH(sizeof(*param));
+				param = RTA_DATA(rta);
+				/* indicate the encryption key length */
+				param->enckeylen = cpu_to_be32( template[i].enckeylen );
+
+				p += RTA_SPACE(sizeof(*param));	/* point to data area */
+
+				/* copy the authentication key into the data area */
+				memcpy( p, template[i].authkey, template[i].authkeylen );
+				p += template[i].authkeylen;
+
+				/* copy the encryption key into the data area */
+				memcpy( p, template[i].enckey, template[i].enckeylen );
+				/* send the combined keys */
+				ret = crypto_aead_setkey(tfm, key, total_keylen);
+
+				/* free the combined key */
+				kfree( key );
+			}
+
+			if (ret) {
+				printk(KERN_INFO "setkey() failed flags=%x\n",
+				       crypto_aead_get_flags(tfm));
+
+				if (!template[i].fail)
+					goto next_one;
+			}
+
+			authsize = abs(template[i].rlen - template[i].ilen);
+			printk( KERN_INFO "Authsize set to %d\n", authsize );
+			ret = crypto_aead_setauthsize(tfm, authsize);
+			if (ret) {
+				printk(KERN_INFO
+				       "failed to set authsize = %u\n",
+				       authsize);
+				goto next_one;
+			}
+
+			/* initialise a scatterlist for source data including ALL input memory */
+			sg_init_one(&sg[0], input,
+				    template[i].ilen + (enc ? authsize : 0));
+
+			/* initialise a scatterlist for assoicated data */
+			sg_init_one(&asg[0], assoc, template[i].alen);
+
+			/* set the source and destination (reuse src memory ) data in the request */
+			aead_request_set_crypt(req, sg, sg,
+					       template[i].ilen, iv);
+
+			/* set the associated data in the request */
+			aead_request_set_assoc(req, asg, template[i].alen);
+
+			/* do it */
+			ret = enc ?
+				crypto_aead_encrypt(req) :
+				crypto_aead_decrypt(req);
+
+			switch (ret) {
+			case 0:
+				break;
+
+			case -EINPROGRESS:
+			case -EBUSY:
+				printk( KERN_INFO "Waiting for completion\n" );
+				ret = wait_for_completion_interruptible(
+					&result.completion);
+				if (!ret && !(ret = result.err)) {
+					INIT_COMPLETION(result.completion);
+					break;
+				}
+				/* fall through */
+			default:
+				printk(KERN_INFO "%s () failed err=%d\n",
+				       e, -ret);
+				goto next_one;
+			}
+
+			q = input;	/* look at output data ( input data overwritten) */
+
+			printk( KERN_INFO "Enc (dec) key...\n" );
+			hexdump( template[i].enckey, template[i].enckeylen );
+
+			printk( KERN_INFO "IV...\n" );
+			if( template[i].iv != NULL ) {
+				hexdump( template[i].iv, 16 );
+			}
+
+			printk( KERN_INFO "Input...\n" );
+			hexdump( template[i].input, template[i].ilen );
+
+			printk( KERN_INFO "Output...\n" );
+			hexdump( q, template[i].ilen + (enc ? authsize : -authsize) );
+
+			printk( KERN_INFO "Expected result...\n" );
+			hexdump( template[i].result, template[i].rlen );
+
+			printk(KERN_INFO "enc/dec: %s\n",
+			       memcmp(q, template[i].result,
+				      template[i].rlen) ? "fail" : "pass");
+next_one:
+			kfree(assoc);
+			kfree(input);
+		}
+	}
+
+
+out:
+	crypto_free_aead(tfm);
+#ifndef ESP_WAY
+	aead_request_free(req);
+#else
+	kfree(tmp);
+#endif
+	printk(KERN_INFO "\nfinished %s %s\n", algo, e);
+}
+
+
+static void test_aead(char *algo, int enc, struct aead_testvec *template,
+		      unsigned int tcount)
+{
+	unsigned int ret, i, j, k, n, temp;
+	char *q;
+	struct crypto_aead *tfm;
+	char *key;
+	struct aead_request *req;
+	struct scatterlist sg[8];
+	struct scatterlist asg[8];
+	const char *e;
+	struct tcrypt_result result;
+	unsigned int authsize;
+	void *input;
+	void *assoc;
+	char iv[MAX_IVLEN];
+
+	if (enc == ENCRYPT)
+		e = "encryption";
+	else
+		e = "decryption";
+
+	printk(KERN_INFO "\ntesting %s %s\n", algo, e);
+
+	init_completion(&result.completion);
+
+	tfm = crypto_alloc_aead(algo, 0, 0);
+
+	if (IS_ERR(tfm)) {
+		printk(KERN_INFO "failed to load transform for %s: %ld\n",
+		       algo, PTR_ERR(tfm));
+		return;
+	}
+
+	req = aead_request_alloc(tfm, GFP_KERNEL);
+	if (!req) {
+		printk(KERN_INFO "failed to allocate request for %s\n", algo);
+		goto out;
+	}
+
+	aead_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+				  tcrypt_complete, &result);
+
+	for (i = 0, j = 0; i < tcount; i++) {
+		if (!template[i].np) {
+			printk(KERN_INFO "test %u (%d bit key):\n",
+			       ++j, template[i].klen * 8);
+
+			/* some tepmplates have no input data but they will
+			 * touch input
+			 */
+			input = kzalloc(template[i].ilen + template[i].rlen, GFP_KERNEL);
+			if (!input)
+				continue;
+
+			assoc = kzalloc(template[i].alen, GFP_KERNEL);
+			if (!assoc) {
+				kfree(input);
+				continue;
+			}
+
+			memcpy(input, template[i].input, template[i].ilen);
+			memcpy(assoc, template[i].assoc, template[i].alen);
+			if (template[i].iv)
+				memcpy(iv, template[i].iv, MAX_IVLEN);
+			else
+				memset(iv, 0, MAX_IVLEN);
+
+			crypto_aead_clear_flags(tfm, ~0);
+			if (template[i].wk)
+				crypto_aead_set_flags(
+					tfm, CRYPTO_TFM_REQ_WEAK_KEY);
+
+			if (template[i].key)
+				key = template[i].key;
+			else
+				key = kzalloc(template[i].klen, GFP_KERNEL);
+
+			ret = crypto_aead_setkey(tfm, key,
+						 template[i].klen);
+			if (ret) {
+				printk(KERN_INFO "setkey() failed flags=%x\n",
+				       crypto_aead_get_flags(tfm));
+
+				if (!template[i].fail)
+					goto next_one;
+			}
+
+			authsize = abs(template[i].rlen - template[i].ilen);
+			ret = crypto_aead_setauthsize(tfm, authsize);
+			if (ret) {
+				printk(KERN_INFO
+				       "failed to set authsize = %u\n",
+				       authsize);
+				goto next_one;
+			}
+
+			sg_init_one(&sg[0], input,
+				    template[i].ilen + (enc ? authsize : 0));
+
+			sg_init_one(&asg[0], assoc, template[i].alen);
+
+			aead_request_set_crypt(req, sg, sg,
+					       template[i].ilen, iv);
+
+			aead_request_set_assoc(req, asg, template[i].alen);
+
+			ret = enc ?
+				crypto_aead_encrypt(req) :
+				crypto_aead_decrypt(req);
+
+			switch (ret) {
+			case 0:
+				break;
+			case -EINPROGRESS:
+			case -EBUSY:
+				ret = wait_for_completion_interruptible(
+					&result.completion);
+				if (!ret && !(ret = result.err)) {
+					INIT_COMPLETION(result.completion);
+					break;
+				}
+				/* fall through */
+			default:
+				printk(KERN_INFO "%s () failed err=%d\n",
+				       e, -ret);
+				goto next_one;
+			}
+
+			q = input;
+			hexdump(q, template[i].rlen);
+
+			printk(KERN_INFO "enc/dec: %s\n",
+			       memcmp(q, template[i].result,
+				      template[i].rlen) ? "fail" : "pass");
+next_one:
+			if (!template[i].key)
+				kfree(key);
+			kfree(assoc);
+			kfree(input);
+		}
+	}
+
+	printk(KERN_INFO "\ntesting %s %s across pages (chunking)\n", algo, e);
+	memset(axbuf, 0, XBUFSIZE);
+
+	for (i = 0, j = 0; i < tcount; i++) {
+		if (template[i].np) {
+			printk(KERN_INFO "test %u (%d bit key):\n",
+			       ++j, template[i].klen * 8);
+
+			if (template[i].iv)
+				memcpy(iv, template[i].iv, MAX_IVLEN);
+			else
+				memset(iv, 0, MAX_IVLEN);
+
+			crypto_aead_clear_flags(tfm, ~0);
+			if (template[i].wk)
+				crypto_aead_set_flags(
+					tfm, CRYPTO_TFM_REQ_WEAK_KEY);
+			key = template[i].key;
+
+			ret = crypto_aead_setkey(tfm, key, template[i].klen);
+			if (ret) {
+				printk(KERN_INFO "setkey() failed flags=%x\n",
+				       crypto_aead_get_flags(tfm));
+
+				if (!template[i].fail)
+					goto out;
+			}
+
+			memset(xbuf, 0, XBUFSIZE);
+			sg_init_table(sg, template[i].np);
+			for (k = 0, temp = 0; k < template[i].np; k++) {
+				memcpy(&xbuf[IDX[k]],
+				       template[i].input + temp,
+				       template[i].tap[k]);
+				temp += template[i].tap[k];
+				sg_set_buf(&sg[k], &xbuf[IDX[k]],
+					   template[i].tap[k]);
+			}
+
+			authsize = abs(template[i].rlen - template[i].ilen);
+			ret = crypto_aead_setauthsize(tfm, authsize);
+			if (ret) {
+				printk(KERN_INFO
+				       "failed to set authsize = %u\n",
+				       authsize);
+				goto out;
+			}
+
+			if (enc)
+				sg[k - 1].length += authsize;
+
+			sg_init_table(asg, template[i].anp);
+			for (k = 0, temp = 0; k < template[i].anp; k++) {
+				memcpy(&axbuf[IDX[k]],
+				       template[i].assoc + temp,
+				       template[i].atap[k]);
+				temp += template[i].atap[k];
+				sg_set_buf(&asg[k], &axbuf[IDX[k]],
+					   template[i].atap[k]);
+			}
+
+			aead_request_set_crypt(req, sg, sg,
+					       template[i].ilen,
+					       iv);
+
+			aead_request_set_assoc(req, asg, template[i].alen);
+
+			ret = enc ?
+				crypto_aead_encrypt(req) :
+				crypto_aead_decrypt(req);
+
+			switch (ret) {
+			case 0:
+				break;
+			case -EINPROGRESS:
+			case -EBUSY:
+				ret = wait_for_completion_interruptible(
+					&result.completion);
+				if (!ret && !(ret = result.err)) {
+					INIT_COMPLETION(result.completion);
+					break;
+				}
+				/* fall through */
+			default:
+				printk(KERN_INFO "%s () failed err=%d\n",
+				       e, -ret);
+				goto out;
+			}
+
+			for (k = 0, temp = 0; k < template[i].np; k++) {
+				printk(KERN_INFO "page %u\n", k);
+				q = &xbuf[IDX[k]];
+
+				n = template[i].tap[k];
+				if (k == template[i].np - 1)
+					n += enc ? authsize : -authsize;
+				hexdump(q, n);
+				printk(KERN_INFO "%s\n",
+				       memcmp(q, template[i].result + temp, n) ?
+				       "fail" : "pass");
+
+				q += n;
+				if (k == template[i].np - 1 && !enc) {
+					if (memcmp(q, template[i].input +
+						      temp + n, authsize))
+						n = authsize;
+					else
+						n = 0;
+				} else {
+					for (n = 0; q[n]; n++)
+						;
+				}
+				if (n) {
+					printk("Result buffer corruption %u "
+					       "bytes:\n", n);
+					hexdump(q, n);
+				}
+
+				temp += template[i].tap[k];
+			}
+		}
+	}
+
+out:
+	crypto_free_aead(tfm);
+	aead_request_free(req);
+}
+
+static void test_cipher(char *algo, int enc,
+			struct cipher_testvec *template, unsigned int tcount)
+{
+	unsigned int ret, i, j, k, n, temp;
+	char *q;
+	struct crypto_ablkcipher *tfm;
+	struct ablkcipher_request *req;
+	struct scatterlist sg[8];
+	const char *e;
+	struct tcrypt_result result;
+	void *data;
+	char iv[MAX_IVLEN];
+
+	if (enc == ENCRYPT)
+	        e = "encryption";
+	else
+		e = "decryption";
+
+	printk("\ntesting %s %s\n", algo, e);
+
+	init_completion(&result.completion);
+	tfm = crypto_alloc_ablkcipher(algo, 0, 0);
+
+	if (IS_ERR(tfm)) {
+		printk("failed to load transform for %s: %ld\n", algo,
+		       PTR_ERR(tfm));
+		return;
+	}
+
+	req = ablkcipher_request_alloc(tfm, GFP_KERNEL);
+	if (!req) {
+		printk("failed to allocate request for %s\n", algo);
+		goto out;
+	}
+
+	ablkcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+					tcrypt_complete, &result);
+
+	j = 0;
+	for (i = 0; i < tcount; i++) {
+
+		data = kzalloc(template[i].ilen, GFP_KERNEL);
+		if (!data)
+			continue;
+
+		memcpy(data, template[i].input, template[i].ilen);
+		if (template[i].iv)
+			memcpy(iv, template[i].iv, MAX_IVLEN);
+		else
+			memset(iv, 0, MAX_IVLEN);
+
+		if (!(template[i].np)) {
+			j++;
+			printk("test %u (%d bit key):\n",
+			j, template[i].klen * 8);
+
+			crypto_ablkcipher_clear_flags(tfm, ~0);
+			if (template[i].wk)
+				crypto_ablkcipher_set_flags(
+					tfm, CRYPTO_TFM_REQ_WEAK_KEY);
+
+			ret = crypto_ablkcipher_setkey(tfm, template[i].key,
+						       template[i].klen);
+			if (ret) {
+				printk("setkey() failed flags=%x\n",
+				       crypto_ablkcipher_get_flags(tfm));
+
+				if (!template[i].fail) {
+					kfree(data);
+					goto out;
+				}
+			}
+
+			sg_init_one(&sg[0], data, template[i].ilen);
+
+			ablkcipher_request_set_crypt(req, sg, sg,
+						     template[i].ilen, iv);
+			ret = enc ?
+				crypto_ablkcipher_encrypt(req) :
+				crypto_ablkcipher_decrypt(req);
+
+			switch (ret) {
+			case 0:
+				break;
+			case -EINPROGRESS:
+			case -EBUSY:
+				ret = wait_for_completion_interruptible(
+					&result.completion);
+				if (!ret && !((ret = result.err))) {
+					INIT_COMPLETION(result.completion);
+					break;
+				}
+				/* fall through */
+			default:
+				printk("%s () failed err=%d\n", e, -ret);
+				kfree(data);
+				goto out;
+			}
+
+			q = data;
+			hexdump(q, template[i].rlen);
+
+			printk("%s\n",
+			       memcmp(q, template[i].result,
+				      template[i].rlen) ? "fail" : "pass");
+		}
+		kfree(data);
+	}
+
+	printk("\ntesting %s %s across pages (chunking)\n", algo, e);
+
+	j = 0;
+	for (i = 0; i < tcount; i++) {
+
+		if (template[i].iv)
+			memcpy(iv, template[i].iv, MAX_IVLEN);
+		else
+			memset(iv, 0, MAX_IVLEN);
+
+		if (template[i].np) {
+			j++;
+			printk("test %u (%d bit key):\n",
+			j, template[i].klen * 8);
+
+			memset(xbuf, 0, XBUFSIZE);
+			crypto_ablkcipher_clear_flags(tfm, ~0);
+			if (template[i].wk)
+				crypto_ablkcipher_set_flags(
+					tfm, CRYPTO_TFM_REQ_WEAK_KEY);
+
+			ret = crypto_ablkcipher_setkey(tfm, template[i].key,
+						       template[i].klen);
+			if (ret) {
+				printk("setkey() failed flags=%x\n",
+						crypto_ablkcipher_get_flags(tfm));
+
+				if (!template[i].fail)
+					goto out;
+			}
+
+			temp = 0;
+			sg_init_table(sg, template[i].np);
+			for (k = 0; k < template[i].np; k++) {
+				memcpy(&xbuf[IDX[k]],
+						template[i].input + temp,
+						template[i].tap[k]);
+				temp += template[i].tap[k];
+				sg_set_buf(&sg[k], &xbuf[IDX[k]],
+						template[i].tap[k]);
+			}
+
+			ablkcipher_request_set_crypt(req, sg, sg,
+					template[i].ilen, iv);
+
+			ret = enc ?
+				crypto_ablkcipher_encrypt(req) :
+				crypto_ablkcipher_decrypt(req);
+
+			switch (ret) {
+			case 0:
+				break;
+			case -EINPROGRESS:
+			case -EBUSY:
+				ret = wait_for_completion_interruptible(
+					&result.completion);
+				if (!ret && !((ret = result.err))) {
+					INIT_COMPLETION(result.completion);
+					break;
+				}
+				/* fall through */
+			default:
+				printk("%s () failed err=%d\n", e, -ret);
+				goto out;
+			}
+
+			temp = 0;
+			for (k = 0; k < template[i].np; k++) {
+				printk("page %u\n", k);
+				q = &xbuf[IDX[k]];
+				hexdump(q, template[i].tap[k]);
+				printk("%s\n",
+					memcmp(q, template[i].result + temp,
+						template[i].tap[k]) ? "fail" :
+					"pass");
+
+				for (n = 0; q[template[i].tap[k] + n]; n++)
+					;
+				if (n) {
+					printk("Result buffer corruption %u "
+					       "bytes:\n", n);
+					hexdump(&q[template[i].tap[k]], n);
+				}
+				temp += template[i].tap[k];
+			}
+		}
+	}
+out:
+	crypto_free_ablkcipher(tfm);
+	ablkcipher_request_free(req);
+}
+
+static int test_cipher_jiffies(struct blkcipher_desc *desc, int enc, char *p,
+			       int blen, int sec)
+{
+	struct scatterlist sg[1];
+	unsigned long start, end;
+	int bcount;
+	int ret;
+
+	sg_init_one(sg, p, blen);
+
+	for (start = jiffies, end = start + sec * HZ, bcount = 0;
+	     time_before(jiffies, end); bcount++) {
+		if (enc)
+			ret = crypto_blkcipher_encrypt(desc, sg, sg, blen);
+		else
+			ret = crypto_blkcipher_decrypt(desc, sg, sg, blen);
+
+		if (ret)
+			return ret;
+	}
+
+	printk("%d operations in %d seconds (%ld bytes)\n",
+	       bcount, sec, (long)bcount * blen);
+	return 0;
+}
+
+static int test_cipher_cycles(struct blkcipher_desc *desc, int enc, char *p,
+			      int blen)
+{
+	struct scatterlist sg[1];
+	unsigned long cycles = 0;
+	int ret = 0;
+	int i;
+
+	sg_init_one(sg, p, blen);
+
+	local_bh_disable();
+	local_irq_disable();
+
+	/* Warm-up run. */
+	for (i = 0; i < 4; i++) {
+		if (enc)
+			ret = crypto_blkcipher_encrypt(desc, sg, sg, blen);
+		else
+			ret = crypto_blkcipher_decrypt(desc, sg, sg, blen);
+
+		if (ret)
+			goto out;
+	}
+
+	/* The real thing. */
+	for (i = 0; i < 8; i++) {
+		cycles_t start, end;
+
+		start = get_cycles();
+		if (enc)
+			ret = crypto_blkcipher_encrypt(desc, sg, sg, blen);
+		else
+			ret = crypto_blkcipher_decrypt(desc, sg, sg, blen);
+		end = get_cycles();
+
+		if (ret)
+			goto out;
+
+		cycles += end - start;
+	}
+
+out:
+	local_irq_enable();
+	local_bh_enable();
+
+	if (ret == 0)
+		printk("1 operation in %lu cycles (%d bytes)\n",
+		       (cycles + 4) / 8, blen);
+
+	return ret;
+}
+
+static u32 block_sizes[] = { 16, 64, 256, 1024, 8192, 0 };
+
+static void test_cipher_speed(char *algo, int enc, unsigned int sec,
+			      struct cipher_testvec *template,
+			      unsigned int tcount, u8 *keysize)
+{
+	unsigned int ret, i, j, iv_len;
+	unsigned char *key, *p, iv[128];
+	struct crypto_blkcipher *tfm;
+	struct blkcipher_desc desc;
+	const char *e;
+	u32 *b_size;
+
+	if (enc == ENCRYPT)
+	        e = "encryption";
+	else
+		e = "decryption";
+
+	printk("\ntesting speed of %s %s\n", algo, e);
+
+	tfm = crypto_alloc_blkcipher(algo, 0, CRYPTO_ALG_ASYNC);
+
+	if (IS_ERR(tfm)) {
+		printk("failed to load transform for %s: %ld\n", algo,
+		       PTR_ERR(tfm));
+		return;
+	}
+	desc.tfm = tfm;
+	desc.flags = 0;
+
+	i = 0;
+	do {
+
+		b_size = block_sizes;
+		do {
+
+			if ((*keysize + *b_size) > TVMEMSIZE) {
+				printk("template (%u) too big for tvmem (%u)\n",
+						*keysize + *b_size, TVMEMSIZE);
+				goto out;
+			}
+
+			printk("test %u (%d bit key, %d byte blocks): ", i,
+					*keysize * 8, *b_size);
+
+			memset(tvmem, 0xff, *keysize + *b_size);
+
+			/* set key, plain text and IV */
+			key = (unsigned char *)tvmem;
+			for (j = 0; j < tcount; j++) {
+				if (template[j].klen == *keysize) {
+					key = template[j].key;
+					break;
+				}
+			}
+			p = (unsigned char *)tvmem + *keysize;
+
+			ret = crypto_blkcipher_setkey(tfm, key, *keysize);
+			if (ret) {
+				printk("setkey() failed flags=%x\n",
+						crypto_blkcipher_get_flags(tfm));
+				goto out;
+			}
+
+			iv_len = crypto_blkcipher_ivsize(tfm);
+			if (iv_len) {
+				memset(&iv, 0xff, iv_len);
+				crypto_blkcipher_set_iv(tfm, iv, iv_len);
+			}
+
+			if (sec)
+				ret = test_cipher_jiffies(&desc, enc, p, *b_size, sec);
+			else
+				ret = test_cipher_cycles(&desc, enc, p, *b_size);
+
+			if (ret) {
+				printk("%s() failed flags=%x\n", e, desc.flags);
+				break;
+			}
+			b_size++;
+			i++;
+		} while (*b_size);
+		keysize++;
+	} while (*keysize);
+
+out:
+	crypto_free_blkcipher(tfm);
+}
+
+static int test_hash_jiffies_digest(struct hash_desc *desc, char *p, int blen,
+				    char *out, int sec)
+{
+	struct scatterlist sg[1];
+	unsigned long start, end;
+	int bcount;
+	int ret;
+
+	sg_init_table(sg, 1);
+
+	for (start = jiffies, end = start + sec * HZ, bcount = 0;
+	     time_before(jiffies, end); bcount++) {
+		sg_set_buf(sg, p, blen);
+		ret = crypto_hash_digest(desc, sg, blen, out);
+		if (ret)
+			return ret;
+	}
+
+	printk("%6u opers/sec, %9lu bytes/sec\n",
+	       bcount / sec, ((long)bcount * blen) / sec);
+
+	return 0;
+}
+
+static int test_hash_jiffies(struct hash_desc *desc, char *p, int blen,
+			     int plen, char *out, int sec)
+{
+	struct scatterlist sg[1];
+	unsigned long start, end;
+	int bcount, pcount;
+	int ret;
+
+	if (plen == blen)
+		return test_hash_jiffies_digest(desc, p, blen, out, sec);
+
+	sg_init_table(sg, 1);
+
+	for (start = jiffies, end = start + sec * HZ, bcount = 0;
+	     time_before(jiffies, end); bcount++) {
+		ret = crypto_hash_init(desc);
+		if (ret)
+			return ret;
+		for (pcount = 0; pcount < blen; pcount += plen) {
+			sg_set_buf(sg, p + pcount, plen);
+			ret = crypto_hash_update(desc, sg, plen);
+			if (ret)
+				return ret;
+		}
+		/* we assume there is enough space in 'out' for the result */
+		ret = crypto_hash_final(desc, out);
+		if (ret)
+			return ret;
+	}
+
+	printk("%6u opers/sec, %9lu bytes/sec\n",
+	       bcount / sec, ((long)bcount * blen) / sec);
+
+	return 0;
+}
+
+static int test_hash_cycles_digest(struct hash_desc *desc, char *p, int blen,
+				   char *out)
+{
+	struct scatterlist sg[1];
+	unsigned long cycles = 0;
+	int i;
+	int ret;
+
+	sg_init_table(sg, 1);
+
+	local_bh_disable();
+	local_irq_disable();
+
+	/* Warm-up run. */
+	for (i = 0; i < 4; i++) {
+		sg_set_buf(sg, p, blen);
+		ret = crypto_hash_digest(desc, sg, blen, out);
+		if (ret)
+			goto out;
+	}
+
+	/* The real thing. */
+	for (i = 0; i < 8; i++) {
+		cycles_t start, end;
+
+		start = get_cycles();
+
+		sg_set_buf(sg, p, blen);
+		ret = crypto_hash_digest(desc, sg, blen, out);
+		if (ret)
+			goto out;
+
+		end = get_cycles();
+
+		cycles += end - start;
+	}
+
+out:
+	local_irq_enable();
+	local_bh_enable();
+
+	if (ret)
+		return ret;
+
+	printk("%6lu cycles/operation, %4lu cycles/byte\n",
+	       cycles / 8, cycles / (8 * blen));
+
+	return 0;
+}
+
+static int test_hash_cycles(struct hash_desc *desc, char *p, int blen,
+			    int plen, char *out)
+{
+	struct scatterlist sg[1];
+	unsigned long cycles = 0;
+	int i, pcount;
+	int ret;
+
+	if (plen == blen)
+		return test_hash_cycles_digest(desc, p, blen, out);
+
+	sg_init_table(sg, 1);
+
+	local_bh_disable();
+	local_irq_disable();
+
+	/* Warm-up run. */
+	for (i = 0; i < 4; i++) {
+		ret = crypto_hash_init(desc);
+		if (ret)
+			goto out;
+		for (pcount = 0; pcount < blen; pcount += plen) {
+			sg_set_buf(sg, p + pcount, plen);
+			ret = crypto_hash_update(desc, sg, plen);
+			if (ret)
+				goto out;
+		}
+		ret = crypto_hash_final(desc, out);
+		if (ret)
+			goto out;
+	}
+
+	/* The real thing. */
+	for (i = 0; i < 8; i++) {
+		cycles_t start, end;
+
+		start = get_cycles();
+
+		ret = crypto_hash_init(desc);
+		if (ret)
+			goto out;
+		for (pcount = 0; pcount < blen; pcount += plen) {
+			sg_set_buf(sg, p + pcount, plen);
+			ret = crypto_hash_update(desc, sg, plen);
+			if (ret)
+				goto out;
+		}
+		ret = crypto_hash_final(desc, out);
+		if (ret)
+			goto out;
+
+		end = get_cycles();
+
+		cycles += end - start;
+	}
+
+out:
+	local_irq_enable();
+	local_bh_enable();
+
+	if (ret)
+		return ret;
+
+	printk("%6lu cycles/operation, %4lu cycles/byte\n",
+	       cycles / 8, cycles / (8 * blen));
+
+	return 0;
+}
+
+static void test_hash_speed(char *algo, unsigned int sec,
+			      struct hash_speed *speed)
+{
+	struct crypto_hash *tfm;
+	struct hash_desc desc;
+	char output[1024];
+	int i;
+	int ret;
+
+	printk("\ntesting speed of %s\n", algo);
+
+	tfm = crypto_alloc_hash(algo, 0, CRYPTO_ALG_ASYNC);
+
+	if (IS_ERR(tfm)) {
+		printk("failed to load transform for %s: %ld\n", algo,
+		       PTR_ERR(tfm));
+		return;
+	}
+
+	desc.tfm = tfm;
+	desc.flags = 0;
+
+	if (crypto_hash_digestsize(tfm) > sizeof(output)) {
+		printk("digestsize(%u) > outputbuffer(%zu)\n",
+		       crypto_hash_digestsize(tfm), sizeof(output));
+		goto out;
+	}
+
+	for (i = 0; speed[i].blen != 0; i++) {
+		if (speed[i].blen > TVMEMSIZE) {
+			printk("template (%u) too big for tvmem (%u)\n",
+			       speed[i].blen, TVMEMSIZE);
+			goto out;
+		}
+
+		printk("test%3u (%5u byte blocks,%5u bytes per update,%4u updates): ",
+		       i, speed[i].blen, speed[i].plen, speed[i].blen / speed[i].plen);
+
+		memset(tvmem, 0xff, speed[i].blen);
+
+		if (sec)
+			ret = test_hash_jiffies(&desc, tvmem, speed[i].blen,
+						speed[i].plen, output, sec);
+		else
+			ret = test_hash_cycles(&desc, tvmem, speed[i].blen,
+					       speed[i].plen, output);
+
+		if (ret) {
+			printk("hashing failed ret=%d\n", ret);
+			break;
+		}
+	}
+
+out:
+	crypto_free_hash(tfm);
+}
+
+static void test_comp(char *algo, struct comp_testvec *ctemplate,
+		       struct comp_testvec *dtemplate, int ctcount, int dtcount)
+{
+	unsigned int i;
+	char result[COMP_BUF_SIZE];
+	struct crypto_comp *tfm;
+	unsigned int tsize;
+
+	printk("\ntesting %s compression\n", algo);
+
+	tfm = crypto_alloc_comp(algo, 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(tfm)) {
+		printk("failed to load transform for %s\n", algo);
+		return;
+	}
+
+	for (i = 0; i < ctcount; i++) {
+		int ilen, ret, dlen = COMP_BUF_SIZE;
+
+		printk("test %u:\n", i + 1);
+		memset(result, 0, sizeof (result));
+
+		ilen = ctemplate[i].inlen;
+		ret = crypto_comp_compress(tfm, ctemplate[i].input,
+		                           ilen, result, &dlen);
+		if (ret) {
+			printk("fail: ret=%d\n", ret);
+			continue;
+		}
+		hexdump(result, dlen);
+		printk("%s (ratio %d:%d)\n",
+		       memcmp(result, ctemplate[i].output, dlen) ? "fail" : "pass",
+		       ilen, dlen);
+	}
+
+	printk("\ntesting %s decompression\n", algo);
+
+	tsize = sizeof(struct comp_testvec);
+	tsize *= dtcount;
+	if (tsize > TVMEMSIZE) {
+		printk("template (%u) too big for tvmem (%u)\n", tsize,
+		       TVMEMSIZE);
+		goto out;
+	}
+
+	for (i = 0; i < dtcount; i++) {
+		int ilen, ret, dlen = COMP_BUF_SIZE;
+
+		printk("test %u:\n", i + 1);
+		memset(result, 0, sizeof (result));
+
+		ilen = dtemplate[i].inlen;
+		ret = crypto_comp_decompress(tfm, dtemplate[i].input,
+		                             ilen, result, &dlen);
+		if (ret) {
+			printk("fail: ret=%d\n", ret);
+			continue;
+		}
+		hexdump(result, dlen);
+		printk("%s (ratio %d:%d)\n",
+		       memcmp(result, dtemplate[i].output, dlen) ? "fail" : "pass",
+		       ilen, dlen);
+	}
+out:
+	crypto_free_comp(tfm);
+}
+
+static void test_available(void)
+{
+	char **name = check;
+
+	while (*name) {
+		printk("alg %s ", *name);
+		printk(crypto_has_alg(*name, 0, 0) ?
+		       "found\n" : "not found\n");
+		name++;
+	}
+}
+
+/*************************
+ * PicoArray Crypto test *
+ *************************/
+
+static void do_picocrypto_test( void )
+{
+	printk( KERN_INFO "Running the PicoArray tests...\n" );
+ 
+	test_authenc("authenc(digest_null,ecb(cipher_null))", DECRYPT, picocrypto_null_ecb_dec_non_tv_template,
+			    PICOCRYPTO_NULL_DEC_NON_TEST_VECTORS);
+
+
+	test_authenc("authenc(digest_null,ecb(cipher_null))", ENCRYPT, picocrypto_null_ecb_enc_non_tv_template,
+			    PICOCRYPTO_NULL_ENC_NON_TEST_VECTORS);
+
+
+#if 1
+	test_authenc("authenc(hmac(sha1),ecb(cipher_null))", DECRYPT, picocrypto_null_ecb_dec_auth_tv_template,
+			    PICOCRYPTO_NULL_DEC_AUTH_TEST_VECTORS);
+#endif
+
+#if 1
+	test_authenc("authenc(hmac(sha1),ecb(cipher_null))", ENCRYPT, picocrypto_null_ecb_enc_auth_tv_template,
+			    PICOCRYPTO_NULL_ENC_AUTH_TEST_VECTORS);
+#endif
+
+#if 1
+	test_authenc("authenc(digest_null,cbc(aes))", DECRYPT, picocrypto_aes_cbc_dec_non_tv_template,
+			    PICOCRYPTO_AES_DEC_NON_TEST_VECTORS);
+#endif
+
+#if 1
+	test_authenc("authenc(digest_null,cbc(aes))", ENCRYPT, picocrypto_aes_cbc_enc_non_tv_template,
+			    PICOCRYPTO_AES_ENC_NON_TEST_VECTORS);
+#endif
+
+#if 1
+	test_authenc("authenc(hmac(sha1),cbc(aes))", DECRYPT, picocrypto_aes_cbc_dec_auth_tv_template,
+			    PICOCRYPTO_AES_DEC_AUTH_TEST_VECTORS);
+#endif
+
+#if 1
+	test_authenc("authenc(hmac(sha1),cbc(aes))", ENCRYPT, picocrypto_aes_cbc_enc_auth_tv_template,
+			    PICOCRYPTO_AES_ENC_AUTH_TEST_VECTORS);
+#endif
+
+}
+
+static void do_test(void)
+{
+	switch (mode) {
+
+	case 0:
+		test_hash("md5", md5_tv_template, MD5_TEST_VECTORS);
+
+		test_hash("sha1", sha1_tv_template, SHA1_TEST_VECTORS);
+
+		//DES
+		test_cipher("ecb(des)", ENCRYPT, des_enc_tv_template,
+			    DES_ENC_TEST_VECTORS);
+		test_cipher("ecb(des)", DECRYPT, des_dec_tv_template,
+			    DES_DEC_TEST_VECTORS);
+		test_cipher("cbc(des)", ENCRYPT, des_cbc_enc_tv_template,
+			    DES_CBC_ENC_TEST_VECTORS);
+		test_cipher("cbc(des)", DECRYPT, des_cbc_dec_tv_template,
+			    DES_CBC_DEC_TEST_VECTORS);
+
+		//DES3_EDE
+		test_cipher("ecb(des3_ede)", ENCRYPT, des3_ede_enc_tv_template,
+			    DES3_EDE_ENC_TEST_VECTORS);
+		test_cipher("ecb(des3_ede)", DECRYPT, des3_ede_dec_tv_template,
+			    DES3_EDE_DEC_TEST_VECTORS);
+
+		test_cipher("cbc(des3_ede)", ENCRYPT,
+			    des3_ede_cbc_enc_tv_template,
+			    DES3_EDE_CBC_ENC_TEST_VECTORS);
+
+		test_cipher("cbc(des3_ede)", DECRYPT,
+			    des3_ede_cbc_dec_tv_template,
+			    DES3_EDE_CBC_DEC_TEST_VECTORS);
+
+		test_hash("md4", md4_tv_template, MD4_TEST_VECTORS);
+
+		test_hash("sha224", sha224_tv_template, SHA224_TEST_VECTORS);
+
+		test_hash("sha256", sha256_tv_template, SHA256_TEST_VECTORS);
+
+		//BLOWFISH
+		test_cipher("ecb(blowfish)", ENCRYPT, bf_enc_tv_template,
+			    BF_ENC_TEST_VECTORS);
+		test_cipher("ecb(blowfish)", DECRYPT, bf_dec_tv_template,
+			    BF_DEC_TEST_VECTORS);
+		test_cipher("cbc(blowfish)", ENCRYPT, bf_cbc_enc_tv_template,
+			    BF_CBC_ENC_TEST_VECTORS);
+		test_cipher("cbc(blowfish)", DECRYPT, bf_cbc_dec_tv_template,
+			    BF_CBC_DEC_TEST_VECTORS);
+
+		//TWOFISH
+		test_cipher("ecb(twofish)", ENCRYPT, tf_enc_tv_template,
+			    TF_ENC_TEST_VECTORS);
+		test_cipher("ecb(twofish)", DECRYPT, tf_dec_tv_template,
+			    TF_DEC_TEST_VECTORS);
+		test_cipher("cbc(twofish)", ENCRYPT, tf_cbc_enc_tv_template,
+			    TF_CBC_ENC_TEST_VECTORS);
+		test_cipher("cbc(twofish)", DECRYPT, tf_cbc_dec_tv_template,
+			    TF_CBC_DEC_TEST_VECTORS);
+
+		//SERPENT
+		test_cipher("ecb(serpent)", ENCRYPT, serpent_enc_tv_template,
+			    SERPENT_ENC_TEST_VECTORS);
+		test_cipher("ecb(serpent)", DECRYPT, serpent_dec_tv_template,
+			    SERPENT_DEC_TEST_VECTORS);
+
+		//TNEPRES
+		test_cipher("ecb(tnepres)", ENCRYPT, tnepres_enc_tv_template,
+			    TNEPRES_ENC_TEST_VECTORS);
+		test_cipher("ecb(tnepres)", DECRYPT, tnepres_dec_tv_template,
+			    TNEPRES_DEC_TEST_VECTORS);
+
+		//AES
+		test_cipher("ecb(aes)", ENCRYPT, aes_enc_tv_template,
+			    AES_ENC_TEST_VECTORS);
+		test_cipher("ecb(aes)", DECRYPT, aes_dec_tv_template,
+			    AES_DEC_TEST_VECTORS);
+		test_cipher("cbc(aes)", ENCRYPT, aes_cbc_enc_tv_template,
+			    AES_CBC_ENC_TEST_VECTORS);
+		test_cipher("cbc(aes)", DECRYPT, aes_cbc_dec_tv_template,
+			    AES_CBC_DEC_TEST_VECTORS);
+		test_cipher("lrw(aes)", ENCRYPT, aes_lrw_enc_tv_template,
+			    AES_LRW_ENC_TEST_VECTORS);
+		test_cipher("lrw(aes)", DECRYPT, aes_lrw_dec_tv_template,
+			    AES_LRW_DEC_TEST_VECTORS);
+		test_cipher("xts(aes)", ENCRYPT, aes_xts_enc_tv_template,
+			    AES_XTS_ENC_TEST_VECTORS);
+		test_cipher("xts(aes)", DECRYPT, aes_xts_dec_tv_template,
+			    AES_XTS_DEC_TEST_VECTORS);
+		test_cipher("rfc3686(ctr(aes))", ENCRYPT, aes_ctr_enc_tv_template,
+			    AES_CTR_ENC_TEST_VECTORS);
+		test_cipher("rfc3686(ctr(aes))", DECRYPT, aes_ctr_dec_tv_template,
+			    AES_CTR_DEC_TEST_VECTORS);
+		test_aead("gcm(aes)", ENCRYPT, aes_gcm_enc_tv_template,
+			  AES_GCM_ENC_TEST_VECTORS);
+		test_aead("gcm(aes)", DECRYPT, aes_gcm_dec_tv_template,
+			  AES_GCM_DEC_TEST_VECTORS);
+		test_aead("ccm(aes)", ENCRYPT, aes_ccm_enc_tv_template,
+			  AES_CCM_ENC_TEST_VECTORS);
+		test_aead("ccm(aes)", DECRYPT, aes_ccm_dec_tv_template,
+			  AES_CCM_DEC_TEST_VECTORS);
+
+		//CAST5
+		test_cipher("ecb(cast5)", ENCRYPT, cast5_enc_tv_template,
+			    CAST5_ENC_TEST_VECTORS);
+		test_cipher("ecb(cast5)", DECRYPT, cast5_dec_tv_template,
+			    CAST5_DEC_TEST_VECTORS);
+
+		//CAST6
+		test_cipher("ecb(cast6)", ENCRYPT, cast6_enc_tv_template,
+			    CAST6_ENC_TEST_VECTORS);
+		test_cipher("ecb(cast6)", DECRYPT, cast6_dec_tv_template,
+			    CAST6_DEC_TEST_VECTORS);
+
+		//ARC4
+		test_cipher("ecb(arc4)", ENCRYPT, arc4_enc_tv_template,
+			    ARC4_ENC_TEST_VECTORS);
+		test_cipher("ecb(arc4)", DECRYPT, arc4_dec_tv_template,
+			    ARC4_DEC_TEST_VECTORS);
+
+		//TEA
+		test_cipher("ecb(tea)", ENCRYPT, tea_enc_tv_template,
+			    TEA_ENC_TEST_VECTORS);
+		test_cipher("ecb(tea)", DECRYPT, tea_dec_tv_template,
+			    TEA_DEC_TEST_VECTORS);
+
+
+		//XTEA
+		test_cipher("ecb(xtea)", ENCRYPT, xtea_enc_tv_template,
+			    XTEA_ENC_TEST_VECTORS);
+		test_cipher("ecb(xtea)", DECRYPT, xtea_dec_tv_template,
+			    XTEA_DEC_TEST_VECTORS);
+
+		//KHAZAD
+		test_cipher("ecb(khazad)", ENCRYPT, khazad_enc_tv_template,
+			    KHAZAD_ENC_TEST_VECTORS);
+		test_cipher("ecb(khazad)", DECRYPT, khazad_dec_tv_template,
+			    KHAZAD_DEC_TEST_VECTORS);
+
+		//ANUBIS
+		test_cipher("ecb(anubis)", ENCRYPT, anubis_enc_tv_template,
+			    ANUBIS_ENC_TEST_VECTORS);
+		test_cipher("ecb(anubis)", DECRYPT, anubis_dec_tv_template,
+			    ANUBIS_DEC_TEST_VECTORS);
+		test_cipher("cbc(anubis)", ENCRYPT, anubis_cbc_enc_tv_template,
+			    ANUBIS_CBC_ENC_TEST_VECTORS);
+		test_cipher("cbc(anubis)", DECRYPT, anubis_cbc_dec_tv_template,
+			    ANUBIS_CBC_ENC_TEST_VECTORS);
+
+		//XETA
+		test_cipher("ecb(xeta)", ENCRYPT, xeta_enc_tv_template,
+			    XETA_ENC_TEST_VECTORS);
+		test_cipher("ecb(xeta)", DECRYPT, xeta_dec_tv_template,
+			    XETA_DEC_TEST_VECTORS);
+
+		//FCrypt
+		test_cipher("pcbc(fcrypt)", ENCRYPT, fcrypt_pcbc_enc_tv_template,
+			    FCRYPT_ENC_TEST_VECTORS);
+		test_cipher("pcbc(fcrypt)", DECRYPT, fcrypt_pcbc_dec_tv_template,
+			    FCRYPT_DEC_TEST_VECTORS);
+
+		//CAMELLIA
+		test_cipher("ecb(camellia)", ENCRYPT,
+			    camellia_enc_tv_template,
+			    CAMELLIA_ENC_TEST_VECTORS);
+		test_cipher("ecb(camellia)", DECRYPT,
+			    camellia_dec_tv_template,
+			    CAMELLIA_DEC_TEST_VECTORS);
+		test_cipher("cbc(camellia)", ENCRYPT,
+			    camellia_cbc_enc_tv_template,
+			    CAMELLIA_CBC_ENC_TEST_VECTORS);
+		test_cipher("cbc(camellia)", DECRYPT,
+			    camellia_cbc_dec_tv_template,
+			    CAMELLIA_CBC_DEC_TEST_VECTORS);
+
+		//SEED
+		test_cipher("ecb(seed)", ENCRYPT, seed_enc_tv_template,
+			    SEED_ENC_TEST_VECTORS);
+		test_cipher("ecb(seed)", DECRYPT, seed_dec_tv_template,
+			    SEED_DEC_TEST_VECTORS);
+
+		//CTS
+		test_cipher("cts(cbc(aes))", ENCRYPT, cts_mode_enc_tv_template,
+			    CTS_MODE_ENC_TEST_VECTORS);
+		test_cipher("cts(cbc(aes))", DECRYPT, cts_mode_dec_tv_template,
+			    CTS_MODE_DEC_TEST_VECTORS);
+
+		test_hash("sha384", sha384_tv_template, SHA384_TEST_VECTORS);
+		test_hash("sha512", sha512_tv_template, SHA512_TEST_VECTORS);
+		test_hash("wp512", wp512_tv_template, WP512_TEST_VECTORS);
+		test_hash("wp384", wp384_tv_template, WP384_TEST_VECTORS);
+		test_hash("wp256", wp256_tv_template, WP256_TEST_VECTORS);
+		test_hash("tgr192", tgr192_tv_template, TGR192_TEST_VECTORS);
+		test_hash("tgr160", tgr160_tv_template, TGR160_TEST_VECTORS);
+		test_hash("tgr128", tgr128_tv_template, TGR128_TEST_VECTORS);
+		test_comp("deflate", deflate_comp_tv_template,
+			  deflate_decomp_tv_template, DEFLATE_COMP_TEST_VECTORS,
+			  DEFLATE_DECOMP_TEST_VECTORS);
+		test_comp("lzo", lzo_comp_tv_template, lzo_decomp_tv_template,
+			  LZO_COMP_TEST_VECTORS, LZO_DECOMP_TEST_VECTORS);
+		test_hash("crc32c", crc32c_tv_template, CRC32C_TEST_VECTORS);
+		test_hash("hmac(md5)", hmac_md5_tv_template,
+			  HMAC_MD5_TEST_VECTORS);
+		test_hash("hmac(sha1)", hmac_sha1_tv_template,
+			  HMAC_SHA1_TEST_VECTORS);
+		test_hash("hmac(sha224)", hmac_sha224_tv_template,
+			  HMAC_SHA224_TEST_VECTORS);
+		test_hash("hmac(sha256)", hmac_sha256_tv_template,
+			  HMAC_SHA256_TEST_VECTORS);
+		test_hash("hmac(sha384)", hmac_sha384_tv_template,
+			  HMAC_SHA384_TEST_VECTORS);
+		test_hash("hmac(sha512)", hmac_sha512_tv_template,
+			  HMAC_SHA512_TEST_VECTORS);
+
+		test_hash("xcbc(aes)", aes_xcbc128_tv_template,
+			  XCBC_AES_TEST_VECTORS);
+
+		test_hash("michael_mic", michael_mic_tv_template, MICHAEL_MIC_TEST_VECTORS);
+		break;
+
+	case 1:
+		test_hash("md5", md5_tv_template, MD5_TEST_VECTORS);
+		break;
+
+	case 2:
+		test_hash("sha1", sha1_tv_template, SHA1_TEST_VECTORS);
+		break;
+
+	case 3:
+		test_cipher("ecb(des)", ENCRYPT, des_enc_tv_template,
+			    DES_ENC_TEST_VECTORS);
+		test_cipher("ecb(des)", DECRYPT, des_dec_tv_template,
+			    DES_DEC_TEST_VECTORS);
+		test_cipher("cbc(des)", ENCRYPT, des_cbc_enc_tv_template,
+			    DES_CBC_ENC_TEST_VECTORS);
+		test_cipher("cbc(des)", DECRYPT, des_cbc_dec_tv_template,
+			    DES_CBC_DEC_TEST_VECTORS);
+		break;
+
+	case 4:
+		test_cipher("ecb(des3_ede)", ENCRYPT, des3_ede_enc_tv_template,
+			    DES3_EDE_ENC_TEST_VECTORS);
+		test_cipher("ecb(des3_ede)", DECRYPT, des3_ede_dec_tv_template,
+			    DES3_EDE_DEC_TEST_VECTORS);
+
+		test_cipher("cbc(des3_ede)", ENCRYPT,
+			    des3_ede_cbc_enc_tv_template,
+			    DES3_EDE_CBC_ENC_TEST_VECTORS);
+
+		test_cipher("cbc(des3_ede)", DECRYPT,
+			    des3_ede_cbc_dec_tv_template,
+			    DES3_EDE_CBC_DEC_TEST_VECTORS);
+		break;
+
+	case 5:
+		test_hash("md4", md4_tv_template, MD4_TEST_VECTORS);
+		break;
+
+	case 6:
+		test_hash("sha256", sha256_tv_template, SHA256_TEST_VECTORS);
+		break;
+
+	case 7:
+		test_cipher("ecb(blowfish)", ENCRYPT, bf_enc_tv_template,
+			    BF_ENC_TEST_VECTORS);
+		test_cipher("ecb(blowfish)", DECRYPT, bf_dec_tv_template,
+			    BF_DEC_TEST_VECTORS);
+		test_cipher("cbc(blowfish)", ENCRYPT, bf_cbc_enc_tv_template,
+			    BF_CBC_ENC_TEST_VECTORS);
+		test_cipher("cbc(blowfish)", DECRYPT, bf_cbc_dec_tv_template,
+			    BF_CBC_DEC_TEST_VECTORS);
+		break;
+
+	case 8:
+		test_cipher("ecb(twofish)", ENCRYPT, tf_enc_tv_template,
+			    TF_ENC_TEST_VECTORS);
+		test_cipher("ecb(twofish)", DECRYPT, tf_dec_tv_template,
+			    TF_DEC_TEST_VECTORS);
+		test_cipher("cbc(twofish)", ENCRYPT, tf_cbc_enc_tv_template,
+			    TF_CBC_ENC_TEST_VECTORS);
+		test_cipher("cbc(twofish)", DECRYPT, tf_cbc_dec_tv_template,
+			    TF_CBC_DEC_TEST_VECTORS);
+		break;
+
+	case 9:
+		test_cipher("ecb(serpent)", ENCRYPT, serpent_enc_tv_template,
+			    SERPENT_ENC_TEST_VECTORS);
+		test_cipher("ecb(serpent)", DECRYPT, serpent_dec_tv_template,
+			    SERPENT_DEC_TEST_VECTORS);
+		break;
+
+	case 10:
+		test_cipher("ecb(aes)", ENCRYPT, aes_enc_tv_template,
+			    AES_ENC_TEST_VECTORS);
+		test_cipher("ecb(aes)", DECRYPT, aes_dec_tv_template,
+			    AES_DEC_TEST_VECTORS);
+		test_cipher("cbc(aes)", ENCRYPT, aes_cbc_enc_tv_template,
+			    AES_CBC_ENC_TEST_VECTORS);
+		test_cipher("cbc(aes)", DECRYPT, aes_cbc_dec_tv_template,
+			    AES_CBC_DEC_TEST_VECTORS);
+		test_cipher("lrw(aes)", ENCRYPT, aes_lrw_enc_tv_template,
+			    AES_LRW_ENC_TEST_VECTORS);
+		test_cipher("lrw(aes)", DECRYPT, aes_lrw_dec_tv_template,
+			    AES_LRW_DEC_TEST_VECTORS);
+		test_cipher("xts(aes)", ENCRYPT, aes_xts_enc_tv_template,
+			    AES_XTS_ENC_TEST_VECTORS);
+		test_cipher("xts(aes)", DECRYPT, aes_xts_dec_tv_template,
+			    AES_XTS_DEC_TEST_VECTORS);
+		test_cipher("rfc3686(ctr(aes))", ENCRYPT, aes_ctr_enc_tv_template,
+			    AES_CTR_ENC_TEST_VECTORS);
+		test_cipher("rfc3686(ctr(aes))", DECRYPT, aes_ctr_dec_tv_template,
+			    AES_CTR_DEC_TEST_VECTORS);
+		break;
+
+	case 11:
+		test_hash("sha384", sha384_tv_template, SHA384_TEST_VECTORS);
+		break;
+
+	case 12:
+		test_hash("sha512", sha512_tv_template, SHA512_TEST_VECTORS);
+		break;
+
+	case 13:
+		test_comp("deflate", deflate_comp_tv_template,
+			  deflate_decomp_tv_template, DEFLATE_COMP_TEST_VECTORS,
+			  DEFLATE_DECOMP_TEST_VECTORS);
+		break;
+
+	case 14:
+		test_cipher("ecb(cast5)", ENCRYPT, cast5_enc_tv_template,
+			    CAST5_ENC_TEST_VECTORS);
+		test_cipher("ecb(cast5)", DECRYPT, cast5_dec_tv_template,
+			    CAST5_DEC_TEST_VECTORS);
+		break;
+
+	case 15:
+		test_cipher("ecb(cast6)", ENCRYPT, cast6_enc_tv_template,
+			    CAST6_ENC_TEST_VECTORS);
+		test_cipher("ecb(cast6)", DECRYPT, cast6_dec_tv_template,
+			    CAST6_DEC_TEST_VECTORS);
+		break;
+
+	case 16:
+		test_cipher("ecb(arc4)", ENCRYPT, arc4_enc_tv_template,
+			    ARC4_ENC_TEST_VECTORS);
+		test_cipher("ecb(arc4)", DECRYPT, arc4_dec_tv_template,
+			    ARC4_DEC_TEST_VECTORS);
+		break;
+
+	case 17:
+		test_hash("michael_mic", michael_mic_tv_template, MICHAEL_MIC_TEST_VECTORS);
+		break;
+
+	case 18:
+		test_hash("crc32c", crc32c_tv_template, CRC32C_TEST_VECTORS);
+		break;
+
+	case 19:
+		test_cipher("ecb(tea)", ENCRYPT, tea_enc_tv_template,
+			    TEA_ENC_TEST_VECTORS);
+		test_cipher("ecb(tea)", DECRYPT, tea_dec_tv_template,
+			    TEA_DEC_TEST_VECTORS);
+		break;
+
+	case 20:
+		test_cipher("ecb(xtea)", ENCRYPT, xtea_enc_tv_template,
+			    XTEA_ENC_TEST_VECTORS);
+		test_cipher("ecb(xtea)", DECRYPT, xtea_dec_tv_template,
+			    XTEA_DEC_TEST_VECTORS);
+		break;
+
+	case 21:
+		test_cipher("ecb(khazad)", ENCRYPT, khazad_enc_tv_template,
+			    KHAZAD_ENC_TEST_VECTORS);
+		test_cipher("ecb(khazad)", DECRYPT, khazad_dec_tv_template,
+			    KHAZAD_DEC_TEST_VECTORS);
+		break;
+
+	case 22:
+		test_hash("wp512", wp512_tv_template, WP512_TEST_VECTORS);
+		break;
+
+	case 23:
+		test_hash("wp384", wp384_tv_template, WP384_TEST_VECTORS);
+		break;
+
+	case 24:
+		test_hash("wp256", wp256_tv_template, WP256_TEST_VECTORS);
+		break;
+
+	case 25:
+		test_cipher("ecb(tnepres)", ENCRYPT, tnepres_enc_tv_template,
+			    TNEPRES_ENC_TEST_VECTORS);
+		test_cipher("ecb(tnepres)", DECRYPT, tnepres_dec_tv_template,
+			    TNEPRES_DEC_TEST_VECTORS);
+		break;
+
+	case 26:
+		test_cipher("ecb(anubis)", ENCRYPT, anubis_enc_tv_template,
+			    ANUBIS_ENC_TEST_VECTORS);
+		test_cipher("ecb(anubis)", DECRYPT, anubis_dec_tv_template,
+			    ANUBIS_DEC_TEST_VECTORS);
+		test_cipher("cbc(anubis)", ENCRYPT, anubis_cbc_enc_tv_template,
+			    ANUBIS_CBC_ENC_TEST_VECTORS);
+		test_cipher("cbc(anubis)", DECRYPT, anubis_cbc_dec_tv_template,
+			    ANUBIS_CBC_ENC_TEST_VECTORS);
+		break;
+
+	case 27:
+		test_hash("tgr192", tgr192_tv_template, TGR192_TEST_VECTORS);
+		break;
+
+	case 28:
+
+		test_hash("tgr160", tgr160_tv_template, TGR160_TEST_VECTORS);
+		break;
+
+	case 29:
+		test_hash("tgr128", tgr128_tv_template, TGR128_TEST_VECTORS);
+		break;
+
+	case 30:
+		test_cipher("ecb(xeta)", ENCRYPT, xeta_enc_tv_template,
+			    XETA_ENC_TEST_VECTORS);
+		test_cipher("ecb(xeta)", DECRYPT, xeta_dec_tv_template,
+			    XETA_DEC_TEST_VECTORS);
+		break;
+
+	case 31:
+		test_cipher("pcbc(fcrypt)", ENCRYPT, fcrypt_pcbc_enc_tv_template,
+			    FCRYPT_ENC_TEST_VECTORS);
+		test_cipher("pcbc(fcrypt)", DECRYPT, fcrypt_pcbc_dec_tv_template,
+			    FCRYPT_DEC_TEST_VECTORS);
+		break;
+
+	case 32:
+		test_cipher("ecb(camellia)", ENCRYPT,
+			    camellia_enc_tv_template,
+			    CAMELLIA_ENC_TEST_VECTORS);
+		test_cipher("ecb(camellia)", DECRYPT,
+			    camellia_dec_tv_template,
+			    CAMELLIA_DEC_TEST_VECTORS);
+		test_cipher("cbc(camellia)", ENCRYPT,
+			    camellia_cbc_enc_tv_template,
+			    CAMELLIA_CBC_ENC_TEST_VECTORS);
+		test_cipher("cbc(camellia)", DECRYPT,
+			    camellia_cbc_dec_tv_template,
+			    CAMELLIA_CBC_DEC_TEST_VECTORS);
+		break;
+	case 33:
+		test_hash("sha224", sha224_tv_template, SHA224_TEST_VECTORS);
+		break;
+
+	case 34:
+		test_cipher("salsa20", ENCRYPT,
+			    salsa20_stream_enc_tv_template,
+			    SALSA20_STREAM_ENC_TEST_VECTORS);
+		break;
+
+	case 35:
+		test_aead("gcm(aes)", ENCRYPT, aes_gcm_enc_tv_template,
+			  AES_GCM_ENC_TEST_VECTORS);
+		test_aead("gcm(aes)", DECRYPT, aes_gcm_dec_tv_template,
+			  AES_GCM_DEC_TEST_VECTORS);
+		break;
+
+	case 36:
+		test_comp("lzo", lzo_comp_tv_template, lzo_decomp_tv_template,
+			  LZO_COMP_TEST_VECTORS, LZO_DECOMP_TEST_VECTORS);
+		break;
+
+	case 37:
+		test_aead("ccm(aes)", ENCRYPT, aes_ccm_enc_tv_template,
+			  AES_CCM_ENC_TEST_VECTORS);
+		test_aead("ccm(aes)", DECRYPT, aes_ccm_dec_tv_template,
+			  AES_CCM_DEC_TEST_VECTORS);
+		break;
+
+	case 38:
+		test_cipher("cts(cbc(aes))", ENCRYPT, cts_mode_enc_tv_template,
+			    CTS_MODE_ENC_TEST_VECTORS);
+		test_cipher("cts(cbc(aes))", DECRYPT, cts_mode_dec_tv_template,
+			    CTS_MODE_DEC_TEST_VECTORS);
+		break;
+
+        case 39:
+		test_hash("rmd128", rmd128_tv_template, RMD128_TEST_VECTORS);
+		break;
+
+        case 40:
+		test_hash("rmd160", rmd160_tv_template, RMD160_TEST_VECTORS);
+		break;
+
+	case 41:
+		test_hash("rmd256", rmd256_tv_template, RMD256_TEST_VECTORS);
+		break;
+
+	case 42:
+		test_hash("rmd320", rmd320_tv_template, RMD320_TEST_VECTORS);
+		break;
+
+	case 100:
+		test_hash("hmac(md5)", hmac_md5_tv_template,
+			  HMAC_MD5_TEST_VECTORS);
+		break;
+
+	case 101:
+		test_hash("hmac(sha1)", hmac_sha1_tv_template,
+			  HMAC_SHA1_TEST_VECTORS);
+		break;
+
+	case 102:
+		test_hash("hmac(sha256)", hmac_sha256_tv_template,
+			  HMAC_SHA256_TEST_VECTORS);
+		break;
+
+	case 103:
+		test_hash("hmac(sha384)", hmac_sha384_tv_template,
+			  HMAC_SHA384_TEST_VECTORS);
+		break;
+
+	case 104:
+		test_hash("hmac(sha512)", hmac_sha512_tv_template,
+			  HMAC_SHA512_TEST_VECTORS);
+		break;
+
+	case 105:
+		test_hash("hmac(sha224)", hmac_sha224_tv_template,
+			  HMAC_SHA224_TEST_VECTORS);
+		break;
+
+	case 106:
+		test_hash("xcbc(aes)", aes_xcbc128_tv_template,
+			  XCBC_AES_TEST_VECTORS);
+		break;
+
+	case 107:
+		test_hash("hmac(rmd128)", hmac_rmd128_tv_template,
+			  HMAC_RMD128_TEST_VECTORS);
+		break;
+
+	case 108:
+		test_hash("hmac(rmd160)", hmac_rmd160_tv_template,
+			  HMAC_RMD160_TEST_VECTORS);
+		break;
+
+	case 200:
+		test_cipher_speed("ecb(aes)", ENCRYPT, sec, NULL, 0,
+				speed_template_16_24_32);
+		test_cipher_speed("ecb(aes)", DECRYPT, sec, NULL, 0,
+				speed_template_16_24_32);
+		test_cipher_speed("cbc(aes)", ENCRYPT, sec, NULL, 0,
+				speed_template_16_24_32);
+		test_cipher_speed("cbc(aes)", DECRYPT, sec, NULL, 0,
+				speed_template_16_24_32);
+		test_cipher_speed("lrw(aes)", ENCRYPT, sec, NULL, 0,
+				speed_template_32_40_48);
+		test_cipher_speed("lrw(aes)", DECRYPT, sec, NULL, 0,
+				speed_template_32_40_48);
+		test_cipher_speed("xts(aes)", ENCRYPT, sec, NULL, 0,
+				speed_template_32_48_64);
+		test_cipher_speed("xts(aes)", DECRYPT, sec, NULL, 0,
+				speed_template_32_48_64);
+		break;
+
+	case 201:
+		test_cipher_speed("ecb(des3_ede)", ENCRYPT, sec,
+				des3_ede_enc_tv_template, DES3_EDE_ENC_TEST_VECTORS,
+				speed_template_24);
+		test_cipher_speed("ecb(des3_ede)", DECRYPT, sec,
+				des3_ede_enc_tv_template, DES3_EDE_ENC_TEST_VECTORS,
+				speed_template_24);
+		test_cipher_speed("cbc(des3_ede)", ENCRYPT, sec,
+				des3_ede_enc_tv_template, DES3_EDE_ENC_TEST_VECTORS,
+				speed_template_24);
+		test_cipher_speed("cbc(des3_ede)", DECRYPT, sec,
+				des3_ede_enc_tv_template, DES3_EDE_ENC_TEST_VECTORS,
+				speed_template_24);
+		break;
+
+	case 202:
+		test_cipher_speed("ecb(twofish)", ENCRYPT, sec, NULL, 0,
+				speed_template_16_24_32);
+		test_cipher_speed("ecb(twofish)", DECRYPT, sec, NULL, 0,
+				speed_template_16_24_32);
+		test_cipher_speed("cbc(twofish)", ENCRYPT, sec, NULL, 0,
+				speed_template_16_24_32);
+		test_cipher_speed("cbc(twofish)", DECRYPT, sec, NULL, 0,
+				speed_template_16_24_32);
+		break;
+
+	case 203:
+		test_cipher_speed("ecb(blowfish)", ENCRYPT, sec, NULL, 0,
+				  speed_template_8_32);
+		test_cipher_speed("ecb(blowfish)", DECRYPT, sec, NULL, 0,
+				  speed_template_8_32);
+		test_cipher_speed("cbc(blowfish)", ENCRYPT, sec, NULL, 0,
+				  speed_template_8_32);
+		test_cipher_speed("cbc(blowfish)", DECRYPT, sec, NULL, 0,
+				  speed_template_8_32);
+		break;
+
+	case 204:
+		test_cipher_speed("ecb(des)", ENCRYPT, sec, NULL, 0,
+				  speed_template_8);
+		test_cipher_speed("ecb(des)", DECRYPT, sec, NULL, 0,
+				  speed_template_8);
+		test_cipher_speed("cbc(des)", ENCRYPT, sec, NULL, 0,
+				  speed_template_8);
+		test_cipher_speed("cbc(des)", DECRYPT, sec, NULL, 0,
+				  speed_template_8);
+		break;
+
+	case 205:
+		test_cipher_speed("ecb(camellia)", ENCRYPT, sec, NULL, 0,
+				speed_template_16_24_32);
+		test_cipher_speed("ecb(camellia)", DECRYPT, sec, NULL, 0,
+				speed_template_16_24_32);
+		test_cipher_speed("cbc(camellia)", ENCRYPT, sec, NULL, 0,
+				speed_template_16_24_32);
+		test_cipher_speed("cbc(camellia)", DECRYPT, sec, NULL, 0,
+				speed_template_16_24_32);
+		break;
+
+	case 206:
+		test_cipher_speed("salsa20", ENCRYPT, sec, NULL, 0,
+				  speed_template_16_32);
+		break;
+
+	case 300:
+		/* fall through */
+
+	case 301:
+		test_hash_speed("md4", sec, generic_hash_speed_template);
+		if (mode > 300 && mode < 400) break;
+
+	case 302:
+		test_hash_speed("md5", sec, generic_hash_speed_template);
+		if (mode > 300 && mode < 400) break;
+
+	case 303:
+		test_hash_speed("sha1", sec, generic_hash_speed_template);
+		if (mode > 300 && mode < 400) break;
+
+	case 304:
+		test_hash_speed("sha256", sec, generic_hash_speed_template);
+		if (mode > 300 && mode < 400) break;
+
+	case 305:
+		test_hash_speed("sha384", sec, generic_hash_speed_template);
+		if (mode > 300 && mode < 400) break;
+
+	case 306:
+		test_hash_speed("sha512", sec, generic_hash_speed_template);
+		if (mode > 300 && mode < 400) break;
+
+	case 307:
+		test_hash_speed("wp256", sec, generic_hash_speed_template);
+		if (mode > 300 && mode < 400) break;
+
+	case 308:
+		test_hash_speed("wp384", sec, generic_hash_speed_template);
+		if (mode > 300 && mode < 400) break;
+
+	case 309:
+		test_hash_speed("wp512", sec, generic_hash_speed_template);
+		if (mode > 300 && mode < 400) break;
+
+	case 310:
+		test_hash_speed("tgr128", sec, generic_hash_speed_template);
+		if (mode > 300 && mode < 400) break;
+
+	case 311:
+		test_hash_speed("tgr160", sec, generic_hash_speed_template);
+		if (mode > 300 && mode < 400) break;
+
+	case 312:
+		test_hash_speed("tgr192", sec, generic_hash_speed_template);
+		if (mode > 300 && mode < 400) break;
+
+	case 313:
+		test_hash_speed("sha224", sec, generic_hash_speed_template);
+		if (mode > 300 && mode < 400) break;
+
+	case 314:
+		test_hash_speed("rmd128", sec, generic_hash_speed_template);
+		if (mode > 300 && mode < 400) break;
+
+	case 315:
+		test_hash_speed("rmd160", sec, generic_hash_speed_template);
+		if (mode > 300 && mode < 400) break;
+
+	case 316:
+		test_hash_speed("rmd256", sec, generic_hash_speed_template);
+		if (mode > 300 && mode < 400) break;
+
+	case 317:
+		test_hash_speed("rmd320", sec, generic_hash_speed_template);
+		if (mode > 300 && mode < 400) break;
+
+	case 399:
+		break;
+
+	case 999:
+		do_picocrypto_test();
+		break;
+
+	case 1000:
+		test_available();
+		break;
+
+	default:
+		/* useful for debugging */
+		printk("not testing anything\n");
+		break;
+	}
+}
+
+static int __init tcrypt_mod_init(void)
+{
+	int err = -ENOMEM;
+
+	tvmem = kmalloc(TVMEMSIZE, GFP_KERNEL);
+	if (tvmem == NULL)
+		return err;
+
+	xbuf = kmalloc(XBUFSIZE, GFP_KERNEL);
+	if (xbuf == NULL)
+		goto err_free_tv;
+
+	axbuf = kmalloc(XBUFSIZE, GFP_KERNEL);
+	if (axbuf == NULL)
+		goto err_free_xbuf;
+
+	/* run the PicoArray Crypto tests */	
+	do_test();
+	
+	/* We intentionaly return -EAGAIN to prevent keeping
+	 * the module. It does all its work from init()
+	 * and doesn't offer any runtime functionality 
+	 * => we don't need it in the memory, do we?
+	 *                                        -- mludvig
+	 */
+	err = -EAGAIN;
+
+	kfree(axbuf);
+ err_free_xbuf:
+	kfree(xbuf);
+ err_free_tv:
+	kfree(tvmem);
+
+	printk( KERN_INFO "Exiting...\n" );
+
+	return err;
+}
+
+/*
+ * If an init function is provided, an exit function must also be provided
+ * to allow module unload.
+ */
+static void __exit tcrypt_mod_fini(void) { }
+
+module_init(tcrypt_mod_init);
+module_exit(tcrypt_mod_fini);
+
+module_param(mode, int, 0);
+module_param(sec, uint, 0);
+MODULE_PARM_DESC(sec, "Length in seconds of speed tests "
+		      "(defaults to zero which uses CPU cycles instead)");
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Quick & dirty crypto testing module");
+MODULE_AUTHOR("James Morris <jmorris@intercode.com.au>");
diff -Naur pico_2.6.28/drivers/ipa/ipa_debug/ipa_debug_card.c ipa_2.6.28/drivers/ipa/ipa_debug/ipa_debug_card.c
--- pico_2.6.28/drivers/ipa/ipa_debug/ipa_debug_card.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/ipa/ipa_debug/ipa_debug_card.c	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,88 @@
+/******************************************************************************
+ *
+ * Copyright (c) 2009 ip.access Ltd.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ * 22 Apr 2009 Created by Simon D Hughes.
+ *
+ * Debug card driver API.  Communicates with FPGA on debug card via EBI.
+ *****************************************************************************
+ * Filename: 
+ *****************************************************************************/
+
+#include "ipa_debug_card.h"
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+static int ipaDebugDevice = -1;
+
+#define MAX_MESSAGE_SIZE 1024
+
+/* Must be called before attempting to write debug messages,
+ * only needs to be called once.
+ * Returns FALSE if it fails to open the device.
+ */
+int openIpaDebugCard(void)
+{
+    if (ipaDebugDevice == -1)
+    {
+        ipaDebugDevice = open("/dev/ipa_debug0", O_SYNC | O_WRONLY);
+    }
+    return (ipaDebugDevice == -1);
+}
+
+/* May be called to close the device.
+ */
+void closeIpaDebugCard(void)
+{
+    if (ipaDebugDevice != -1)
+    {
+        close(ipaDebugDevice);
+    }
+}
+
+/* Pushes a message to the FPGA to be sent out of the USB tracing port.
+ *   pid may be 0-15, is used to identify the process.
+ *   message is an array of 16bit words to be sent as payload.
+ *   length is the size of the message in 16bit words.
+ */
+int  writeIpaDebugMessage(unsigned char pid, unsigned short* message, unsigned short length)
+{
+    int wordsWritten = 0;
+
+    if ((pid <= 15) &&
+        (message != 0) && 
+        (length > 0) && 
+        ((length*2+2) < MAX_MESSAGE_SIZE))
+    {
+        unsigned char messageBuffer[MAX_MESSAGE_SIZE];
+        int index = 0;
+        unsigned short pidBit = 0;
+        /* pack pid */
+        pidBit = 1 << pid;
+        messageBuffer[0] = (pidBit >> 8);
+        messageBuffer[1] = (pidBit & 0x00ff);
+        /* pack message words */
+        for (index = 2; index <= (length*2); index += 2)
+        {
+            messageBuffer[index]   = (*message >> 8);
+            messageBuffer[index+1] = (*message & 0x00ff);
+            message++;
+            wordsWritten++;
+        }
+        if (write(ipaDebugDevice, messageBuffer, (length*2+2)) != (length*2+2))
+        {
+            wordsWritten = 0;
+        }
+        fsync(ipaDebugDevice);
+    }
+    return wordsWritten;
+}
+
+
diff -Naur pico_2.6.28/drivers/ipa/ipa_debug/ipa_debug_card.h ipa_2.6.28/drivers/ipa/ipa_debug/ipa_debug_card.h
--- pico_2.6.28/drivers/ipa/ipa_debug/ipa_debug_card.h	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/ipa/ipa_debug/ipa_debug_card.h	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,37 @@
+/******************************************************************************
+ *
+ * Copyright (c) 2009 ip.access Ltd.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ * 22 Apr 2009 Created by Simon D Hughes.
+ *
+ * Debug card driver API.  Communicates with FPGA on debug card via EBI.
+ *****************************************************************************
+ * Filename: 
+ *****************************************************************************/
+
+#ifndef IPA_DEBUG_CARD_H
+#define IPA_DEBUG_CARD_H
+
+/* Must be called before attempting to write debug messages,
+ * only needs to be called once.
+ * Returns 1 if it fails to open the device.
+ */
+int openIpaDebugCard(void);
+
+/* May be called to close the device.
+ */
+void closeIpaDebugCard(void);
+
+/* Pushes a message to the FPGA to be sent out of the USB tracing port.
+ *   pid may be 0-15, is used to identify the process.
+ *   message is an array of 16bit words to be sent as payload.
+ *   length is the size of the message in 16bit words.
+ */
+int  writeIpaDebugMessage(unsigned char pid, unsigned short* message, unsigned short length);
+
+#endif
diff -Naur pico_2.6.28/drivers/ipa/ipa_debug/ipa_debug_card_test.c ipa_2.6.28/drivers/ipa/ipa_debug/ipa_debug_card_test.c
--- pico_2.6.28/drivers/ipa/ipa_debug/ipa_debug_card_test.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/ipa/ipa_debug/ipa_debug_card_test.c	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,108 @@
+/******************************************************************************
+ *
+ * Copyright (c) 2009 ip.access Ltd.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ * 22 Apr 2009 Created by Simon D Hughes.
+ *
+ * Debug card driver API.  Communicates with FPGA on debug card via EBI.
+ *****************************************************************************
+ * Filename: 
+ *****************************************************************************/
+
+#include "ipa_debug_card.h"
+#include <stdio.h>
+
+unsigned short testVector[] = 
+{
+    0x0001, 0x0002, 0x0004, 0x0008,
+    0x0001, 0x0002, 0x0004, 0x0008,
+    0x0001, 0x0002, 0x0004, 0x0008,
+    0x0001, 0x0002, 0x0004, 0x0008,
+//     0xBEEF, 0xC0DE, 0xBEEF, 0xC0DE,
+//     0xBEEF, 0xC0DE, 0xBEEF, 0xC0DE,
+//     0xBEEF, 0xC0DE, 0xBEEF, 0xC0DE,
+//     0xBEEF, 0xC0DE, 0xBEEF, 0xC0DE,
+//     0xABAB, 0xABAB, 0xABAB, 0xABAB,    
+//     0xABAB, 0xABAB, 0xABAB, 0xABAB,    
+//     0xABAB, 0xABAB, 0xABAB, 0xABAB,    
+//     0xABAB, 0xABAB, 0xABAB, 0xABAB,    
+    0x8000, 0x4000, 0x2000, 0x1000,
+    0x0800, 0x0400, 0x0200, 0x0100,
+    0x0080, 0x0040, 0x0020, 0x0010,
+    0x0008, 0x0004, 0x0002, 0x0001,
+    0x0001, 0x0002, 0x0004, 0x0008,
+    0x0001, 0x0002, 0x0004, 0x0008,
+    0x0001, 0x0002, 0x0004, 0x0008,
+    0x0001, 0x0002, 0x0004, 0x0008,
+    0x8000, 0x4000, 0x2000, 0x1000,
+    0x0800, 0x0400, 0x0200, 0x0100,
+    0x0080, 0x0040, 0x0020, 0x0010,
+    0x0008, 0x0004, 0x0002, 0x0001,
+    0x0001, 0x0002, 0x0004, 0x0008,
+    0x0001, 0x0002, 0x0004, 0x0008,
+    0x0001, 0x0002, 0x0004, 0x0008,
+    0x0001, 0x0002, 0x0004, 0x0008,
+//     0xBEEF, 0xC0DE, 0xBEEF, 0xC0DE,
+//     0xBEEF, 0xC0DE, 0xBEEF, 0xC0DE,
+//     0xBEEF, 0xC0DE, 0xBEEF, 0xC0DE,
+//     0xBEEF, 0xC0DE, 0xBEEF, 0xC0DE,
+//     0xABAB, 0xABAB, 0xABAB, 0xABAB,    
+//     0xABAB, 0xABAB, 0xABAB, 0xABAB,    
+//     0xABAB, 0xABAB, 0xABAB, 0xABAB,    
+//     0xABAB, 0xABAB, 0xABAB, 0xABAB,    
+    0x8000, 0x4000, 0x2000, 0x1000,
+    0x0800, 0x0400, 0x0200, 0x0100,
+    0x0080, 0x0040, 0x0020, 0x0010,
+    0x0008, 0x0004, 0x0002, 0x0001,
+};
+
+int main(int argc, char* argv[])
+{
+    int maxPid = 1;
+    int verbose = 0;
+
+    if (argc > 1)
+    {
+        maxPid = atoi(argv[1]);
+    }
+    if (maxPid < 1 || maxPid > 16)
+    {
+        maxPid = 1;
+    }
+    if (argc > 2)
+    {
+        verbose = atoi(argv[2]);
+    }
+
+    if (openIpaDebugCard() == 0)
+    {
+        int pid = 0;
+        for (pid = 0; pid < maxPid; pid++)
+        {
+            if (writeIpaDebugMessage(pid, testVector, sizeof(testVector)/sizeof(unsigned short)) > 0)
+            {
+                if (verbose)
+                {
+                    int index = 0;
+                    printf("For PID %u, wrote: \n",pid);
+                    for (index = 0; index < sizeof(testVector)/sizeof(unsigned short); index++)
+                    {
+                        printf(" 0x%04X", testVector[index]);
+                        if (((index+1)%4) == 0)
+                        {
+                            printf("\n");
+                        }
+                    }
+                    printf("\n");
+                }
+            }
+        }
+        closeIpaDebugCard();
+    }
+    return 0;
+}
diff -Naur pico_2.6.28/drivers/ipa/ipa_debug/ipa_debug_main.c ipa_2.6.28/drivers/ipa/ipa_debug/ipa_debug_main.c
--- pico_2.6.28/drivers/ipa/ipa_debug/ipa_debug_main.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/ipa/ipa_debug/ipa_debug_main.c	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,793 @@
+/******************************************************************************
+ *
+ * Copyright (c) 2009 ip.access Ltd.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ * 22 Apr 2009 Created by Simon D Hughes.
+ *
+ * Debug card driver.  Communicates with FPGA on debug card via EBI.
+ *****************************************************************************
+ * Filename: 
+ *****************************************************************************/
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/cdev.h>
+#include <linux/ioport.h>
+#include <linux/uio.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+#if defined(CONFIG_ARCH_FIRECRACKER)
+#include <mach/pc20x/pc20x.h>
+#elif defined(CONFIG_ARCH_PC302)
+#include <mach/pc302/pc302.h>
+#include <mach/pc302/ebi.h>
+#else  /* CONFIG_ARCH_... */
+#  error "Unknown architecture"
+#endif /* CONFIG_ARCH_... */
+
+#include <mach/hardware.h>
+
+#if defined(CONFIG_IPACCESS_FPGA_DEBUG)
+#include <mach/fpga_debug.h>
+#endif /* defined(CONFIG_IPACCESS_FPGA_DEBUG) */
+
+#define IPA_DEBUG_MAJOR 212
+#define DEVICE_NAME "ipa_debug"
+
+#define TEST_FPGA_INTERFACE 0
+
+#define noIPA_VERBOSE 1
+
+#ifdef IPA_VERBOSE 
+#define IPA_PRINTK(A) printk A
+#else
+#define IPA_PRINTK(A)
+#endif
+
+#define START_OF_MESSAGE    0xFAFA
+#define ESCAPE_SEQUENCE     0xFAF8
+#define SWITCH_OF_CHANNEL   0xFAF9
+#define END_OF_MESSAGE      0xFAFB
+
+/* Defined in PC202 programmer's guide, section 3.2.1
+ * Start address for external chip 2.
+ */
+#define DEBUG_FPGA_BASE_ADDRESS                     IO_ADDRESS(0x40000000)
+
+#define LWORD_TO_BYTE(A)                            ((A) * 4)
+
+#define DEBUG_FPGA_BASE_OFFSET                      0
+#define FPGA_VERSION_REGISTER(bASE)                 ((bASE) + DEBUG_FPGA_BASE_OFFSET)
+#define FPGA_BUFFER_READ_CONTROL_REGISTER(bASE)     ((bASE) + DEBUG_FPGA_BASE_OFFSET + LWORD_TO_BYTE(0x01))
+#define FPGA_TEST_REGISTER(bASE)                    ((bASE) + DEBUG_FPGA_BASE_OFFSET + LWORD_TO_BYTE(0x02))
+#define FPGA_BUFFER_DEPTH_REGISTER(bASE)            ((bASE) + DEBUG_FPGA_BASE_OFFSET + LWORD_TO_BYTE(0x03))
+#define FPGA_DATA_LOSS_TOKEN1_REGISTER(bASE)        ((bASE) + DEBUG_FPGA_BASE_OFFSET + LWORD_TO_BYTE(0x04))
+#define FPGA_DATA_LOSS_TOKEN2_REGISTER(bASE)        ((bASE) + DEBUG_FPGA_BASE_OFFSET + LWORD_TO_BYTE(0x05))
+#define FPGA_CLEAR_BUFFER_REGISTER(bASE)            ((bASE) + DEBUG_FPGA_BASE_OFFSET + LWORD_TO_BYTE(0x06))
+#define FPGA_ARM_PID_ENABLE_REGISTER(bASE)          ((bASE) + DEBUG_FPGA_BASE_OFFSET + LWORD_TO_BYTE(0x10))
+#define FPGA_ARM_PID_VALUE_REGISTER(bASE)           ((bASE) + DEBUG_FPGA_BASE_OFFSET + LWORD_TO_BYTE(0x11))
+#define FPGA_ARM_MESSAGE_WRITE_REGISTER(bASE)       ((bASE) + DEBUG_FPGA_BASE_OFFSET + LWORD_TO_BYTE(0x12))
+#define FPGA_ARM_MESSAGE_TERMINATE_REGISTER(bASE)   ((bASE) + DEBUG_FPGA_BASE_OFFSET + LWORD_TO_BYTE(0x13))
+#define FPGA_ARM_NUM_WORDS_REGISTER(bASE)           ((bASE) + DEBUG_FPGA_BASE_OFFSET + LWORD_TO_BYTE(0x14))
+#define FPGA_ARM_MESSAGE_READ_REGISTER(bASE)        ((bASE) + DEBUG_FPGA_BASE_OFFSET + LWORD_TO_BYTE(0x15))
+
+#define DEBUG_FPGA_SIZEOF_REG_MAP             LWORD_TO_BYTE(0x20)
+
+/* Buffer Read Control values */
+#define BUFFER_DATA_GOES_TO_USB               0x00
+#define BUFFER_DATA_GOES_TO_ARM               0x01
+
+/* Dataloss token, magic pattern for detecting overruns */
+#define DATA_LOSS_TOKEN1                       0xdead
+#define DATA_LOSS_TOKEN2                       0xfeed
+
+/* Number of words in the FPGA message buffer */
+#define DEFAULT_BUFFER_DEPTH                  64
+
+#if defined(CONFIG_ARCH_FIRECRACKER)
+
+/* Defined in PC202 programmer's guide, appendix N
+ * EBI Configuration
+ */
+#define EBI_CONFIG_BASE_ADDRESS               IO_ADDRESS(PC20X_EBI_BASE) /* 0xFFE20000 */
+#define EBI_SRAM_ADDR_CONFIG_BANK_2           EBI_CONFIG_BASE_ADDRESS + 0x0000005C
+#define EBI_SRAM_TIMING_CONFIG_SET_1          EBI_CONFIG_BASE_ADDRESS + 0x00000098
+
+/* The EBI clock is normally 70MHz, however early versions of the silicon
+ * needed to be run at a slower clock speed so for them the EBI clock
+ * is running at 40MHz.
+ */
+#define EBI_40MHZ_CLOCK_PERIOD_NS             25
+#define EBI_70MHZ_CLOCK_PERIOD_NS             14
+#define EBI_CLOCK_PERIOD_NS                   EBI_40MHZ_CLOCK_PERIOD_NS
+
+/* Address Map Register, see appendix N.3
+ */
+#define ADDR_CONFIG_RESERVED_BITS             0x00000100
+#define ADDR_CONFIG_MEM_TYPE_SRAM             0x00000020
+#define ADDR_CONFIG_MEM_TYPE_FLASH            0x00000040
+#define ADDR_CONFIG_MEM_SIZE_NONE             0x00000000
+#define ADDR_CONFIG_MEM_SIZE_512MB            0x0000000E
+
+#define SRAM_ADDR_CONFIG_MASK                 ( 0x0000007F )
+#define SRAM_ADDR_CONFIG_FOR_FPGA             ( ADDR_CONFIG_RESERVED_BITS | \
+                                                ADDR_CONFIG_MEM_TYPE_SRAM | \
+                                                ADDR_CONFIG_MEM_SIZE_512MB )
+
+/* Static Memory Timing Register, see appendix N.3
+ */
+#define TIMING_CONFIG_RESERVED_BITS_31_27_MASK   0xF8000000
+#define TIMING_CONFIG_RESERVED_BITS_31_27        0x10000000
+#define TIMING_CONFIG_DATA_READY_MASK            0x04000000
+#define TIMING_CONFIG_IS_DATA_READY_DEV          0x04000000
+#define TIMING_CONFIG_IS_NOT_DATA_READY_DEV      0x00000000
+#define TIMING_CONFIG_RESERVED_BITS_25_23_MASK   0x03800000
+#define TIMING_CONFIG_RESERVED_BITS_25_23        0x00000000
+/* Page mode Read Cycle time - n/a for SRAM, use default value */
+#define TIMING_CONFIG_T_PRC_MASK                 0x00780000
+#define TIMING_CONFIG_T_PRC_2_CYCLES             0x00080000
+/* Bus Turn Around time - must be at least 50ns (2 cycles @ 40MHz or 3.5 @ 70MHz) */
+#define TIMING_CONFIG_T_BTA_MASK                 0x00070000
+#define TIMING_CONFIG_T_BTA_2_CYCLES             0x00040000
+#define TIMING_CONFIG_T_BTA_3_CYCLES             0x00060000
+/* Write Pulse width - using default (2 clock cycles) */
+#define TIMING_CONFIG_T_WP_MASK                  0x0000FC00
+#define TIMING_CONFIG_T_WP_2_CYCLES              0x00000400
+#define TIMING_CONFIG_T_WP_3_CYCLES              0x00000800
+/* WRite address hold time - using default (0.5 clock cycle) */
+#define TIMING_CONFIG_T_WR_MASK                  0x00000300
+#define TIMING_CONFIG_T_WR_HALF_CYCLE            0x00000100
+/* write Address Setup time - using default (1.0 clock cycle) */
+#define TIMING_CONFIG_T_AS_MASK                  0x000000C0
+#define TIMING_CONFIG_T_AS_1_CYCLE               0x00000080
+/* Read Cycle time - using default (3.0 clock cycle) */
+#define TIMING_CONFIG_T_RC_MASK                  0x0000003F
+#define TIMING_CONFIG_T_RC_3_CYCLES              0x00000005
+
+#define SRAM_TIMING_CONFIG_MASK        ( 0x07FFFFFF )
+#define SRAM_TIMING_CONFIG_FOR_FPGA    ( TIMING_CONFIG_RESERVED_BITS_31_27 | \
+                                         TIMING_CONFIG_IS_NOT_DATA_READY_DEV | \
+                                         TIMING_CONFIG_RESERVED_BITS_25_23 | \
+                                         TIMING_CONFIG_T_PRC_2_CYCLES | \
+                                         TIMING_CONFIG_T_BTA_2_CYCLES | \
+                                         TIMING_CONFIG_T_WP_3_CYCLES | \
+                                         TIMING_CONFIG_T_WR_HALF_CYCLE | \
+                                         TIMING_CONFIG_T_AS_1_CYCLE | \
+                                         TIMING_CONFIG_T_RC_3_CYCLES )
+
+#elif defined(CONFIG_ARCH_PC302)
+
+/* Defined in PC302 programmer's guide, appendix D
+ * EBI Configuration
+ */
+#define EBI_CONFIG_BASE_ADDRESS               IO_ADDRESS(PC302_EBI_BASE) /* 0xFFE20000 */
+#define EBI_SRAM_ADDR_CONFIG_BANK_2           (EBI_CONFIG_BASE_ADDRESS + SMASK0_REG_OFFSET)
+#define EBI_SRAM_TIMING_CONFIG_SET_1          (EBI_CONFIG_BASE_ADDRESS + STATIC_MEM_TIMSET2_REG_OFFSET)
+
+#define EBI_40MHZ_CLOCK_PERIOD_NS             25
+#define EBI_70MHZ_CLOCK_PERIOD_NS             14
+
+/* Address Map Register, see appendix D.3
+ */
+
+#define SRAM_ADDR_CONFIG_MASK \
+    (EBI_SMSKR_REG_SELECT_MASK << EBI_SMSKR_REG_SELECT_SHIFT) | \
+    (EBI_SMSKR_MEM_TYPE_MASK << EBI_SMSKR_MEM_TYPE_SHIFT) | \
+    (EBI_SMSKR_MEM_SIZE_MASK << EBI_SMSKR_MEM_SIZE_SHIFT)
+
+#define SRAM_ADDR_CONFIG_FOR_FPGA \
+    (EBI_REG_SELECT_TIMING_SET_2 << EBI_SMSKR_REG_SELECT_SHIFT) | \
+    (EBI_MEM_TYPE_SRAM << EBI_SMSKR_MEM_TYPE_SHIFT) | \
+    (EBI_MEM_SIZE_512MB << EBI_SMSKR_MEM_SIZE_SHIFT)
+
+/* Static Memory Timing Register, see appendix D.3
+ */
+#define SRAM_TIMING_CONFIG_MASK \
+    ( EBI_SMTMGR_REG_CLK_SYNC_MASK << EBI_SMTMGR_REG_CLK_SYNC_SHIFT) | \
+    ( EBI_SMTMGR_REG_READY_MODE_MASK << EBI_SMTMGR_REG_READY_MODE_SHIFT) | \
+    ( EBI_SMTMGR_REG_PAGE_READ_CYCLE_MASK << EBI_SMTMGR_REG_PAGE_READ_CYCLE_SHIFT) | \
+    ( EBI_SMTMGR_REG_BUS_TURN_AROUND_MASK << EBI_SMTMGR_REG_BUS_TURN_AROUND_SHIFT) | \
+    ( EBI_SMTMGR_REG_WRITE_PULSE_MASK << EBI_SMTMGR_REG_WRITE_PULSE_SHIFT) | \
+    ( EBI_SMTMGR_REG_ADDR_HOLD_MASK << EBI_SMTMGR_REG_ADDR_HOLD_SHIFT) | \
+    ( EBI_SMTMGR_REG_ADDR_SETUP_MASK << EBI_SMTMGR_REG_ADDR_SETUP_SHIFT) | \
+    ( EBI_SMTMGR_REG_TIMING_READ_CYCLE_MASK)
+
+#define EBI_SMTMGR_REG_PAGE_READ_CYCLE_2_CYCLES         1
+#define EBI_SMTMGR_REG_BUS_TURN_AROUND_2_CYCLES         4
+#define EBI_SMTMGR_REG_WRITE_PULSE_3_CYCLES             2
+#define EBI_SMTMGR_REG_ADDR_HOLD_HALF_CYCLE             1
+#define EBI_SMTMGR_REG_ADDR_SETUP_1_CYCLE               2
+#define EBI_SMTMGR_REG_TIMING_READ_CYCLE_3_CYCLES       5
+
+#define SRAM_TIMING_CONFIG_FOR_FPGA \
+    ( 0 << EBI_SMTMGR_REG_CLK_SYNC_SHIFT) | \
+    ( 0 << EBI_SMTMGR_REG_READY_MODE_SHIFT) | \
+    ( EBI_SMTMGR_REG_PAGE_READ_CYCLE_2_CYCLES << EBI_SMTMGR_REG_PAGE_READ_CYCLE_SHIFT ) | \
+    ( EBI_SMTMGR_REG_BUS_TURN_AROUND_2_CYCLES << EBI_SMTMGR_REG_BUS_TURN_AROUND_SHIFT ) | \
+    ( EBI_SMTMGR_REG_WRITE_PULSE_3_CYCLES << EBI_SMTMGR_REG_WRITE_PULSE_SHIFT ) | \
+    ( EBI_SMTMGR_REG_ADDR_HOLD_HALF_CYCLE << EBI_SMTMGR_REG_ADDR_HOLD_SHIFT ) | \
+    ( EBI_SMTMGR_REG_ADDR_SETUP_1_CYCLE << EBI_SMTMGR_REG_ADDR_SETUP_SHIFT ) | \
+    ( EBI_SMTMGR_REG_TIMING_READ_CYCLE_3_CYCLES )
+
+#else  /* CONFIG_ARCH_... */
+
+#  error "Unknown architecture"
+
+#endif /* CONFIG_ARCH_... */
+
+/* module init return codes */
+#define IPA_DEBUG_MODULE_LOAD_SUCCESS  0
+#define IPA_DEBUG_MODULE_LOAD_ERROR   -1
+
+static spinlock_t  mySpinLock = SPIN_LOCK_UNLOCKED;
+
+static struct cdev ipa_debug_cdev;
+static void *fpgaRegBaseAddr = 0;        /* io mapped address fix me: put in driver ctx */
+
+static ssize_t ipa_debug_read ( struct file* fileHandle,
+                                char __user* inputBuffer,
+                                size_t       length,
+                                loff_t*      offset )
+{
+    ssize_t numBytesRead = 0;
+    ssize_t numArmWordToRead = 0;
+
+    unsigned long fpgaVersion = 0;
+    //void *fpgaRegBaseAddr = 0;
+
+    IPA_PRINTK( ( KERN_INFO "Reading %d bytes of message\n", length) );
+
+    //fpgaRegBaseAddr = ioremap(DEBUG_FPGA_BASE_ADDRESS,DEBUG_FPGA_SIZEOF_REG_MAP);
+    
+    fpgaVersion = ioread32(FPGA_VERSION_REGISTER(fpgaRegBaseAddr));
+    IPA_PRINTK( ( KERN_INFO "FPGA version 0x%lx for the IPA Debug card\n",fpgaVersion) );
+    
+    if (inputBuffer)
+    {
+        numArmWordToRead = ioread32(FPGA_ARM_NUM_WORDS_REGISTER(fpgaRegBaseAddr));
+        IPA_PRINTK( ( KERN_INFO "%d words available\n", numArmWordToRead) );
+
+        for (numBytesRead = 0; 
+             ((numBytesRead < length) && 
+             (numBytesRead < (sizeof(unsigned short)*numArmWordToRead))); 
+             numBytesRead+=sizeof(unsigned short))
+        {
+            unsigned long wordRead = 0;
+            unsigned char kernelWord[2];
+            wordRead = ioread32(FPGA_ARM_MESSAGE_READ_REGISTER(fpgaRegBaseAddr));
+            kernelWord[0] = (wordRead >> 8) & 0xff;
+            kernelWord[1] = wordRead & 0xff;
+            if (copy_to_user(inputBuffer+numBytesRead,kernelWord,2))
+            {
+                return -EFAULT;
+            }
+        }
+
+    }
+
+    //iounmap(fpgaRegBaseAddr);
+
+    return numBytesRead;
+}
+
+static ssize_t ipa_debug_write ( struct file*       fileHandle,
+                                 const char __user* outputBuffer,
+                                 size_t             length,
+                                 loff_t*            offset )
+{
+    size_t                         index;
+    unsigned short                 msgWord;
+    const unsigned short __user*   readPtr = (const unsigned short __user*)outputBuffer;
+    unsigned long                  readTest = 0;
+    unsigned long                  flags;
+   
+    IPA_PRINTK( ( KERN_INFO "Writing %d bytes of message\n", length) );
+
+    if ((length < 2) || (length & 1) || !access_ok(VERIFY_READ, (void __user*)readPtr, length)) {
+        IPA_PRINTK( ( KERN_INFO "Write had invalid parameteri %d %p\n", length, outputBuffer) );
+        return 0;
+    }
+
+    /* Check for alignment in the buffer */
+    if (((unsigned long)outputBuffer) & 1) {
+        IPA_PRINTK( ( KERN_INFO "Write had misalignment %p\n", outputBuffer) );
+        return 0;
+    }
+
+    spin_lock_irqsave(&mySpinLock, flags);
+    
+    /* Begin the message and generate the time stamp */
+    iowrite32(START_OF_MESSAGE, FPGA_ARM_PID_VALUE_REGISTER(fpgaRegBaseAddr));
+    readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+
+    /* Write the message length, allowing for the PID that follows */
+    iowrite32(length+2, FPGA_ARM_MESSAGE_WRITE_REGISTER(fpgaRegBaseAddr));
+    readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+
+    /* Write the PID */
+    iowrite32(current->pid, FPGA_ARM_MESSAGE_WRITE_REGISTER(fpgaRegBaseAddr));
+    readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+
+    /* Write all but the last one */
+    for (index=2; index<length; index+=2) {
+        __get_user(msgWord, readPtr);
+        iowrite32(msgWord, FPGA_ARM_MESSAGE_WRITE_REGISTER(fpgaRegBaseAddr));
+        readPtr++;
+    }
+
+    /* Last one terminates */
+    __get_user(msgWord, readPtr);
+    iowrite32(msgWord, FPGA_ARM_MESSAGE_TERMINATE_REGISTER(fpgaRegBaseAddr));
+
+    spin_unlock_irqrestore(&mySpinLock, flags);
+    
+    return length;
+}
+
+static ssize_t ipa_debug_aio_write ( struct kiocb*        iocb,
+                                     const struct iovec*  iov,
+                                     unsigned long        count,
+                                     loff_t               offset )
+{
+    ssize_t                        index  = 0;
+    __kernel_size_t                length = 0;
+    unsigned short                 msgWord;
+    __kernel_size_t                base   = 0;
+    unsigned long                  element;
+    const unsigned short __user*   readPtr;
+    unsigned long                  readTest = 0;
+    unsigned long                  flags;
+    
+    IPA_PRINTK( ( KERN_INFO "Writing vector of %ld elements\n", count) );
+
+    /* Find the total number of bytes to be written (length), check that
+       each separate element is a whole number of 2-byte words and get
+       the size of the largest element. */
+    for (element=0; element<count; ++element) {
+
+        __kernel_size_t  element_length = iov[element].iov_len;
+
+        if (element_length & 1) {
+            IPA_PRINTK( ( KERN_INFO "ipa_debug: Buffer has odd length %d\n", element_length) );
+            return 0;
+        }
+
+        if (!access_ok(VERIFY_READ, (void __user*)iov[element].iov_base, element_length)) {
+            IPA_PRINTK( ( KERN_INFO "ipa_debug: Buffer not accessible\n") );
+            return 0;
+        }
+
+        length += element_length;
+    }
+
+    IPA_PRINTK( ( KERN_INFO "Writing vectors with total of %d bytes\n", length) );
+
+    if (length < 2) {
+        /* Nothing to do */
+        return 0;
+    }
+
+    spin_lock_irqsave(&mySpinLock, flags);
+    
+    /* Begin the message and generate the time stamp */
+    iowrite32(START_OF_MESSAGE, FPGA_ARM_PID_VALUE_REGISTER(fpgaRegBaseAddr));
+    readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+
+    /* Write the message length, allowing for the PID that follows */
+    iowrite32(length+2, FPGA_ARM_MESSAGE_WRITE_REGISTER(fpgaRegBaseAddr));
+    readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+
+    /* Write the PID */
+    iowrite32(current->pid, FPGA_ARM_MESSAGE_WRITE_REGISTER(fpgaRegBaseAddr));
+    readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+
+    readPtr = (const unsigned short __user*)iov[0].iov_base;
+	
+    for (element=0; element<count; ++element) {
+
+        __kernel_size_t   element_len = iov[element].iov_len;
+
+        readPtr = (const unsigned short __user*)iov[element].iov_base;
+
+        if (element_len+base >= length-2) {
+            element_len = length-2 - base;
+        }
+        base += element_len;
+
+        for (index=0; index<element_len; index+=2) {
+            __get_user(msgWord, readPtr);
+            iowrite32(msgWord, FPGA_ARM_MESSAGE_WRITE_REGISTER(fpgaRegBaseAddr));
+            readPtr++;
+        }
+    }
+
+    /* Last one terminates */
+    __get_user(msgWord, readPtr);
+    iowrite32(msgWord, FPGA_ARM_MESSAGE_TERMINATE_REGISTER(fpgaRegBaseAddr));
+
+    spin_unlock_irqrestore(&mySpinLock, flags);
+    
+    return length;
+}
+
+#if defined(CONFIG_IPACCESS_FPGA_DEBUG)
+static void ipaDebugFpgaKernelCommon(const char* text, int n, int num1, int num2, int num3, int num4)
+{
+    __kernel_size_t                length = 0;
+    unsigned short                 msgWord;
+    unsigned long                  readTest = 0;
+    unsigned long                  flags;
+    
+    /* Find the total number of bytes to be written (length), check that
+       each separate element is a whole number of 2-byte words and get
+       the size of the largest element. */
+    length = ((strlen(text)+2) & ~1) + 12 + 4*n;
+
+    spin_lock_irqsave(&mySpinLock, flags);
+    
+    /* Begin the message and generate the time stamp */
+    iowrite32(START_OF_MESSAGE, FPGA_ARM_PID_VALUE_REGISTER(fpgaRegBaseAddr));
+    readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+
+    /* Write the message length */
+    iowrite32(length, FPGA_ARM_MESSAGE_WRITE_REGISTER(fpgaRegBaseAddr));
+    readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+
+    /* Write the PID */
+    iowrite32(0, FPGA_ARM_MESSAGE_WRITE_REGISTER(fpgaRegBaseAddr));
+    readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+
+    /* Write the AppName token */
+    iowrite32(0, FPGA_ARM_MESSAGE_WRITE_REGISTER(fpgaRegBaseAddr));
+    readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+
+    iowrite32(0, FPGA_ARM_MESSAGE_WRITE_REGISTER(fpgaRegBaseAddr));
+    readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+
+    /* Write "K" */
+    iowrite32(0x004B, FPGA_ARM_MESSAGE_WRITE_REGISTER(fpgaRegBaseAddr));
+    readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+
+    /* Write the Text token */
+    iowrite32(0, FPGA_ARM_MESSAGE_WRITE_REGISTER(fpgaRegBaseAddr));
+    readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+
+    iowrite32(0, FPGA_ARM_MESSAGE_WRITE_REGISTER(fpgaRegBaseAddr));
+    readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+
+    /* Write the text */
+    msgWord = 0;
+    
+    while (*text) {
+    
+        msgWord = *text++;
+        
+        if (*text) {
+            msgWord |= (*text++) << 8;
+            iowrite32(msgWord, FPGA_ARM_MESSAGE_WRITE_REGISTER(fpgaRegBaseAddr));
+            readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+            msgWord = 0;
+        } else {
+            break;
+        }
+    }
+    readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+
+    if (n > 0) {
+        iowrite32(msgWord, FPGA_ARM_MESSAGE_WRITE_REGISTER(fpgaRegBaseAddr));
+        readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+    
+        iowrite32((num1 & 0xFFFF), FPGA_ARM_MESSAGE_WRITE_REGISTER(fpgaRegBaseAddr));
+        readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+
+        msgWord = num1 >> 16;
+    }
+    if (n > 1) {
+        iowrite32(msgWord, FPGA_ARM_MESSAGE_WRITE_REGISTER(fpgaRegBaseAddr));
+        readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+    
+        iowrite32((num2 & 0xFFFF), FPGA_ARM_MESSAGE_WRITE_REGISTER(fpgaRegBaseAddr));
+        readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+
+        msgWord = num2 >> 16;
+    }
+    if (n > 2) {
+        iowrite32(msgWord, FPGA_ARM_MESSAGE_WRITE_REGISTER(fpgaRegBaseAddr));
+        readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+    
+        iowrite32((num3 & 0xFFFF), FPGA_ARM_MESSAGE_WRITE_REGISTER(fpgaRegBaseAddr));
+        readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+
+        msgWord = num3 >> 16;
+    }
+    if (n > 3) {
+        iowrite32(msgWord, FPGA_ARM_MESSAGE_WRITE_REGISTER(fpgaRegBaseAddr));
+        readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+    
+        iowrite32((num4 & 0xFFFF), FPGA_ARM_MESSAGE_WRITE_REGISTER(fpgaRegBaseAddr));
+        readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+
+        msgWord = num4 >> 16;
+    }
+    
+    /* Last one terminates */
+    iowrite32(msgWord, FPGA_ARM_MESSAGE_TERMINATE_REGISTER(fpgaRegBaseAddr));
+    
+    spin_unlock_irqrestore(&mySpinLock, flags);
+}
+
+static void ipaDebugFpgaKernel0(const char* text)
+{
+    ipaDebugFpgaKernelCommon(text, 0, 0, 0, 0, 0);
+}
+
+static void ipaDebugFpgaKernel1(const char* text, int num1)
+{
+    ipaDebugFpgaKernelCommon(text, 1, num1, 0, 0, 0);
+}
+
+static void ipaDebugFpgaKernel2(const char* text, int num1, int num2)
+{
+    ipaDebugFpgaKernelCommon(text, 2, num1, num2, 0, 0);
+}
+
+static void ipaDebugFpgaKernel3(const char* text, int num1, int num2, int num3)
+{
+    ipaDebugFpgaKernelCommon(text, 3, num1, num2, num3, 0);
+}
+
+static void ipaDebugFpgaKernel4(const char* text, int num1, int num2, int num3, int num4)
+{
+    ipaDebugFpgaKernelCommon(text, 4, num1, num2, num3, num4);
+}
+#endif /* defined(CONFIG_IPACCESS_FPGA_DEBUG) */
+
+/* File operations - driver entry points */
+static struct file_operations ipa_debug_fops =
+{
+    .owner     = THIS_MODULE,
+    .read      = ipa_debug_read,
+    .write     = ipa_debug_write,
+    .aio_write = ipa_debug_aio_write,
+};
+
+/* Called when module is loaded */
+static int __init ipa_debug_init(void)
+{
+    int devNum = 0;
+    int error = 0;
+    int status = IPA_DEBUG_MODULE_LOAD_SUCCESS;
+    
+    printk ( KERN_INFO "IPA Debug driver built " __DATE__ " " __TIME__ "\n" );
+    
+    /* Set up Cdev */
+    cdev_init ( &ipa_debug_cdev, &ipa_debug_fops );
+    ipa_debug_cdev.owner = THIS_MODULE;
+    ipa_debug_cdev.ops = &ipa_debug_fops;
+    
+    /* Register the class device */
+    devNum = MKDEV ( IPA_DEBUG_MAJOR, 0 );
+    error = cdev_add ( &ipa_debug_cdev, devNum, 1 );
+    if ( error )
+    {
+        printk ( KERN_ERR "Error %d adding the IPA Debug driver\n", error );
+        status = IPA_DEBUG_MODULE_LOAD_ERROR;
+    }
+    else
+    {
+        /* Register the major number */
+        register_chrdev_region ( MKDEV ( IPA_DEBUG_MAJOR, 0 ), 1, DEVICE_NAME );
+    
+        /* Set up EBI for device 2 - the FPGA acts as SRAM on CS2 of this bus */
+        if (request_region(EBI_SRAM_ADDR_CONFIG_BANK_2, sizeof(unsigned long), DEVICE_NAME) &&
+            request_region(EBI_SRAM_TIMING_CONFIG_SET_1, sizeof(unsigned long), DEVICE_NAME) &&
+            request_mem_region(DEBUG_FPGA_BASE_ADDRESS, DEBUG_FPGA_SIZEOF_REG_MAP, DEVICE_NAME))
+        {
+            unsigned ebiRegisterRead;
+            unsigned long fpgaVersion = 0;
+            //unsigned long readCtrlVal = 0;
+            unsigned long readTest = 0;
+            //void *fpgaRegBaseAddr = 0;
+
+            IPA_PRINTK( ( KERN_ERR "Setting EBI registers for the IPA Debug driver\n") );
+            ebiRegisterRead = inl(EBI_SRAM_ADDR_CONFIG_BANK_2);
+            ebiRegisterRead &= ~SRAM_ADDR_CONFIG_MASK;
+            ebiRegisterRead |= SRAM_ADDR_CONFIG_FOR_FPGA;
+            outl(ebiRegisterRead, EBI_SRAM_ADDR_CONFIG_BANK_2);
+            
+            ebiRegisterRead = inl(EBI_SRAM_TIMING_CONFIG_SET_1);
+            ebiRegisterRead &= SRAM_TIMING_CONFIG_MASK;
+            ebiRegisterRead |= SRAM_TIMING_CONFIG_FOR_FPGA;
+            outl(ebiRegisterRead, EBI_SRAM_TIMING_CONFIG_SET_1);
+        
+            fpgaRegBaseAddr = ioremap(DEBUG_FPGA_BASE_ADDRESS,DEBUG_FPGA_SIZEOF_REG_MAP);
+
+            fpgaVersion = ioread32(FPGA_VERSION_REGISTER(fpgaRegBaseAddr));
+            printk ( KERN_INFO "FPGA version 0x%lx for the IPA Debug card\n",fpgaVersion);
+
+            /* Set read direction to USB */
+            iowrite32(BUFFER_DATA_GOES_TO_USB,FPGA_BUFFER_READ_CONTROL_REGISTER(fpgaRegBaseAddr));
+
+            /* FIXME - EBI timings needs work to prevent successive writes going
+             * out too quickly.  Workaround for now is to add a read between writes
+             * to use BTA to hold off nect write.
+             */
+
+            /* force delay between writes */
+            readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+
+            /* Allow allow PIDs through - no filtering */
+            iowrite32(0xffff,FPGA_ARM_PID_ENABLE_REGISTER(fpgaRegBaseAddr));
+
+            /* force delay between writes */
+            readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+
+            /* Set token for buffer overrun indication */
+            iowrite32(DATA_LOSS_TOKEN1, FPGA_DATA_LOSS_TOKEN1_REGISTER(fpgaRegBaseAddr));
+            readTest = ioread32(FPGA_DATA_LOSS_TOKEN1_REGISTER(fpgaRegBaseAddr));
+            printk ( KERN_INFO "Data loss token1 = 0x%lx\n",readTest);
+
+            /* force delay between writes */
+            readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+
+            /* Set token for buffer overrun indication */
+            iowrite32(DATA_LOSS_TOKEN2, FPGA_DATA_LOSS_TOKEN2_REGISTER(fpgaRegBaseAddr));
+            readTest = ioread32(FPGA_DATA_LOSS_TOKEN2_REGISTER(fpgaRegBaseAddr));
+            printk ( KERN_INFO "Data loss token2 = 0x%lx\n",readTest);
+
+            /* force delay between writes */
+            readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+
+            /* Set message buffer depth in FPGA */
+            iowrite32(DEFAULT_BUFFER_DEPTH, FPGA_BUFFER_DEPTH_REGISTER(fpgaRegBaseAddr));
+
+            //iounmap(fpgaRegBaseAddr);
+            if (TEST_FPGA_INTERFACE) {
+
+                int  i;
+                int  wordsToRead = 0;
+
+                /* Display current values of the registers we can read from */
+                readTest = ioread32(FPGA_BUFFER_READ_CONTROL_REGISTER(fpgaRegBaseAddr));
+                printk( KERN_INFO "Control Reg is %lx\n", readTest);
+
+                readTest = ioread32(FPGA_DATA_LOSS_TOKEN1_REGISTER(fpgaRegBaseAddr));
+                printk( KERN_INFO "Data loss token1 = %lx\n", readTest);
+
+                readTest = ioread32(FPGA_DATA_LOSS_TOKEN2_REGISTER(fpgaRegBaseAddr));
+                printk( KERN_INFO "Data loss token2 = %lx\n", readTest);
+
+                readTest = ioread32(FPGA_ARM_PID_ENABLE_REGISTER(fpgaRegBaseAddr));
+                printk( KERN_INFO "ARM PID Enable register is %lx\n", readTest);
+
+                /* Check each data bit using the test register */
+                for (i=0; i<=16; i++) {
+
+                    int check = 1<<i;
+
+                    iowrite32(check, FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+                    readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+                    readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+
+                    printk( KERN_INFO "test reg: wrote %x read %lx\n", check, readTest);
+                }
+
+                /* Check that we can write data to the buffer and read it back */
+                iowrite32(BUFFER_DATA_GOES_TO_ARM,FPGA_BUFFER_READ_CONTROL_REGISTER(fpgaRegBaseAddr));
+                readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+
+                iowrite32(0,FPGA_CLEAR_BUFFER_REGISTER(fpgaRegBaseAddr));
+                readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+
+                iowrite32(1, FPGA_ARM_PID_VALUE_REGISTER(fpgaRegBaseAddr));
+                readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+
+                for (i=0; i<=16; i++) {
+
+                    int check = 1<<i;
+
+                    iowrite32(check, FPGA_ARM_MESSAGE_WRITE_REGISTER(fpgaRegBaseAddr));
+                    readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+                }
+
+                iowrite32(0xFFFF, FPGA_ARM_MESSAGE_TERMINATE_REGISTER(fpgaRegBaseAddr));
+                readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+
+                wordsToRead = ioread32(FPGA_ARM_NUM_WORDS_REGISTER(fpgaRegBaseAddr));
+                printk( KERN_INFO "Number of words to read is %d\n", wordsToRead);
+                
+                for (i=0; i<wordsToRead; i++) {
+
+                    readTest = ioread32(FPGA_ARM_MESSAGE_READ_REGISTER(fpgaRegBaseAddr));
+                    printk( KERN_INFO "Value %d is %lx\n", i, readTest);
+                }
+
+                /* Switch back to sending data to the USB interface */
+                iowrite32(BUFFER_DATA_GOES_TO_USB,FPGA_BUFFER_READ_CONTROL_REGISTER(fpgaRegBaseAddr));
+
+                iowrite32(0xFAFA, FPGA_ARM_PID_VALUE_REGISTER(fpgaRegBaseAddr));
+                readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+
+                iowrite32(38, FPGA_ARM_MESSAGE_WRITE_REGISTER(fpgaRegBaseAddr));
+                readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+
+                iowrite32(0x5555, FPGA_ARM_MESSAGE_WRITE_REGISTER(fpgaRegBaseAddr));
+                readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+
+                for (i=0; i<=16; i++) {
+
+                    int check = 1<<i;
+
+                    iowrite32(check, FPGA_ARM_MESSAGE_WRITE_REGISTER(fpgaRegBaseAddr));
+                    readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+                }
+
+                iowrite32(0xFFFF, FPGA_ARM_MESSAGE_TERMINATE_REGISTER(fpgaRegBaseAddr));
+                readTest = ioread32(FPGA_TEST_REGISTER(fpgaRegBaseAddr));
+
+            }
+
+            release_region(EBI_SRAM_ADDR_CONFIG_BANK_2, sizeof(unsigned long));
+            release_region(EBI_SRAM_TIMING_CONFIG_SET_1, sizeof(unsigned long));
+        }
+        else
+        {
+            printk ( KERN_ERR "Error accessing EBI registers for the IPA Debug driver\n");
+            status = IPA_DEBUG_MODULE_LOAD_ERROR;
+        }
+    
+    }    
+ 
+#if defined(CONFIG_IPACCESS_FPGA_DEBUG)
+    if (status == IPA_DEBUG_MODULE_LOAD_SUCCESS)
+    {
+        ipaFpgaDebug0Ptr = ipaDebugFpgaKernel0;
+        ipaFpgaDebug1Ptr = ipaDebugFpgaKernel1;
+        ipaFpgaDebug2Ptr = ipaDebugFpgaKernel2;
+        ipaFpgaDebug3Ptr = ipaDebugFpgaKernel3;
+        ipaFpgaDebug4Ptr = ipaDebugFpgaKernel4;
+    }
+    else
+    {
+        ipaFpgaDebug0Ptr = NULL;
+        ipaFpgaDebug1Ptr = NULL;
+        ipaFpgaDebug2Ptr = NULL;
+        ipaFpgaDebug3Ptr = NULL;
+        ipaFpgaDebug4Ptr = NULL;
+    }
+#endif /* defined(CONFIG_IPACCESS_FPGA_DEBUG) */
+
+    return status;
+}
+
+/* Called to unload the module */
+static void __exit ipa_debug_exit(void)
+{
+#if defined(CONFIG_IPACCESS_FPGA_DEBUG)
+    ipaFpgaDebug0Ptr = NULL;
+    ipaFpgaDebug1Ptr = NULL;
+    ipaFpgaDebug2Ptr = NULL;
+    ipaFpgaDebug3Ptr = NULL;
+    ipaFpgaDebug4Ptr = NULL;
+#endif /* defined(CONFIG_IPACCESS_FPGA_DEBUG) */
+
+    iounmap(fpgaRegBaseAddr);
+    fpgaRegBaseAddr = 0;
+    release_mem_region(DEBUG_FPGA_BASE_ADDRESS, DEBUG_FPGA_SIZEOF_REG_MAP);
+    unregister_chrdev_region ( MKDEV ( IPA_DEBUG_MAJOR, 0 ), 1 );
+    cdev_del ( &ipa_debug_cdev );
+}
+
+module_init( ipa_debug_init );
+module_exit( ipa_debug_exit );
+
+MODULE_AUTHOR ( "IP Access Ltd" );
+MODULE_DESCRIPTION ( "IPA Debug Card driver" );
+MODULE_LICENSE("GPL");
diff -Naur pico_2.6.28/drivers/ipa/ipa_debug/Makefile ipa_2.6.28/drivers/ipa/ipa_debug/Makefile
--- pico_2.6.28/drivers/ipa/ipa_debug/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/ipa/ipa_debug/Makefile	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,28 @@
+################################################################################
+# 
+# Copyright (c) 2009 ip.access Ltd.
+#
+#  This program is free software; you can redistribute  it and/or modify it
+#  under  the terms of  the GNU General  Public License as published by the
+#  Free Software Foundation;  either version 2 of the  License, or (at your
+#  option) any later version.
+#
+# 9 Apr 2008 Created by Simon D Hughes.
+# 
+# Makefile for the ipa_debug
+# 
+##############################################################################
+# Filename: 
+##############################################################################
+
+
+obj-$(CONFIG_IPACCESS_DEBUG) += ipa_debug.o
+ipa_debug-objs := ipa_debug_main.o
+
+
+lib:
+	$(CROSS_COMPILE)gcc -c ipa_debug_card.c -o ipa_debug_card.o
+	$(CROSS_COMPILE)ar r libipa_debug_card.a ipa_debug_card.o
+
+test:
+	$(CROSS_COMPILE)gcc ipa_debug_card_test.c -L. -I. -lipa_debug_card -o ipa_debug_card_test
diff -Naur pico_2.6.28/drivers/ipa/Kconfig ipa_2.6.28/drivers/ipa/Kconfig
--- pico_2.6.28/drivers/ipa/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/ipa/Kconfig	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,60 @@
+################################################################################
+# 
+# Copyright (c) 2009 ip.access Ltd.
+#
+#  This program is free software; you can redistribute  it and/or modify it
+#  under  the terms of  the GNU General  Public License as published by the
+#  Free Software Foundation;  either version 2 of the  License, or (at your
+#  option) any later version.
+#
+# 22 Apr 2009 Created by Simon D Hughes.
+##############################################################################
+# Filename: 
+##############################################################################
+
+#
+# IPAccess device drivers
+#
+
+menu "IP Access Drivers"
+
+config IPACCESS
+    tristate
+
+config IPACCESS_CPETD
+    tristate "cpetd support"
+    select IPACCESS
+    ---help---
+      The CPE Timer Device Driver. This device driver is used to give
+      fine grained timer ticks to user mode applications e.g. 3g ctrl
+      and data apps.
+
+config IPACCESS_DEBUG
+    tristate "ipa_debug support"
+    select IPACCESS
+    ---help---
+      Support for the 3GAP FPGA logger card.
+
+config IPACCESS_LED
+    tristate "leddriver support"
+    select IPACCESS
+    ---help---
+      Support for the 3GAP ip202ff xbplus & xd leds.
+
+config IPACCESS_CRYPTO
+    tristate "crypto offload for IPsec"
+    default m
+    help
+      Enable platform support for using the PicoArray for IPsec 
+      crypto and auth offload
+
+config IPACCESS_FPGA_DEBUG
+    bool "kernel debug via FPGA"
+    ---help---
+      This option allows kernel functions and driver modules to output trace
+      information to the FPGA debug card.  It also allows access to the hires
+      timer maintained by the CPETD.  To enable these functions, both the
+      cpetd and ipa_debug driver modules must be loaded, though the kernel will
+      still function correctly without them.
+
+endmenu
diff -Naur pico_2.6.28/drivers/ipa/leddriver/ip202_gpio_usage.h ipa_2.6.28/drivers/ipa/leddriver/ip202_gpio_usage.h
--- pico_2.6.28/drivers/ipa/leddriver/ip202_gpio_usage.h	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/ipa/leddriver/ip202_gpio_usage.h	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,36 @@
+/*
+ * FILE NAME ip202_gpio_usage.h
+ *
+ * Copyright (c) 2007 ip.access Ltd.
+ *
+ * BRIEF MODULE DESCRIPTION
+ *  Header file which determines which GPIO line is used for which purpose
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+ 
+#if !defined (INCLUDED_IP202_GPIO_USAGE_H)
+#define  INCLUDED_IP202_GPIO_USAGE_H
+
+/* FixMe: Add beyond XB card support! */
+#define ARM_GPIO_IN_SWITCH              (PC202_GPIO_PIN_ARM_0)
+#define ARM_GPIO_OUT_NRESET             (PC202_GPIO_PIN_ARM_1)
+#define ARM_GPIO_OUT_SERVICE_LED        (PC202_GPIO_PIN_ARM_2)
+#define ARM_GPIO_IN_ETHPHY              (PC202_GPIO_PIN_ARM_3)
+#define ARM_GPIO_IN_TEMPWARN            (PC202_GPIO_PIN_ARM_4)
+#define ARM_GPIO_OUT_SYS_LED_RED        (PC202_GPIO_PIN_ARM_5)
+
+/* These lines are only used on customer HW */
+#define ARM_GPIO_OUT_ADD_LED_RED        (PC202_GPIO_PIN_ARM_6)
+#define ARM_GPIO_OUT_ADD_LED_GPS        (PC202_GPIO_PIN_ARM_7)
+
+#define LED_DRIVER_ALLOWED_GPIOS        (( ARM_GPIO_OUT_SERVICE_LED ) | \
+                                        ( ARM_GPIO_OUT_SYS_LED_RED ) | \
+                                        ( ARM_GPIO_OUT_ADD_LED_RED ) | \
+                                        ( ARM_GPIO_OUT_ADD_LED_GPS ))
+
+#endif /*INCLUDED_IP202_GPIO_USAGE_H*/
diff -Naur pico_2.6.28/drivers/ipa/leddriver/ip302_gpio_usage.h ipa_2.6.28/drivers/ipa/leddriver/ip302_gpio_usage.h
--- pico_2.6.28/drivers/ipa/leddriver/ip302_gpio_usage.h	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/ipa/leddriver/ip302_gpio_usage.h	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,28 @@
+/*
+ * FILE NAME ip302_gpio_usage.h
+ *
+ * Copyright (c) 2009 ip.access Ltd.
+ *
+ * BRIEF MODULE DESCRIPTION
+ *  Header file which determines which GPIO line is used for which purpose
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+ 
+#if !defined (INCLUDED_IP302_GPIO_USAGE_H)
+#define  INCLUDED_IP302_GPIO_USAGE_H
+
+#define ARM_GPIO_IN_SWITCH              (PC302_GPIO_PIN_ARM_4)
+#define ARM_GPIO_OUT_SERVICE_LED        (PC302_GPIO_PIN_ARM_5)
+#define ARM_GPIO_OUT_SYS_LED_RED        (PC302_GPIO_PIN_ARM_3)
+#define ARM_GPIO_OUT_NRESET             (PC302_GPIO_PIN_ARM_1)
+
+/* These lines are only used on customer HW */
+#define ARM_GPIO_OUT_ADD_LED_RED        (PC302_GPIO_PIN_ARM_6)
+#define ARM_GPIO_OUT_ADD_LED_GPS        (PC302_GPIO_PIN_ARM_7)
+
+#endif /*INCLUDED_IP202_GPIO_USAGE_H*/
diff -Naur pico_2.6.28/drivers/ipa/leddriver/leddriver.h ipa_2.6.28/drivers/ipa/leddriver/leddriver.h
--- pico_2.6.28/drivers/ipa/leddriver/leddriver.h	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/ipa/leddriver/leddriver.h	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,157 @@
+/*
+ * FILE NAME leddriver.h
+ *
+ * Copyright (c) 2007 ip.access Ltd.
+ *
+ * BRIEF MODULE DESCRIPTION
+ *  Driver for LED
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#if !defined ( INCLUDED_LEDDRIVER_H )
+#define INCLUDED_LEDDRIVER_H
+
+/****************************************************************************
+ * Standard Library Includes
+ ****************************************************************************/ 
+# if defined( USER_SPACE_TESTHARNESS )
+#  include <sys/time.h>
+#  include <signal.h>
+#  include <stdlib.h>
+#  include <stdio.h>
+# else   // KERNEL Module
+#  include <linux/timer.h>
+#  include <linux/module.h>
+#  include <linux/moduleparam.h>
+#  include <linux/init.h>
+#  include <linux/kernel.h>   /* printk() */
+#  include <linux/slab.h>     /* kmalloc() */
+#  include <linux/fs.h>       /* everything... */
+#  include <linux/errno.h>    /* error codes */
+#  include <linux/types.h>    /* size_t */
+#  include <linux/proc_fs.h>
+#  include <asm/uaccess.h>
+#  include <linux/jiffies.h>
+#  include <linux/cdev.h>
+#  include <linux/string.h>
+#endif
+
+/****************************************************************************
+ * Definitions
+ ****************************************************************************/
+#if defined(LEDDRIVER_DEBUG)
+#   if defined(USER_SPACE_TESTHARNESS)
+#       define PDEBUG(fmt, args...) printf( "leddriver: " fmt, ## args)
+#   else
+#       define PDEBUG(fmt, args...) printk( KERN_DEBUG "leddriver: " fmt, ## args)
+#   endif /* USER_SPACE_TESTHARNESS */
+#else
+#   define PDEBUG(fmt, args...) /* not debugging: nothing */
+#endif
+
+
+/* Macros for thread serialisation */
+#define ACQUIRE(iNSTANCE)  \
+    spin_lock_irqsave(&(iNSTANCE->spinlock), iNSTANCE->spinlock_flags);
+
+#define RELEASE(iNSTANCE)  \
+    spin_unlock_irqrestore(&(iNSTANCE->spinlock), iNSTANCE->spinlock_flags);
+
+/****************************************************************************
+ * Constants
+ ****************************************************************************/
+#define INDEFINITE_REPEAT       -1
+#define ON_PERMANENT            1
+#define ON_IGNORE               0
+#define OFF_IGNORE              0
+#define OFF_PERMANENT           1
+
+#define MAX_NUM_LED_INSTANCES   2
+#define MAX_NUM_PATTERNS        10
+#define MAX_NUM_PATTERNS_STR    "10"
+#define MAX_NUM_STATES          10
+#define MAX_NUM_STATES_STR      "10"
+#define MAX_NUM_SEQUENCES       12
+#define SEQUENCE_NAME_LEN       30
+
+/****************************************************************************
+ * Types
+ ****************************************************************************/
+typedef enum 
+{
+    LED_ON,
+    LED_OFF
+}LedState;
+
+typedef struct {
+    int onPeriodMs;
+    int offPeriodMs;
+} LedFlashPattern;
+
+typedef struct {
+    int pattern;
+    unsigned char gpioOnHigh;
+    unsigned char gpioOnLow;
+    unsigned char gpioOffHigh;
+    unsigned char gpioOffLow;
+    int repeat;
+    int delay_before_next_pattern_ms;
+    int nextState;
+} LedSequenceEntry;
+
+typedef struct
+{
+    char name[SEQUENCE_NAME_LEN];
+    LedSequenceEntry sequenceEntry[MAX_NUM_STATES];
+    int numStates;
+} SequencePatternTable;
+
+
+typedef struct {
+    LedSequenceEntry *currentSequence_p;
+    int currentSequenceIndex;
+    int state;
+    LedState  ledState;
+    int repeatCount;
+} LedStateMachine;
+
+/*
+ * Device structure
+ */
+typedef struct LeddriverDevTag
+{
+    int             instance;
+    char            sequenceCode;
+    int             numPatterns;
+    int             numSequences;
+    LedFlashPattern *ledPattenTable;
+    SequencePatternTable     *sequenceTable;
+    LedStateMachine stateMachine;
+    
+#if !defined (USER_SPACE_TESTHARNESS)
+    struct cdev     cdev;
+    struct timer_list ledTimer;
+    spinlock_t spinlock;
+    unsigned long spinlock_flags;
+#endif
+} LeddriverDev;
+ /****************************************************************************
+ * Function Prototypes
+ ****************************************************************************/
+extern void create_proc_fs( void );
+extern void remove_proc_fs( void );
+extern int parse_pattern_buffer( char* buf, unsigned long count );
+extern int parse_sequence_buffer( char* buf, unsigned long count );
+
+/****************************************************************************
+ * Exported Variables
+ ****************************************************************************/
+extern int leddriverNumDevs;
+extern LeddriverDev leddev[MAX_NUM_LED_INSTANCES];
+ 
+#endif /* INCLUDED_LEDDRIVER_H */
diff -Naur pico_2.6.28/drivers/ipa/leddriver/leddriver_main.c ipa_2.6.28/drivers/ipa/leddriver/leddriver_main.c
--- pico_2.6.28/drivers/ipa/leddriver/leddriver_main.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/ipa/leddriver/leddriver_main.c	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,726 @@
+/*
+ * FILE NAME leddriver_main.c
+ *
+ * Copyright (c) 2007 ip.access Ltd.
+ *
+ * BRIEF MODULE DESCRIPTION
+ *  Driver for LED
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+ 
+ 
+/****************************************************************************
+ * Standard Library Includes
+ ****************************************************************************/ 
+#include "leddriver.h"
+
+#if !defined( USER_SPACE_TESTHARNESS )
+
+#include <linux/gpio.h>
+
+#if defined(CONFIG_ARCH_FIRECRACKER)
+#   include "ip202_gpio_usage.h"
+#elif defined(CONFIG_ARCH_PC302)
+#   include "ip302_gpio_usage.h"
+#else  /* CONFIG_ARCH_... */
+#  error "Unknown architecture"
+#endif /* CONFIG_ARCH_... */
+
+#endif
+
+/****************************************************************************
+  Private Definitions
+ ****************************************************************************/
+
+/****************************************************************************
+  Private Types
+ ****************************************************************************/
+
+/****************************************************************************
+ * Private Function Prototypes
+ ****************************************************************************/
+static void start_timer( LeddriverDev * dev_p, int periodms );
+static void stop_timer( LeddriverDev * dev_p );
+static void turnLed( LedState state, unsigned char gpioHigh, unsigned char gpioLow );
+
+/****************************************************************************
+ * Private Constants
+ ****************************************************************************/
+static const unsigned char ledMappingTable[8] = 
+{
+     ARM_GPIO_OUT_SERVICE_LED,  /*   1 */
+     ARM_GPIO_OUT_SYS_LED_RED,  /*   2 */
+     ARM_GPIO_OUT_ADD_LED_RED,  /*   4 */
+     ARM_GPIO_OUT_ADD_LED_GPS,  /*   8 */
+    -1,                         /*  16 */
+    -1,                         /*  32 */
+    -1,                         /*  64 */
+    -1,                         /* 128 */
+};
+
+
+/****************************************************************************
+ * Exported Variables
+ ****************************************************************************/
+LeddriverDev        leddev[MAX_NUM_LED_INSTANCES];
+
+/****************************************************************************
+ * Private Variables (Must be declared static)
+ ****************************************************************************/
+
+static char led0_patterns_str[]=
+"0:0,0,1\n"        // OFF solid (special case)
+"0:1,1,0\n"        // ON solid (special case)
+"0:2,50,50\n" 
+"0:3,50,200\n" 
+"0:4,300,50\n" 
+"0:5,200,1800\n" 
+"0:6,1000,1000\n"
+"0:7,1800,200";
+
+static char led1_patterns_str[]=
+"1:0,0,1\n"        // OFF solid (special case)
+"1:1,1,0\n"        // ON solid (special case)
+"1:2,50,50\n" 
+"1:3,50,200\n" 
+"1:4,300,50\n" 
+"1:5,200,1800\n" 
+"1:6,1000,1000\n" 
+"1:7,1800,200";
+
+static char led0_sequences_str[]=
+"0:A,1,\"No IP Address (off)\",{0,2,0,2,1,-1,0,0}\n"
+"0:B,1,\"Not Provisioned\",{5,3,0,2,1,-1,0,0}\n"
+"0:C,1,\"Provisioned\",{6,3,0,2,1,-1,0,0}\n"
+"0:D,1,\"In Test\",{6,3,0,2,1,-1,0,0}\n"
+"0:E,1,\"No Service\",{7,3,0,2,1,-1,0,0}\n"   // Alt is : {7,6,1,2,5,-1,0,0}
+"0:F,1,\"Service Available (on)\",{1,3,0,2,1,-1,0,0}\n"
+"0:G,1,\"Button Pressed\",{2,3,0,2,1,-1,0,0}\n"
+"0:H,1,\"Factory Restore\",{3,3,0,2,1,-1,0,0}\n"
+"0:I,1,\"Firmware Upgrade\",{4,3,0,2,1,-1,0,0}\n"
+"0:J,1,\"Fault (red)\",{1,0,3,0,3,-1,0,0}\n"  // Fault uses Sys LED Red (Turn 2 OFF!)
+"0:K,3,\"SOS\",{3,3,0,2,1,3,500,1},{4,3,0,2,1,3,500,2},{3,3,0,2,1,3,1000,0}\n";
+
+static char led1_sequences_str[]=
+"1:A,1,\"Off\",{0,0,8,0,8,-1,0,0}\n"
+"1:B,1,\"Searching\",{5,8,0,0,8,-1,0,0}\n"
+"1:C,1,\"Antenna State Change\",{2,8,0,0,8,-1,0,0}\n"
+"1:D,1,\"Fix Achieved\",{1,8,0,0,8,-1,0,0}\n";
+
+
+/****************************************************************************
+ * Function Name  : turnLed 
+ * Description    : On real HW this should cause the real LED to change state
+ ****************************************************************************/
+static void turnLed( LedState state, unsigned char gpioHigh, unsigned char gpioLow )
+{
+#ifdef USER_SPACE_TESTHARNESS
+    // Do Nothing! (we don't have a real LED to flash!)
+#else   // KERNEL Module
+    unsigned char i;
+    
+    PDEBUG("turnLeds: state: %d, gpioHigh: 0x%x gpioLow: 0x%x\n",
+                    state, gpioHigh, gpioLow );
+    
+    for (i = 0; i < 8; i++)
+    {
+        unsigned char led = ledMappingTable[i];
+        
+        if (led >= 0)
+        {
+            if (gpioHigh & (1 << i))
+            {
+                gpio_set_value( led, 1 );
+            }
+
+            if (gpioLow & (1 << i))
+            {
+                gpio_set_value( led, 0 );
+            }
+        }
+    }
+    
+#endif
+}
+
+/****************************************************************************
+ * Function Name  : timerHandler 
+ * Description    : Determines how long to set the delay for next and calls
+ *                  routine to actually change the LED state
+ ****************************************************************************/
+#if defined(USER_SPACE_TESTHARNESS)
+void timerHandler( int signum )
+{
+    LeddriverDev *dev_p = &leddev[0]; // User space test harness only supports 1 instance
+#else // KERNEL Module
+void timerHandler( unsigned long data )
+{
+    LeddriverDev *dev_p = (LeddriverDev *)data;
+#endif
+    LedSequenceEntry *state_p;
+    int period;
+
+    ACQUIRE(dev_p);
+    state_p = &(dev_p->stateMachine.currentSequence_p[dev_p->stateMachine.state]);
+    
+    // Timer has gone off, determine what we're doing next
+    if (LED_ON == dev_p->stateMachine.ledState)
+    {
+        // Next state is LED_OFF - turn off LED
+        dev_p->stateMachine.ledState = LED_OFF;
+        turnLed( LED_OFF, state_p->gpioOffHigh, state_p->gpioOffLow );
+        
+        // Set timer for 'off_period_ms'
+        period = dev_p->ledPattenTable[state_p->pattern].offPeriodMs;
+        
+        if ( INDEFINITE_REPEAT != state_p->repeat )
+        {   // If this pattern is the last repeat then add on the delay_before_next_pattern_ms
+            if ((dev_p->stateMachine.repeatCount+1) == state_p->repeat)
+            {
+                period += state_p->delay_before_next_pattern_ms;
+                PDEBUG("extending delay_before_next_pattern_ms  (%d)\n",
+                            state_p->delay_before_next_pattern_ms);
+            }
+        }
+    }
+    else
+    {
+        // Next state is LED_ON - turn on LED
+        dev_p->stateMachine.ledState = LED_ON;
+        turnLed( LED_ON, state_p->gpioOnHigh, state_p->gpioOnLow );
+        
+        if ( INDEFINITE_REPEAT != state_p->repeat )
+        {// Do we repeat this pattern?
+            if (++(dev_p->stateMachine.repeatCount) < state_p->repeat)
+            {
+                // yes
+                period = dev_p->ledPattenTable[state_p->pattern].onPeriodMs;
+            }
+            else
+            {
+                // We have to find the next state
+                dev_p->stateMachine.state = state_p->nextState;
+                // check this is a valid entry
+                if ( dev_p->stateMachine.state >=
+                         dev_p->sequenceTable[dev_p->stateMachine.currentSequenceIndex].numStates )
+                {
+                    PDEBUG("Warning detected nextState number invalid on sequence %d\n",
+                                 dev_p->stateMachine.currentSequenceIndex);
+                    dev_p->stateMachine.state = 0;
+                }
+                PDEBUG("Changing state to : (state)%d (nextState)%d (currSeqIndex)%d\n",
+                    dev_p->stateMachine.state,
+                    state_p->nextState,
+                    dev_p->stateMachine.currentSequenceIndex);
+                    
+                // Start a new LedSequenceEntry
+                state_p = &(dev_p->stateMachine.currentSequence_p[dev_p->stateMachine.state]);
+                dev_p->stateMachine.repeatCount = 0;
+                period = dev_p->ledPattenTable[state_p->pattern].onPeriodMs;
+            }
+        }
+        else
+        {
+            period = dev_p->ledPattenTable[state_p->pattern].onPeriodMs;
+        }
+    }
+
+    RELEASE(dev_p);
+    
+    /* If the LED period is a magic value (ON_PERMANENT or OFF_PERMANENT) then don't
+     * Start the timer, this will leave the LED stuck in this state until someone changes
+     * the Sequence
+     */
+    if (period != ON_PERMANENT && period != OFF_PERMANENT)
+    {
+        start_timer(dev_p, period);
+    }
+
+    PDEBUG("LedState=%s state=%d, currentSequence[state].pattern = %d, repeatCount = %d\n",
+        dev_p->stateMachine.ledState==LED_ON?"ON":"OFF",
+        dev_p->stateMachine.state,
+        state_p->pattern,
+        dev_p->stateMachine.repeatCount);
+
+    
+}
+
+
+#ifdef USER_SPACE_TESTHARNESS
+/****************************************************************************
+ * Function Name  : start_timer 
+ * Description    : ... hmm I wonder
+ ****************************************************************************/
+/* NOTE: In USER_SPACE_TESTHARNESS This will only work for 1 instance of LeddriverDev!!! */
+static void start_timer(LeddriverDev *dev_p, int periodms )
+{
+	struct itimerval itimer;
+	int result;
+	int sec = periodms/1000;
+	periodms -= (sec*1000);
+	
+	itimer.it_value.tv_sec = (long) sec;
+	
+	itimer.it_value.tv_usec = (long) (periodms*1000);
+	//PDEBUG("Starting timer %d.%d\n",sec,periodms);
+	result = setitimer(ITIMER_REAL, &itimer, NULL);
+	
+}
+static void stop_timer(LeddriverDev *dev_p)
+{
+	struct itimerval itimer;
+	itimer.it_value.tv_sec = 0;
+	itimer.it_value.tv_usec = 0;
+	PDEBUG("Stopping timer\n");
+	setitimer(ITIMER_REAL, &itimer, NULL);
+}
+#else // KERNEL Module
+static void start_timer(LeddriverDev *dev_p, int periodms )
+{
+    init_timer( &(dev_p->ledTimer) ); 
+    dev_p->ledTimer.function = timerHandler;
+    dev_p->ledTimer.expires  = jiffies + (periodms * (HZ/1000));
+    dev_p->ledTimer.data = (unsigned long) dev_p;   // Pass context back to handler
+    add_timer( &(dev_p->ledTimer) );
+    PDEBUG("Starting timer (periodms:%d) now: %li expires: %li data: %li\n",periodms, jiffies,
+            dev_p->ledTimer.expires, dev_p->ledTimer.data);
+}
+static void stop_timer(LeddriverDev *dev_p)
+{
+	del_timer_sync( &(dev_p->ledTimer) );
+}
+#endif /* USER_SPACE_TESTHARNESS */
+
+
+/* Allow this function to be called from other modules */
+void changeLedSequence( int instance, int index )
+{
+    LeddriverDev * dev_p = &leddev[0];
+    
+    if (instance < 0 || instance > MAX_NUM_LED_INSTANCES )
+    {
+        PDEBUG("Invalid LED Driver instance number\n");
+    }
+    else
+    {
+        dev_p = &leddev[instance];
+    }
+    
+    if ( index >= dev_p->numSequences )
+    {
+        PDEBUG("Invalid LED sequence index\n");
+        return;
+    }
+    
+    // Delete the timer
+    stop_timer( dev_p );
+    
+    dev_p->stateMachine.ledState = LED_OFF;
+    dev_p->stateMachine.currentSequenceIndex = index;
+    dev_p->stateMachine.currentSequence_p = &(dev_p->sequenceTable[index].sequenceEntry[0]);
+    dev_p->stateMachine.repeatCount = -1;
+    dev_p->stateMachine.state = 0;
+    
+#ifdef USER_SPACE_TESTHARNESS
+	timerHandler(SIGALRM);
+#else
+	timerHandler( (long unsigned) dev_p );
+#endif /* USER_SPACE_TESTHARNESS */
+}
+
+
+#ifdef USER_SPACE_TESTHARNESS
+int main(int argc, char *argv[])
+{
+	signal (SIGALRM, timerHandler);
+	
+	if (argc == 2)
+	{
+		int seq = atoi(argv[1]);
+		int numSeq = sizeof(sequenceTable)/sizeof(SequencePatternTable); 
+		if( seq < 0 || seq > (numSeq-1) )
+		{
+			printf("Sorry please enter sequence number [0-%d]\n", numSeq-1);
+			exit(1);
+		}
+		changeLedSequence(0, seq);
+	}
+	else
+	{
+		changeLedSequence(0, 3 );
+	}
+	
+	while(1)
+	{
+		int i;
+		for(i=0; i<800000;i++) { i=i*2;i/=2; } // Delay to reduce amount of printf's per time period
+		printf("%s",stateMachine.ledState==LED_ON ? "^" : "_");
+		fflush(stdout);
+	}
+	
+	return 0;
+}
+#endif /* USER_SPACE_TESTHARNESS */
+
+#if !defined(USER_SPACE_TESTHARNESS)
+/*
+ * export symbols to the kernel
+ */
+#define LEDDRIVER_MAJOR         241
+
+int     leddriverMajor           = LEDDRIVER_MAJOR;
+int     leddriverNumDevs         = 2;
+
+module_param (leddriverMajor, int, 0);
+module_param (leddriverNumDevs, int, 0);
+
+MODULE_AUTHOR ("ip.access");
+MODULE_LICENSE ("Dual BSD/GPL");
+
+/*
+ * invoked when user process issues an open() call (or equivalent) on device file
+ */
+int leddriver_open (struct inode *inode, struct file *filp)
+{
+    LeddriverDev    *dev_p; /* device information */
+
+    /*  Find the device */
+    dev_p = container_of (inode->i_cdev, LeddriverDev, cdev);
+
+    /* and use filp->private_data to point to the device data */
+    filp->private_data = dev_p;
+
+    return 0;          /* success */
+}
+
+
+/*---------------------------------------------------------------------------*/
+/*
+ * invoked when user process issues a close() call (or equivalent) on device file
+ */
+int leddriver_release (struct inode *inode, struct file *filp)
+{
+    return 0;
+}
+
+
+/*---------------------------------------------------------------------------*/
+/*
+ * invoked when user process issues a read() call (or equivalent) on device file
+ */
+ssize_t leddriver_read (struct file *filp,
+                    char __user *buf_p,
+                    size_t      count,
+                    loff_t      *f_pos_p)
+{
+    LeddriverDev        *dev_p = filp->private_data;
+    char                returnBuffer [1];
+
+    returnBuffer [0] = dev_p->sequenceCode;
+
+    if (copy_to_user (buf_p, &returnBuffer [0], 1))
+    {
+        return -EFAULT;
+    }
+
+    return 1;
+}
+
+/*---------------------------------------------------------------------------*/
+/*
+ * invoked when user process issues a write() call (or equivalent) on device file
+ */
+ssize_t leddriver_write (struct file *filp,
+                    const char __user *buf_p,
+                    size_t      count,
+                    loff_t      *f_pos_p)
+{
+    LeddriverDev        *dev_p = filp->private_data;
+    char                writeBuffer [1];
+    LedSequenceEntry *seqEntry_p = &dev_p->sequenceTable[0].sequenceEntry[0];
+
+        
+    if (copy_from_user (&writeBuffer [0], buf_p, 1))
+    {
+        return -EFAULT;
+    }
+    
+    // Check that the writeBuffer character is in range
+    if (writeBuffer[0] == '0')
+    {
+        dev_p->sequenceCode = writeBuffer[0];
+        stop_timer(dev_p);
+        
+        turnLed (LED_OFF, seqEntry_p->gpioOffHigh, seqEntry_p->gpioOffLow );
+    }
+    else if ( writeBuffer[0] == '1')
+    {
+        dev_p->sequenceCode = writeBuffer[0];
+        stop_timer(dev_p);
+        turnLed (LED_ON, seqEntry_p->gpioOnHigh, seqEntry_p->gpioOnLow );
+    }
+    else if ( (writeBuffer[0] >= 'A') && (writeBuffer[0] < ('A' + dev_p->numSequences)) )
+    {
+        dev_p->sequenceCode = writeBuffer[0];
+        changeLedSequence( dev_p->instance, (int) (writeBuffer[0] - 'A') );
+    }
+    else
+    {
+        PDEBUG("Invalid pattern : %c\n",writeBuffer[0]);
+    }
+    
+    return 1;
+}
+
+/*---------------------------------------------------------------------------*/
+/*
+ * The ioctl() implementation
+ */
+int leddriver_ioctl (struct inode   *inode_p,
+                 struct file    *filp,
+                 unsigned int   cmd,
+                 unsigned long  arg)
+{
+    int         ret = 0;
+ 
+    /* Keep a stub function here in case we want to use an IOCTL in the future! */
+    return ret;
+}
+
+
+/*---------------------------------------------------------------------------*/
+/*
+ * The fops - this structure tells the kernel which functiosn to invoke to
+ * handle user process access to the device file
+ */
+struct file_operations leddriverFops =
+{
+    .owner =     THIS_MODULE,
+    .read =      leddriver_read,
+    .write =     leddriver_write,
+    .ioctl =     leddriver_ioctl,
+    .open =      leddriver_open,
+    .release =   leddriver_release,
+};
+
+/*---------------------------------------------------------------------------*/
+/*
+ * The proc filesystem: function to read an entry
+ */
+
+
+
+/*---------------------------------------------------------------------------*/
+/*
+ * Initialise a character device kernel structure
+ */
+static void leddriver_setup_cdev (LeddriverDev *dev_p, int index)
+{
+    int     err;
+    int     devno = MKDEV (leddriverMajor, index);
+
+    cdev_init (&dev_p->cdev, &leddriverFops);
+    dev_p->cdev.owner = THIS_MODULE;
+    dev_p->cdev.ops = &leddriverFops;
+    err = cdev_add (&dev_p->cdev, devno, 1);
+    /* Fail gracefully if need be */
+    if (err)
+    {
+        printk (KERN_NOTICE "Error %d adding leddriver%d", err, index);
+    }
+}
+
+
+/*---------------------------------------------------------------------------*/
+/*
+ * Invoked by the kernel when the device driver is loaded (insmod)
+ */
+int leddriver_init (void)
+{
+    int         result;
+    dev_t       dev = MKDEV (leddriverMajor, 0);
+    LeddriverDev * dev_p;
+    int         devNum;
+
+    if ((leddriverNumDevs < 1) || (leddriverNumDevs > MAX_NUM_LED_INSTANCES))
+    {
+        printk (KERN_NOTICE "leddriver: Num devices is out of range 1 to %d (%d)",
+                            MAX_NUM_LED_INSTANCES, leddriverNumDevs);
+        return -EINVAL;
+    }
+
+    /*
+     * Register our major device number, and accept a dynamic number.
+     */
+    if (leddriverMajor)
+    {
+        result = register_chrdev_region (dev, 1, "leddriver");
+    }
+    else
+    {
+        result = alloc_chrdev_region (&dev, 0, 1, "leddriver");
+        leddriverMajor = MAJOR (dev);
+    }
+    if (result < 0)
+    {
+        goto err;
+    }
+
+    result = gpio_request(ARM_GPIO_OUT_SERVICE_LED, "SERVICE_LED");
+    if (result < 0)
+    {
+        goto err;
+    }
+    
+    result = gpio_request(ARM_GPIO_OUT_SYS_LED_RED, "SYS_LED");
+    if (result < 0)
+    {
+        goto err_no_sys_led;
+    }
+    
+    result = gpio_request(ARM_GPIO_OUT_ADD_LED_RED, "ADD_LED");
+    if (result < 0)
+    {
+        goto err_no_add_led;
+    }
+    
+    if ( leddriverNumDevs > 1)
+    {
+        result = gpio_request(ARM_GPIO_OUT_ADD_LED_GPS, "GPS_LED");
+        if (result < 0)
+        {
+            goto err_no_gps_led;
+        }
+    }
+    
+    dev_p = &leddev[0];
+    for (devNum = 0; devNum < leddriverNumDevs; devNum++)
+    {
+        leddriver_setup_cdev (dev_p, devNum);
+        dev_p->sequenceCode = '0';
+        dev_p->instance = devNum;
+        dev_p->numPatterns = 0;
+        dev_p->numSequences = 0;
+        
+        dev_p->ledPattenTable = kmalloc( (sizeof(LedFlashPattern)*MAX_NUM_PATTERNS), GFP_KERNEL );
+        if ( dev_p->ledPattenTable == NULL )
+        {
+            printk("leddriver: KMALLOC failed\n");
+            result = -ENOMEM;
+            goto err_table_alloc;
+        }
+
+        dev_p->sequenceTable = kmalloc( (sizeof(SequencePatternTable)*MAX_NUM_SEQUENCES), GFP_KERNEL );
+        if ( dev_p->sequenceTable == NULL )
+        {
+            printk("leddriver: KMALLOC failed\n");
+            result = -ENOMEM;
+            goto err_table_alloc;
+        }
+
+        dev_p->stateMachine.currentSequence_p = &dev_p->sequenceTable[0].sequenceEntry[0];
+        dev_p->stateMachine.currentSequenceIndex = 0;
+        dev_p->stateMachine.state = 0;
+        dev_p->stateMachine.ledState = LED_OFF;
+        dev_p->stateMachine.repeatCount = 0;     
+                
+        dev_p++;
+    }
+
+    create_proc_fs();
+
+    // Initialise some default patterns
+    parse_pattern_buffer(led0_patterns_str, sizeof(led0_patterns_str));
+    parse_sequence_buffer(led0_sequences_str, sizeof(led0_sequences_str));
+    
+    gpio_set_value(ARM_GPIO_OUT_SERVICE_LED, 0);
+    gpio_set_value(ARM_GPIO_OUT_SYS_LED_RED, 1);
+    gpio_set_value(ARM_GPIO_OUT_ADD_LED_RED, 0);
+
+    gpio_direction_output(ARM_GPIO_OUT_SERVICE_LED, 0);
+    gpio_direction_output(ARM_GPIO_OUT_SYS_LED_RED, 1);
+    gpio_direction_output(ARM_GPIO_OUT_ADD_LED_RED, 0);
+    
+    gpio_set_value(ARM_GPIO_OUT_SERVICE_LED, 0);
+    gpio_set_value(ARM_GPIO_OUT_SYS_LED_RED, 1);
+    gpio_set_value(ARM_GPIO_OUT_ADD_LED_RED, 0);
+
+    // On custom hardware additional I/O is available for LED
+    if ( leddriverNumDevs > 1)
+    {
+        parse_pattern_buffer(led1_patterns_str, sizeof(led1_patterns_str));
+        parse_sequence_buffer(led1_sequences_str, sizeof(led1_sequences_str));
+        
+        gpio_set_value(ARM_GPIO_OUT_ADD_LED_GPS, 0);
+        gpio_direction_output(ARM_GPIO_OUT_ADD_LED_GPS, 0);
+        gpio_set_value(ARM_GPIO_OUT_ADD_LED_GPS, 0);
+    }
+    
+    printk( "Added leddriver.ko with major number=%d\n",leddriverMajor );
+
+    return 0; /* succeed */
+    
+err_table_alloc:
+    if ( leddriverNumDevs > 1)
+    {
+        gpio_free(ARM_GPIO_OUT_ADD_LED_GPS);
+    }
+err_no_gps_led:
+    gpio_free(ARM_GPIO_OUT_ADD_LED_RED);
+err_no_add_led:
+    gpio_free(ARM_GPIO_OUT_SYS_LED_RED);
+err_no_sys_led:
+    gpio_free(ARM_GPIO_OUT_SERVICE_LED);
+err:
+    return result;
+}
+
+
+/*---------------------------------------------------------------------------*/
+/*
+ * Invoked by the kernel when the device driver is unloaded (rmmod)
+ */
+void leddriver_cleanup (void)
+{
+    LeddriverDev * dev_p;
+    int         devNum;
+    
+    gpio_free(ARM_GPIO_OUT_SERVICE_LED);
+    gpio_free(ARM_GPIO_OUT_SYS_LED_RED);
+    gpio_free(ARM_GPIO_OUT_ADD_LED_RED);
+    if ( leddriverNumDevs > 1)
+    {
+        gpio_free(ARM_GPIO_OUT_ADD_LED_GPS);
+    }
+    
+    dev_p = &leddev[0];
+    for (devNum = 0; devNum < leddriverNumDevs; devNum++)
+    {
+        stop_timer(dev_p);    
+        cdev_del (&(dev_p->cdev));
+
+        kfree(dev_p->sequenceTable);
+        kfree(dev_p->ledPattenTable);
+        dev_p++;
+    }
+
+    remove_proc_fs();
+    
+    unregister_chrdev_region (MKDEV (leddriverMajor, 0), 1);
+}
+
+
+/*---------------------------------------------------------------------------*/
+/*
+ * Export device driver main entry points.
+ */
+module_init (leddriver_init);
+module_exit (leddriver_cleanup);
+
+EXPORT_SYMBOL(changeLedSequence); // To allow the reset switch driver to change led state
+#endif /* USER_SPACE_TESTHARNESS */
diff -Naur pico_2.6.28/drivers/ipa/leddriver/leddriver_procfs.c ipa_2.6.28/drivers/ipa/leddriver/leddriver_procfs.c
--- pico_2.6.28/drivers/ipa/leddriver/leddriver_procfs.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/ipa/leddriver/leddriver_procfs.c	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,692 @@
+/*
+ * FILE NAME leddriver_procfs.c
+ *
+ * Copyright (c) 2008 ip.access Ltd.
+ *
+ * BRIEF MODULE DESCRIPTION
+ *  Driver for LED (procfs handler)
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+/****************************************************************************
+ * Standard Library Includes
+ ****************************************************************************/ 
+#include "leddriver.h"
+
+/****************************************************************************
+  Private Definitions
+ ****************************************************************************/
+
+/****************************************************************************
+  Private Types
+ ****************************************************************************/
+
+
+ /****************************************************************************
+ * Private Function Prototypes
+ ****************************************************************************/
+static int proc_write( struct file *file, const char __user *buffer,
+               unsigned long count, void *data);
+static int proc_read (char    *buf_p,   char    **start_p,
+               off_t   offset, int     count,   int     *eof_p, void    *data_p);
+
+static int update_pattern_entry( int devNum, int patternIdx, int onPeriodMs, int offPeriodMs);
+
+static int update_sequence_entry( int devNum, char sequenceLetter, char *sequenceName,
+                     int numStates, LedSequenceEntry *sequences_p );
+
+static int print_patterns( char *buf_p, int count, int devNum );
+static int print_sequences( char *buf_p, int count, int devNum );
+
+static int modify_pattern_entry(int devNum, int patternIdx, int onPeriodMs, int offPeriodMs);
+static int modify_sequence_entry( int devNum, char sequenceLetter, char *sequenceName,
+                     int numStates, LedSequenceEntry *sequences_p );
+                     
+static int update_pattern_entry( int devNum, int patternIdx, int onPeriodMs, int offPeriodMs);
+static int update_sequence_entry( int devNum, char sequenceLetter, char *sequenceName,
+                     int numStates, LedSequenceEntry *sequences_p );
+static int process_sequence_entries(char *buf, char **ptr_p, int numStates, LedSequenceEntry *sequences_p);
+
+/****************************************************************************
+ * Private Constants
+ ****************************************************************************/
+#define PATTERN_PARSER_EXIT -1
+#define FIND_DEV_INSTANCE   20
+#define FIND_PATTERN_IDX    21
+#define FIND_ON_PERIOD      22
+#define FIND_OFF_PERIOD     23
+
+#define PATTERN_MAGIC_VAL   100
+#define SEQUENCE_MAGIC_VAL  200
+
+/****************************************************************************
+ * Exported Variables
+ ****************************************************************************/
+ 
+/****************************************************************************
+ * Private Variables (Must be declared static)
+ ****************************************************************************/
+static struct proc_dir_entry * proc_leddriver = NULL;
+
+ /****************************************************************************
+ * Function Name  : remove_proc_fs entries
+ * Description    : Removes the 'files' in /proc/
+ ****************************************************************************/
+void remove_proc_fs( void )
+{
+
+    remove_proc_entry( "patterns", proc_leddriver );
+    remove_proc_entry( "sequences", proc_leddriver );
+    remove_proc_entry( "driver/leddriver", NULL );
+
+}
+ /****************************************************************************
+ * Function Name  : create_proc_fs entries
+ * Description    : creates the 'files' in /proc/
+ ****************************************************************************/
+void create_proc_fs( void )
+{
+    struct proc_dir_entry * patterns;
+    struct proc_dir_entry * sequences;
+
+    PDEBUG("Adding procfs entries... \n");
+    if (!proc_leddriver)
+    {
+        PDEBUG("Adding proc/driver/leddriver...\n");
+
+        proc_leddriver = proc_mkdir( "driver/leddriver",
+                                NULL);
+    }
+
+    if (proc_leddriver)
+    {
+        patterns = create_proc_entry( "patterns",
+                                S_IFREG | S_IWUSR,
+                                proc_leddriver);
+                                    
+        if (patterns)
+        {
+            patterns->read_proc = proc_read;
+            patterns->write_proc = proc_write;
+            patterns->data = (void*)PATTERN_MAGIC_VAL;
+        }
+        else
+        {
+            PDEBUG("Failed to add /proc/driver/leddriver/patterns !\n");
+        }
+    
+    
+        sequences = create_proc_entry( "sequences",
+                                    S_IFREG | S_IWUSR,
+                                    proc_leddriver);
+        if (sequences)
+        {
+            sequences->read_proc = proc_read;
+            sequences->write_proc = proc_write;
+            sequences->data = (void*)SEQUENCE_MAGIC_VAL;
+        }
+        else
+        {
+            PDEBUG("Failed to add /proc/driver/leddriver/sequences !\n");
+        }
+    }
+    else
+    {
+        PDEBUG("Failed to add /proc/driver/leddriver folder !\n");
+    }
+}
+
+/*
+# format of patterns (up to 10 patterns 0-9 can be added) in the form devInstance:PatternIndex, On period, Off period
+#   0:0,50,50
+#   0:1,50,200
+#   0:2,300,50
+#   0:3,200,1800
+#   0:4,1000,1000
+#   0:5,1800,200
+*/
+/****************************************************************************
+ * Function Name  : parse_pattern_buffer
+ * Description    : Parses /proc/drivers/leddriver/patterns buffer. Can also be called
+ *                  from intialisation to provide default patterns
+ ****************************************************************************/
+int parse_pattern_buffer( char* buf, unsigned long count )
+{
+    char *ptr = buf;
+    int limit = 0;
+    int devNum = 0, patternIdx = 0, onPeriodMs = 50, offPeriodMs = 50;
+
+    printk("procesing ...\n%s\n", buf);
+
+    while ( sscanf(ptr, "%d:%d,%d,%d\n", &devNum, &patternIdx, &onPeriodMs, &offPeriodMs) == 4 )
+    {
+        if( update_pattern_entry( devNum, patternIdx, onPeriodMs, offPeriodMs) == -1)
+        {
+            break; // Something went wrong
+        }
+        
+
+        ptr++;
+        ptr = strstr(ptr,"\n"); // find the next CR
+        if (NULL == ptr)
+            break; // we can't find any more lines - exit
+
+        // Catch endless loops that otherwise may take down the board
+        if ( ++limit > 100 )
+            break;
+    }   
+
+    return (count);
+}
+/*
+# format of sequences (up to 12 Sequences A-L can be added)
+#    in the form devInstance:SequenceIndex,numStates,"SequenceName",
+        {Pattern, gpioOnHigh, gpioOnLow,gpioOffHigh,gpioOffLow,RepeatCount,Del before next patt, nextState}
+#"0:A,1,\"No IP Address (off)\",{0,32,0,32,0,-1,0,0}\n"
+#"0:B,1,\"Not Provisioned\",{5,36,0,32,4,-1,0,0}\n"
+#"0:C,1,\"Provisioned\",{6,36,0,32,4,-1,0,0}\n"
+#"0:D,1,\"In Test\",{6,36,0,32,4,-1,0,0}\n"
+#"0:E,1,\"No Service\",{7,36,0,32,4,-1,0,0}\n"   // Alt is : {7,96,4,32,68,-1,0,0}
+#"0:F,1,\"Service Available (on)\",{1,36,0,32,4,-1,0,0}\n"
+#"0:G,1,\"Button Pressed\",{2,36,0,32,4,-1,0,0}\n"
+#"0:H,1,\"Factory Restore\",{3,36,0,32,4,-1,0,0}\n"
+#"0:I,1,\"Firmware Upgrade\",{4,36,0,32,4,-1,0,0}\n"
+#"0:J,1,\"Fault (red)\",{1,0,36,0,36,-1,0,0}\n"  // Fault uses Sys LED Red (Turn 32 OFF!)
+#"0:K,3,\"SOS\",{3,36,0,32,4,3,500,1},{4,36,0,32,4,3,500,2},{3,36,0,32,4,3,1000,0}\n";
+*/
+/****************************************************************************
+ * Function Name  : parse_sequence_buffer
+ * Description    : Parses /proc/drivers/leddriver/sequences buffer. Can also be called
+ *                  from intialisation to provide default sequences
+ ****************************************************************************/
+int parse_sequence_buffer( char* buf, unsigned long count )
+{
+    char *ptr = buf;
+    char *oldPtr, *start_p, *end_p;
+    int limit = 0, bCont;
+    int devNum = 0, numStates = 1, actualNumStates;
+    char sequenceLetter;
+    char sequenceName[SEQUENCE_NAME_LEN];
+    LedSequenceEntry *sequences_base_p = NULL;
+    
+    sequences_base_p = kmalloc( MAX_NUM_STATES * sizeof(LedSequenceEntry), GFP_KERNEL );
+    if (!sequences_base_p)
+    {
+        // Abort
+        printk("Kernel malloc failed to allocate sequences\n");
+        return count;
+    }
+
+    printk("procesing ...\n%s\n", ptr);
+    
+    bCont = 1;
+    while ( bCont )
+    {
+        if ( sscanf(ptr, "%d:%c,%d", &devNum, &sequenceLetter,&numStates) == 3)
+        {
+            /* Find sequenceName */
+            end_p = NULL;
+            start_p = strstr(ptr,"\"");
+            if( start_p )
+            {
+                start_p++; // move to next char after "
+                end_p = strstr(start_p,"\"");
+                if( end_p )
+                {   
+                    *end_p = '\0';
+                    strncpy((char*) &sequenceName, start_p, sizeof(sequenceName)-1);
+                    sequenceName[SEQUENCE_NAME_LEN-1] = '\0';
+                    ptr = end_p + 1;
+                }
+            }
+        
+            if ( start_p == NULL || end_p == NULL )
+            {
+                bCont = 0;
+                printk("ptr=%d, can't find quotes for sequenceName! (%s)\n",start_p-buf, start_p);
+                break;  // We can't find a quote
+            }
+                    
+            if (count < (ptr-buf))
+            {
+                bCont = 0;
+                printk("ptr=%d, not enough chars left in string to continue\n",start_p-buf);
+                break;
+            }
+
+            if (numStates <1 || numStates >= MAX_NUM_STATES)
+            {
+                bCont = 0;
+                printk("ptr=%d, numStates = %d (out of range!)\n",start_p-buf, numStates);
+                break;
+            }
+            
+            memset(sequences_base_p, 0, MAX_NUM_STATES * sizeof(LedSequenceEntry));
+            actualNumStates = process_sequence_entries(buf, &ptr, numStates, sequences_base_p);
+            if (actualNumStates != numStates)
+            {                            
+                bCont = 0;
+                printk("ptr=%d, number of states (%d) doesn't match for sequence %s\n",ptr-buf, numStates, sequenceName);
+                break;                            
+            }
+            update_sequence_entry( devNum, sequenceLetter, sequenceName, numStates, sequences_base_p);
+        }
+        else
+        {
+            bCont = 0;
+        }
+
+        /* Try to process the next sequence */
+        oldPtr = ptr;
+        ptr = strstr(oldPtr,"\n");
+        if (NULL == ptr) break;
+        
+        // Catch endless loops that otherwise may take down the board
+        if ( ++limit > 100 ) break;
+    }   
+    
+    kfree(sequences_base_p);
+    
+    return (count);
+} 
+
+/************************* LOCAL FUNCTIONS BELOW ****************************/
+
+/****************************************************************************
+ * Function Name  : proc_read
+ * Description    : Handles reads to proc filesystem
+ ****************************************************************************/
+static int proc_read (char    *buf_p,
+                        char    **start_p,
+                        off_t   offset,
+                        int     count,
+                        int     *eof_p,
+                        void    *data_p)
+{
+    int                 len = 0;
+    int                 devNum;
+    int magicValue = (int) data_p;
+            
+    
+    len += sprintf (buf_p + len,"\nleddriverNumDevs = %d\n", leddriverNumDevs);
+    
+    for (devNum = 0; devNum < leddriverNumDevs; devNum++)
+    {
+        if ( magicValue == PATTERN_MAGIC_VAL )
+        {
+            len += print_patterns(buf_p + len, count-len, devNum );
+        }
+        else if ( magicValue == SEQUENCE_MAGIC_VAL )
+        {
+            len += print_sequences(buf_p + len, count-len, devNum );
+        }
+    }
+        
+    *eof_p = 1;
+    return len;
+}
+/****************************************************************************
+ * Function Name  : proc_write
+ * Description    : Handles writes to proc filesystem
+ ****************************************************************************/
+ static int proc_write( struct file *file, const char __user *buffer,
+               unsigned long count, void *data)
+{
+    char *localBuf;
+    int magicValue = (int) data;
+    
+    if (count > 1024)
+    {
+        count = 1024;
+    }
+
+    localBuf = kmalloc(count+1,GFP_KERNEL);
+
+    if (localBuf)
+    {
+        if (copy_from_user(localBuf, buffer, count))
+        {
+            kfree(localBuf);
+            return -EFAULT;
+        }
+        else
+        {
+            localBuf[count] = '\0'; // Null term string
+
+            if ( magicValue == PATTERN_MAGIC_VAL )
+            {
+                count = parse_pattern_buffer(localBuf, count );
+            }
+            else if ( magicValue == SEQUENCE_MAGIC_VAL )
+            {
+                count = parse_sequence_buffer(localBuf, count );
+            }
+            kfree(localBuf);
+
+            return count;
+        }
+
+    }
+    return -EFAULT;
+        
+}
+
+/****************************************************************************
+ * Function Name  : print_patterns
+ * Description    : Dumps pattern enries for a particular device
+ *                  buf is a buffer to sprintf into, Count is size of buffer
+ ****************************************************************************/
+static int print_patterns( char *buf_p, int count, int devNum )
+{
+    int i;
+    int len = 0;
+    LeddriverDev *dev_p = &leddev[devNum];
+            
+    for( i = 0; i < dev_p->numPatterns; i++)
+    {
+        len += sprintf (buf_p + len,"%d:%d,%d,%d\n",
+                            devNum,
+                            i,
+                            dev_p->ledPattenTable[i].onPeriodMs,
+                            dev_p->ledPattenTable[i].offPeriodMs);
+    }
+
+    return len;
+}
+/****************************************************************************
+ * Function Name  : print_sequences
+ * Description    : Dumps sequence enries for a particular device
+ *                  buf is a buffer to sprintf into, Count is size of buffer
+ ****************************************************************************/
+static int print_sequences( char *buf_p, int count, int devNum )
+{
+    int j;
+    int i;
+    int len = 0;
+    LeddriverDev *dev_p = &leddev[devNum];
+    LedSequenceEntry * sequences_p;
+    
+    for ( j = 0; j < dev_p->numSequences ; j++)
+    {
+        int numStates = dev_p->sequenceTable[j].numStates;
+        
+        len += sprintf (buf_p + len,"%d:%c,%d,\"%s\"",
+                        devNum,
+                        'A' + j,
+                        numStates,
+                        dev_p->sequenceTable[j].name);
+
+        sequences_p = dev_p->sequenceTable[j].sequenceEntry;
+        
+        for( i = 0; i < numStates; i++)
+        {
+            len += sprintf (buf_p + len, ",{%d,%d,%d,%d,%d,%d,%d,%d}",
+                        sequences_p->pattern,
+                        sequences_p->gpioOnHigh,
+                        sequences_p->gpioOnLow,
+                        sequences_p->gpioOffHigh,
+                        sequences_p->gpioOffLow,
+                        sequences_p->repeat,
+                        sequences_p->delay_before_next_pattern_ms,
+                        sequences_p->nextState );
+            sequences_p++;
+            
+            if (len > count - 100) // Allow some headroom    
+                break;
+        }
+        
+        len += sprintf (buf_p + len,"\n");
+        if (len > count - 100)
+            break;
+    }
+    
+    return len;
+}
+/****************************************************************************
+ * Function Name  : modify_pattern_entry
+ * Description    : Actually modifies the pattern table - assumes it is safe
+ *                  to use this data structure prior to use.
+ ****************************************************************************/
+static int modify_pattern_entry(int devNum, int patternIdx, int onPeriodMs, int offPeriodMs)
+{
+    LeddriverDev *dev_p;
+     
+    if(devNum < 0 || devNum >= leddriverNumDevs)
+    {
+        printk("devNum is out of range! (%d)\n", devNum);
+        return -1;
+    }
+    if( patternIdx >= MAX_NUM_PATTERNS )
+    {
+        printk("patternIdx is out of range! (%d)\n", patternIdx);
+        return -1;
+    }
+    
+    dev_p = &leddev[devNum];
+
+    /* Get spinlock */
+    ACQUIRE(dev_p);
+    
+    dev_p->ledPattenTable[patternIdx].onPeriodMs = onPeriodMs;
+    dev_p->ledPattenTable[patternIdx].offPeriodMs = offPeriodMs;
+
+    /* Update the largest valid pattern index - Note we can't decrease this by design */
+    if ( patternIdx >= dev_p->numPatterns)
+    {
+        dev_p->numPatterns = patternIdx + 1;
+    }
+
+    /* Release spinlock */
+    RELEASE(dev_p);
+    
+    return 0;
+}
+/****************************************************************************
+ * Function Name  : update_pattern_entry
+ * Description    : Validates values are in range before calling modify function
+ *                  - assumes it is safe to use this data structure prior to use.
+ ****************************************************************************/
+static int update_pattern_entry( int devNum, int patternIdx, int onPeriodMs, int offPeriodMs)
+{
+    PDEBUG("update_pattern_entry: %d %d %d %d\n", devNum, patternIdx, onPeriodMs, offPeriodMs);
+    
+    if ( devNum < 0 || devNum > leddriverNumDevs)
+    {
+        printk("devNum (%d) is out of range, should be 0-%d\n",devNum, leddriverNumDevs);
+        return -1;
+    }
+
+    if ( patternIdx < 0 || patternIdx >= MAX_NUM_PATTERNS)
+    {
+        printk("patternIdx (%d) is out of range, should be 0-" MAX_NUM_PATTERNS_STR "\n",patternIdx);
+        return -1;
+    }
+    
+    if ( (onPeriodMs != ON_IGNORE) && (onPeriodMs != ON_PERMANENT) && (onPeriodMs < 50 ))
+    {
+        printk("onPeriodMs (%d) is out of range, should be >50 ms\n",onPeriodMs);
+        return -1;
+    }
+
+    if ( (offPeriodMs != OFF_IGNORE) && (offPeriodMs != OFF_PERMANENT) && (offPeriodMs < 50 ))
+    {
+        printk("offPeriodMs (%d) is out of range, should be >50 ms\n",offPeriodMs);
+        return -1;
+    }
+
+    return (modify_pattern_entry( devNum, patternIdx,  onPeriodMs, offPeriodMs));
+}
+
+/**************************** SEQUENCES BELOW *******************************/
+
+/****************************************************************************
+ * Function Name  : modify_sequence_entry
+ * Description    : Actually modifies the sequence table - assumes it is safe
+ *                  to use this data structure prior to use.
+ ****************************************************************************/
+static int modify_sequence_entry( int devNum, char sequenceLetter, char *sequenceName,
+                     int numStates, LedSequenceEntry *sequences_p )
+{
+    LeddriverDev *dev_p;
+    int sequenceNum;
+    int i;
+     
+    if(devNum < 0 || devNum >= leddriverNumDevs)
+    {
+        printk("devNum is out of range! (%d)\n", devNum);
+        return -1;
+    }
+    if( numStates >= MAX_NUM_STATES )
+    {
+        printk("numStates is out of range! (%d)\n", numStates);
+        return -1;
+    }
+
+    dev_p = &leddev[devNum];
+
+    sequenceNum = sequenceLetter - 'A';
+    if ( (sequenceNum < 0) || (sequenceNum >= MAX_NUM_SEQUENCES) )
+    {
+        printk("sequenceLetter (%c) out of range\n", sequenceLetter);
+        return -1;
+    }
+
+    /* Get spinlock */
+    ACQUIRE(dev_p);
+    
+    strncpy(dev_p->sequenceTable[sequenceNum].name, sequenceName, SEQUENCE_NAME_LEN-1);
+    dev_p->sequenceTable[sequenceNum].name[SEQUENCE_NAME_LEN-1] ='\0';
+    dev_p->sequenceTable[sequenceNum].numStates = numStates;
+
+    for (i = 0; i < numStates; i++ )
+    {  
+        dev_p->sequenceTable[sequenceNum].sequenceEntry[i] = *sequences_p;
+        sequences_p++;
+    }
+
+    /* Update the largest valid sequence index - Note we can't decrease this by design */
+    if ( sequenceNum >= dev_p->numSequences)
+    {
+        dev_p->numSequences = sequenceNum + 1;
+    }   
+
+    /* Release spinlock */
+    RELEASE(dev_p);
+    
+    return 0;   
+}
+
+/****************************************************************************
+ * Function Name  : update_sequence_entry
+ * Description    : Validates values are in range before calling modify function
+ *                  - assumes it is safe to use this data structure prior to use.
+ ****************************************************************************/
+static int update_sequence_entry( int devNum, char sequenceLetter, char *sequenceName,
+                     int numStates, LedSequenceEntry *sequences_p )
+{
+    int i;
+    LedSequenceEntry * base_p = sequences_p;
+
+    for( i = 0; i < numStates; i++)
+    {
+        sequences_p++;
+        /* validate that these are sensible values */
+        if (sequences_p->pattern < 0 || sequences_p->pattern > MAX_NUM_PATTERNS)
+        {
+            printk("In state %d pattern (%d) is out of range, should be 0-" MAX_NUM_PATTERNS_STR "\n",
+                        i, sequences_p->pattern);
+            return -1;
+        }
+        
+        if (sequences_p->nextState < 0 || sequences_p->nextState >= numStates)
+        {
+            printk("In state %d nextState (%d) is out of range, should be 0-%d\n",
+                        i, sequences_p->nextState, numStates);
+            return -1;
+        }       
+    }
+    
+    if ( devNum < 0 || devNum > leddriverNumDevs)
+    {
+        printk("devNum (%d) is out of range, should be 0-%d\n",devNum, leddriverNumDevs);
+        return -1;
+    }
+
+    if ( sequenceLetter < 'A' || (sequenceLetter >= 'A' + MAX_NUM_SEQUENCES))
+    {
+        printk("sequenceLetter (%c) is out of range, should be A-%c\n",sequenceLetter, 'A' + MAX_NUM_SEQUENCES);
+        return -1;
+    }
+    
+    if ( numStates < 1 || numStates > MAX_NUM_STATES)
+    {
+        printk("numStates (%d) is out of range, should be 1-" MAX_NUM_STATES_STR "\n",numStates);
+        return -1;
+    }
+
+    /* Everything looks okay */
+    PDEBUG("Trying to add %d %c \"%s\" %d...\n",devNum, sequenceLetter, sequenceName, numStates);
+    return ( modify_sequence_entry(devNum, sequenceLetter, sequenceName, numStates, base_p));
+}
+
+/****************************************************************************
+ * Function Name  : process_sequence_entries
+ * Description    : Parses the sequence entries and populates array of sequnces
+ ****************************************************************************/
+static int process_sequence_entries(char *buf, char **ptr_p, int numStates, LedSequenceEntry *sequences_p)
+{
+    int i, actualNumStates = 0;
+    char *oldPtr, *ptr = *ptr_p;
+    int pattern, gpioOnHigh, gpioOnLow, gpioOffHigh, gpioOffLow, repeat, delay_before_next_pattern_ms, nextState;
+    
+    for (i = 0; (i < numStates) && (i < MAX_NUM_STATES); i++)
+    {
+//printk("DBG: %d, %s\n", i, ptr);
+        oldPtr = ptr;
+        ptr = strstr(ptr,"{"); // find the next '{'
+        if (NULL == ptr)
+        {
+            printk("ptr=%d, Can't find any more '{' in %s on %d)\n", oldPtr-buf, oldPtr, i);
+            break;
+        }
+        if ( sscanf(ptr, "{%d,%d,%d,%d,%d,%d,%d,%d}",  &pattern, &gpioOnHigh, &gpioOnLow, &gpioOffHigh,
+                &gpioOffLow, &repeat, &delay_before_next_pattern_ms, &nextState ) == 8 )
+        {
+            sequences_p->pattern = pattern;
+            sequences_p->gpioOnHigh = gpioOnHigh;
+            sequences_p->gpioOnLow = gpioOnLow;
+            sequences_p->gpioOffHigh = gpioOffHigh;
+            sequences_p->gpioOffLow = gpioOffLow;
+            sequences_p->repeat = repeat;
+            sequences_p->delay_before_next_pattern_ms = delay_before_next_pattern_ms;
+            sequences_p->nextState = nextState;
+            sequences_p++;
+            actualNumStates++;
+            ptr++;  // skip the open { and next time we should find the next entry
+        }
+        else
+        {
+            printk("ptr: %d - failed to parse %s\n", ptr-buf, ptr );
+            break;
+        }
+    }
+
+    // Update return variables
+    *ptr_p = ptr;
+    
+    if (i != numStates)
+    {
+        return 0;   // Error
+    }
+    else
+    {
+        return actualNumStates;
+    }
+     
+}
+/* end of leddriver_procfs.c */
diff -Naur pico_2.6.28/drivers/ipa/leddriver/Makefile ipa_2.6.28/drivers/ipa/leddriver/Makefile
--- pico_2.6.28/drivers/ipa/leddriver/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/ipa/leddriver/Makefile	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,20 @@
+################################################################################
+# 
+# Copyright (c) 2009 ip.access Ltd.
+#
+#  This program is free software; you can redistribute  it and/or modify it
+#  under  the terms of  the GNU General  Public License as published by the
+#  Free Software Foundation;  either version 2 of the  License, or (at your
+#  option) any later version.
+#
+#  9 Apr 2008 Created by Simon D Hughes.
+# 
+# Makefile for the leddriver
+# 
+##############################################################################
+# Filename: 
+##############################################################################
+
+obj-$(CONFIG_IPACCESS_LED) := leddriver.o
+leddriver-objs := leddriver_main.o leddriver_procfs.o
+
diff -Naur pico_2.6.28/drivers/ipa/Makefile ipa_2.6.28/drivers/ipa/Makefile
--- pico_2.6.28/drivers/ipa/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/ipa/Makefile	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,18 @@
+################################################################################
+# 
+# Copyright (c) 2009 ip.access Ltd.
+#
+#  This program is free software; you can redistribute  it and/or modify it
+#  under  the terms of  the GNU General  Public License as published by the
+#  Free Software Foundation;  either version 2 of the  License, or (at your
+#  option) any later version.
+#
+#  9 Apr 2008 Created by Simon D Hughes.
+##############################################################################
+# Filename: 
+##############################################################################
+
+obj-$(CONFIG_IPACCESS_CPETD) += cpetd/
+obj-$(CONFIG_IPACCESS_DEBUG) += ipa_debug/
+obj-$(CONFIG_IPACCESS_LED) += leddriver/
+obj-$(CONFIG_IPACCESS_CRYPTO) += crypto/
diff -Naur pico_2.6.28/drivers/Kconfig ipa_2.6.28/drivers/Kconfig
--- pico_2.6.28/drivers/Kconfig	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/drivers/Kconfig	2011-04-26 14:51:35.000000000 +0100
@@ -1,3 +1,16 @@
+################################################################################
+# 
+# Copyright (c) 2009 ip.access Ltd.
+#
+#  This program is free software; you can redistribute  it and/or modify it
+#  under  the terms of  the GNU General  Public License as published by the
+#  Free Software Foundation;  either version 2 of the  License, or (at your
+#  option) any later version.
+#
+# 22 Apr 2009 Created by Simon D Hughes.
+##############################################################################
+# Filename: 
+##############################################################################
 # drivers/Kconfig
 
 menu "Device Drivers"
@@ -104,6 +117,8 @@
 
 source "drivers/picochip/Kconfig"
 
+source "drivers/ipa/Kconfig"
+
 source "drivers/auxdisplay/Kconfig"
 
 source "drivers/uio/Kconfig"
diff -Naur pico_2.6.28/drivers/Makefile ipa_2.6.28/drivers/Makefile
--- pico_2.6.28/drivers/Makefile	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/drivers/Makefile	2011-04-26 14:51:35.000000000 +0100
@@ -1,9 +1,22 @@
+################################################################################
+# 
+# Copyright (c) 2009 ip.access Ltd.
+#
+#  This program is free software; you can redistribute  it and/or modify it
+#  under  the terms of  the GNU General  Public License as published by the
+#  Free Software Foundation;  either version 2 of the  License, or (at your
+#  option) any later version.
+#
+# 22 Apr 2009 Created by Simon D Hughes.
 #
 # Makefile for the Linux kernel device drivers.
 #
 # 15 Sep 2000, Christoph Hellwig <hch@infradead.org>
 # Rewritten to use lists instead of if-statements.
 #
+##############################################################################
+# Filename: 
+##############################################################################
 
 obj-y				+= gpio/
 obj-$(CONFIG_PCI)		+= pci/
@@ -106,3 +119,4 @@
 obj-$(CONFIG_REGULATOR)		+= regulator/
 obj-$(CONFIG_STAGING)		+= staging/
 obj-y				+= perfcounters/
+obj-$(CONFIG_IPACCESS)		+= ipa/
diff -Naur pico_2.6.28/drivers/misc/pc202gpio.c ipa_2.6.28/drivers/misc/pc202gpio.c
--- pico_2.6.28/drivers/misc/pc202gpio.c	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/drivers/misc/pc202gpio.c	2011-04-26 14:51:35.000000000 +0100
@@ -37,6 +37,9 @@
 #include <mach/irqs.h>
 #include <mach/pc20x/gpio.h>
 #include <mach/pc20x/pc20x.h>
+#include <mach/reset.h>
+
+#define  PC202_RESET_OUTPUT_PIN  PC202_GPIO_PIN_ARM_1
 
 #define CARDNAME "pc202gpio"
 #define PC202_GPIO_MINOR    ( 243 )
@@ -2036,6 +2039,26 @@
     return 0;
 }
 
+/* A function that we pass to the kernel so that it can do a hard reset */
+static void pc202gpio_board_reset(char mode, void *cookie)
+{
+    /* RESET the board!! */
+    if (gpio_request( PC202_RESET_OUTPUT_PIN, "reset") < 0)
+    {
+        return;
+    }
+    
+    if (gpio_set_value( PC202_RESET_OUTPUT_PIN, 0 ) < 0)
+    {
+        return;
+    }
+    
+    if (gpio_direction_output( PC202_RESET_OUTPUT_PIN, 0 ) < 0)
+    {
+        return;
+    }
+}
+
 static int
 pc202gpio_init( void )
 {
@@ -2062,6 +2085,8 @@
         printk( KERN_ALERT "failed to wake up the AHB2PICO block.\n");
     }
 
+    register_reset_handler(pc202gpio_board_reset, NULL);
+
     ret = platform_driver_register( &pc202gpio_driver );
     if ( 0 != ret )
     {
@@ -2078,6 +2103,8 @@
 static void
 pc202gpio_exit( void )
 {
+    deregister_reset_handler(pc202gpio_board_reset, NULL);
+    
 #ifdef CONFIG_CONFIGFS_FS
     configfs_unregister_subsystem( &pc202gpio_subsys );
 #endif /* CONFIG_CONFIGFS_FS */
diff -Naur pico_2.6.28/drivers/misc/pc302gpio.c ipa_2.6.28/drivers/misc/pc302gpio.c
--- pico_2.6.28/drivers/misc/pc302gpio.c	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/drivers/misc/pc302gpio.c	2011-04-26 14:51:35.000000000 +0100
@@ -41,6 +41,9 @@
 #include <mach/pc302/pc302.h>
 #include <mach/pc302/vic.h>
 #include <mach/hardware.h>
+#include <mach/reset.h>
+ 
+#define  PC302_RESET_OUTPUT_PIN  PC302_GPIO_PIN_ARM_1
 
 #define CARDNAME "pc302gpio"
 #define PC302_GPIO_MINOR    ( 243 )
@@ -114,6 +117,7 @@
         ( _n * PC302_GPIO_SD_PIN_CONFIG_SPACING )
 
 /** Control source bit. */
+#define PC302_GPIO_SD_CONFIG_CS       ( 1 << 15 )
 #define PC302_GPIO_SD_CONFIG_CS_MASK ~( 1 << 15 )
 
 /** Analogue not digital bit. */
@@ -234,6 +238,20 @@
     /** Boolean flag for an input GPIO. */
     int is_input;
 
+    /** Boolean flag for a dynamic direction GPIO.  Previously the
+     * default state of a GPIO when it was requested, as recorded in
+     * the is_input flag, was always an output, even if the HW was
+     * actually set to be an input.  That made it possible for user
+     * code to request the pin, set an initial output value and then
+     * switch the direction to output.  When we add code to set the
+     * value of is_input from the actual HW state, it breaks code that
+     * uses that idiom, since writing a value to a GPIO with is_input
+     * set is EINVAL.  To work around this we introduce this flag that
+     * allows output values to be set between requesting a GPIO and the
+     * operation that sets the desired direction.
+     */
+    int direction_unset;
+
     /** Boolean flag for whether the pin is active. */
     int enabled;
 
@@ -320,6 +338,13 @@
 
 static int pc302gpio_pai_muxing( picoifGpioPinNum_t pin );
 
+static int
+pc302gpio_arm_get_direction( struct pc302gpio_pin_allocation *pin );
+
+static int
+pc302gpio_sd_get_direction( struct pc302gpio_pin_allocation *pin );
+
+
 #ifdef CONFIG_CONFIGFS_FS
 ssize_t	pc302gpio_cfs_show_attribute( struct config_item *,
                                       struct configfs_attribute *,
@@ -466,7 +491,6 @@
                         AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_LO ) );
     syscfg_update( AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_MASK, val );
     spin_unlock( &pc302gpio_priv.lock );
-
     return 0;
 }
 
@@ -547,6 +571,7 @@
     pc302gpio_pads[ pad_num ] = pc302gpio_alloc_pin( label );
     pc302gpio_pads[ pad_num ]->pin_num = gpio;
     pc302gpio_pads[ pad_num ]->pad = pad_num;
+    pc302gpio_pads[ pad_num ]->direction_unset = 1;
 
     pin = pc302gpio_find_pin( gpio );
     ptype = pc302gpio_get_pin_type( pin );
@@ -562,6 +587,28 @@
             ret = -EIO;
             goto out;
         }
+        
+        /* Read the initial direction from the HW */
+        ret = pc302gpio_sd_get_direction( pin );
+        if (ret < 0)
+        {
+            ret = -EIO;
+            goto out;
+        }
+
+        pc302gpio_pads[ pad_num ]->is_input = !!ret;
+    }
+    else if ( PC302_GPIO_ARM == ptype )
+    {
+        /* Read the initial direction from the HW */
+        ret = pc302gpio_arm_get_direction( pin );
+        if (ret < 0)
+        {
+            ret = -EIO;
+            goto out;
+        }
+        
+        pc302gpio_pads[ pad_num ]->is_input = !!ret;
     }
 
     ret = 0;
@@ -643,6 +690,7 @@
         goto out;
 
     pin->is_input = 1;
+    pin->direction_unset = 0;
     ret = pc302gpio_set_direction( pin, 1 );
 
 out:
@@ -682,11 +730,17 @@
         goto out;
 
     pin->is_input = 0;
+    pin->direction_unset = 0;
     ret = pc302gpio_set_direction( pin, 0 );
     if ( 0 != ret )
     {
         goto out;
     }
+    else if (value < 0)
+    {
+        /* Leave the value of the pin alone. */
+        ret = 0;
+    }
     else
     {
         ret = pc302gpio_set_value( pin, value );
@@ -868,6 +922,7 @@
         p->pad = -1;
         p->enabled = 0;
         p->is_input = 0;
+        p->direction_unset = 1;
         p->a_not_d = 0;
     }
 
@@ -964,7 +1019,11 @@
     u16 data;
     BUG_ON( NULL == pin );
 
-    if ( pin->is_input )
+    /* Allow client to set value before setting direction for
+     * the first time.  Client code does this to try to avoid
+     * glitches when the output is enabled in HW.
+     */
+    if ( pin->is_input && !pin->direction_unset )
         return -EINVAL;
 
     block_pin = pc302gpio_pin_to_block_pin( pin );
@@ -1024,12 +1083,25 @@
     u16 data;
     BUG_ON( NULL == pin );
 
-    if ( !pin->is_input && !pin->a_not_d )
-        return -EINVAL;
-
     block_pin = pc302gpio_pin_to_block_pin( pin );
 
-    if ( !pin->a_not_d )
+    if ( !pin->is_input && !pin->a_not_d )
+    {
+        /* Digital mode output.  Return the programmed output value.
+         * This is needed to allow an app to read the state of an
+         * output that's been set by another app.
+         */
+        ret = picoif_config_read( 0, PC302_AXI2PICO_CAEID,
+                                  PC302_GPIO_SD_OUTPUT_VAL_REG, 1, &data );
+        if ( 1 != ret )
+        {
+            printk( KERN_ALERT "failed to read SDGPIO output value reg\n" );
+            return -EIO;
+        }
+
+        return !!( data & ( 1 << block_pin ) );
+    }
+    else if ( !pin->a_not_d )
     {
         /* Digital mode */
         ret = picoif_config_read( 0, PC302_AXI2PICO_CAEID,
@@ -1074,8 +1146,7 @@
     u32 val;
     BUG_ON( NULL == pin );
 
-    if ( !pin->is_input )
-        return -EINVAL;
+    /* If the pin is an output then return the current output value */
 
     block_pin = pc302gpio_pin_to_block_pin( pin );
 
@@ -1095,7 +1166,7 @@
     }
     else
     {
-        printk( KERN_INFO "cannot set value of ARM GPIO pin (%d)\n",
+        printk( KERN_INFO "cannot get value of ARM GPIO pin (%d)\n",
                 block_pin );
         return -ENXIO;
     }
@@ -1168,10 +1239,80 @@
         return -EIO;
     }
 
+    /* If this is an input then there's no guarantee that the control reg will
+     * be updated before we try to read the input unless we perform a dummy data
+     * write.  See the register description, p7 of PC302 Programmers Guide
+     * Appendix S.  That involves reading the register and writing the same value
+     * back to avoid changing any output values.  Without this, the input is dead
+     * until someone writes to an output.
+     */
+    ret = picoif_config_read( 0, PC302_AXI2PICO_CAEID,
+                                PC302_GPIO_SD_OUTPUT_VAL_REG, 1, &data );
+    if ( 1 != ret )
+    {
+        printk( KERN_ALERT "failed to read SDGPIO output value reg\n" );
+        return -EIO;
+    }
+
+    ret = picoif_config_write( 0, PC302_AXI2PICO_CAEID,
+            PC302_GPIO_SD_OUTPUT_VAL_REG, 1, &data );
+    if ( 1 != ret )
+    {
+        printk( KERN_ALERT "failed to write output register for SDGPIO"
+                "pin %u\n", block_pin );
+        return -EIO;
+    }
     return 0;
 }
 
 /**
+ * Get the direction of an SD-GPIO pin.
+ *
+ * \param pin The pin to get the direction of.
+ * \return Returns 0 for output, 1 for input, less than zero on failure.
+ */
+static int
+pc302gpio_sd_get_direction( struct pc302gpio_pin_allocation *pin )
+{
+    int ret;
+    u16 data;
+    unsigned block_pin;
+
+    /* Check if the pin is controlled by the picoBus. */
+    block_pin = pc302gpio_pin_to_block_pin( pin );
+
+    ret = picoif_config_read( 0, PC302_AXI2PICO_CAEID,
+                              PC302_GPIO_SD_PIN_CONFIG( block_pin ),
+                              1, &data );
+    if ( 1 != ret )
+    {
+        printk( KERN_ALERT "failed to read config register for SDGPIO \
+                pin %u\n", block_pin );
+        return -EIO;
+    }
+
+    if (PC302_GPIO_SD_CONFIG_CS & data)
+    {
+        /* If controlled by picoBus then essentially an input for us. */
+        return 1;
+    }
+
+    /* Read the direction bit of the configuration bus programming. */
+    ret = picoif_config_read( 0, PC302_AXI2PICO_CAEID,
+                              PC302_GPIO_SD_CONTROL_VAL_REG, 1, &data );
+    if ( 1 != ret )
+    {
+        printk( KERN_ALERT "failed to read SDGPIO control value register\n" );
+        return -EIO;
+    }
+
+    if ( data & ( 1 << block_pin ) )
+        return 0;
+    else
+        return 1;
+}
+
+/**
  * Set the direction of an ARM GPIO pin.
  *
  * \param pin The pin to set the direction of.
@@ -1231,6 +1372,55 @@
 }
 
 /**
+ * Get the direction of an ARM GPIO pin.
+ *
+ * \param pin The pin to get the direction of.
+ * \return Returns 0 for output, 1 for input, less than zero on failure.
+ */
+static int
+pc302gpio_arm_get_direction( struct pc302gpio_pin_allocation *pin )
+{
+    unsigned block_pin;
+    void __iomem *port_ddr;
+    void __iomem *port_cr;
+    u32 val;
+    u32 pin_offset;
+
+    /* Get the pin number. */
+    block_pin = pc302gpio_pin_to_block_pin( pin );
+
+    if ( block_pin >= PC302_GPIO_PIN_ARM_0 &&
+         block_pin <= PC302_GPIO_PIN_ARM_7 )
+    {
+        port_ddr = pc302gpio_priv.mem_region + GPIO_SW_PORT_A_DDR_REG_OFFSET;
+        port_cr = pc302gpio_priv.mem_region + GPIO_SW_PORT_A_CTL_REG_OFFSET;
+        pin_offset = block_pin;
+    }
+    else if ( block_pin >= ( PC302_GPIO_PIN_ARM_8 -
+                             PC302_ARM_GPIO_PORT_WIDTH ) &&
+              block_pin <= ( PC302_GPIO_PIN_ARM_15 -
+                             PC302_ARM_GPIO_PORT_WIDTH ) )
+    {
+        port_ddr = pc302gpio_priv.mem_region + GPIO_SW_PORT_B_DDR_REG_OFFSET;
+        port_cr = pc302gpio_priv.mem_region + GPIO_SW_PORT_B_CTL_REG_OFFSET;
+        pin_offset = block_pin - PC302_ARM_GPIO_PORT_WIDTH;
+    }
+    else
+    {
+        printk( KERN_INFO "cannot get direction of ARM GPIO pin (%d)\n",
+                block_pin );
+        return -ENXIO;
+    }
+
+    /* Get the direction register (a bit set indicates output). */
+    val = ioread32( port_ddr );
+    if ( val & ( 1 << pin_offset ) )
+        return 0;
+    else
+        return 1;
+}
+
+/**
  * Set the value of an output ARM GPIO pin.
  *
  * \param pin The pin to set the value of.
@@ -1247,7 +1437,11 @@
     void __iomem *port_dr;
     BUG_ON( NULL == pin );
 
-    if ( pin->is_input )
+    /* Allow client to set value before setting direction for
+     * the first time.  Client code does this to try to avoid
+     * glitches when the output is enabled in HW.
+     */
+    if ( pin->is_input && !pin->direction_unset )
         return -EINVAL;
 
     block_pin = pc302gpio_pin_to_block_pin( pin );
@@ -1307,7 +1501,10 @@
         ret = -EINVAL;
 
     if ( !ret )
+    {
         pin->is_input = !!input;
+        pin->direction_unset = 0;
+    }
 
     return ret;
 }
@@ -1760,6 +1957,7 @@
         goto out;
 
     pin->phys_pin->is_input = simple_strtoul( buf, NULL, 10 );
+    pin->phys_pin->direction_unset = 0;
     pc302gpio_set_direction( pin->phys_pin, pin->phys_pin->is_input );
 
     ret = strlen( buf );
@@ -2439,7 +2637,7 @@
             if ( PICOGPIO_INPUT == op.value )
                 ret = gpio_direction_input( op.pin );
             else if ( PICOGPIO_OUTPUT == op.value )
-                ret = gpio_direction_output( op.pin, 0 );
+                ret = gpio_direction_output( op.pin, -1 );
             else
                 ret = -EINVAL;
             break;
@@ -2536,6 +2734,10 @@
 #endif
 
     ret = misc_register( &pc302gpio_priv.dev );
+    if (ret)
+    {
+        goto remap_failed;
+    }
 
     return ret;
 
@@ -2559,6 +2761,27 @@
     return 0;
 }
 
+/* A function that we pass to the kernel so that it can do a hard reset */
+static void pc302gpio_board_reset(char mode, void *cookie)
+{
+    /* RESET the board!! */
+    if (gpio_request( PC302_RESET_OUTPUT_PIN, "reset") < 0)
+    {
+        return;
+    }
+    
+    if (gpio_set_value( PC302_RESET_OUTPUT_PIN, 0 ) < 0)
+    {
+        return;
+    }
+    
+    if (gpio_direction_output( PC302_RESET_OUTPUT_PIN, 0 ) < 0)
+    {
+        return;
+    }
+    
+}
+
 static int
 pc302gpio_init( void )
 {
@@ -2589,6 +2812,8 @@
         printk( KERN_ALERT "failed to wake up the AXI2PICO block.\n");
     }
 
+    register_reset_handler(pc302gpio_board_reset, NULL);
+
     ret = platform_driver_register( &pc302gpio_driver );
     if ( 0 != ret )
     {
@@ -2606,6 +2831,8 @@
 static void
 pc302gpio_exit( void )
 {
+    deregister_reset_handler(pc302gpio_board_reset, NULL);
+    
 #ifdef CONFIG_CONFIGFS_FS
     configfs_unregister_subsystem( &pc302gpio_subsys );
 #endif /* CONFIG_CONFIGFS_FS */
diff -Naur pico_2.6.28/drivers/mtd/chips/cfi_cmdset_0001.c ipa_2.6.28/drivers/mtd/chips/cfi_cmdset_0001.c
--- pico_2.6.28/drivers/mtd/chips/cfi_cmdset_0001.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/drivers/mtd/chips/cfi_cmdset_0001.c	2011-04-26 14:51:35.000000000 +0100
@@ -43,14 +43,17 @@
 // debugging, turns off buffer write mode if set to 1
 #define FORCE_WORD_WRITE 0
 
-#define MANUFACTURER_INTEL	0x0089
+/* Intel chips */
 #define I82802AB	0x00ad
 #define I82802AC	0x00ac
-#define MANUFACTURER_ST         0x0020
+#define PF38F4476	0x881c
+/* STMicroelectronics chips */
 #define M50LPW080       0x002F
 #define M50FLW080A	0x0080
 #define M50FLW080B	0x0081
+/* Atmel chips */
 #define AT49BV640D	0x02de
+#define AT49BV640DT	0x02db
 
 static int cfi_intelext_read (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
 static int cfi_intelext_write_words(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
@@ -198,6 +201,16 @@
 	cfi->cfiq->BufWriteTimeoutMax = 0;
 }
 
+static void fixup_at49bv640dx_lock(struct mtd_info *mtd, void *param)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	struct cfi_pri_intelext *cfip = cfi->cmdset_priv;
+
+	cfip->FeatureSupport |= (1 << 5);
+	mtd->flags |= MTD_POWERUP_LOCK;
+}
+
 #ifdef CMDSET0001_DISABLE_ERASE_SUSPEND_ON_WRITE
 /* Some Intel Strata Flash prior to FPO revision C has bugs in this area */
 static void fixup_intel_strataflash(struct mtd_info *mtd, void* param)
@@ -282,6 +295,8 @@
 
 static struct cfi_fixup cfi_fixup_table[] = {
 	{ CFI_MFR_ATMEL, CFI_ID_ANY, fixup_convert_atmel_pri, NULL },
+	{ CFI_MFR_ATMEL, AT49BV640D, fixup_at49bv640dx_lock, NULL },
+	{ CFI_MFR_ATMEL, AT49BV640DT, fixup_at49bv640dx_lock, NULL },
 #ifdef CMDSET0001_DISABLE_ERASE_SUSPEND_ON_WRITE
 	{ CFI_MFR_ANY, CFI_ID_ANY, fixup_intel_strataflash, NULL },
 #endif
@@ -293,16 +308,16 @@
 #endif
 	{ CFI_MFR_ST, 0x00ba, /* M28W320CT */ fixup_st_m28w320ct, NULL },
 	{ CFI_MFR_ST, 0x00bb, /* M28W320CB */ fixup_st_m28w320cb, NULL },
-	{ MANUFACTURER_INTEL, CFI_ID_ANY, fixup_unlock_powerup_lock, NULL, },
+	{ CFI_MFR_INTEL, CFI_ID_ANY, fixup_unlock_powerup_lock, NULL, },
 	{ 0, 0, NULL, NULL }
 };
 
 static struct cfi_fixup jedec_fixup_table[] = {
-	{ MANUFACTURER_INTEL, I82802AB,   fixup_use_fwh_lock, NULL, },
-	{ MANUFACTURER_INTEL, I82802AC,   fixup_use_fwh_lock, NULL, },
-	{ MANUFACTURER_ST,    M50LPW080,  fixup_use_fwh_lock, NULL, },
-	{ MANUFACTURER_ST,    M50FLW080A, fixup_use_fwh_lock, NULL, },
-	{ MANUFACTURER_ST,    M50FLW080B, fixup_use_fwh_lock, NULL, },
+	{ CFI_MFR_INTEL, I82802AB,   fixup_use_fwh_lock, NULL, },
+	{ CFI_MFR_INTEL, I82802AC,   fixup_use_fwh_lock, NULL, },
+	{ CFI_MFR_ST,    M50LPW080,  fixup_use_fwh_lock, NULL, },
+	{ CFI_MFR_ST,    M50FLW080A, fixup_use_fwh_lock, NULL, },
+	{ CFI_MFR_ST,    M50FLW080B, fixup_use_fwh_lock, NULL, },
 	{ 0, 0, NULL, NULL }
 };
 static struct cfi_fixup fixup_table[] = {
@@ -315,10 +330,20 @@
 	{ 0, 0, NULL, NULL }
 };
 
+static void cfi_fixup_major_minor(struct cfi_private *cfi,
+						struct cfi_pri_intelext *extp)
+{
+	if (cfi->mfr == CFI_MFR_INTEL &&
+			cfi->id == PF38F4476 && extp->MinorVersion == '3')
+		extp->MinorVersion = '1';
+}
+
 static inline struct cfi_pri_intelext *
 read_pri_intelext(struct map_info *map, __u16 adr)
 {
+	struct cfi_private *cfi = map->fldrv_priv;
 	struct cfi_pri_intelext *extp;
+	unsigned int extra_size = 0;
 	unsigned int extp_size = sizeof(*extp);
 
  again:
@@ -326,6 +351,8 @@
 	if (!extp)
 		return NULL;
 
+	cfi_fixup_major_minor(cfi, extp);
+
 	if (extp->MajorVersion != '1' ||
 	    (extp->MinorVersion < '0' || extp->MinorVersion > '5')) {
 		printk(KERN_ERR "  Unknown Intel/Sharp Extended Query "
@@ -340,19 +367,24 @@
 	extp->BlkStatusRegMask = le16_to_cpu(extp->BlkStatusRegMask);
 	extp->ProtRegAddr = le16_to_cpu(extp->ProtRegAddr);
 
-	if (extp->MajorVersion == '1' && extp->MinorVersion >= '3') {
-		unsigned int extra_size = 0;
-		int nb_parts, i;
+	if (extp->MinorVersion >= '0') {
+		extra_size = 0;
 
 		/* Protection Register info */
 		extra_size += (extp->NumProtectionFields - 1) *
 			      sizeof(struct cfi_intelext_otpinfo);
+	}
 
+	if (extp->MinorVersion >= '1') {
 		/* Burst Read info */
 		extra_size += 2;
 		if (extp_size < sizeof(*extp) + extra_size)
 			goto need_more;
-		extra_size += extp->extra[extra_size-1];
+		extra_size += extp->extra[extra_size - 1];
+	}
+
+	if (extp->MinorVersion >= '3') {
+		int nb_parts, i;
 
 		/* Number of hardware-partitions */
 		extra_size += 1;
@@ -583,10 +615,8 @@
 	return mtd;
 
  setup_err:
-	if(mtd) {
-		kfree(mtd->eraseregions);
-		kfree(mtd);
-	}
+	kfree(mtd->eraseregions);
+	kfree(mtd);
 	kfree(cfi->cmdset_priv);
 	return NULL;
 }
@@ -695,8 +725,7 @@
 				/* those should be reset too since
 				   they create memory references. */
 				init_waitqueue_head(&chip->wq);
-				spin_lock_init(&chip->_spinlock);
-				chip->mutex = &chip->_spinlock;
+				mutex_init(&chip->mutex);
 				chip++;
 			}
 		}
@@ -742,9 +771,9 @@
 			if (chip->priv && map_word_andequal(map, status, status_PWS, status_PWS))
 				break;
 
-			spin_unlock(chip->mutex);
+			mutex_unlock(&chip->mutex);
 			cfi_udelay(1);
-			spin_lock(chip->mutex);
+			mutex_lock(&chip->mutex);
 			/* Someone else might have been playing with it. */
 			return -EAGAIN;
 		}
@@ -791,9 +820,9 @@
 				return -EIO;
 			}
 
-			spin_unlock(chip->mutex);
+			mutex_unlock(&chip->mutex);
 			cfi_udelay(1);
-			spin_lock(chip->mutex);
+			mutex_lock(&chip->mutex);
 			/* Nobody will touch it while it's in state FL_ERASE_SUSPENDING.
 			   So we can just loop here. */
 		}
@@ -820,10 +849,10 @@
 	sleep:
 		set_current_state(TASK_UNINTERRUPTIBLE);
 		add_wait_queue(&chip->wq, &wait);
-		spin_unlock(chip->mutex);
+		mutex_unlock(&chip->mutex);
 		schedule();
 		remove_wait_queue(&chip->wq, &wait);
-		spin_lock(chip->mutex);
+		mutex_lock(&chip->mutex);
 		return -EAGAIN;
 	}
 }
@@ -869,20 +898,20 @@
 			 * it'll happily send us to sleep.  In any case, when
 			 * get_chip returns success we're clear to go ahead.
 			 */
-			ret = spin_trylock(contender->mutex);
+			ret = mutex_trylock(&contender->mutex);
 			spin_unlock(&shared->lock);
 			if (!ret)
 				goto retry;
-			spin_unlock(chip->mutex);
+			mutex_unlock(&chip->mutex);
 			ret = chip_ready(map, contender, contender->start, mode);
-			spin_lock(chip->mutex);
+			mutex_lock(&chip->mutex);
 
 			if (ret == -EAGAIN) {
-				spin_unlock(contender->mutex);
+				mutex_unlock(&contender->mutex);
 				goto retry;
 			}
 			if (ret) {
-				spin_unlock(contender->mutex);
+				mutex_unlock(&contender->mutex);
 				return ret;
 			}
 			spin_lock(&shared->lock);
@@ -891,10 +920,10 @@
 			 * in FL_SYNCING state. Put contender and retry. */
 			if (chip->state == FL_SYNCING) {
 				put_chip(map, contender, contender->start);
-				spin_unlock(contender->mutex);
+				mutex_unlock(&contender->mutex);
 				goto retry;
 			}
-			spin_unlock(contender->mutex);
+			mutex_unlock(&contender->mutex);
 		}
 
 		/* Check if we already have suspended erase
@@ -904,10 +933,10 @@
 			spin_unlock(&shared->lock);
 			set_current_state(TASK_UNINTERRUPTIBLE);
 			add_wait_queue(&chip->wq, &wait);
-			spin_unlock(chip->mutex);
+			mutex_unlock(&chip->mutex);
 			schedule();
 			remove_wait_queue(&chip->wq, &wait);
-			spin_lock(chip->mutex);
+			mutex_lock(&chip->mutex);
 			goto retry;
 		}
 
@@ -937,12 +966,12 @@
 			if (shared->writing && shared->writing != chip) {
 				/* give back ownership to who we loaned it from */
 				struct flchip *loaner = shared->writing;
-				spin_lock(loaner->mutex);
+				mutex_lock(&loaner->mutex);
 				spin_unlock(&shared->lock);
-				spin_unlock(chip->mutex);
+				mutex_unlock(&chip->mutex);
 				put_chip(map, loaner, loaner->start);
-				spin_lock(chip->mutex);
-				spin_unlock(loaner->mutex);
+				mutex_lock(&chip->mutex);
+				mutex_unlock(&loaner->mutex);
 				wake_up(&chip->wq);
 				return;
 			}
@@ -1112,7 +1141,7 @@
 			(void) map_read(map, adr);
 			xip_iprefetch();
 			local_irq_enable();
-			spin_unlock(chip->mutex);
+			mutex_unlock(&chip->mutex);
 			xip_iprefetch();
 			cond_resched();
 
@@ -1122,15 +1151,15 @@
 			 * a suspended erase state.  If so let's wait
 			 * until it's done.
 			 */
-			spin_lock(chip->mutex);
+			mutex_lock(&chip->mutex);
 			while (chip->state != newstate) {
 				DECLARE_WAITQUEUE(wait, current);
 				set_current_state(TASK_UNINTERRUPTIBLE);
 				add_wait_queue(&chip->wq, &wait);
-				spin_unlock(chip->mutex);
+				mutex_unlock(&chip->mutex);
 				schedule();
 				remove_wait_queue(&chip->wq, &wait);
-				spin_lock(chip->mutex);
+				mutex_lock(&chip->mutex);
 			}
 			/* Disallow XIP again */
 			local_irq_disable();
@@ -1186,10 +1215,10 @@
 	int chip_state = chip->state;
 	unsigned int timeo, sleep_time, reset_timeo;
 
-	spin_unlock(chip->mutex);
+	mutex_unlock(&chip->mutex);
 	if (inval_len)
 		INVALIDATE_CACHED_RANGE(map, inval_adr, inval_len);
-	spin_lock(chip->mutex);
+	mutex_lock(&chip->mutex);
 
 	timeo = chip_op_time_max;
 	if (!timeo)
@@ -1209,7 +1238,7 @@
 		}
 
 		/* OK Still waiting. Drop the lock, wait a while and retry. */
-		spin_unlock(chip->mutex);
+		mutex_unlock(&chip->mutex);
 		if (sleep_time >= 1000000/HZ) {
 			/*
 			 * Half of the normal delay still remaining
@@ -1224,22 +1253,26 @@
 			cond_resched();
 			timeo--;
 		}
-		spin_lock(chip->mutex);
+		mutex_lock(&chip->mutex);
 
 		while (chip->state != chip_state) {
 			/* Someone's suspended the operation: sleep */
 			DECLARE_WAITQUEUE(wait, current);
 			set_current_state(TASK_UNINTERRUPTIBLE);
 			add_wait_queue(&chip->wq, &wait);
-			spin_unlock(chip->mutex);
+			mutex_unlock(&chip->mutex);
 			schedule();
 			remove_wait_queue(&chip->wq, &wait);
-			spin_lock(chip->mutex);
+			mutex_lock(&chip->mutex);
 		}
-		if (chip->erase_suspended || chip->write_suspended)  {
-			/* Suspend has occured while sleep: reset timeout */
+		if (chip->erase_suspended && chip_state == FL_ERASING)  {
+			/* Erase suspend occured while sleep: reset timeout */
 			timeo = reset_timeo;
 			chip->erase_suspended = 0;
+		}
+		if (chip->write_suspended && chip_state == FL_WRITING)  {
+			/* Write suspend occured while sleep: reset timeout */
+			timeo = reset_timeo;
 			chip->write_suspended = 0;
 		}
 	}
@@ -1266,7 +1299,7 @@
 	/* Ensure cmd read/writes are aligned. */
 	cmd_addr = adr & ~(map_bankwidth(map)-1);
 
-	spin_lock(chip->mutex);
+	mutex_lock(&chip->mutex);
 
 	ret = get_chip(map, chip, cmd_addr, FL_POINT);
 
@@ -1277,7 +1310,7 @@
 		chip->state = FL_POINT;
 		chip->ref_point_counter++;
 	}
-	spin_unlock(chip->mutex);
+	mutex_unlock(&chip->mutex);
 
 	return ret;
 }
@@ -1362,7 +1395,7 @@
 		else
 			thislen = len;
 
-		spin_lock(chip->mutex);
+		mutex_lock(&chip->mutex);
 		if (chip->state == FL_POINT) {
 			chip->ref_point_counter--;
 			if(chip->ref_point_counter == 0)
@@ -1371,7 +1404,7 @@
 			printk(KERN_ERR "%s: Warning: unpoint called on non pointed region\n", map->name); /* Should this give an error? */
 
 		put_chip(map, chip, chip->start);
-		spin_unlock(chip->mutex);
+		mutex_unlock(&chip->mutex);
 
 		len -= thislen;
 		ofs = 0;
@@ -1390,10 +1423,10 @@
 	/* Ensure cmd read/writes are aligned. */
 	cmd_addr = adr & ~(map_bankwidth(map)-1);
 
-	spin_lock(chip->mutex);
+	mutex_lock(&chip->mutex);
 	ret = get_chip(map, chip, cmd_addr, FL_READY);
 	if (ret) {
-		spin_unlock(chip->mutex);
+		mutex_unlock(&chip->mutex);
 		return ret;
 	}
 
@@ -1407,7 +1440,7 @@
 
 	put_chip(map, chip, cmd_addr);
 
-	spin_unlock(chip->mutex);
+	mutex_unlock(&chip->mutex);
 	return 0;
 }
 
@@ -1470,10 +1503,10 @@
 		return -EINVAL;
 	}
 
-	spin_lock(chip->mutex);
+	mutex_lock(&chip->mutex);
 	ret = get_chip(map, chip, adr, mode);
 	if (ret) {
-		spin_unlock(chip->mutex);
+		mutex_unlock(&chip->mutex);
 		return ret;
 	}
 
@@ -1519,7 +1552,7 @@
 
 	xip_enable(map, chip, adr);
  out:	put_chip(map, chip, adr);
-	spin_unlock(chip->mutex);
+	mutex_unlock(&chip->mutex);
 	return ret;
 }
 
@@ -1628,10 +1661,10 @@
 	/* Let's determine this according to the interleave only once */
 	write_cmd = (cfi->cfiq->P_ID != 0x0200) ? CMD(0xe8) : CMD(0xe9);
 
-	spin_lock(chip->mutex);
+	mutex_lock(&chip->mutex);
 	ret = get_chip(map, chip, cmd_adr, FL_WRITING);
 	if (ret) {
-		spin_unlock(chip->mutex);
+		mutex_unlock(&chip->mutex);
 		return ret;
 	}
 
@@ -1762,7 +1795,7 @@
 
 	xip_enable(map, chip, cmd_adr);
  out:	put_chip(map, chip, cmd_adr);
-	spin_unlock(chip->mutex);
+	mutex_unlock(&chip->mutex);
 	return ret;
 }
 
@@ -1841,10 +1874,10 @@
 	adr += chip->start;
 
  retry:
-	spin_lock(chip->mutex);
+	mutex_lock(&chip->mutex);
 	ret = get_chip(map, chip, adr, FL_ERASING);
 	if (ret) {
-		spin_unlock(chip->mutex);
+		mutex_unlock(&chip->mutex);
 		return ret;
 	}
 
@@ -1900,7 +1933,7 @@
 		} else if (chipstatus & 0x20 && retries--) {
 			printk(KERN_DEBUG "block erase failed at 0x%08lx: status 0x%lx. Retrying...\n", adr, chipstatus);
 			put_chip(map, chip, adr);
-			spin_unlock(chip->mutex);
+			mutex_unlock(&chip->mutex);
 			goto retry;
 		} else {
 			printk(KERN_ERR "%s: block erase failed at 0x%08lx (status 0x%lx)\n", map->name, adr, chipstatus);
@@ -1912,7 +1945,7 @@
 
 	xip_enable(map, chip, adr);
  out:	put_chip(map, chip, adr);
-	spin_unlock(chip->mutex);
+	mutex_unlock(&chip->mutex);
 	return ret;
 }
 
@@ -1945,7 +1978,7 @@
 	for (i=0; !ret && i<cfi->numchips; i++) {
 		chip = &cfi->chips[i];
 
-		spin_lock(chip->mutex);
+		mutex_lock(&chip->mutex);
 		ret = get_chip(map, chip, chip->start, FL_SYNCING);
 
 		if (!ret) {
@@ -1956,7 +1989,7 @@
 			 * with the chip now anyway.
 			 */
 		}
-		spin_unlock(chip->mutex);
+		mutex_unlock(&chip->mutex);
 	}
 
 	/* Unlock the chips again */
@@ -1964,14 +1997,14 @@
 	for (i--; i >=0; i--) {
 		chip = &cfi->chips[i];
 
-		spin_lock(chip->mutex);
+		mutex_lock(&chip->mutex);
 
 		if (chip->state == FL_SYNCING) {
 			chip->state = chip->oldstate;
 			chip->oldstate = FL_READY;
 			wake_up(&chip->wq);
 		}
-		spin_unlock(chip->mutex);
+		mutex_unlock(&chip->mutex);
 	}
 }
 
@@ -2017,10 +2050,10 @@
 
 	adr += chip->start;
 
-	spin_lock(chip->mutex);
+	mutex_lock(&chip->mutex);
 	ret = get_chip(map, chip, adr, FL_LOCKING);
 	if (ret) {
-		spin_unlock(chip->mutex);
+		mutex_unlock(&chip->mutex);
 		return ret;
 	}
 
@@ -2054,7 +2087,7 @@
 
 	xip_enable(map, chip, adr);
 out:	put_chip(map, chip, adr);
-	spin_unlock(chip->mutex);
+	mutex_unlock(&chip->mutex);
 	return ret;
 }
 
@@ -2119,10 +2152,10 @@
 	struct cfi_private *cfi = map->fldrv_priv;
 	int ret;
 
-	spin_lock(chip->mutex);
+	mutex_lock(&chip->mutex);
 	ret = get_chip(map, chip, chip->start, FL_JEDEC_QUERY);
 	if (ret) {
-		spin_unlock(chip->mutex);
+		mutex_unlock(&chip->mutex);
 		return ret;
 	}
 
@@ -2141,7 +2174,7 @@
 	INVALIDATE_CACHED_RANGE(map, chip->start + offset, size);
 
 	put_chip(map, chip, chip->start);
-	spin_unlock(chip->mutex);
+	mutex_unlock(&chip->mutex);
 	return 0;
 }
 
@@ -2213,7 +2246,7 @@
 
 	/* Some chips have OTP located in the _top_ partition only.
 	   For example: Intel 28F256L18T (T means top-parameter device) */
-	if (cfi->mfr == MANUFACTURER_INTEL) {
+	if (cfi->mfr == CFI_MFR_INTEL) {
 		switch (cfi->id) {
 		case 0x880b:
 		case 0x880c:
@@ -2416,7 +2449,7 @@
 	for (i=0; !ret && i<cfi->numchips; i++) {
 		chip = &cfi->chips[i];
 
-		spin_lock(chip->mutex);
+		mutex_lock(&chip->mutex);
 
 		switch (chip->state) {
 		case FL_READY:
@@ -2448,7 +2481,7 @@
 		case FL_PM_SUSPENDED:
 			break;
 		}
-		spin_unlock(chip->mutex);
+		mutex_unlock(&chip->mutex);
 	}
 
 	/* Unlock the chips again */
@@ -2457,7 +2490,7 @@
 		for (i--; i >=0; i--) {
 			chip = &cfi->chips[i];
 
-			spin_lock(chip->mutex);
+			mutex_lock(&chip->mutex);
 
 			if (chip->state == FL_PM_SUSPENDED) {
 				/* No need to force it into a known state here,
@@ -2467,7 +2500,7 @@
 				chip->oldstate = FL_READY;
 				wake_up(&chip->wq);
 			}
-			spin_unlock(chip->mutex);
+			mutex_unlock(&chip->mutex);
 		}
 	}
 
@@ -2508,7 +2541,7 @@
 
 		chip = &cfi->chips[i];
 
-		spin_lock(chip->mutex);
+		mutex_lock(&chip->mutex);
 
 		/* Go to known state. Chip may have been power cycled */
 		if (chip->state == FL_PM_SUSPENDED) {
@@ -2517,7 +2550,7 @@
 			wake_up(&chip->wq);
 		}
 
-		spin_unlock(chip->mutex);
+		mutex_unlock(&chip->mutex);
 	}
 
 	if ((mtd->flags & MTD_POWERUP_LOCK)
@@ -2537,13 +2570,14 @@
 		/* force the completion of any ongoing operation
 		   and switch to array mode so any bootloader in
 		   flash is accessible for soft reboot. */
-		spin_lock(chip->mutex);
+		mutex_lock(&chip->mutex);
 		ret = get_chip(map, chip, chip->start, FL_SHUTDOWN);
 		if (!ret) {
 			map_write(map, CMD(0xff), chip->start);
 			chip->state = FL_SHUTDOWN;
+			put_chip(map, chip, chip->start);
 		}
-		spin_unlock(chip->mutex);
+		mutex_unlock(&chip->mutex);
 	}
 
 	return 0;
diff -Naur pico_2.6.28/drivers/mtd/chips/cfi_cmdset_0002.c ipa_2.6.28/drivers/mtd/chips/cfi_cmdset_0002.c
--- pico_2.6.28/drivers/mtd/chips/cfi_cmdset_0002.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/drivers/mtd/chips/cfi_cmdset_0002.c	2011-04-26 14:53:04.000000000 +0100
@@ -32,6 +32,7 @@
 #include <linux/slab.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
+#include <linux/reboot.h>
 #include <linux/mtd/compatmac.h>
 #include <linux/mtd/map.h>
 #include <linux/mtd/mtd.h>
@@ -43,10 +44,6 @@
 
 #define MAX_WORD_RETRIES 3
 
-#define MANUFACTURER_AMD	0x0001
-#define MANUFACTURER_ATMEL	0x001F
-#define MANUFACTURER_MACRONIX	0x00C2
-#define MANUFACTURER_SST	0x00BF
 #define SST49LF004B	        0x0060
 #define SST49LF040B	        0x0050
 #define SST49LF008A		0x005a
@@ -60,6 +57,7 @@
 static void cfi_amdstd_sync (struct mtd_info *);
 static int cfi_amdstd_suspend (struct mtd_info *);
 static void cfi_amdstd_resume (struct mtd_info *);
+static int cfi_amdstd_reboot(struct notifier_block *, unsigned long, void *);
 static int cfi_amdstd_secsi_read (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
 
 static void cfi_amdstd_destroy(struct mtd_info *);
@@ -168,7 +166,7 @@
 			 * This reduces the risk of false detection due to
 			 * the 8-bit device ID.
 			 */
-			(cfi->mfr == MANUFACTURER_MACRONIX)) {
+			(cfi->mfr == CFI_MFR_MACRONIX)) {
 			DEBUG(MTD_DEBUG_LEVEL1,
 				"%s: Macronix MX29LV400C with bottom boot block"
 				" detected\n", map->name);
@@ -260,6 +258,42 @@
 	mtd->flags |= MTD_POWERUP_LOCK;
 }
 
+static void fixup_old_sst_eraseregion(struct mtd_info *mtd)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+
+	/*
+	 * These flashes report two seperate eraseblock regions based on the
+	 * sector_erase-size and block_erase-size, although they both operate on the
+	 * same memory. This is not allowed according to CFI, so we just pick the
+	 * sector_erase-size.
+	 */
+	cfi->cfiq->NumEraseRegions = 1;
+}
+
+static void fixup_sst39vf(struct mtd_info *mtd, void *param)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+
+	fixup_old_sst_eraseregion(mtd);
+
+	cfi->addr_unlock1 = 0x5555;
+	cfi->addr_unlock2 = 0x2AAA;
+}
+
+static void fixup_sst39vf_rev_b(struct mtd_info *mtd, void *param)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+
+	fixup_old_sst_eraseregion(mtd);
+
+	cfi->addr_unlock1 = 0x555;
+	cfi->addr_unlock2 = 0x2AA;
+}
+
 static void fixup_s29gl064n_sectors(struct mtd_info *mtd, void *param)
 {
 	struct map_info *map = mtd->priv;
@@ -282,11 +316,24 @@
 	}
 }
 
+/* Used to fix CFI-Tables of chips without Extended Query Tables */
+static struct cfi_fixup cfi_nopri_fixup_table[] = {
+	{ CFI_MFR_SST, 0x234A, fixup_sst39vf, NULL, }, // SST39VF1602
+	{ CFI_MFR_SST, 0x234B, fixup_sst39vf, NULL, }, // SST39VF1601
+	{ CFI_MFR_SST, 0x235A, fixup_sst39vf, NULL, }, // SST39VF3202
+	{ CFI_MFR_SST, 0x235B, fixup_sst39vf, NULL, }, // SST39VF3201
+	{ CFI_MFR_SST, 0x235C, fixup_sst39vf_rev_b, NULL, }, // SST39VF3202B
+	{ CFI_MFR_SST, 0x235D, fixup_sst39vf_rev_b, NULL, }, // SST39VF3201B
+	{ CFI_MFR_SST, 0x236C, fixup_sst39vf_rev_b, NULL, }, // SST39VF6402B
+	{ CFI_MFR_SST, 0x236D, fixup_sst39vf_rev_b, NULL, }, // SST39VF6401B
+	{ 0, 0, NULL, NULL }
+};
+
 static struct cfi_fixup cfi_fixup_table[] = {
 	{ CFI_MFR_ATMEL, CFI_ID_ANY, fixup_convert_atmel_pri, NULL },
 #ifdef AMD_BOOTLOC_BUG
 	{ CFI_MFR_AMD, CFI_ID_ANY, fixup_amd_bootblock, NULL },
-	{ MANUFACTURER_MACRONIX, CFI_ID_ANY, fixup_amd_bootblock, NULL },
+	{ CFI_MFR_MACRONIX, CFI_ID_ANY, fixup_amd_bootblock, NULL },
 #endif
 	{ CFI_MFR_AMD, 0x0050, fixup_use_secsi, NULL, },
 	{ CFI_MFR_AMD, 0x0053, fixup_use_secsi, NULL, },
@@ -304,9 +351,9 @@
 	{ 0, 0, NULL, NULL }
 };
 static struct cfi_fixup jedec_fixup_table[] = {
-	{ MANUFACTURER_SST, SST49LF004B, fixup_use_fwh_lock, NULL, },
-	{ MANUFACTURER_SST, SST49LF040B, fixup_use_fwh_lock, NULL, },
-	{ MANUFACTURER_SST, SST49LF008A, fixup_use_fwh_lock, NULL, },
+	{ CFI_MFR_SST, SST49LF004B, fixup_use_fwh_lock, NULL, },
+	{ CFI_MFR_SST, SST49LF040B, fixup_use_fwh_lock, NULL, },
+	{ CFI_MFR_SST, SST49LF008A, fixup_use_fwh_lock, NULL, },
 	{ 0, 0, NULL, NULL }
 };
 
@@ -322,6 +369,14 @@
 };
 
 
+static void cfi_fixup_major_minor(struct cfi_private *cfi,
+				  struct cfi_pri_amdstd *extp)
+{
+	if (cfi->mfr == CFI_MFR_SAMSUNG && cfi->id == 0x257e &&
+	    extp->MajorVersion == '0')
+		extp->MajorVersion = '1';
+}
+
 struct mtd_info *cfi_cmdset_0002(struct map_info *map, int primary)
 {
 	struct cfi_private *cfi = map->fldrv_priv;
@@ -347,65 +402,72 @@
 	mtd->name    = map->name;
 	mtd->writesize = 1;
 
+	mtd->reboot_notifier.notifier_call = cfi_amdstd_reboot;
+
 	if (cfi->cfi_mode==CFI_MODE_CFI){
 		unsigned char bootloc;
-		/*
-		 * It's a real CFI chip, not one for which the probe
-		 * routine faked a CFI structure. So we read the feature
-		 * table from it.
-		 */
 		__u16 adr = primary?cfi->cfiq->P_ADR:cfi->cfiq->A_ADR;
 		struct cfi_pri_amdstd *extp;
 
 		extp = (struct cfi_pri_amdstd*)cfi_read_pri(map, adr, sizeof(*extp), "Amd/Fujitsu");
-		if (!extp) {
-			kfree(mtd);
-			return NULL;
-		}
+		if (extp) {
+			/*
+			 * It's a real CFI chip, not one for which the probe
+			 * routine faked a CFI structure.
+			 */
+			cfi_fixup_major_minor(cfi, extp);
 
-		if (extp->MajorVersion != '1' ||
-		    (extp->MinorVersion < '0' || extp->MinorVersion > '4')) {
-			printk(KERN_ERR "  Unknown Amd/Fujitsu Extended Query "
-			       "version %c.%c.\n",  extp->MajorVersion,
-			       extp->MinorVersion);
-			kfree(extp);
-			kfree(mtd);
-			return NULL;
-		}
+			if (extp->MajorVersion != '1' ||
+			    (extp->MinorVersion < '0' || extp->MinorVersion > '4')) {
+				printk(KERN_ERR "  Unknown Amd/Fujitsu Extended Query "
+				       "version %c.%c.\n",  extp->MajorVersion,
+				       extp->MinorVersion);
+				kfree(extp);
+				kfree(mtd);
+				return NULL;
+			}
 
-		/* Install our own private info structure */
-		cfi->cmdset_priv = extp;
+			/* Install our own private info structure */
+			cfi->cmdset_priv = extp;
 
-		/* Apply cfi device specific fixups */
-		cfi_fixup(mtd, cfi_fixup_table);
+			/* Apply cfi device specific fixups */
+			cfi_fixup(mtd, cfi_fixup_table);
 
 #ifdef DEBUG_CFI_FEATURES
-		/* Tell the user about it in lots of lovely detail */
-		cfi_tell_features(extp);
+			/* Tell the user about it in lots of lovely detail */
+			cfi_tell_features(extp);
 #endif
 
-		bootloc = extp->TopBottom;
-		if ((bootloc != 2) && (bootloc != 3)) {
-			printk(KERN_WARNING "%s: CFI does not contain boot "
-			       "bank location. Assuming top.\n", map->name);
-			bootloc = 2;
-		}
-
-		if (bootloc == 3 && cfi->cfiq->NumEraseRegions > 1) {
-			printk(KERN_WARNING "%s: Swapping erase regions for broken CFI table.\n", map->name);
-
-			for (i=0; i<cfi->cfiq->NumEraseRegions / 2; i++) {
-				int j = (cfi->cfiq->NumEraseRegions-1)-i;
-				__u32 swap;
-
-				swap = cfi->cfiq->EraseRegionInfo[i];
-				cfi->cfiq->EraseRegionInfo[i] = cfi->cfiq->EraseRegionInfo[j];
-				cfi->cfiq->EraseRegionInfo[j] = swap;
+			bootloc = extp->TopBottom;
+			if ((bootloc < 2) || (bootloc > 5)) {
+				printk(KERN_WARNING "%s: CFI contains unrecognised boot "
+				       "bank location (%d). Assuming bottom.\n",
+				       map->name, bootloc);
+				bootloc = 2;
+			}
+
+			if (bootloc == 3 && cfi->cfiq->NumEraseRegions > 1) {
+				printk(KERN_WARNING "%s: Swapping erase regions for top-boot CFI table.\n", map->name);
+
+				for (i=0; i<cfi->cfiq->NumEraseRegions / 2; i++) {
+					int j = (cfi->cfiq->NumEraseRegions-1)-i;
+					__u32 swap;
+
+					swap = cfi->cfiq->EraseRegionInfo[i];
+					cfi->cfiq->EraseRegionInfo[i] = cfi->cfiq->EraseRegionInfo[j];
+					cfi->cfiq->EraseRegionInfo[j] = swap;
+				}
 			}
+			/* Set the default CFI lock/unlock addresses */
+			cfi->addr_unlock1 = 0x555;
+			cfi->addr_unlock2 = 0x2aa;
+		}
+		cfi_fixup(mtd, cfi_nopri_fixup_table);
+
+		if (!cfi->addr_unlock1 || !cfi->addr_unlock2) {
+			kfree(mtd);
+			return NULL;
 		}
-		/* Set the default CFI lock/unlock addresses */
-		cfi->addr_unlock1 = 0x555;
-		cfi->addr_unlock2 = 0x2aa;
 
 	} /* CFI mode */
 	else if (cfi->cfi_mode == CFI_MODE_JEDEC) {
@@ -427,7 +489,11 @@
 
 	return cfi_amdstd_setup(mtd);
 }
+struct mtd_info *cfi_cmdset_0006(struct map_info *map, int primary) __attribute__((alias("cfi_cmdset_0002")));
+struct mtd_info *cfi_cmdset_0701(struct map_info *map, int primary) __attribute__((alias("cfi_cmdset_0002")));
 EXPORT_SYMBOL_GPL(cfi_cmdset_0002);
+EXPORT_SYMBOL_GPL(cfi_cmdset_0006);
+EXPORT_SYMBOL_GPL(cfi_cmdset_0701);
 
 static struct mtd_info *cfi_amdstd_setup(struct mtd_info *mtd)
 {
@@ -480,18 +546,13 @@
 	}
 #endif
 
-	/* FIXME: erase-suspend-program is broken.  See
-	   http://lists.infradead.org/pipermail/linux-mtd/2003-December/009001.html */
-	printk(KERN_NOTICE "cfi_cmdset_0002: Disabling erase-suspend-program due to code brokenness.\n");
-
 	__module_get(THIS_MODULE);
+	register_reboot_notifier(&mtd->reboot_notifier);
 	return mtd;
 
  setup_err:
-	if(mtd) {
-		kfree(mtd->eraseregions);
-		kfree(mtd);
-	}
+	kfree(mtd->eraseregions);
+	kfree(mtd);
 	kfree(cfi->cmdset_priv);
 	kfree(cfi->cfiq);
 	return NULL;
@@ -561,14 +622,13 @@
 			if (chip_ready(map, adr))
 				break;
 
-			if (time_after(jiffies, timeo)) {
+			if (time_after(jiffies, timeo) && !chip_ready(map, adr)) {
 				printk(KERN_ERR "Waiting for chip to be ready timed out.\n");
-				spin_unlock(chip->mutex);
 				return -EIO;
 			}
-			spin_unlock(chip->mutex);
+			mutex_unlock(&chip->mutex);
 			cfi_udelay(1);
-			spin_lock(chip->mutex);
+			mutex_lock(&chip->mutex);
 			/* Someone else might have been playing with it. */
 			goto retry;
 		}
@@ -579,15 +639,9 @@
 		return 0;
 
 	case FL_ERASING:
-		if (mode == FL_WRITING) /* FIXME: Erase-suspend-program appears broken. */
-			goto sleep;
-
-		if (!(   mode == FL_READY
-		      || mode == FL_POINT
-		      || !cfip
-		      || (mode == FL_WRITING && (cfip->EraseSuspend & 0x2))
-		      || (mode == FL_WRITING && (cfip->EraseSuspend & 0x1)
-		    )))
+		if (!cfip || !(cfip->EraseSuspend & (0x1|0x2)) ||
+		    !(mode == FL_READY || mode == FL_POINT ||
+		    (mode == FL_WRITING && (cfip->EraseSuspend & 0x2))))
 			goto sleep;
 
 		/* We could check to see if we're trying to access the sector
@@ -605,12 +659,16 @@
 			if (chip_ready(map, adr))
 				break;
 
-			if (time_after(jiffies, timeo)) {
+			if (time_after(jiffies, timeo) && !chip_ready(map, adr)) {
 				/* Should have suspended the erase by now.
 				 * Send an Erase-Resume command as either
 				 * there was an error (so leave the erase
 				 * routine to recover from it) or we trying to
 				 * use the erase-in-progress sector. */
+				/* before resume, insert a dummy 0xF0 cycle for Micron M29EW devices */
+				if (cfi->mfr == CFI_MFR_NMX)
+					map_write(map, CMD(0xF0), chip->in_progress_block_addr);
+ 
 				map_write(map, CMD(0x30), chip->in_progress_block_addr);
 				chip->state = FL_ERASING;
 				chip->oldstate = FL_READY;
@@ -618,9 +676,9 @@
 				return -EIO;
 			}
 
-			spin_unlock(chip->mutex);
+			mutex_unlock(&chip->mutex);
 			cfi_udelay(1);
-			spin_lock(chip->mutex);
+			mutex_lock(&chip->mutex);
 			/* Nobody will touch it while it's in state FL_ERASE_SUSPENDING.
 			   So we can just loop here. */
 		}
@@ -635,6 +693,10 @@
 		chip->state = FL_READY;
 		return 0;
 
+	case FL_SHUTDOWN:
+		/* The machine is rebooting */
+		return -EIO;
+
 	case FL_POINT:
 		/* Only if there's no operation suspended... */
 		if (mode == FL_READY && chip->oldstate == FL_READY)
@@ -644,10 +706,10 @@
 	sleep:
 		set_current_state(TASK_UNINTERRUPTIBLE);
 		add_wait_queue(&chip->wq, &wait);
-		spin_unlock(chip->mutex);
+		mutex_unlock(&chip->mutex);
 		schedule();
 		remove_wait_queue(&chip->wq, &wait);
-		spin_lock(chip->mutex);
+		mutex_lock(&chip->mutex);
 		goto resettime;
 	}
 }
@@ -660,6 +722,10 @@
 	switch(chip->oldstate) {
 	case FL_ERASING:
 		chip->state = chip->oldstate;
+		/* before resume, insert a dummy 0xF0 cycle for Micron M29EW devices */
+		if (cfi->mfr == CFI_MFR_NMX)
+			map_write(map, CMD(0xF0), chip->in_progress_block_addr);
+                        
 		map_write(map, CMD(0x30), chip->in_progress_block_addr);
 		chip->oldstate = FL_READY;
 		chip->state = FL_ERASING;
@@ -779,7 +845,7 @@
 			(void) map_read(map, adr);
 			xip_iprefetch();
 			local_irq_enable();
-			spin_unlock(chip->mutex);
+			mutex_unlock(&chip->mutex);
 			xip_iprefetch();
 			cond_resched();
 
@@ -789,20 +855,24 @@
 			 * a suspended erase state.  If so let's wait
 			 * until it's done.
 			 */
-			spin_lock(chip->mutex);
+			mutex_lock(&chip->mutex);
 			while (chip->state != FL_XIP_WHILE_ERASING) {
 				DECLARE_WAITQUEUE(wait, current);
 				set_current_state(TASK_UNINTERRUPTIBLE);
 				add_wait_queue(&chip->wq, &wait);
-				spin_unlock(chip->mutex);
+				mutex_unlock(&chip->mutex);
 				schedule();
 				remove_wait_queue(&chip->wq, &wait);
-				spin_lock(chip->mutex);
+				mutex_lock(&chip->mutex);
 			}
 			/* Disallow XIP again */
 			local_irq_disable();
 
 			/* Resume the write or erase operation */
+			/* before resume, insert a dummy 0xF0 cycle for Micron M29EW devices */
+			if (cfi->mfr == CFI_MFR_NMX)
+				map_write(map, CMD(0xF0), adr);
+                                
 			map_write(map, CMD(0x30), adr);
 			chip->state = oldstate;
 			start = xip_currtime();
@@ -859,17 +929,17 @@
 
 #define UDELAY(map, chip, adr, usec)  \
 do {  \
-	spin_unlock(chip->mutex);  \
+	mutex_unlock(&chip->mutex);  \
 	cfi_udelay(usec);  \
-	spin_lock(chip->mutex);  \
+	mutex_lock(&chip->mutex);  \
 } while (0)
 
 #define INVALIDATE_CACHE_UDELAY(map, chip, adr, len, usec)  \
 do {  \
-	spin_unlock(chip->mutex);  \
+	mutex_unlock(&chip->mutex);  \
 	INVALIDATE_CACHED_RANGE(map, adr, len);  \
 	cfi_udelay(usec);  \
-	spin_lock(chip->mutex);  \
+	mutex_lock(&chip->mutex);  \
 } while (0)
 
 #endif
@@ -885,10 +955,10 @@
 	/* Ensure cmd read/writes are aligned. */
 	cmd_addr = adr & ~(map_bankwidth(map)-1);
 
-	spin_lock(chip->mutex);
+	mutex_lock(&chip->mutex);
 	ret = get_chip(map, chip, cmd_addr, FL_READY);
 	if (ret) {
-		spin_unlock(chip->mutex);
+		mutex_unlock(&chip->mutex);
 		return ret;
 	}
 
@@ -901,7 +971,7 @@
 
 	put_chip(map, chip, cmd_addr);
 
-	spin_unlock(chip->mutex);
+	mutex_unlock(&chip->mutex);
 	return 0;
 }
 
@@ -955,7 +1025,7 @@
 	struct cfi_private *cfi = map->fldrv_priv;
 
  retry:
-	spin_lock(chip->mutex);
+	mutex_lock(&chip->mutex);
 
 	if (chip->state != FL_READY){
 #if 0
@@ -964,7 +1034,7 @@
 		set_current_state(TASK_UNINTERRUPTIBLE);
 		add_wait_queue(&chip->wq, &wait);
 
-		spin_unlock(chip->mutex);
+		mutex_unlock(&chip->mutex);
 
 		schedule();
 		remove_wait_queue(&chip->wq, &wait);
@@ -993,7 +1063,7 @@
 	cfi_send_gen_cmd(0x00, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
 
 	wake_up(&chip->wq);
-	spin_unlock(chip->mutex);
+	mutex_unlock(&chip->mutex);
 
 	return 0;
 }
@@ -1062,10 +1132,10 @@
 
 	adr += chip->start;
 
-	spin_lock(chip->mutex);
+	mutex_lock(&chip->mutex);
 	ret = get_chip(map, chip, adr, FL_WRITING);
 	if (ret) {
-		spin_unlock(chip->mutex);
+		mutex_unlock(&chip->mutex);
 		return ret;
 	}
 
@@ -1108,11 +1178,11 @@
 
 			set_current_state(TASK_UNINTERRUPTIBLE);
 			add_wait_queue(&chip->wq, &wait);
-			spin_unlock(chip->mutex);
+			mutex_unlock(&chip->mutex);
 			schedule();
 			remove_wait_queue(&chip->wq, &wait);
 			timeo = jiffies + (HZ / 2); /* FIXME */
-			spin_lock(chip->mutex);
+			mutex_lock(&chip->mutex);
 			continue;
 		}
 
@@ -1144,7 +1214,7 @@
  op_done:
 	chip->state = FL_READY;
 	put_chip(map, chip, adr);
-	spin_unlock(chip->mutex);
+	mutex_unlock(&chip->mutex);
 
 	return ret;
 }
@@ -1176,7 +1246,7 @@
 		map_word tmp_buf;
 
  retry:
-		spin_lock(cfi->chips[chipnum].mutex);
+		mutex_lock(&cfi->chips[chipnum].mutex);
 
 		if (cfi->chips[chipnum].state != FL_READY) {
 #if 0
@@ -1185,7 +1255,7 @@
 			set_current_state(TASK_UNINTERRUPTIBLE);
 			add_wait_queue(&cfi->chips[chipnum].wq, &wait);
 
-			spin_unlock(cfi->chips[chipnum].mutex);
+			mutex_unlock(&cfi->chips[chipnum].mutex);
 
 			schedule();
 			remove_wait_queue(&cfi->chips[chipnum].wq, &wait);
@@ -1199,7 +1269,7 @@
 		/* Load 'tmp_buf' with old contents of flash */
 		tmp_buf = map_read(map, bus_ofs+chipstart);
 
-		spin_unlock(cfi->chips[chipnum].mutex);
+		mutex_unlock(&cfi->chips[chipnum].mutex);
 
 		/* Number of bytes to copy from buffer */
 		n = min_t(int, len, map_bankwidth(map)-i);
@@ -1254,7 +1324,7 @@
 		map_word tmp_buf;
 
  retry1:
-		spin_lock(cfi->chips[chipnum].mutex);
+		mutex_lock(&cfi->chips[chipnum].mutex);
 
 		if (cfi->chips[chipnum].state != FL_READY) {
 #if 0
@@ -1263,7 +1333,7 @@
 			set_current_state(TASK_UNINTERRUPTIBLE);
 			add_wait_queue(&cfi->chips[chipnum].wq, &wait);
 
-			spin_unlock(cfi->chips[chipnum].mutex);
+			mutex_unlock(&cfi->chips[chipnum].mutex);
 
 			schedule();
 			remove_wait_queue(&cfi->chips[chipnum].wq, &wait);
@@ -1276,7 +1346,7 @@
 
 		tmp_buf = map_read(map, ofs + chipstart);
 
-		spin_unlock(cfi->chips[chipnum].mutex);
+		mutex_unlock(&cfi->chips[chipnum].mutex);
 
 		tmp_buf = map_word_load_partial(map, tmp_buf, buf, 0, len);
 
@@ -1311,10 +1381,10 @@
 	adr += chip->start;
 	cmd_adr = adr;
 
-	spin_lock(chip->mutex);
+	mutex_lock(&chip->mutex);
 	ret = get_chip(map, chip, adr, FL_WRITING);
 	if (ret) {
-		spin_unlock(chip->mutex);
+		mutex_unlock(&chip->mutex);
 		return ret;
 	}
 
@@ -1369,11 +1439,11 @@
 
 			set_current_state(TASK_UNINTERRUPTIBLE);
 			add_wait_queue(&chip->wq, &wait);
-			spin_unlock(chip->mutex);
+			mutex_unlock(&chip->mutex);
 			schedule();
 			remove_wait_queue(&chip->wq, &wait);
 			timeo = jiffies + (HZ / 2); /* FIXME */
-			spin_lock(chip->mutex);
+			mutex_lock(&chip->mutex);
 			continue;
 		}
 
@@ -1401,7 +1471,7 @@
  op_done:
 	chip->state = FL_READY;
 	put_chip(map, chip, adr);
-	spin_unlock(chip->mutex);
+	mutex_unlock(&chip->mutex);
 
 	return ret;
 }
@@ -1501,10 +1571,10 @@
 
 	adr = cfi->addr_unlock1;
 
-	spin_lock(chip->mutex);
+	mutex_lock(&chip->mutex);
 	ret = get_chip(map, chip, adr, FL_WRITING);
 	if (ret) {
-		spin_unlock(chip->mutex);
+		mutex_unlock(&chip->mutex);
 		return ret;
 	}
 
@@ -1537,10 +1607,10 @@
 			/* Someone's suspended the erase. Sleep */
 			set_current_state(TASK_UNINTERRUPTIBLE);
 			add_wait_queue(&chip->wq, &wait);
-			spin_unlock(chip->mutex);
+			mutex_unlock(&chip->mutex);
 			schedule();
 			remove_wait_queue(&chip->wq, &wait);
-			spin_lock(chip->mutex);
+			mutex_lock(&chip->mutex);
 			continue;
 		}
 		if (chip->erase_suspended) {
@@ -1574,7 +1644,7 @@
 	chip->state = FL_READY;
 	xip_enable(map, chip, adr);
 	put_chip(map, chip, adr);
-	spin_unlock(chip->mutex);
+	mutex_unlock(&chip->mutex);
 
 	return ret;
 }
@@ -1589,10 +1659,10 @@
 
 	adr += chip->start;
 
-	spin_lock(chip->mutex);
+	mutex_lock(&chip->mutex);
 	ret = get_chip(map, chip, adr, FL_ERASING);
 	if (ret) {
-		spin_unlock(chip->mutex);
+		mutex_unlock(&chip->mutex);
 		return ret;
 	}
 
@@ -1625,10 +1695,10 @@
 			/* Someone's suspended the erase. Sleep */
 			set_current_state(TASK_UNINTERRUPTIBLE);
 			add_wait_queue(&chip->wq, &wait);
-			spin_unlock(chip->mutex);
+			mutex_unlock(&chip->mutex);
 			schedule();
 			remove_wait_queue(&chip->wq, &wait);
-			spin_lock(chip->mutex);
+			mutex_lock(&chip->mutex);
 			continue;
 		}
 		if (chip->erase_suspended) {
@@ -1664,7 +1734,7 @@
 
 	chip->state = FL_READY;
 	put_chip(map, chip, adr);
-	spin_unlock(chip->mutex);
+	mutex_unlock(&chip->mutex);
 	return ret;
 }
 
@@ -1716,7 +1786,7 @@
 	struct cfi_private *cfi = map->fldrv_priv;
 	int ret;
 
-	spin_lock(chip->mutex);
+	mutex_lock(&chip->mutex);
 	ret = get_chip(map, chip, adr + chip->start, FL_LOCKING);
 	if (ret)
 		goto out_unlock;
@@ -1742,7 +1812,7 @@
 	ret = 0;
 
 out_unlock:
-	spin_unlock(chip->mutex);
+	mutex_unlock(&chip->mutex);
 	return ret;
 }
 
@@ -1752,7 +1822,7 @@
 	struct cfi_private *cfi = map->fldrv_priv;
 	int ret;
 
-	spin_lock(chip->mutex);
+	mutex_lock(&chip->mutex);
 	ret = get_chip(map, chip, adr + chip->start, FL_UNLOCKING);
 	if (ret)
 		goto out_unlock;
@@ -1770,7 +1840,7 @@
 	ret = 0;
 
 out_unlock:
-	spin_unlock(chip->mutex);
+	mutex_unlock(&chip->mutex);
 	return ret;
 }
 
@@ -1798,7 +1868,7 @@
 		chip = &cfi->chips[i];
 
 	retry:
-		spin_lock(chip->mutex);
+		mutex_lock(&chip->mutex);
 
 		switch(chip->state) {
 		case FL_READY:
@@ -1812,7 +1882,7 @@
 			 * with the chip now anyway.
 			 */
 		case FL_SYNCING:
-			spin_unlock(chip->mutex);
+			mutex_unlock(&chip->mutex);
 			break;
 
 		default:
@@ -1820,7 +1890,7 @@
 			set_current_state(TASK_UNINTERRUPTIBLE);
 			add_wait_queue(&chip->wq, &wait);
 
-			spin_unlock(chip->mutex);
+			mutex_unlock(&chip->mutex);
 
 			schedule();
 
@@ -1835,13 +1905,13 @@
 	for (i--; i >=0; i--) {
 		chip = &cfi->chips[i];
 
-		spin_lock(chip->mutex);
+		mutex_lock(&chip->mutex);
 
 		if (chip->state == FL_SYNCING) {
 			chip->state = chip->oldstate;
 			wake_up(&chip->wq);
 		}
-		spin_unlock(chip->mutex);
+		mutex_unlock(&chip->mutex);
 	}
 }
 
@@ -1857,7 +1927,7 @@
 	for (i=0; !ret && i<cfi->numchips; i++) {
 		chip = &cfi->chips[i];
 
-		spin_lock(chip->mutex);
+		mutex_lock(&chip->mutex);
 
 		switch(chip->state) {
 		case FL_READY:
@@ -1877,7 +1947,7 @@
 			ret = -EAGAIN;
 			break;
 		}
-		spin_unlock(chip->mutex);
+		mutex_unlock(&chip->mutex);
 	}
 
 	/* Unlock the chips again */
@@ -1886,13 +1956,13 @@
 		for (i--; i >=0; i--) {
 			chip = &cfi->chips[i];
 
-			spin_lock(chip->mutex);
+			mutex_lock(&chip->mutex);
 
 			if (chip->state == FL_PM_SUSPENDED) {
 				chip->state = chip->oldstate;
 				wake_up(&chip->wq);
 			}
-			spin_unlock(chip->mutex);
+			mutex_unlock(&chip->mutex);
 		}
 	}
 
@@ -1911,7 +1981,7 @@
 
 		chip = &cfi->chips[i];
 
-		spin_lock(chip->mutex);
+		mutex_lock(&chip->mutex);
 
 		if (chip->state == FL_PM_SUSPENDED) {
 			chip->state = FL_READY;
@@ -1921,15 +1991,62 @@
 		else
 			printk(KERN_ERR "Argh. Chip not in PM_SUSPENDED state upon resume()\n");
 
-		spin_unlock(chip->mutex);
+		mutex_unlock(&chip->mutex);
+	}
+}
+
+
+/*
+ * Ensure that the flash device is put back into read array mode before
+ * unloading the driver or rebooting.  On some systems, rebooting while
+ * the flash is in query/program/erase mode will prevent the CPU from
+ * fetching the bootloader code, requiring a hard reset or power cycle.
+ */
+static int cfi_amdstd_reset(struct mtd_info *mtd)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	int i, ret;
+	struct flchip *chip;
+
+	for (i = 0; i < cfi->numchips; i++) {
+
+		chip = &cfi->chips[i];
+
+		mutex_lock(&chip->mutex);
+
+		ret = get_chip(map, chip, chip->start, FL_SHUTDOWN);
+		if (!ret) {
+			map_write(map, CMD(0xF0), chip->start);
+			chip->state = FL_SHUTDOWN;
+			put_chip(map, chip, chip->start);
+		}
+
+		mutex_unlock(&chip->mutex);
 	}
+
+	return 0;
+}
+
+
+static int cfi_amdstd_reboot(struct notifier_block *nb, unsigned long val,
+			       void *v)
+{
+	struct mtd_info *mtd;
+
+	mtd = container_of(nb, struct mtd_info, reboot_notifier);
+	cfi_amdstd_reset(mtd);
+	return NOTIFY_DONE;
 }
 
+
 static void cfi_amdstd_destroy(struct mtd_info *mtd)
 {
 	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
 
+	cfi_amdstd_reset(mtd);
+	unregister_reboot_notifier(&mtd->reboot_notifier);
 	kfree(cfi->cmdset_priv);
 	kfree(cfi->cfiq);
 	kfree(cfi);
@@ -1939,3 +2056,5 @@
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Crossnet Co. <info@crossnet.co.jp> et al.");
 MODULE_DESCRIPTION("MTD chip driver for AMD/Fujitsu flash chips");
+MODULE_ALIAS("cfi_cmdset_0006");
+MODULE_ALIAS("cfi_cmdset_0701");
diff -Naur pico_2.6.28/drivers/mtd/chips/cfi_cmdset_0020.c ipa_2.6.28/drivers/mtd/chips/cfi_cmdset_0020.c
--- pico_2.6.28/drivers/mtd/chips/cfi_cmdset_0020.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/drivers/mtd/chips/cfi_cmdset_0020.c	2011-04-26 14:51:35.000000000 +0100
@@ -265,7 +265,7 @@
 
 	timeo = jiffies + HZ;
  retry:
-	spin_lock_bh(chip->mutex);
+	mutex_lock(&chip->mutex);
 
 	/* Check that the chip's ready to talk to us.
 	 * If it's in FL_ERASING state, suspend it and make it talk now.
@@ -296,15 +296,15 @@
 				/* make sure we're in 'read status' mode */
 				map_write(map, CMD(0x70), cmd_addr);
 				chip->state = FL_ERASING;
-				spin_unlock_bh(chip->mutex);
+				mutex_unlock(&chip->mutex);
 				printk(KERN_ERR "Chip not ready after erase "
 				       "suspended: status = 0x%lx\n", status.x[0]);
 				return -EIO;
 			}
 
-			spin_unlock_bh(chip->mutex);
+			mutex_unlock(&chip->mutex);
 			cfi_udelay(1);
-			spin_lock_bh(chip->mutex);
+			mutex_lock(&chip->mutex);
 		}
 
 		suspended = 1;
@@ -335,13 +335,13 @@
 
 		/* Urgh. Chip not yet ready to talk to us. */
 		if (time_after(jiffies, timeo)) {
-			spin_unlock_bh(chip->mutex);
+			mutex_unlock(&chip->mutex);
 			printk(KERN_ERR "waiting for chip to be ready timed out in read. WSM status = %lx\n", status.x[0]);
 			return -EIO;
 		}
 
 		/* Latency issues. Drop the lock, wait a while and retry */
-		spin_unlock_bh(chip->mutex);
+		mutex_unlock(&chip->mutex);
 		cfi_udelay(1);
 		goto retry;
 
@@ -351,7 +351,7 @@
 		   someone changes the status */
 		set_current_state(TASK_UNINTERRUPTIBLE);
 		add_wait_queue(&chip->wq, &wait);
-		spin_unlock_bh(chip->mutex);
+		mutex_unlock(&chip->mutex);
 		schedule();
 		remove_wait_queue(&chip->wq, &wait);
 		timeo = jiffies + HZ;
@@ -376,7 +376,7 @@
 	}
 
 	wake_up(&chip->wq);
-	spin_unlock_bh(chip->mutex);
+	mutex_unlock(&chip->mutex);
 	return 0;
 }
 
@@ -445,7 +445,7 @@
 #ifdef DEBUG_CFI_FEATURES
        printk("%s: chip->state[%d]\n", __func__, chip->state);
 #endif
-	spin_lock_bh(chip->mutex);
+	mutex_lock(&chip->mutex);
 
 	/* Check that the chip's ready to talk to us.
 	 * Later, we can actually think about interrupting it
@@ -470,14 +470,14 @@
 			break;
 		/* Urgh. Chip not yet ready to talk to us. */
 		if (time_after(jiffies, timeo)) {
-			spin_unlock_bh(chip->mutex);
+			mutex_unlock(&chip->mutex);
                         printk(KERN_ERR "waiting for chip to be ready timed out in buffer write Xstatus = %lx, status = %lx\n",
                                status.x[0], map_read(map, cmd_adr).x[0]);
 			return -EIO;
 		}
 
 		/* Latency issues. Drop the lock, wait a while and retry */
-		spin_unlock_bh(chip->mutex);
+		mutex_unlock(&chip->mutex);
 		cfi_udelay(1);
 		goto retry;
 
@@ -486,7 +486,7 @@
 		   someone changes the status */
 		set_current_state(TASK_UNINTERRUPTIBLE);
 		add_wait_queue(&chip->wq, &wait);
-		spin_unlock_bh(chip->mutex);
+		mutex_unlock(&chip->mutex);
 		schedule();
 		remove_wait_queue(&chip->wq, &wait);
 		timeo = jiffies + HZ;
@@ -503,16 +503,16 @@
 		if (map_word_andequal(map, status, status_OK, status_OK))
 			break;
 
-		spin_unlock_bh(chip->mutex);
+		mutex_unlock(&chip->mutex);
 		cfi_udelay(1);
-		spin_lock_bh(chip->mutex);
+		mutex_lock(&chip->mutex);
 
 		if (++z > 100) {
 			/* Argh. Not ready for write to buffer */
 			DISABLE_VPP(map);
                         map_write(map, CMD(0x70), cmd_adr);
 			chip->state = FL_STATUS;
-			spin_unlock_bh(chip->mutex);
+			mutex_unlock(&chip->mutex);
 			printk(KERN_ERR "Chip not ready for buffer write. Xstatus = %lx\n", status.x[0]);
 			return -EIO;
 		}
@@ -532,9 +532,9 @@
 	map_write(map, CMD(0xd0), cmd_adr);
 	chip->state = FL_WRITING;
 
-	spin_unlock_bh(chip->mutex);
+	mutex_unlock(&chip->mutex);
 	cfi_udelay(chip->buffer_write_time);
-	spin_lock_bh(chip->mutex);
+	mutex_lock(&chip->mutex);
 
 	timeo = jiffies + (HZ/2);
 	z = 0;
@@ -543,11 +543,11 @@
 			/* Someone's suspended the write. Sleep */
 			set_current_state(TASK_UNINTERRUPTIBLE);
 			add_wait_queue(&chip->wq, &wait);
-			spin_unlock_bh(chip->mutex);
+			mutex_unlock(&chip->mutex);
 			schedule();
 			remove_wait_queue(&chip->wq, &wait);
 			timeo = jiffies + (HZ / 2); /* FIXME */
-			spin_lock_bh(chip->mutex);
+			mutex_lock(&chip->mutex);
 			continue;
 		}
 
@@ -563,16 +563,16 @@
                         map_write(map, CMD(0x70), adr);
 			chip->state = FL_STATUS;
 			DISABLE_VPP(map);
-			spin_unlock_bh(chip->mutex);
+			mutex_unlock(&chip->mutex);
 			printk(KERN_ERR "waiting for chip to be ready timed out in bufwrite\n");
 			return -EIO;
 		}
 
 		/* Latency issues. Drop the lock, wait a while and retry */
-		spin_unlock_bh(chip->mutex);
+		mutex_unlock(&chip->mutex);
 		cfi_udelay(1);
 		z++;
-		spin_lock_bh(chip->mutex);
+		mutex_lock(&chip->mutex);
 	}
 	if (!z) {
 		chip->buffer_write_time--;
@@ -596,11 +596,11 @@
 		/* put back into read status register mode */
 		map_write(map, CMD(0x70), adr);
 		wake_up(&chip->wq);
-		spin_unlock_bh(chip->mutex);
+		mutex_unlock(&chip->mutex);
 		return map_word_bitsset(map, status, CMD(0x02)) ? -EROFS : -EIO;
 	}
 	wake_up(&chip->wq);
-	spin_unlock_bh(chip->mutex);
+	mutex_unlock(&chip->mutex);
 
         return 0;
 }
@@ -749,7 +749,7 @@
 
 	timeo = jiffies + HZ;
 retry:
-	spin_lock_bh(chip->mutex);
+	mutex_lock(&chip->mutex);
 
 	/* Check that the chip's ready to talk to us. */
 	switch (chip->state) {
@@ -766,13 +766,13 @@
 
 		/* Urgh. Chip not yet ready to talk to us. */
 		if (time_after(jiffies, timeo)) {
-			spin_unlock_bh(chip->mutex);
+			mutex_unlock(&chip->mutex);
 			printk(KERN_ERR "waiting for chip to be ready timed out in erase\n");
 			return -EIO;
 		}
 
 		/* Latency issues. Drop the lock, wait a while and retry */
-		spin_unlock_bh(chip->mutex);
+		mutex_unlock(&chip->mutex);
 		cfi_udelay(1);
 		goto retry;
 
@@ -781,7 +781,7 @@
 		   someone changes the status */
 		set_current_state(TASK_UNINTERRUPTIBLE);
 		add_wait_queue(&chip->wq, &wait);
-		spin_unlock_bh(chip->mutex);
+		mutex_unlock(&chip->mutex);
 		schedule();
 		remove_wait_queue(&chip->wq, &wait);
 		timeo = jiffies + HZ;
@@ -797,9 +797,9 @@
 	map_write(map, CMD(0xD0), adr);
 	chip->state = FL_ERASING;
 
-	spin_unlock_bh(chip->mutex);
+	mutex_unlock(&chip->mutex);
 	msleep(1000);
-	spin_lock_bh(chip->mutex);
+	mutex_lock(&chip->mutex);
 
 	/* FIXME. Use a timer to check this, and return immediately. */
 	/* Once the state machine's known to be working I'll do that */
@@ -810,11 +810,11 @@
 			/* Someone's suspended the erase. Sleep */
 			set_current_state(TASK_UNINTERRUPTIBLE);
 			add_wait_queue(&chip->wq, &wait);
-			spin_unlock_bh(chip->mutex);
+			mutex_unlock(&chip->mutex);
 			schedule();
 			remove_wait_queue(&chip->wq, &wait);
 			timeo = jiffies + (HZ*20); /* FIXME */
-			spin_lock_bh(chip->mutex);
+			mutex_lock(&chip->mutex);
 			continue;
 		}
 
@@ -828,14 +828,14 @@
 			chip->state = FL_STATUS;
 			printk(KERN_ERR "waiting for erase to complete timed out. Xstatus = %lx, status = %lx.\n", status.x[0], map_read(map, adr).x[0]);
 			DISABLE_VPP(map);
-			spin_unlock_bh(chip->mutex);
+			mutex_unlock(&chip->mutex);
 			return -EIO;
 		}
 
 		/* Latency issues. Drop the lock, wait a while and retry */
-		spin_unlock_bh(chip->mutex);
+		mutex_unlock(&chip->mutex);
 		cfi_udelay(1);
-		spin_lock_bh(chip->mutex);
+		mutex_lock(&chip->mutex);
 	}
 
 	DISABLE_VPP(map);
@@ -878,7 +878,7 @@
 				printk(KERN_DEBUG "Chip erase failed at 0x%08lx: status 0x%x. Retrying...\n", adr, chipstatus);
 				timeo = jiffies + HZ;
 				chip->state = FL_STATUS;
-				spin_unlock_bh(chip->mutex);
+				mutex_unlock(&chip->mutex);
 				goto retry;
 			}
 			printk(KERN_DEBUG "Chip erase failed at 0x%08lx: status 0x%x\n", adr, chipstatus);
@@ -887,7 +887,7 @@
 	}
 
 	wake_up(&chip->wq);
-	spin_unlock_bh(chip->mutex);
+	mutex_unlock(&chip->mutex);
 	return ret;
 }
 
@@ -995,7 +995,7 @@
 		chip = &cfi->chips[i];
 
 	retry:
-		spin_lock_bh(chip->mutex);
+		mutex_lock(&chip->mutex);
 
 		switch(chip->state) {
 		case FL_READY:
@@ -1009,7 +1009,7 @@
 			 * with the chip now anyway.
 			 */
 		case FL_SYNCING:
-			spin_unlock_bh(chip->mutex);
+			mutex_unlock(&chip->mutex);
 			break;
 
 		default:
@@ -1017,7 +1017,7 @@
 			set_current_state(TASK_UNINTERRUPTIBLE);
 			add_wait_queue(&chip->wq, &wait);
 
-			spin_unlock_bh(chip->mutex);
+			mutex_unlock(&chip->mutex);
 			schedule();
 		        remove_wait_queue(&chip->wq, &wait);
 
@@ -1030,13 +1030,13 @@
 	for (i--; i >=0; i--) {
 		chip = &cfi->chips[i];
 
-		spin_lock_bh(chip->mutex);
+		mutex_lock(&chip->mutex);
 
 		if (chip->state == FL_SYNCING) {
 			chip->state = chip->oldstate;
 			wake_up(&chip->wq);
 		}
-		spin_unlock_bh(chip->mutex);
+		mutex_unlock(&chip->mutex);
 	}
 }
 
@@ -1054,7 +1054,7 @@
 
 	timeo = jiffies + HZ;
 retry:
-	spin_lock_bh(chip->mutex);
+	mutex_lock(&chip->mutex);
 
 	/* Check that the chip's ready to talk to us. */
 	switch (chip->state) {
@@ -1071,13 +1071,13 @@
 
 		/* Urgh. Chip not yet ready to talk to us. */
 		if (time_after(jiffies, timeo)) {
-			spin_unlock_bh(chip->mutex);
+			mutex_unlock(&chip->mutex);
 			printk(KERN_ERR "waiting for chip to be ready timed out in lock\n");
 			return -EIO;
 		}
 
 		/* Latency issues. Drop the lock, wait a while and retry */
-		spin_unlock_bh(chip->mutex);
+		mutex_unlock(&chip->mutex);
 		cfi_udelay(1);
 		goto retry;
 
@@ -1086,7 +1086,7 @@
 		   someone changes the status */
 		set_current_state(TASK_UNINTERRUPTIBLE);
 		add_wait_queue(&chip->wq, &wait);
-		spin_unlock_bh(chip->mutex);
+		mutex_unlock(&chip->mutex);
 		schedule();
 		remove_wait_queue(&chip->wq, &wait);
 		timeo = jiffies + HZ;
@@ -1098,9 +1098,9 @@
 	map_write(map, CMD(0x01), adr);
 	chip->state = FL_LOCKING;
 
-	spin_unlock_bh(chip->mutex);
+	mutex_unlock(&chip->mutex);
 	msleep(1000);
-	spin_lock_bh(chip->mutex);
+	mutex_lock(&chip->mutex);
 
 	/* FIXME. Use a timer to check this, and return immediately. */
 	/* Once the state machine's known to be working I'll do that */
@@ -1118,21 +1118,21 @@
 			chip->state = FL_STATUS;
 			printk(KERN_ERR "waiting for lock to complete timed out. Xstatus = %lx, status = %lx.\n", status.x[0], map_read(map, adr).x[0]);
 			DISABLE_VPP(map);
-			spin_unlock_bh(chip->mutex);
+			mutex_unlock(&chip->mutex);
 			return -EIO;
 		}
 
 		/* Latency issues. Drop the lock, wait a while and retry */
-		spin_unlock_bh(chip->mutex);
+		mutex_unlock(&chip->mutex);
 		cfi_udelay(1);
-		spin_lock_bh(chip->mutex);
+		mutex_lock(&chip->mutex);
 	}
 
 	/* Done and happy. */
 	chip->state = FL_STATUS;
 	DISABLE_VPP(map);
 	wake_up(&chip->wq);
-	spin_unlock_bh(chip->mutex);
+	mutex_unlock(&chip->mutex);
 	return 0;
 }
 static int cfi_staa_lock(struct mtd_info *mtd, loff_t ofs, size_t len)
@@ -1203,7 +1203,7 @@
 
 	timeo = jiffies + HZ;
 retry:
-	spin_lock_bh(chip->mutex);
+	mutex_lock(&chip->mutex);
 
 	/* Check that the chip's ready to talk to us. */
 	switch (chip->state) {
@@ -1220,13 +1220,13 @@
 
 		/* Urgh. Chip not yet ready to talk to us. */
 		if (time_after(jiffies, timeo)) {
-			spin_unlock_bh(chip->mutex);
+			mutex_unlock(&chip->mutex);
 			printk(KERN_ERR "waiting for chip to be ready timed out in unlock\n");
 			return -EIO;
 		}
 
 		/* Latency issues. Drop the lock, wait a while and retry */
-		spin_unlock_bh(chip->mutex);
+		mutex_unlock(&chip->mutex);
 		cfi_udelay(1);
 		goto retry;
 
@@ -1235,7 +1235,7 @@
 		   someone changes the status */
 		set_current_state(TASK_UNINTERRUPTIBLE);
 		add_wait_queue(&chip->wq, &wait);
-		spin_unlock_bh(chip->mutex);
+		mutex_unlock(&chip->mutex);
 		schedule();
 		remove_wait_queue(&chip->wq, &wait);
 		timeo = jiffies + HZ;
@@ -1247,9 +1247,9 @@
 	map_write(map, CMD(0xD0), adr);
 	chip->state = FL_UNLOCKING;
 
-	spin_unlock_bh(chip->mutex);
+	mutex_unlock(&chip->mutex);
 	msleep(1000);
-	spin_lock_bh(chip->mutex);
+	mutex_lock(&chip->mutex);
 
 	/* FIXME. Use a timer to check this, and return immediately. */
 	/* Once the state machine's known to be working I'll do that */
@@ -1267,21 +1267,21 @@
 			chip->state = FL_STATUS;
 			printk(KERN_ERR "waiting for unlock to complete timed out. Xstatus = %lx, status = %lx.\n", status.x[0], map_read(map, adr).x[0]);
 			DISABLE_VPP(map);
-			spin_unlock_bh(chip->mutex);
+			mutex_unlock(&chip->mutex);
 			return -EIO;
 		}
 
 		/* Latency issues. Drop the unlock, wait a while and retry */
-		spin_unlock_bh(chip->mutex);
+		mutex_unlock(&chip->mutex);
 		cfi_udelay(1);
-		spin_lock_bh(chip->mutex);
+		mutex_lock(&chip->mutex);
 	}
 
 	/* Done and happy. */
 	chip->state = FL_STATUS;
 	DISABLE_VPP(map);
 	wake_up(&chip->wq);
-	spin_unlock_bh(chip->mutex);
+	mutex_unlock(&chip->mutex);
 	return 0;
 }
 static int cfi_staa_unlock(struct mtd_info *mtd, loff_t ofs, size_t len)
@@ -1334,7 +1334,7 @@
 	for (i=0; !ret && i<cfi->numchips; i++) {
 		chip = &cfi->chips[i];
 
-		spin_lock_bh(chip->mutex);
+		mutex_lock(&chip->mutex);
 
 		switch(chip->state) {
 		case FL_READY:
@@ -1354,7 +1354,7 @@
 			ret = -EAGAIN;
 			break;
 		}
-		spin_unlock_bh(chip->mutex);
+		mutex_unlock(&chip->mutex);
 	}
 
 	/* Unlock the chips again */
@@ -1363,7 +1363,7 @@
 		for (i--; i >=0; i--) {
 			chip = &cfi->chips[i];
 
-			spin_lock_bh(chip->mutex);
+			mutex_lock(&chip->mutex);
 
 			if (chip->state == FL_PM_SUSPENDED) {
 				/* No need to force it into a known state here,
@@ -1372,7 +1372,7 @@
 				chip->state = chip->oldstate;
 				wake_up(&chip->wq);
 			}
-			spin_unlock_bh(chip->mutex);
+			mutex_unlock(&chip->mutex);
 		}
 	}
 
@@ -1390,7 +1390,7 @@
 
 		chip = &cfi->chips[i];
 
-		spin_lock_bh(chip->mutex);
+		mutex_lock(&chip->mutex);
 
 		/* Go to known state. Chip may have been power cycled */
 		if (chip->state == FL_PM_SUSPENDED) {
@@ -1399,7 +1399,7 @@
 			wake_up(&chip->wq);
 		}
 
-		spin_unlock_bh(chip->mutex);
+		mutex_unlock(&chip->mutex);
 	}
 }
 
diff -Naur pico_2.6.28/drivers/mtd/chips/cfi_probe.c ipa_2.6.28/drivers/mtd/chips/cfi_probe.c
--- pico_2.6.28/drivers/mtd/chips/cfi_probe.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/drivers/mtd/chips/cfi_probe.c	2011-04-26 14:53:04.000000000 +0100
@@ -158,6 +158,10 @@
 	__u32 base = 0;
 	int num_erase_regions = cfi_read_query(map, base + (0x10 + 28)*ofs_factor);
 	int i;
+	int extendedId1 = 0;
+	int extendedId2 = 0;
+	int extendedId3 = 0;
+	int addr_unlock1 = 0x555, addr_unlock2 = 0x2AA;
 
 	xip_enable(base, map, cfi);
 #ifdef DEBUG_CFI
@@ -181,29 +185,6 @@
 	for (i=0; i<(sizeof(struct cfi_ident) + num_erase_regions * 4); i++)
 		((unsigned char *)cfi->cfiq)[i] = cfi_read_query(map,base + (0x10 + i)*ofs_factor);
 
-	/* Note we put the device back into Read Mode BEFORE going into Auto
-	 * Select Mode, as some devices support nesting of modes, others
-	 * don't. This way should always work.
-	 * On cmdset 0001 the writes of 0xaa and 0x55 are not needed, and
-	 * so should be treated as nops or illegal (and so put the device
-	 * back into Read Mode, which is a nop in this case).
-	 */
-	cfi_send_gen_cmd(0xf0,     0, base, map, cfi, cfi->device_type, NULL);
-	cfi_send_gen_cmd(0xaa, 0x555, base, map, cfi, cfi->device_type, NULL);
-	cfi_send_gen_cmd(0x55, 0x2aa, base, map, cfi, cfi->device_type, NULL);
-	cfi_send_gen_cmd(0x90, 0x555, base, map, cfi, cfi->device_type, NULL);
-	cfi->mfr = cfi_read_query16(map, base);
-	cfi->id = cfi_read_query16(map, base + ofs_factor);
-
-	/* Get AMD/Spansion extended JEDEC ID */
-	if (cfi->mfr == CFI_MFR_AMD && (cfi->id & 0xff) == 0x7e)
-		cfi->id = cfi_read_query(map, base + 0xe * ofs_factor) << 8 |
-			  cfi_read_query(map, base + 0xf * ofs_factor);
-
-	/* Put it back into Read Mode */
-	cfi_qry_mode_off(base, map, cfi);
-	xip_allowed(base, map);
-
 	/* Do any necessary byteswapping */
 	cfi->cfiq->P_ID = le16_to_cpu(cfi->cfiq->P_ID);
 
@@ -228,9 +209,57 @@
 #endif
 	}
 
-	printk(KERN_INFO "%s: Found %d x%d devices at 0x%x in %d-bit bank\n",
+	if (cfi->cfiq->P_ID == P_ID_SST_OLD) {
+		addr_unlock1 = 0x5555;
+		addr_unlock2 = 0x2AAA;
+	}
+
+	/*
+	 * Note we put the device back into Read Mode BEFORE going into Auto
+	 * Select Mode, as some devices support nesting of modes, others
+	 * don't. This way should always work.
+	 * On cmdset 0001 the writes of 0xaa and 0x55 are not needed, and
+	 * so should be treated as nops or illegal (and so put the device
+	 * back into Read Mode, which is a nop in this case).
+	 */
+	cfi_send_gen_cmd(0xf0,     0, base, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0xaa, addr_unlock1, base, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x55, addr_unlock2, base, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x90, addr_unlock1, base, map, cfi, cfi->device_type, NULL);
+	cfi->mfr = cfi_read_query16(map, base);
+	cfi->id = cfi_read_query16(map, base + ofs_factor);
+        
+	/* Get device ID cycle 1,2,3 for Micron/ST devices */
+	if ((cfi->mfr == CFI_MFR_NMX || cfi->mfr == CFI_MFR_ST)
+			&& ((cfi->id & 0xff) == 0x7e)
+			&& (le16_to_cpu(cfi->cfiq->P_ID) == 0x0002)) {
+		extendedId1 = cfi_read_query16(map, base + 0x1 * ofs_factor);
+		extendedId2 = cfi_read_query16(map, base + 0xe * ofs_factor);
+		extendedId3 = cfi_read_query16(map, base + 0xf * ofs_factor);
+	}
+        
+	/* If the device is a M29EW used in 8-bit mode, adjust buffer size */
+	if (	(cfi->cfiq->MaxBufWriteSize > 0x8) &&
+		(cfi->mfr == CFI_MFR_NMX || cfi->mfr == CFI_MFR_ST) &&
+		(extendedId1 == 0x7E) &&
+		(extendedId2 == 0x22 || extendedId2 == 0x23 || extendedId2 == 0x28) &&
+		(extendedId3 == 0x01)) {
+		cfi->cfiq->MaxBufWriteSize = 0x8;
+		pr_warning("Adjusted buffer size on Micron Flash M29EW family in 8 bit mode\n");
+	}
+
+	/* Get AMD/Spansion extended JEDEC ID */
+	if (cfi->mfr == CFI_MFR_AMD && (cfi->id & 0xff) == 0x7e)
+		cfi->id = cfi_read_query(map, base + 0xe * ofs_factor) << 8 |
+			  cfi_read_query(map, base + 0xf * ofs_factor);
+
+	/* Put it back into Read Mode */
+	cfi_qry_mode_off(base, map, cfi);
+	xip_allowed(base, map);
+
+	printk(KERN_INFO "%s: Found %d x%d devices at 0x%x in %d-bit bank. ID is 0x%x. Mfr is 0x%x\n",
 	       map->name, cfi->interleave, cfi->device_type*8, base,
-	       map->bankwidth*8);
+	       map->bankwidth*8, cfi->id, cfi->mfr);
 
 	return 1;
 }
@@ -269,6 +298,9 @@
 	case P_ID_SST_PAGE:
 		return "SST Page Write";
 
+	case P_ID_SST_OLD:
+		return "SST 39VF160x/39VF320x";
+
 	case P_ID_INTEL_PERFORMANCE:
 		return "Intel Performance Code";
 
diff -Naur pico_2.6.28/drivers/mtd/chips/cfi_util.c ipa_2.6.28/drivers/mtd/chips/cfi_util.c
--- pico_2.6.28/drivers/mtd/chips/cfi_util.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/drivers/mtd/chips/cfi_util.c	2011-04-26 14:51:35.000000000 +0100
@@ -71,6 +71,13 @@
 	cfi_send_gen_cmd(0x98, 0x555, base, map, cfi, cfi->device_type, NULL);
 	if (cfi_qry_present(map, base, cfi))
 		return 1;
+	/* some old SST chips, e.g. 39VF160x/39VF320x */
+	cfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0xAA, 0x5555, base, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x55, 0x2AAA, base, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x98, 0x5555, base, map, cfi, cfi->device_type, NULL);
+	if (cfi_qry_present(map, base, cfi))
+		return 1;
 	/* QRY not found */
 	return 0;
 }
@@ -81,6 +88,10 @@
 {
 	cfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);
 	cfi_send_gen_cmd(0xFF, 0, base, map, cfi, cfi->device_type, NULL);
+	/* M29W128G flashes require an additional reset command
+	   when exit qry mode */
+	if ((cfi->mfr == CFI_MFR_ST) && (cfi->id == 0x227E || cfi->id == 0x7E))
+		cfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);
 }
 EXPORT_SYMBOL_GPL(cfi_qry_mode_off);
 
@@ -93,10 +104,11 @@
 	int i;
 	struct cfi_extquery *extp = NULL;
 
-	printk(" %s Extended Query Table at 0x%4.4X\n", name, adr);
 	if (!adr)
 		goto out;
 
+	printk(KERN_INFO "%s Extended Query Table at 0x%4.4X\n", name, adr);
+
 	extp = kmalloc(size, GFP_KERNEL);
 	if (!extp) {
 		printk(KERN_ERR "Failed to allocate memory\n");
diff -Naur pico_2.6.28/drivers/mtd/chips/fwh_lock.h ipa_2.6.28/drivers/mtd/chips/fwh_lock.h
--- pico_2.6.28/drivers/mtd/chips/fwh_lock.h	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/drivers/mtd/chips/fwh_lock.h	2011-04-26 14:51:35.000000000 +0100
@@ -58,10 +58,10 @@
 	 * to flash memory - that means that we don't have to check status
 	 * and timeout.
 	 */
-	spin_lock(chip->mutex);
+	mutex_lock(&chip->mutex);
 	ret = get_chip(map, chip, adr, FL_LOCKING);
 	if (ret) {
-		spin_unlock(chip->mutex);
+		mutex_unlock(&chip->mutex);
 		return ret;
 	}
 
@@ -72,7 +72,7 @@
 	/* Done and happy. */
 	chip->state = chip->oldstate;
 	put_chip(map, chip, adr);
-	spin_unlock(chip->mutex);
+	mutex_unlock(&chip->mutex);
 	return 0;
 }
 
diff -Naur pico_2.6.28/drivers/mtd/chips/gen_probe.c ipa_2.6.28/drivers/mtd/chips/gen_probe.c
--- pico_2.6.28/drivers/mtd/chips/gen_probe.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/drivers/mtd/chips/gen_probe.c	2011-04-26 14:51:35.000000000 +0100
@@ -155,8 +155,7 @@
 			pchip->start = (i << cfi.chipshift);
 			pchip->state = FL_READY;
 			init_waitqueue_head(&pchip->wq);
-			spin_lock_init(&pchip->_spinlock);
-			pchip->mutex = &pchip->_spinlock;
+			mutex_init(&pchip->mutex);
 		}
 	}
 
@@ -242,17 +241,19 @@
 		/* We need these for the !CONFIG_MODULES case,
 		   because symbol_get() doesn't work there */
 #ifdef CONFIG_MTD_CFI_INTELEXT
-	case 0x0001:
-	case 0x0003:
-	case 0x0200:
+	case P_ID_INTEL_EXT:
+	case P_ID_INTEL_STD:
+	case P_ID_INTEL_PERFORMANCE:
 		return cfi_cmdset_0001(map, primary);
 #endif
 #ifdef CONFIG_MTD_CFI_AMDSTD
-	case 0x0002:
+	case P_ID_AMD_STD:
+	case P_ID_SST_OLD:
+	case P_ID_WINBOND:
 		return cfi_cmdset_0002(map, primary);
 #endif
 #ifdef CONFIG_MTD_CFI_STAA
-        case 0x0020:
+        case P_ID_ST_ADV:
 		return cfi_cmdset_0020(map, primary);
 #endif
 	default:
diff -Naur pico_2.6.28/drivers/mtd/chips/jedec_probe.c ipa_2.6.28/drivers/mtd/chips/jedec_probe.c
--- pico_2.6.28/drivers/mtd/chips/jedec_probe.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/drivers/mtd/chips/jedec_probe.c	2011-04-26 14:51:35.000000000 +0100
@@ -22,24 +22,6 @@
 #include <linux/mtd/cfi.h>
 #include <linux/mtd/gen_probe.h>
 
-/* Manufacturers */
-#define MANUFACTURER_AMD	0x0001
-#define MANUFACTURER_ATMEL	0x001f
-#define MANUFACTURER_EON	0x001c
-#define MANUFACTURER_FUJITSU	0x0004
-#define MANUFACTURER_HYUNDAI	0x00AD
-#define MANUFACTURER_INTEL	0x0089
-#define MANUFACTURER_MACRONIX	0x00C2
-#define MANUFACTURER_NEC	0x0010
-#define MANUFACTURER_PMC	0x009D
-#define MANUFACTURER_SHARP	0x00b0
-#define MANUFACTURER_SST	0x00BF
-#define MANUFACTURER_ST		0x0020
-#define MANUFACTURER_TOSHIBA	0x0098
-#define MANUFACTURER_WINBOND	0x00da
-#define CONTINUATION_CODE	0x007f
-
-
 /* AMD */
 #define AM29DL800BB	0x22CB
 #define AM29DL800BT	0x224A
@@ -111,6 +93,11 @@
 #define I28F320B3B	0x8897
 #define I28F640B3T	0x8898
 #define I28F640B3B	0x8899
+#define I28F640C3B	0x88CD
+#define I28F160F3T	0x88F3
+#define I28F160F3B	0x88F4
+#define I28F160C3T	0x88C2
+#define I28F160C3B	0x88C3
 #define I82802AB	0x00ad
 #define I82802AC	0x00ac
 
@@ -137,8 +124,8 @@
 
 /* ST - www.st.com */
 #define M29F800AB	0x0058
-#define M29W800DT	0x00D7
-#define M29W800DB	0x005B
+#define M29W800DT	0x22D7
+#define M29W800DB	0x225B
 #define M29W400DT	0x00EE
 #define M29W400DB	0x00EF
 #define M29W160DT	0x22C4
@@ -150,6 +137,7 @@
 #define M50LPW080       0x002F
 #define M50FLW080A	0x0080
 #define M50FLW080B	0x0081
+#define PSD4256G6V	0x00e9
 
 /* SST */
 #define SST29EE020	0x0010
@@ -159,12 +147,16 @@
 #define SST39LF800	0x2781
 #define SST39LF160	0x2782
 #define SST39VF1601	0x234b
+#define SST39VF3201	0x235b
+#define SST39WF1601	0x274b
+#define SST39WF1602	0x274a
 #define SST39LF512	0x00D4
 #define SST39LF010	0x00D5
 #define SST39LF020	0x00D6
 #define SST39LF040	0x00D7
 #define SST39SF010A	0x00B5
 #define SST39SF020A	0x00B6
+#define SST39SF040	0x00B7
 #define SST49LF004B	0x0060
 #define SST49LF040B	0x0050
 #define SST49LF008A	0x005a
@@ -199,6 +191,7 @@
 	MTD_UADDR_0x0555_0x02AA,
 	MTD_UADDR_0x0555_0x0AAA,
 	MTD_UADDR_0x5555_0x2AAA,
+	MTD_UADDR_0x0AAA_0x0554,
 	MTD_UADDR_0x0AAA_0x0555,
 	MTD_UADDR_0xAAAA_0x5555,
 	MTD_UADDR_DONT_CARE,		/* Requires an arbitrary address */
@@ -217,7 +210,7 @@
  * exists, but is for MTD_UADDR_NOT_SUPPORTED - and, therefore,
  * should not be used.  The  problem is that structures with
  * initializers have extra fields initialized to 0.  It is _very_
- * desireable to have the unlock address entries for unsupported
+ * desirable to have the unlock address entries for unsupported
  * data widths automatically initialized - that means that
  * MTD_UADDR_NOT_SUPPORTED must be 0 and the first entry here
  * must go unused.
@@ -243,6 +236,11 @@
 		.addr2 = 0x2aaa
 	},
 
+	[MTD_UADDR_0x0AAA_0x0554] = {
+		.addr1 = 0x0AAA,
+		.addr2 = 0x0554
+	},
+
 	[MTD_UADDR_0x0AAA_0x0555] = {
 		.addr1 = 0x0AAA,
 		.addr2 = 0x0555
@@ -295,7 +293,7 @@
  */
 static const struct amd_flash_info jedec_table[] = {
 	{
-		.mfr_id		= MANUFACTURER_AMD,
+		.mfr_id		= CFI_MFR_AMD,
 		.dev_id		= AM29F032B,
 		.name		= "AMD AM29F032B",
 		.uaddr		= MTD_UADDR_0x0555_0x02AA,
@@ -307,7 +305,7 @@
 			ERASEINFO(0x10000,64)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_AMD,
+		.mfr_id		= CFI_MFR_AMD,
 		.dev_id		= AM29LV160DT,
 		.name		= "AMD AM29LV160DT",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -322,7 +320,7 @@
 			ERASEINFO(0x04000,1)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_AMD,
+		.mfr_id		= CFI_MFR_AMD,
 		.dev_id		= AM29LV160DB,
 		.name		= "AMD AM29LV160DB",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -337,7 +335,7 @@
 			ERASEINFO(0x10000,31)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_AMD,
+		.mfr_id		= CFI_MFR_AMD,
 		.dev_id		= AM29LV400BB,
 		.name		= "AMD AM29LV400BB",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -352,7 +350,7 @@
 			ERASEINFO(0x10000,7)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_AMD,
+		.mfr_id		= CFI_MFR_AMD,
 		.dev_id		= AM29LV400BT,
 		.name		= "AMD AM29LV400BT",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -367,7 +365,7 @@
 			ERASEINFO(0x04000,1)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_AMD,
+		.mfr_id		= CFI_MFR_AMD,
 		.dev_id		= AM29LV800BB,
 		.name		= "AMD AM29LV800BB",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -383,7 +381,7 @@
 		}
 	}, {
 /* add DL */
-		.mfr_id		= MANUFACTURER_AMD,
+		.mfr_id		= CFI_MFR_AMD,
 		.dev_id		= AM29DL800BB,
 		.name		= "AMD AM29DL800BB",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -400,7 +398,7 @@
 			ERASEINFO(0x10000,14)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_AMD,
+		.mfr_id		= CFI_MFR_AMD,
 		.dev_id		= AM29DL800BT,
 		.name		= "AMD AM29DL800BT",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -417,7 +415,7 @@
 			ERASEINFO(0x04000,1)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_AMD,
+		.mfr_id		= CFI_MFR_AMD,
 		.dev_id		= AM29F800BB,
 		.name		= "AMD AM29F800BB",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -432,7 +430,7 @@
 			ERASEINFO(0x10000,15),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_AMD,
+		.mfr_id		= CFI_MFR_AMD,
 		.dev_id		= AM29LV800BT,
 		.name		= "AMD AM29LV800BT",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -447,7 +445,7 @@
 			ERASEINFO(0x04000,1)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_AMD,
+		.mfr_id		= CFI_MFR_AMD,
 		.dev_id		= AM29F800BT,
 		.name		= "AMD AM29F800BT",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -462,7 +460,7 @@
 			ERASEINFO(0x04000,1)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_AMD,
+		.mfr_id		= CFI_MFR_AMD,
 		.dev_id		= AM29F017D,
 		.name		= "AMD AM29F017D",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -474,7 +472,7 @@
 			ERASEINFO(0x10000,32),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_AMD,
+		.mfr_id		= CFI_MFR_AMD,
 		.dev_id		= AM29F016D,
 		.name		= "AMD AM29F016D",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -486,7 +484,7 @@
 			ERASEINFO(0x10000,32),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_AMD,
+		.mfr_id		= CFI_MFR_AMD,
 		.dev_id		= AM29F080,
 		.name		= "AMD AM29F080",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -498,7 +496,7 @@
 			ERASEINFO(0x10000,16),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_AMD,
+		.mfr_id		= CFI_MFR_AMD,
 		.dev_id		= AM29F040,
 		.name		= "AMD AM29F040",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -510,7 +508,7 @@
 			ERASEINFO(0x10000,8),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_AMD,
+		.mfr_id		= CFI_MFR_AMD,
 		.dev_id		= AM29LV040B,
 		.name		= "AMD AM29LV040B",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -522,7 +520,7 @@
 			ERASEINFO(0x10000,8),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_AMD,
+		.mfr_id		= CFI_MFR_AMD,
 		.dev_id		= AM29F002T,
 		.name		= "AMD AM29F002T",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -537,7 +535,7 @@
 			ERASEINFO(0x04000,1),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_AMD,
+		.mfr_id		= CFI_MFR_AMD,
 		.dev_id		= AM29SL800DT,
 		.name		= "AMD AM29SL800DT",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -552,7 +550,7 @@
 			ERASEINFO(0x04000,1),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_AMD,
+		.mfr_id		= CFI_MFR_AMD,
 		.dev_id		= AM29SL800DB,
 		.name		= "AMD AM29SL800DB",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -567,7 +565,7 @@
 			ERASEINFO(0x10000,15),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_ATMEL,
+		.mfr_id		= CFI_MFR_ATMEL,
 		.dev_id		= AT49BV512,
 		.name		= "Atmel AT49BV512",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -579,7 +577,7 @@
 			ERASEINFO(0x10000,1)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_ATMEL,
+		.mfr_id		= CFI_MFR_ATMEL,
 		.dev_id		= AT29LV512,
 		.name		= "Atmel AT29LV512",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -592,7 +590,7 @@
 			ERASEINFO(0x80,256)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_ATMEL,
+		.mfr_id		= CFI_MFR_ATMEL,
 		.dev_id		= AT49BV16X,
 		.name		= "Atmel AT49BV16X",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -605,7 +603,7 @@
 			ERASEINFO(0x10000,31)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_ATMEL,
+		.mfr_id		= CFI_MFR_ATMEL,
 		.dev_id		= AT49BV16XT,
 		.name		= "Atmel AT49BV16XT",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -618,7 +616,7 @@
 			ERASEINFO(0x02000,8)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_ATMEL,
+		.mfr_id		= CFI_MFR_ATMEL,
 		.dev_id		= AT49BV32X,
 		.name		= "Atmel AT49BV32X",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -631,7 +629,7 @@
 			ERASEINFO(0x10000,63)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_ATMEL,
+		.mfr_id		= CFI_MFR_ATMEL,
 		.dev_id		= AT49BV32XT,
 		.name		= "Atmel AT49BV32XT",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -644,7 +642,7 @@
 			ERASEINFO(0x02000,8)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_EON,
+		.mfr_id		= CFI_MFR_EON,
 		.dev_id		= EN29SL800BT,
 		.name		= "Eon EN29SL800BT",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -659,7 +657,7 @@
 			ERASEINFO(0x04000,1),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_EON,
+		.mfr_id		= CFI_MFR_EON,
 		.dev_id		= EN29SL800BB,
 		.name		= "Eon EN29SL800BB",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -674,7 +672,7 @@
 			ERASEINFO(0x10000,15),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_FUJITSU,
+		.mfr_id		= CFI_MFR_FUJITSU,
 		.dev_id		= MBM29F040C,
 		.name		= "Fujitsu MBM29F040C",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -686,7 +684,7 @@
 			ERASEINFO(0x10000,8)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_FUJITSU,
+		.mfr_id		= CFI_MFR_FUJITSU,
 		.dev_id		= MBM29F800BA,
 		.name		= "Fujitsu MBM29F800BA",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -701,7 +699,7 @@
 			ERASEINFO(0x10000,15),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_FUJITSU,
+		.mfr_id		= CFI_MFR_FUJITSU,
 		.dev_id		= MBM29LV650UE,
 		.name		= "Fujitsu MBM29LV650UE",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -713,7 +711,7 @@
 			ERASEINFO(0x10000,128)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_FUJITSU,
+		.mfr_id		= CFI_MFR_FUJITSU,
 		.dev_id		= MBM29LV320TE,
 		.name		= "Fujitsu MBM29LV320TE",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -726,7 +724,7 @@
 			ERASEINFO(0x02000,8)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_FUJITSU,
+		.mfr_id		= CFI_MFR_FUJITSU,
 		.dev_id		= MBM29LV320BE,
 		.name		= "Fujitsu MBM29LV320BE",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -739,7 +737,7 @@
 			ERASEINFO(0x10000,63)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_FUJITSU,
+		.mfr_id		= CFI_MFR_FUJITSU,
 		.dev_id		= MBM29LV160TE,
 		.name		= "Fujitsu MBM29LV160TE",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -754,7 +752,7 @@
 			ERASEINFO(0x04000,1)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_FUJITSU,
+		.mfr_id		= CFI_MFR_FUJITSU,
 		.dev_id		= MBM29LV160BE,
 		.name		= "Fujitsu MBM29LV160BE",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -769,7 +767,7 @@
 			ERASEINFO(0x10000,31)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_FUJITSU,
+		.mfr_id		= CFI_MFR_FUJITSU,
 		.dev_id		= MBM29LV800BA,
 		.name		= "Fujitsu MBM29LV800BA",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -784,7 +782,7 @@
 			ERASEINFO(0x10000,15)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_FUJITSU,
+		.mfr_id		= CFI_MFR_FUJITSU,
 		.dev_id		= MBM29LV800TA,
 		.name		= "Fujitsu MBM29LV800TA",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -799,7 +797,7 @@
 			ERASEINFO(0x04000,1)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_FUJITSU,
+		.mfr_id		= CFI_MFR_FUJITSU,
 		.dev_id		= MBM29LV400BC,
 		.name		= "Fujitsu MBM29LV400BC",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -814,7 +812,7 @@
 			ERASEINFO(0x10000,7)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_FUJITSU,
+		.mfr_id		= CFI_MFR_FUJITSU,
 		.dev_id		= MBM29LV400TC,
 		.name		= "Fujitsu MBM29LV400TC",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -829,7 +827,7 @@
 			ERASEINFO(0x04000,1)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_HYUNDAI,
+		.mfr_id		= CFI_MFR_HYUNDAI,
 		.dev_id		= HY29F002T,
 		.name		= "Hyundai HY29F002T",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -844,7 +842,7 @@
 			ERASEINFO(0x04000,1),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_INTEL,
+		.mfr_id		= CFI_MFR_INTEL,
 		.dev_id		= I28F004B3B,
 		.name		= "Intel 28F004B3B",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -857,7 +855,7 @@
 			ERASEINFO(0x10000, 7),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_INTEL,
+		.mfr_id		= CFI_MFR_INTEL,
 		.dev_id		= I28F004B3T,
 		.name		= "Intel 28F004B3T",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -870,7 +868,7 @@
 			ERASEINFO(0x02000, 8),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_INTEL,
+		.mfr_id		= CFI_MFR_INTEL,
 		.dev_id		= I28F400B3B,
 		.name		= "Intel 28F400B3B",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -883,7 +881,7 @@
 			ERASEINFO(0x10000, 7),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_INTEL,
+		.mfr_id		= CFI_MFR_INTEL,
 		.dev_id		= I28F400B3T,
 		.name		= "Intel 28F400B3T",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -896,7 +894,7 @@
 			ERASEINFO(0x02000, 8),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_INTEL,
+		.mfr_id		= CFI_MFR_INTEL,
 		.dev_id		= I28F008B3B,
 		.name		= "Intel 28F008B3B",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -909,7 +907,7 @@
 			ERASEINFO(0x10000, 15),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_INTEL,
+		.mfr_id		= CFI_MFR_INTEL,
 		.dev_id		= I28F008B3T,
 		.name		= "Intel 28F008B3T",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -922,7 +920,7 @@
 			ERASEINFO(0x02000, 8),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_INTEL,
+		.mfr_id		= CFI_MFR_INTEL,
 		.dev_id		= I28F008S5,
 		.name		= "Intel 28F008S5",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -934,7 +932,7 @@
 			ERASEINFO(0x10000,16),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_INTEL,
+		.mfr_id		= CFI_MFR_INTEL,
 		.dev_id		= I28F016S5,
 		.name		= "Intel 28F016S5",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -946,7 +944,7 @@
 			ERASEINFO(0x10000,32),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_INTEL,
+		.mfr_id		= CFI_MFR_INTEL,
 		.dev_id		= I28F008SA,
 		.name		= "Intel 28F008SA",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -958,7 +956,7 @@
 			ERASEINFO(0x10000, 16),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_INTEL,
+		.mfr_id		= CFI_MFR_INTEL,
 		.dev_id		= I28F800B3B,
 		.name		= "Intel 28F800B3B",
 		.devtypes	= CFI_DEVICETYPE_X16,
@@ -971,7 +969,7 @@
 			ERASEINFO(0x10000, 15),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_INTEL,
+		.mfr_id		= CFI_MFR_INTEL,
 		.dev_id		= I28F800B3T,
 		.name		= "Intel 28F800B3T",
 		.devtypes	= CFI_DEVICETYPE_X16,
@@ -984,7 +982,7 @@
 			ERASEINFO(0x02000, 8),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_INTEL,
+		.mfr_id		= CFI_MFR_INTEL,
 		.dev_id		= I28F016B3B,
 		.name		= "Intel 28F016B3B",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -997,7 +995,7 @@
 			ERASEINFO(0x10000, 31),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_INTEL,
+		.mfr_id		= CFI_MFR_INTEL,
 		.dev_id		= I28F016S3,
 		.name		= "Intel I28F016S3",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1009,7 +1007,7 @@
 			ERASEINFO(0x10000, 32),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_INTEL,
+		.mfr_id		= CFI_MFR_INTEL,
 		.dev_id		= I28F016B3T,
 		.name		= "Intel 28F016B3T",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1022,7 +1020,7 @@
 			ERASEINFO(0x02000, 8),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_INTEL,
+		.mfr_id		= CFI_MFR_INTEL,
 		.dev_id		= I28F160B3B,
 		.name		= "Intel 28F160B3B",
 		.devtypes	= CFI_DEVICETYPE_X16,
@@ -1035,7 +1033,7 @@
 			ERASEINFO(0x10000, 31),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_INTEL,
+		.mfr_id		= CFI_MFR_INTEL,
 		.dev_id		= I28F160B3T,
 		.name		= "Intel 28F160B3T",
 		.devtypes	= CFI_DEVICETYPE_X16,
@@ -1048,7 +1046,7 @@
 			ERASEINFO(0x02000, 8),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_INTEL,
+		.mfr_id		= CFI_MFR_INTEL,
 		.dev_id		= I28F320B3B,
 		.name		= "Intel 28F320B3B",
 		.devtypes	= CFI_DEVICETYPE_X16,
@@ -1061,7 +1059,7 @@
 			ERASEINFO(0x10000, 63),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_INTEL,
+		.mfr_id		= CFI_MFR_INTEL,
 		.dev_id		= I28F320B3T,
 		.name		= "Intel 28F320B3T",
 		.devtypes	= CFI_DEVICETYPE_X16,
@@ -1074,7 +1072,7 @@
 			ERASEINFO(0x02000, 8),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_INTEL,
+		.mfr_id		= CFI_MFR_INTEL,
 		.dev_id		= I28F640B3B,
 		.name		= "Intel 28F640B3B",
 		.devtypes	= CFI_DEVICETYPE_X16,
@@ -1087,7 +1085,7 @@
 			ERASEINFO(0x10000, 127),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_INTEL,
+		.mfr_id		= CFI_MFR_INTEL,
 		.dev_id		= I28F640B3T,
 		.name		= "Intel 28F640B3T",
 		.devtypes	= CFI_DEVICETYPE_X16,
@@ -1100,7 +1098,20 @@
 			ERASEINFO(0x02000, 8),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_INTEL,
+		.mfr_id		= CFI_MFR_INTEL,
+		.dev_id		= I28F640C3B,
+		.name		= "Intel 28F640C3B",
+		.devtypes	= CFI_DEVICETYPE_X16,
+		.uaddr		= MTD_UADDR_UNNECESSARY,
+		.dev_size	= SIZE_8MiB,
+		.cmd_set	= P_ID_INTEL_STD,
+		.nr_regions	= 2,
+		.regions	= {
+			ERASEINFO(0x02000, 8),
+			ERASEINFO(0x10000, 127),
+		}
+	}, {
+		.mfr_id		= CFI_MFR_INTEL,
 		.dev_id		= I82802AB,
 		.name		= "Intel 82802AB",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1112,7 +1123,7 @@
 			ERASEINFO(0x10000,8),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_INTEL,
+		.mfr_id		= CFI_MFR_INTEL,
 		.dev_id		= I82802AC,
 		.name		= "Intel 82802AC",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1124,7 +1135,7 @@
 			ERASEINFO(0x10000,16),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_MACRONIX,
+		.mfr_id		= CFI_MFR_MACRONIX,
 		.dev_id		= MX29LV040C,
 		.name		= "Macronix MX29LV040C",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1136,7 +1147,7 @@
 			ERASEINFO(0x10000,8),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_MACRONIX,
+		.mfr_id		= CFI_MFR_MACRONIX,
 		.dev_id		= MX29LV160T,
 		.name		= "MXIC MX29LV160T",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -1151,11 +1162,11 @@
 			ERASEINFO(0x04000,1)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_NEC,
+		.mfr_id		= CFI_MFR_NEC,
 		.dev_id		= UPD29F064115,
 		.name		= "NEC uPD29F064115",
-		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
-		.uaddr		= MTD_UADDR_0x0555_0x02AA,	/* ???? */
+		.devtypes	= CFI_DEVICETYPE_X16,
+		.uaddr		= MTD_UADDR_0xAAAA_0x5555,
 		.dev_size	= SIZE_8MiB,
 		.cmd_set	= P_ID_AMD_STD,
 		.nr_regions	= 3,
@@ -1165,7 +1176,7 @@
 			ERASEINFO(0x2000,8),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_MACRONIX,
+		.mfr_id		= CFI_MFR_MACRONIX,
 		.dev_id		= MX29LV160B,
 		.name		= "MXIC MX29LV160B",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -1180,7 +1191,7 @@
 			ERASEINFO(0x10000,31)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_MACRONIX,
+		.mfr_id		= CFI_MFR_MACRONIX,
 		.dev_id		= MX29F040,
 		.name		= "Macronix MX29F040",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1192,7 +1203,7 @@
 			ERASEINFO(0x10000,8),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_MACRONIX,
+		.mfr_id		= CFI_MFR_MACRONIX,
 		.dev_id		= MX29F016,
 		.name		= "Macronix MX29F016",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1204,7 +1215,7 @@
 			ERASEINFO(0x10000,32),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_MACRONIX,
+		.mfr_id		= CFI_MFR_MACRONIX,
 		.dev_id		= MX29F004T,
 		.name		= "Macronix MX29F004T",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1219,7 +1230,7 @@
 			ERASEINFO(0x04000,1),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_MACRONIX,
+		.mfr_id		= CFI_MFR_MACRONIX,
 		.dev_id		= MX29F004B,
 		.name		= "Macronix MX29F004B",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1234,7 +1245,7 @@
 			ERASEINFO(0x10000,7),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_MACRONIX,
+		.mfr_id		= CFI_MFR_MACRONIX,
 		.dev_id		= MX29F002T,
 		.name		= "Macronix MX29F002T",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1249,7 +1260,7 @@
 			ERASEINFO(0x04000,1),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_PMC,
+		.mfr_id		= CFI_MFR_PMC,
 		.dev_id		= PM49FL002,
 		.name		= "PMC Pm49FL002",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1261,7 +1272,7 @@
 			ERASEINFO( 0x01000, 64 )
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_PMC,
+		.mfr_id		= CFI_MFR_PMC,
 		.dev_id		= PM49FL004,
 		.name		= "PMC Pm49FL004",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1273,7 +1284,7 @@
 			ERASEINFO( 0x01000, 128 )
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_PMC,
+		.mfr_id		= CFI_MFR_PMC,
 		.dev_id		= PM49FL008,
 		.name		= "PMC Pm49FL008",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1285,7 +1296,7 @@
 			ERASEINFO( 0x01000, 256 )
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_SHARP,
+		.mfr_id		= CFI_MFR_SHARP,
 		.dev_id		= LH28F640BF,
 		.name		= "LH28F640BF",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1297,7 +1308,7 @@
 			ERASEINFO(0x40000,16),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_SST,
+		.mfr_id		= CFI_MFR_SST,
 		.dev_id		= SST39LF512,
 		.name		= "SST 39LF512",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1309,7 +1320,7 @@
 			ERASEINFO(0x01000,16),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_SST,
+		.mfr_id		= CFI_MFR_SST,
 		.dev_id		= SST39LF010,
 		.name		= "SST 39LF010",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1321,8 +1332,8 @@
 			ERASEINFO(0x01000,32),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_SST,
- 		.dev_id 	= SST29EE020,
+		.mfr_id		= CFI_MFR_SST,
+		.dev_id		= SST29EE020,
 		.name		= "SST 29EE020",
 		.devtypes	= CFI_DEVICETYPE_X8,
 		.uaddr		= MTD_UADDR_0x5555_0x2AAA,
@@ -1332,9 +1343,9 @@
 		.regions = {ERASEINFO(0x01000,64),
 		}
 	}, {
- 		.mfr_id		= MANUFACTURER_SST,
+		.mfr_id		= CFI_MFR_SST,
 		.dev_id		= SST29LE020,
- 		.name		= "SST 29LE020",
+		.name		= "SST 29LE020",
 		.devtypes	= CFI_DEVICETYPE_X8,
 		.uaddr		= MTD_UADDR_0x5555_0x2AAA,
 		.dev_size	= SIZE_256KiB,
@@ -1343,7 +1354,7 @@
 		.regions = {ERASEINFO(0x01000,64),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_SST,
+		.mfr_id		= CFI_MFR_SST,
 		.dev_id		= SST39LF020,
 		.name		= "SST 39LF020",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1355,7 +1366,7 @@
 			ERASEINFO(0x01000,64),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_SST,
+		.mfr_id		= CFI_MFR_SST,
 		.dev_id		= SST39LF040,
 		.name		= "SST 39LF040",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1367,7 +1378,7 @@
 			ERASEINFO(0x01000,128),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_SST,
+		.mfr_id		= CFI_MFR_SST,
 		.dev_id		= SST39SF010A,
 		.name		= "SST 39SF010A",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1379,7 +1390,7 @@
 			ERASEINFO(0x01000,32),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_SST,
+		.mfr_id		= CFI_MFR_SST,
 		.dev_id		= SST39SF020A,
 		.name		= "SST 39SF020A",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1391,7 +1402,19 @@
 			ERASEINFO(0x01000,64),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_SST,
+		.mfr_id		= CFI_MFR_SST,
+		.dev_id		= SST39SF040,
+		.name		= "SST 39SF040",
+		.devtypes	= CFI_DEVICETYPE_X8,
+		.uaddr		= MTD_UADDR_0x5555_0x2AAA,
+		.dev_size	= SIZE_512KiB,
+		.cmd_set	= P_ID_AMD_STD,
+		.nr_regions	= 1,
+		.regions	= {
+			ERASEINFO(0x01000,128),
+		}
+	}, {
+		.mfr_id		= CFI_MFR_SST,
 		.dev_id		= SST49LF040B,
 		.name		= "SST 49LF040B",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1404,7 +1427,7 @@
 		}
 	}, {
 
-		.mfr_id		= MANUFACTURER_SST,
+		.mfr_id		= CFI_MFR_SST,
 		.dev_id		= SST49LF004B,
 		.name		= "SST 49LF004B",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1416,7 +1439,7 @@
 			ERASEINFO(0x01000,128),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_SST,
+		.mfr_id		= CFI_MFR_SST,
 		.dev_id		= SST49LF008A,
 		.name		= "SST 49LF008A",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1428,7 +1451,7 @@
 			ERASEINFO(0x01000,256),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_SST,
+		.mfr_id		= CFI_MFR_SST,
 		.dev_id		= SST49LF030A,
 		.name		= "SST 49LF030A",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1440,7 +1463,7 @@
 			ERASEINFO(0x01000,96),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_SST,
+		.mfr_id		= CFI_MFR_SST,
 		.dev_id		= SST49LF040A,
 		.name		= "SST 49LF040A",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1452,7 +1475,7 @@
 			ERASEINFO(0x01000,128),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_SST,
+		.mfr_id		= CFI_MFR_SST,
 		.dev_id		= SST49LF080A,
 		.name		= "SST 49LF080A",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1464,7 +1487,7 @@
 			ERASEINFO(0x01000,256),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_SST,     /* should be CFI */
+		.mfr_id		= CFI_MFR_SST,     /* should be CFI */
 		.dev_id		= SST39LF160,
 		.name		= "SST 39LF160",
 		.devtypes	= CFI_DEVICETYPE_X16,
@@ -1477,7 +1500,7 @@
 			ERASEINFO(0x1000,256)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_SST,     /* should be CFI */
+		.mfr_id		= CFI_MFR_SST,     /* should be CFI */
 		.dev_id		= SST39VF1601,
 		.name		= "SST 39VF1601",
 		.devtypes	= CFI_DEVICETYPE_X16,
@@ -1490,7 +1513,50 @@
 			ERASEINFO(0x1000,256)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_SST,
+		/* CFI is broken: reports AMD_STD, but needs custom uaddr */
+		.mfr_id		= CFI_MFR_SST,
+		.dev_id		= SST39WF1601,
+		.name		= "SST 39WF1601",
+		.devtypes	= CFI_DEVICETYPE_X16,
+		.uaddr		= MTD_UADDR_0xAAAA_0x5555,
+		.dev_size	= SIZE_2MiB,
+		.cmd_set	= P_ID_AMD_STD,
+		.nr_regions	= 2,
+		.regions	= {
+			ERASEINFO(0x1000,256),
+			ERASEINFO(0x1000,256)
+		}
+	}, {
+		/* CFI is broken: reports AMD_STD, but needs custom uaddr */
+		.mfr_id		= CFI_MFR_SST,
+		.dev_id		= SST39WF1602,
+		.name		= "SST 39WF1602",
+		.devtypes	= CFI_DEVICETYPE_X16,
+		.uaddr		= MTD_UADDR_0xAAAA_0x5555,
+		.dev_size	= SIZE_2MiB,
+		.cmd_set	= P_ID_AMD_STD,
+		.nr_regions	= 2,
+		.regions	= {
+			ERASEINFO(0x1000,256),
+			ERASEINFO(0x1000,256)
+		}
+	}, {
+		.mfr_id		= CFI_MFR_SST,     /* should be CFI */
+		.dev_id		= SST39VF3201,
+		.name		= "SST 39VF3201",
+		.devtypes	= CFI_DEVICETYPE_X16,
+		.uaddr		= MTD_UADDR_0xAAAA_0x5555,
+		.dev_size	= SIZE_4MiB,
+		.cmd_set	= P_ID_AMD_STD,
+		.nr_regions	= 4,
+		.regions	= {
+			ERASEINFO(0x1000,256),
+			ERASEINFO(0x1000,256),
+			ERASEINFO(0x1000,256),
+			ERASEINFO(0x1000,256)
+		}
+	}, {
+		.mfr_id		= CFI_MFR_SST,
 		.dev_id		= SST36VF3203,
 		.name		= "SST 36VF3203",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -1502,7 +1568,7 @@
 			ERASEINFO(0x10000,64),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_ST,
+		.mfr_id		= CFI_MFR_ST,
 		.dev_id		= M29F800AB,
 		.name		= "ST M29F800AB",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -1517,11 +1583,11 @@
 			ERASEINFO(0x10000,15),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_ST,	/* FIXME - CFI device? */
+		.mfr_id		= CFI_MFR_ST,	/* FIXME - CFI device? */
 		.dev_id		= M29W800DT,
 		.name		= "ST M29W800DT",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
-		.uaddr		= MTD_UADDR_0x5555_0x2AAA,	/* ???? */
+		.uaddr		= MTD_UADDR_0x0AAA_0x0555,
 		.dev_size	= SIZE_1MiB,
 		.cmd_set	= P_ID_AMD_STD,
 		.nr_regions	= 4,
@@ -1532,11 +1598,11 @@
 			ERASEINFO(0x04000,1)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_ST,	/* FIXME - CFI device? */
+		.mfr_id		= CFI_MFR_ST,	/* FIXME - CFI device? */
 		.dev_id		= M29W800DB,
 		.name		= "ST M29W800DB",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
-		.uaddr		= MTD_UADDR_0x5555_0x2AAA,	/* ???? */
+		.uaddr		= MTD_UADDR_0x0AAA_0x0555,
 		.dev_size	= SIZE_1MiB,
 		.cmd_set	= P_ID_AMD_STD,
 		.nr_regions	= 4,
@@ -1547,7 +1613,7 @@
 			ERASEINFO(0x10000,15)
 		}
 	},  {
-		.mfr_id         = MANUFACTURER_ST,
+		.mfr_id         = CFI_MFR_ST,
 		.dev_id         = M29W400DT,
 		.name           = "ST M29W400DT",
 		.devtypes       = CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -1562,7 +1628,7 @@
 			ERASEINFO(0x10000,1)
 		}
 	}, {
-		.mfr_id         = MANUFACTURER_ST,
+		.mfr_id         = CFI_MFR_ST,
 		.dev_id         = M29W400DB,
 		.name           = "ST M29W400DB",
 		.devtypes       = CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -1577,7 +1643,7 @@
 			ERASEINFO(0x10000,7)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_ST,	/* FIXME - CFI device? */
+		.mfr_id		= CFI_MFR_ST,	/* FIXME - CFI device? */
 		.dev_id		= M29W160DT,
 		.name		= "ST M29W160DT",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -1592,7 +1658,7 @@
 			ERASEINFO(0x04000,1)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_ST,	/* FIXME - CFI device? */
+		.mfr_id		= CFI_MFR_ST,	/* FIXME - CFI device? */
 		.dev_id		= M29W160DB,
 		.name		= "ST M29W160DB",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -1607,7 +1673,7 @@
 			ERASEINFO(0x10000,31)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_ST,
+		.mfr_id		= CFI_MFR_ST,
 		.dev_id		= M29W040B,
 		.name		= "ST M29W040B",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1619,7 +1685,7 @@
 			ERASEINFO(0x10000,8),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_ST,
+		.mfr_id		= CFI_MFR_ST,
 		.dev_id		= M50FW040,
 		.name		= "ST M50FW040",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1631,7 +1697,7 @@
 			ERASEINFO(0x10000,8),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_ST,
+		.mfr_id		= CFI_MFR_ST,
 		.dev_id		= M50FW080,
 		.name		= "ST M50FW080",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1643,7 +1709,7 @@
 			ERASEINFO(0x10000,16),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_ST,
+		.mfr_id		= CFI_MFR_ST,
 		.dev_id		= M50FW016,
 		.name		= "ST M50FW016",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1655,7 +1721,7 @@
 			ERASEINFO(0x10000,32),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_ST,
+		.mfr_id		= CFI_MFR_ST,
 		.dev_id		= M50LPW080,
 		.name		= "ST M50LPW080",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1667,7 +1733,7 @@
 			ERASEINFO(0x10000,16),
 		},
 	}, {
-		.mfr_id		= MANUFACTURER_ST,
+		.mfr_id		= CFI_MFR_ST,
 		.dev_id		= M50FLW080A,
 		.name		= "ST M50FLW080A",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1682,7 +1748,7 @@
 			ERASEINFO(0x1000,16),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_ST,
+		.mfr_id		= CFI_MFR_ST,
 		.dev_id		= M50FLW080B,
 		.name		= "ST M50FLW080B",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1697,7 +1763,19 @@
 			ERASEINFO(0x1000,16),
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_TOSHIBA,
+		.mfr_id		= 0xff00 | CFI_MFR_ST,
+		.dev_id		= 0xff00 | PSD4256G6V,
+		.name		= "ST PSD4256G6V",
+		.devtypes	= CFI_DEVICETYPE_X16,
+		.uaddr		= MTD_UADDR_0x0AAA_0x0554,
+		.dev_size	= SIZE_1MiB,
+		.cmd_set	= P_ID_AMD_STD,
+		.nr_regions	= 1,
+		.regions	= {
+			ERASEINFO(0x10000,16),
+		}
+	}, {
+		.mfr_id		= CFI_MFR_TOSHIBA,
 		.dev_id		= TC58FVT160,
 		.name		= "Toshiba TC58FVT160",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -1712,7 +1790,7 @@
 			ERASEINFO(0x04000,1)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_TOSHIBA,
+		.mfr_id		= CFI_MFR_TOSHIBA,
 		.dev_id		= TC58FVB160,
 		.name		= "Toshiba TC58FVB160",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -1727,7 +1805,7 @@
 			ERASEINFO(0x10000,31)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_TOSHIBA,
+		.mfr_id		= CFI_MFR_TOSHIBA,
 		.dev_id		= TC58FVB321,
 		.name		= "Toshiba TC58FVB321",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -1740,7 +1818,7 @@
 			ERASEINFO(0x10000,63)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_TOSHIBA,
+		.mfr_id		= CFI_MFR_TOSHIBA,
 		.dev_id		= TC58FVT321,
 		.name		= "Toshiba TC58FVT321",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -1753,7 +1831,7 @@
 			ERASEINFO(0x02000,8)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_TOSHIBA,
+		.mfr_id		= CFI_MFR_TOSHIBA,
 		.dev_id		= TC58FVB641,
 		.name		= "Toshiba TC58FVB641",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -1766,7 +1844,7 @@
 			ERASEINFO(0x10000,127)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_TOSHIBA,
+		.mfr_id		= CFI_MFR_TOSHIBA,
 		.dev_id		= TC58FVT641,
 		.name		= "Toshiba TC58FVT641",
 		.devtypes	= CFI_DEVICETYPE_X16|CFI_DEVICETYPE_X8,
@@ -1779,7 +1857,7 @@
 			ERASEINFO(0x02000,8)
 		}
 	}, {
-		.mfr_id		= MANUFACTURER_WINBOND,
+		.mfr_id		= CFI_MFR_WINBOND,
 		.dev_id		= W49V002A,
 		.name		= "Winbond W49V002A",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1812,7 +1890,7 @@
 		mask = (1 << (cfi->device_type * 8)) - 1;
 		result = map_read(map, base + ofs);
 		bank++;
-	} while ((result.x[0] & mask) == CONTINUATION_CODE);
+	} while ((result.x[0] & mask) == CFI_MFR_CONTINUATION);
 
 	return result.x[0] & mask;
 }
@@ -1903,7 +1981,7 @@
 	p_cfi->addr_unlock1 = unlock_addrs[uaddr].addr1 / p_cfi->device_type;
 	p_cfi->addr_unlock2 = unlock_addrs[uaddr].addr2 / p_cfi->device_type;
 
-	return 1; 	/* ok */
+	return 1;	/* ok */
 }
 
 
diff -Naur pico_2.6.28/drivers/mtd/mtdpart.c ipa_2.6.28/drivers/mtd/mtdpart.c
--- pico_2.6.28/drivers/mtd/mtdpart.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/drivers/mtd/mtdpart.c	2011-04-26 14:51:35.000000000 +0100
@@ -434,7 +434,8 @@
 		for (i = 0; i < max && regions[i].offset <= slave->offset; i++)
 			;
 		/* The loop searched for the region _behind_ the first one */
-		i--;
+		if (i > 0)
+			i--;
 
 		/* Pick biggest erasesize */
 		for (; i < max && regions[i].offset < end; i++) {
diff -Naur pico_2.6.28/drivers/net/Kconfig ipa_2.6.28/drivers/net/Kconfig
--- pico_2.6.28/drivers/net/Kconfig	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/drivers/net/Kconfig	2011-04-26 14:51:35.000000000 +0100
@@ -223,6 +223,13 @@
 	depends on ARCH_PC302
 	help
           This driver provides Ethernet support for the picoChip PC302 device.
+
+config PC302_MICREL_VLAN_SWITCH
+       depends on PC302_EMAC && I2C
+       bool "Micrel KSZ8863/8873 is fitted"
+       help
+         Select this if the Micrel KSZ8863/8873 VLAN switch is fitted.
+         The switch will provide the Ethernet PHY, configured via I2C
           
 source "drivers/net/arm/Kconfig"
 
diff -Naur pico_2.6.28/drivers/net/Makefile ipa_2.6.28/drivers/net/Makefile
--- pico_2.6.28/drivers/net/Makefile	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/drivers/net/Makefile	2011-04-26 14:51:35.000000000 +0100
@@ -230,7 +230,8 @@
 obj-$(CONFIG_XTENSA_XT2000_SONIC) += xtsonic.o
 
 obj-$(CONFIG_MACB) += macb.o
-obj-$(CONFIG_PC302_EMAC) += pc302_emac.o
+obj-$(CONFIG_PC302_EMAC) += pc302_emac_ipa.o
+pc302_emac_ipa-objs := pc302_emac.o pc302_i2c_phy.o
 
 obj-$(CONFIG_ARM) += arm/
 obj-$(CONFIG_DEV_APPLETALK) += appletalk/
diff -Naur pico_2.6.28/drivers/net/pc302_emac.c ipa_2.6.28/drivers/net/pc302_emac.c
--- pico_2.6.28/drivers/net/pc302_emac.c	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/drivers/net/pc302_emac.c	2011-04-26 14:51:35.000000000 +0100
@@ -11,6 +11,7 @@
  * (macb.c/h) Copyright (C) 2004-2006 Atmel Corporation.
  *
  * Copyright (c) 2008 picoChip Designs Ltd.
+ * Copyright (c) 2010 ip.access Ltd.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -33,7 +34,11 @@
 #include <linux/dma-mapping.h>
 #include <linux/autoconf.h>
 #include <linux/sysfs.h>
+#include <linux/if_vlan.h>
 #include "pc302_emac.h"
+#ifdef CONFIG_PC302_MICREL_VLAN_SWITCH
+#include "pc302_i2c_phy.h"
+#endif /* CONFIG_PC302_MICREL_VLAN_SWITCH */
 
 /* Required for hw timestamping */
 #include <net/timestamping.h>
@@ -142,14 +147,20 @@
 
     struct mii_bus	    *mii_bus;
     struct phy_device	    *phy_dev;
+    int                     phy_probed;
     int 	            link;
     int 	            speed;
     int 	            duplex;
 
+    int hwaddr_failure;
+    
     /* Used to indicate whether hw timestamping
        of received packets is required or not */
     unsigned int            hw_timestamp_flag;
 
+    /* For VLAN */
+    struct vlan_group *vlgrp;
+
     /* Cache of tx buffers. */
     struct dma_pool         *tx_buf_pool;
 };
@@ -251,6 +262,15 @@
                                  | EMAC_ENABLE_RX_USED_BIT_READ	\
 				 | EMAC_ENABLE_RX_OVERRUN)
 
+#define EMAC_TX_INT_FLAGS    ( EMAC_ENABLE_TX_COMPLETE \
+                             | EMAC_ENABLE_TX_BUFF_UNDERRUN \
+                             | EMAC_ENABLE_RETRY_LIMIT_EXCEEDED \
+                             | EMAC_ENABLE_TRANSMIT_CORRUPTION_AHB_ERROR )
+
+#define EMAC_TX_ERROR_FLAGS  ( EMAC_TRANSMIT_UNDERRUN \
+                             | EMAC_TRANSMIT_CORRUPTION_AHB_ERROR \
+                             | EMAC_TRANSMIT_RETRY_LIMIT_EXCEEDED )
+                             
 /*!
  * Define the size (in bytes) of the received frame checksum (CRC)
  */
@@ -303,6 +323,17 @@
 pc302emac_get_hwaddr(struct net_device *dev);
 
 /*!
+ * Read the EMAC hardware for a MAC address. We expect this to
+ * have been setup by the bootloader.
+ * Confirm that this matches the MAC address we programmed.If this MAC address is valid we'll use it. If not, the
+ *
+ * \param dev A pointer to the net_device structure.
+ */
+static void
+pc302emac_check_hwaddr(struct net_device *dev);
+
+#ifndef CONFIG_PC302_MICREL_VLAN_SWITCH
+/*!
  * Read from an Ethernet Phy conneccted to the EMAC management bus.
  *
  * \param bus A pointer to the mii_bus structure.
@@ -373,6 +404,7 @@
  */
 static int
 pc302emac_mii_init(struct net_device *dev);
+#endif /* ! CONFIG_PC302_MICREL_VLAN_SWITCH */
 
 /*!
  * Update the statistics counters located in the private driver structure,
@@ -795,6 +827,10 @@
 static int
 emac_drv_remove(struct platform_device *pdev);
 
+static void emac_vlan_rx_register(struct net_device *dev, struct vlan_group *grp);
+
+static void emac_vlan_rx_kill_vid(struct net_device *dev, uint16_t vid);
+
 /*!
  * Module initialisation function.
  *
@@ -835,9 +871,26 @@
 static void
 pc302emac_set_hwaddr(struct net_device *dev)
 {
+    struct pc302_emac *priv = netdev_priv(dev);
     u32 bottom = 0;
     u32 top = 0;
+    u32 old_bottom = 0;
+    u32 old_top = 0;
 
+    /* Obtain bytes 1-4 of the MAC address from the EMAC hardware */
+    old_bottom = emac_ioread32(dev, EMAC_SPEC_ADDR_1_BOT_31_0_REG_OFFSET);
+    
+    /* Obtain bytes 5-6 of the MAC address from the EMAC hardware */
+    old_top = emac_ioread32(dev, EMAC_SPEC_ADDR_1_TOP_47_32_REG_OFFSET);
+    
+    printk("MAC to be written to HW is %02X:%02X:%02X:%02X:%02X:%02X in pid=%d (%s)\n",
+        dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
+        dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5],
+        current->pid, current->comm);
+        
+    printk("MAC bottom register was %08X\n", old_bottom);
+    printk("MAC top register was %04X\n", old_top);
+    
     /* Obtain the least significant 4 bytes of the MAC address from dev */
     bottom = dev->dev_addr[3] << 24 |
              dev->dev_addr[2] << 16 |
@@ -848,26 +901,39 @@
     top = dev->dev_addr[5] << 8 |
           dev->dev_addr[4];
 
+    printk("MAC bottom register will be %08X\n", bottom);
+    
     /* Program the EMAC Specific Address #1 'bottom' register */
     emac_iowrite32(dev, bottom, EMAC_SPEC_ADDR_1_BOT_31_0_REG_OFFSET);
 
+    printk("MAC top register will be %04X\n", top);
+    
     /* Program the EMAC Specific Address #1 'top' register */
     emac_iowrite32(dev, (u32)top, EMAC_SPEC_ADDR_1_TOP_47_32_REG_OFFSET);
+        
+    show_stack(0, NULL);
+    
+    priv->hwaddr_failure = 0;
 }
 
 static void
 pc302emac_get_hwaddr(struct net_device *dev)
 {
+    struct pc302_emac *priv = netdev_priv(dev);
     u32 bottom = 0;
     u16 top = 0;
     u8 addr[ETH_ALEN];
 
     /* Obtain bytes 1-4 of the MAC address from the EMAC hardware */
     bottom = emac_ioread32(dev, EMAC_SPEC_ADDR_1_BOT_31_0_REG_OFFSET);
+    
+    printk("MAC bottom register was %08X\n", bottom);
 
     /* Obtain bytes 5-6 of the MAC address from the EMAC hardware */
     top = emac_ioread32(dev, EMAC_SPEC_ADDR_1_TOP_47_32_REG_OFFSET);
 
+    printk("MAC top register was %04X\n", top);
+
     addr[0] = bottom & 0xff;
     addr[1] = (bottom >> 8) & 0xff;
     addr[2] = (bottom >> 16) & 0xff;
@@ -875,22 +941,74 @@
     addr[4] = top & 0xff;
     addr[5] = (top >> 8) & 0xff;
 
+    printk("MAC read from HW is %02X:%02X:%02X:%02X:%02X:%02X in pid=%d (%s)\n",
+        addr[0], addr[1], addr[2],
+        addr[3], addr[4], addr[5],
+        current->pid, current->comm);
+    
     if (is_valid_ether_addr(addr))
     {
-	/* We have read a valid MAC address from the EMAC hardware,
+    /* We have read a valid MAC address from the EMAC hardware,
            copy it into the net_device structure */
         memcpy(dev->dev_addr, addr, ETH_ALEN);
     }
     else
     {
-	/* We have read an invalid MAC address from the EMAC hardware,
+    /* We have read an invalid MAC address from the EMAC hardware,
            use the default instead */
         printk(KERN_INFO "%s: invalid MAC address read from hardware, "
                          "using default\n", dev->name);
-	memcpy(dev->dev_addr, default_mac_address, ETH_ALEN);
+    memcpy(dev->dev_addr, default_mac_address, ETH_ALEN);
+    }
+    
+    printk("MAC saved in struct net_device is %02X:%02X:%02X:%02X:%02X:%02X\n",
+        dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
+        dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5]);
+        
+    show_stack(0, NULL);
+    
+    priv->hwaddr_failure = 0;
+}
+
+static void
+pc302emac_check_hwaddr(struct net_device *dev)
+{
+    static int last_pid = -1;
+    struct pc302_emac *priv = netdev_priv(dev);
+    u32 bottom = 0;
+    u16 top = 0;
+    u8 addr[ETH_ALEN];
+
+    /* Obtain bytes 1-4 of the MAC address from the EMAC hardware */
+    bottom = emac_ioread32(dev, EMAC_SPEC_ADDR_1_BOT_31_0_REG_OFFSET);
+    
+    /* Obtain bytes 5-6 of the MAC address from the EMAC hardware */
+    top = emac_ioread32(dev, EMAC_SPEC_ADDR_1_TOP_47_32_REG_OFFSET);
+
+    addr[0] = bottom & 0xff;
+    addr[1] = (bottom >> 8) & 0xff;
+    addr[2] = (bottom >> 16) & 0xff;
+    addr[3] = (bottom >> 24) & 0xff;
+    addr[4] = top & 0xff;
+    addr[5] = (top >> 8) & 0xff;
+
+    if (memcmp(dev->dev_addr, addr, ETH_ALEN))
+    {
+        printk("MAC saved in struct net_device is %02X:%02X:%02X:%02X:%02X:%02X"
+               " but the MAC in HW(%p) is %02X:%02X:%02X:%02X:%02X:%02X lastpid=%d thispid=%d (%s)\n",
+               dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
+               dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5],
+               priv->regs,
+               addr[0], addr[1], addr[2], addr[3], addr[4], addr[5],
+               last_pid, current->pid, current->comm);
+               
+        priv->hwaddr_failure = 1;
     }
+    
+    last_pid = current->pid;
 }
 
+#ifndef CONFIG_PC302_MICREL_VLAN_SWITCH
 static int
 pc302emac_mdio_read(struct mii_bus *bus,
                     int mii_id,
@@ -978,8 +1096,15 @@
         /* Check for time out */
         if (time_after(jiffies, timeout_jiffies))
         {
-            /* Oops we've timed out */
-            ret = -ETIMEDOUT;
+            /* Oops we might have timed out.  Check one last time to handle
+             * the case where the CPU was busy elsewhere for a long time
+             * between the previous check and the call to time_after.
+             */
+            status = emac_ioread32(priv->dev, EMAC_NETWORK_STATUS_REG_OFFSET);
+            if ((status & EMAC_PHY_MANAGEMENT_IDLE) == 0)
+            {
+                ret = -ETIMEDOUT;
+            }
             break;
         }
 
@@ -1002,6 +1127,7 @@
 {
     return SUCCESS;
 }
+#endif /* ! CONFIG_PC302_MICREL_VLAN_SWITCH */
 
 static void
 pc302emac_handle_link_change(struct net_device *dev)
@@ -1071,6 +1197,7 @@
     }
 }
 
+#ifndef CONFIG_PC302_MICREL_VLAN_SWITCH
 static int
 pc302emac_mii_probe(struct net_device *dev)
 {
@@ -1090,43 +1217,55 @@
 	}
     }
 
-    if (!phydev)
+    if (phydev)
     {
-	printk(KERN_ERR "%s: no Phy found\n", dev->name);
-	return -ENXIO;
-    }
+        pdata = priv->pdev->dev.platform_data;
 
-    pdata = priv->pdev->dev.platform_data;
+        /* attach the mac to the phy */
+        if (pdata && pdata->is_rmii)
+        {
+            phydev = phy_connect(dev, phydev->dev.bus_id,
+                                 &pc302emac_handle_link_change,
+                                 0, PHY_INTERFACE_MODE_RMII);
+        }
+        else
+        {
+            phydev = phy_connect(dev, phydev->dev.bus_id,
+                                 &pc302emac_handle_link_change,
+                                 0, PHY_INTERFACE_MODE_MII);
+        }
 
-    /* attach the mac to the phy */
-    if (pdata && pdata->is_rmii)
-    {
-	phydev = phy_connect(dev, phydev->dev.bus_id,
-			     &pc302emac_handle_link_change,
-                             0, PHY_INTERFACE_MODE_RMII);
+        if (IS_ERR(phydev))
+        {
+            printk(KERN_ERR "%s: could not attach to Phy\n", dev->name);
+            return PTR_ERR(phydev);
+        }
+
+        /* mask with MAC supported features */
+        phydev->supported &= PHY_BASIC_FEATURES;
+
+        phydev->advertising = phydev->supported;
+
+        priv->link = 0;
+        priv->speed = 0;
+        priv->duplex = -1;
+        priv->phy_dev = phydev;
     }
     else
     {
-	phydev = phy_connect(dev, phydev->dev.bus_id,
-			     &pc302emac_handle_link_change,
-                             0, PHY_INTERFACE_MODE_MII);
-    }
-
-    if (IS_ERR(phydev))
-    {
-	printk(KERN_ERR "%s: could not attach to Phy\n", dev->name);
-	return PTR_ERR(phydev);
+        u32 config;
+	printk(KERN_ERR "%s: no Phy found, assuming direct MII\n", dev->name);
+        priv->link = 1;
+        priv->speed = SPEED_100;
+        priv->duplex = DUPLEX_FULL;
+        priv->phy_dev = NULL;
+
+        config = emac_ioread32(dev, EMAC_NETWORK_CFG_REG_OFFSET);
+        config |= EMAC_SPEED_100_MBPS | EMAC_FULL_DUPLEX;
+        emac_iowrite32(dev, config, EMAC_NETWORK_CFG_REG_OFFSET);
     }
 
-    /* mask with MAC supported features */
-    phydev->supported &= PHY_BASIC_FEATURES;
-
-    phydev->advertising = phydev->supported;
-
-    priv->link = 0;
-    priv->speed = 0;
-    priv->duplex = -1;
-    priv->phy_dev = phydev;
+    priv->phy_probed = 1;
 
     return SUCCESS;
 }
@@ -1206,6 +1345,38 @@
     return ret;
 }
 
+#else /* CONFIG_PC302_MICREL_VLAN_SWITCH */
+
+static int
+pc302emac_i2c_probe(struct net_device *dev)
+{
+    struct pc302_emac *priv = netdev_priv(dev);
+    struct phy_device *phydev = NULL;
+
+    phydev = i2c_phy_connect(dev, "", &pc302emac_handle_link_change,
+                             0, PHY_INTERFACE_MODE_MII);
+
+    if (IS_ERR(phydev))
+    {
+	printk(KERN_ERR "%s: could not attach to Phy\n", dev->name);
+	return PTR_ERR(phydev);
+    }
+
+    /* mask with MAC supported features */
+    phydev->supported &= PHY_BASIC_FEATURES;
+
+    phydev->advertising = phydev->supported;
+
+    priv->link = 0;
+    priv->speed = 0;
+    priv->duplex = -1;
+    priv->phy_dev = phydev;
+
+    return SUCCESS;
+}
+
+#endif /* CONFIG_PC302_MICREL_VLAN_SWITCH */
+
 static void
 pc302emac_update_stats(struct pc302_emac *priv)
 {
@@ -1229,18 +1400,51 @@
     unsigned int tail = 0;
     unsigned int head = 0;
 
+    unsigned int bufferReset = 0;
+
     u32 status = 0;
     u32 control = 0;
 
     status = emac_ioread32(dev, EMAC_TX_STATUS_REG_OFFSET);
     emac_iowrite32(dev, status, EMAC_TX_STATUS_REG_OFFSET);
 
-    if (status & EMAC_TRANSMIT_UNDERRUN)
+    if (status & EMAC_TRANSMIT_HRESP_NOT_OK)
+    {
+        printk(KERN_ERR "%s: TX hresp not OK\n", dev->name);
+    }
+
+    if (status & EMAC_TX_ERROR_FLAGS)
     {
         int i;
-	printk(KERN_ERR "%s: Tx underrun, resetting buffers\n",
-			 dev->name);
 
+        bufferReset = 1;
+
+        if (status & EMAC_TRANSMIT_UNDERRUN)
+        {
+            printk(KERN_ERR "%s: Tx underrun, resetting buffers\n", dev->name);
+        }
+
+        if (status & EMAC_TRANSMIT_CORRUPTION_AHB_ERROR)
+        {
+            printk(KERN_ERR "%s: Tx corruption (bus error), resetting buffers\n", dev->name);
+        }
+
+        if (status & EMAC_TRANSMIT_RETRY_LIMIT_EXCEEDED)
+        {
+            printk(KERN_ERR "%s: Tx retry limit exceeded, resetting buffers\n", dev->name);
+        }
+
+        /* If we're resetting the head and tail pointers for the ring then we
+         * have to tell the transmitter to reset its next available TX buffer
+         * descriptor to the beginning of the TX buffer descriptor list.  The
+         * only way we can do that is by disabling the transmitter.
+         */
+        control = emac_ioread32(dev, EMAC_NETWORK_CTRL_REG_OFFSET);
+        control &= ~EMAC_TX_ENABLE;
+        emac_iowrite32(dev, control, EMAC_NETWORK_CTRL_REG_OFFSET);
+        
+        emac_iowrite32(dev, 0xFFFFFFFF, EMAC_TX_STATUS_REG_OFFSET);
+        
 	head = priv->tx_head;
 
 	/*Mark all the buffer as used to avoid sending a lost buffer*/
@@ -1266,10 +1470,24 @@
 	}
 
 	priv->tx_head = priv->tx_tail = 0;
+
+        /* Now that the SW and HW agree where the next TX descriptor should
+         * be read from, we can restart the transmitter.
+         */    
+        control = emac_ioread32(dev, EMAC_NETWORK_CTRL_REG_OFFSET);
+        control |= EMAC_TX_ENABLE;
+        emac_iowrite32(dev, control, EMAC_NETWORK_CTRL_REG_OFFSET);
+        
     }
 
     if (!(status & EMAC_TRANSMIT_COMPLETE))
     {
+        if (netif_queue_stopped(priv->dev) && bufferReset)
+        {
+            printk(KERN_ERR "%s: TX buffer reset with queue stopped.  Resuming queue\n", dev->name);
+            netif_wake_queue(priv->dev);
+        }
+
 	/*
 	 * This may happen when a buffer becomes complete
 	 * between reading the ISR and scanning the
@@ -1338,6 +1556,7 @@
     unsigned int offset = 0;
     unsigned int frag_len = RX_BUFFER_SIZE;
     u32 csum_status = 0;
+    unsigned short vlan_tag = 0;
 
     ktime_t hw_timestamp;
     s32 sec_from_hardware = 0;
@@ -1401,12 +1620,34 @@
         }
     }
 
-    skb->protocol = eth_type_trans(skb, priv->dev);
-
     priv->stats.rx_packets++;
     priv->stats.rx_bytes += len;
     priv->dev->last_rx = jiffies;
 
+    /* Set up the Ethernet device that received the packet */
+    skb->dev = dev;
+
+    /* If the hardware tells us it is a VLAN frame, get the tag from the
+     * data before we remove the header.
+     * This is often done by the hardware but not in our case, we have
+     * to look inside the header ourselves.
+     * Remove the VLAN header data from the received frame by shifting the
+     * source and destination MAC addresses. This turns the VLAN frame
+     * into a normal Ethernet packet which is what the network stack
+     * expects from us.
+     */
+    if (priv->rx_ring[last_frag].ctrl & EMAC_RX_DESC_VLAN_TAG) {
+
+        /* Ignore the return value. If the hardware tells us it is VLAN
+         * and it is not, something much more serious has occurred.
+         */
+        vlan_get_tag(skb, &vlan_tag);
+
+        /* Shift the MAC addresses to make it into an normal packet */
+        memmove(skb->data + VLAN_HLEN, skb->data, ETH_ALEN + ETH_ALEN);
+        skb_pull(skb, VLAN_HLEN);
+    }
+    
     if (priv->hw_timestamp_flag == HWTSTAMP_FILTER_ALL)
     {
         /* We have been asked to include the hardware timestamp of the
@@ -1448,8 +1689,17 @@
         skb_hwtstamp_set(skb, hw_timestamp);
     }
 
-    /* Pass received packet up to higher networking layers */
-    netif_receive_skb(skb);
+    skb->protocol = eth_type_trans(skb, priv->dev);
+
+    if ( (priv->rx_ring[last_frag].ctrl & EMAC_RX_DESC_VLAN_TAG)  && priv->vlgrp) {
+        /* Pass the packet to the VLAN layer */
+        vlan_hwaccel_receive_skb(skb, priv->vlgrp, vlan_tag);
+    }
+    else
+    {
+        /* Pass received packet up to higher networking layers */
+        netif_receive_skb(skb);
+    }
 
     return SUCCESS;
 }
@@ -1614,6 +1864,7 @@
 	if (unlikely(!netif_running(dev)))
         {
 	    /* Disable all interrupts */
+            printk("Disable all interrupts in irq handler due to close\n");
             emac_iowrite32(dev, 0xFFFFFFFF, EMAC_INT_DISABLE_REG_OFFSET);
 	    break;
 	}
@@ -1633,7 +1884,7 @@
 	    }
         }
 
-        if (status & (EMAC_ENABLE_TX_COMPLETE | EMAC_ENABLE_TX_BUFF_UNDERRUN))
+        if (status & EMAC_TX_INT_FLAGS)
         {
             /* We have a Tx related interrupt */
             pc302emac_tx(dev);
@@ -1671,6 +1922,11 @@
     len = skb->len;
     spin_lock_irq(&priv->lock);
 
+    if (!priv->hwaddr_failure)
+    {
+        pc302emac_check_hwaddr(dev);
+    }
+
     /* This is a hard error, log it. */
     if (TX_BUFFS_AVAIL(priv) < 1)
     {
@@ -1893,6 +2149,9 @@
 
     /* Pause Enable */
     config |= EMAC_PAUSE_ENABLE;
+    
+    /* Enable reception of 1536 byte frames */
+    config |= EMAC_RX_1536_BYTE_FRAMES;
 
     /* Discard frames with length errors */
     config |= EMAC_LENGTH_FIELD_ERROR_FRAME_DISCARD;
@@ -1942,6 +2201,7 @@
                      | EMAC_ENABLE_TX_BUFF_UNDERRUN
                      | EMAC_ENABLE_TRANSMIT_CORRUPTION_AHB_ERROR
                      | EMAC_ENABLE_TX_COMPLETE
+                     | EMAC_ENABLE_RETRY_LIMIT_EXCEEDED
                      | EMAC_ENABLE_RX_OVERRUN
                      | EMAC_ENABLE_HRESP_NOT_OK;
 
@@ -2088,7 +2348,7 @@
     int ret = 0;
 
     /* If the phy is not yet registered, retry later */
-    if (!priv->phy_dev)
+    if (!priv->phy_dev && !priv->phy_probed)
     {
     	return -EAGAIN;
     }
@@ -2112,7 +2372,14 @@
     pc302emac_init_hw(dev);
 
     /* schedule a link state check */
-    phy_start(priv->phy_dev);
+    if (priv->phy_dev)
+    {
+        phy_start(priv->phy_dev);
+    }
+    else
+    {
+        netif_carrier_on(dev);
+    }
 
     netif_start_queue(dev);
 
@@ -2124,6 +2391,50 @@
 {
     struct pc302_emac *priv = netdev_priv(dev);
     unsigned long flags = 0;
+    int i;
+
+    printk("Closing emac interface %s\n", dev->name);
+    printk("Register dump:\n");
+    for (i=0; i<0x28; i+=4)
+    {
+        printk("  0x%03X:0x%08X\n", i, emac_ioread32(dev, i));
+    }
+    for (i=0x30; i<0x40; i+=4)
+    {
+        printk("  0x%03X:0x%08X\n", i, emac_ioread32(dev, i));
+    }
+    for (i=0x80; i<0xC4; i+=4)
+    {
+        printk("  0x%03X:0x%08X\n", i, emac_ioread32(dev, i));
+    }
+    for (i=0x100; i<0x1B4; i+=4)
+    {
+        printk("  0x%03X:0x%08X\n", i, emac_ioread32(dev, i));
+    }
+    for (i=0x1C8; i<0x200; i+=4)
+    {
+        printk("  0x%03X:0x%08X\n", i, emac_ioread32(dev, i));
+    }
+    printk("RX tail=%u, pending=%u\n", priv->rx_tail, priv->rx_pending);
+    printk("RX ring is at %p\n", priv->rx_ring);
+    if (priv->rx_ring)
+    {
+        for (i=0; i<RX_RING_SIZE; i++)
+        {
+            printk("  rx_dma[%02d]: addr=0x%08X ctrl=0x%08X\n", i, priv->rx_ring[i].addr, priv->rx_ring[i].ctrl);
+        }
+    }
+    printk("TX head=%u tail=%u, pending=%u, avail=%u\n", priv->tx_head, priv->tx_tail, priv->tx_pending, TX_BUFFS_AVAIL(priv));
+    printk("TX ring is at %p\n", priv->tx_ring);
+    if (priv->tx_ring)
+    {
+        for (i=0; i<TX_RING_SIZE; i++)
+        {
+            printk("  tx_dma[%02d]: addr=0x%08X ctrl=0x%08X\n", i, priv->tx_ring[i].addr, priv->tx_ring[i].ctrl);
+        }
+    }
+    printk("TX is %sstopped\n", netif_queue_stopped(dev)?"":"not ");
+    printk("Link=%d, speed=%d, duplex=%d\n", priv->link, priv->speed, priv->duplex);
 
     netif_stop_queue(dev);
     napi_disable(&priv->napi);
@@ -2198,6 +2509,9 @@
 pc302emac_get_settings(struct net_device *dev,
                        struct ethtool_cmd *cmd)
 {
+#ifdef CONFIG_PC302_MICREL_VLAN_SWITCH
+    return -ENODEV;
+#else /* CONFIG_PC302_MICREL_VLAN_SWITCH */
     struct pc302_emac *priv = netdev_priv(dev);
     struct phy_device *phydev = priv->phy_dev;
 
@@ -2207,12 +2521,16 @@
     }
 
     return phy_ethtool_gset(phydev, cmd);
+#endif /* CONFIG_PC302_MICREL_VLAN_SWITCH */
 }
 
 static int
 pc302emac_set_settings(struct net_device *dev,
                        struct ethtool_cmd *cmd)
 {
+#ifdef CONFIG_PC302_MICREL_VLAN_SWITCH
+    return -ENODEV;
+#else /* CONFIG_PC302_MICREL_VLAN_SWITCH */
     struct pc302_emac *priv = netdev_priv(dev);
     struct phy_device *phydev = priv->phy_dev;
 
@@ -2222,6 +2540,7 @@
     }
 
     return phy_ethtool_sset(phydev, cmd);
+#endif /* CONFIG_PC302_MICREL_VLAN_SWITCH */
 }
 
 static void
@@ -2257,12 +2576,6 @@
 	return -EINVAL;
     }
 
-    /* Do we have a connected phy ? */
-    if (!phydev)
-    {
-	return -ENODEV;
-    }
-
     switch (cmd)
     {
         case SIOCGMIIPHY:
@@ -2272,7 +2585,19 @@
             /* Fall through intentional */
 
         case SIOCSMIIREG:
-            return phy_mii_ioctl(phydev, if_mii(rq), cmd);
+#ifdef CONFIG_PC302_MICREL_VLAN_SWITCH
+	    return -EOPNOTSUPP;
+#else /* CONFIG_PC302_MICREL_VLAN_SWITCH */
+            /* Do we have a connected phy ? */
+            if (phydev)
+            {
+                return phy_mii_ioctl(phydev, if_mii(rq), cmd);
+            }
+            else
+            {
+                return -ENODEV;
+            }
+#endif /* CONFIG_PC302_MICREL_VLAN_SWITCH */
 
         case SIOCSHWTSTAMP:
 	    return pc302emac_hwtstamp_ioctl(dev, rq, cmd);
@@ -2623,7 +2948,12 @@
     SET_NETDEV_DEV(dev, &pdev->dev);
 
     priv = netdev_priv(dev);
+    
+    priv->hwaddr_failure = 0;
+    
+#ifndef CONFIG_PC302_MICREL_VLAN_SWITCH
     priv->mii_bus = mdiobus_alloc();
+#endif /* ! CONFIG_PC302_MICREL_VLAN_SWITCH */
     priv->pdev = pdev;
     priv->dev = dev;
     /* Create a DMA pool for the transmit buffers. We use this to copy the
@@ -2666,10 +2996,14 @@
     dev->hard_start_xmit = pc302emac_start_xmit;
     dev->get_stats = pc302emac_get_stats;
     dev->set_multicast_list = pc302emac_set_rx_mode;
+    dev->vlan_rx_register   = emac_vlan_rx_register;
+    dev->vlan_rx_kill_vid   = emac_vlan_rx_kill_vid;
     dev->do_ioctl = pc302emac_ioctl;
     netif_napi_add(dev, &priv->napi, pc302emac_poll, 16);
     dev->ethtool_ops = &pc302emac_ethtool_ops;
 
+    dev->features           |= NETIF_F_HW_VLAN_RX;
+
     dev->base_addr = regs->start;
 
     /* Set MII management clock divider */
@@ -2693,11 +3027,20 @@
         goto out_reg_netdev_failed;
     }
 
+#ifdef CONFIG_PC302_MICREL_VLAN_SWITCH
+    if (pc302emac_i2c_probe(priv->dev) != 0)
+    {
+	printk(KERN_ERR "%s: pc302emac_i2c_probe() failed\n", dev->name);
+        ret = -ENXIO;
+        goto out_mii_init_failed;
+    }
+#else /* !CONFIG_PC302_MICREL_VLAN_SWITCH */
     if (pc302emac_mii_init(dev) != 0)
     {
         ret = -ENXIO;
         goto out_mii_init_failed;
     }
+#endif /* !CONFIG_PC302_MICREL_VLAN_SWITCH */
 
     platform_set_drvdata(pdev, dev);
 
@@ -2717,11 +3060,17 @@
            CARDNAME);
 
     phydev = priv->phy_dev;
-    printk(KERN_INFO "%s: attached Phy driver [%s] "
-		     "(mii_bus:phy_addr=%s, irq=%d)\n",
-		     dev->name, phydev->drv->name, phydev->dev.bus_id,
-                     phydev->irq);
-
+    if (phydev)
+    {
+        printk(KERN_INFO "%s: attached Phy driver [%s] "
+                         "(mii_bus:phy_addr=%s, irq=%d)\n",
+                         dev->name, phydev->drv->name, phydev->dev.bus_id,
+                         phydev->irq);
+    }
+    else
+    {
+        printk(KERN_INFO "%s: no Phy found\n", dev->name);
+    }
     return SUCCESS;
 
 out_mii_init_failed:
@@ -2757,6 +3106,7 @@
     if (dev)
     {
         priv = netdev_priv(dev);
+#ifndef CONFIG_PC302_MICREL_VLAN_SWITCH
 	if (priv->phy_dev)
         {
 	    phy_disconnect(priv->phy_dev);
@@ -2764,6 +3114,7 @@
 	mdiobus_unregister(priv->mii_bus);
 	kfree(priv->mii_bus->irq);
         mdiobus_free(priv->mii_bus);
+#endif /* ! CONFIG_PC302_MICREL_VLAN_SWITCH */
 	unregister_netdev(dev);
 	free_irq(dev->irq, dev);
 	iounmap(priv->regs);
@@ -2778,6 +3129,20 @@
     return SUCCESS;
 }
 
+/* Enables and disables VLAN insertion/extraction */
+static void emac_vlan_rx_register(
+        struct net_device *dev, struct vlan_group *grp)
+{
+    struct pc302_emac *priv = netdev_priv(dev);
+
+    priv->vlgrp = grp;
+}
+
+static void emac_vlan_rx_kill_vid(struct net_device *dev, uint16_t vid)
+{
+    /* Nothing to do. We do not support filtering */
+}
+
 /*!
  * Platform driver data structure.
  */
@@ -2797,11 +3162,23 @@
 {
     int ret = 0;
 
+#ifdef CONFIG_PC302_MICREL_VLAN_SWITCH
+    ret = pc302_i2c_phy_init();
+    if (ret != 0)
+    {
+        printk(KERN_ERR "%s: Failed to register Micrel phy driver\n", CARDNAME);
+        return ret;
+    }
+#endif /* CONFIG_PC302_MICREL_VLAN_SWITCH */
+
     /* Register the platform driver */
     ret = platform_driver_register(&emac_driver);
     if (ret != 0)
     {
         printk(KERN_ERR "%s: Failed to register EMAC driver\n", CARDNAME);
+#ifdef CONFIG_PC302_MICREL_VLAN_SWITCH
+        pc302_i2c_phy_uninit();
+#endif /* CONFIG_PC302_MICREL_VLAN_SWITCH */
     }
 
     return ret;
@@ -2810,6 +3187,9 @@
 static void
 emac_cleanup_module(void)
 {
+#ifdef CONFIG_PC302_MICREL_VLAN_SWITCH
+    pc302_i2c_phy_uninit();
+#endif /* CONFIG_PC302_MICREL_VLAN_SWITCH */
     platform_driver_unregister(&emac_driver);
 }
 
diff -Naur pico_2.6.28/drivers/net/pc302_emac.h ipa_2.6.28/drivers/net/pc302_emac.h
--- pico_2.6.28/drivers/net/pc302_emac.h	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/drivers/net/pc302_emac.h	2011-04-26 14:51:35.000000000 +0100
@@ -154,6 +154,7 @@
 #define EMAC_MDC_CLOCK_DIV_96                                       (0x5 <<18)
 #define EMAC_LENGTH_FIELD_ERROR_FRAME_DISCARD                       (1 << 16)
 #define EMAC_PAUSE_ENABLE                                           (1 << 13)
+#define EMAC_RX_1536_BYTE_FRAMES                                    (1 << 8)
 #define EMAC_MULTICAST_HASH_ENABLE                                  (1 << 6)
 #define EMAC_NO_BROADCAST_FRAMES                                    (1 << 5)
 #define EMAC_COPY_ALL_FRAMES                                        (1 << 4)
@@ -186,12 +187,19 @@
 /*!
  * EMAC_TX_STATUS_REG_OFFSET bits
  */
+#define EMAC_TRANSMIT_HRESP_NOT_OK                                  (1 << 8)
 #define EMAC_TRANSMIT_UNDERRUN                                      (1 << 6)
 #define EMAC_TRANSMIT_COMPLETE                                      (1 << 5)
+#define EMAC_TRANSMIT_CORRUPTION_AHB_ERROR                          (1 << 4)
+#define EMAC_TRANSMIT_GO                                            (1 << 3)
+#define EMAC_TRANSMIT_RETRY_LIMIT_EXCEEDED                          (1 << 2)
+#define EMAC_COLLISION_OCCURRED                                     (1 << 1)
+#define EMAC_USED_BIT_READ                                          (1 << 0)
 
 /*!
  * EMAC_RX_STATUS_REG_OFFSET bits
  */
+#define EMAC_RECEIVE_HRESP_NOT_OK                                   (1 << 3)
 #define EMAC_RECEIVE_OVERRUN                                        (1 << 2)
 #define EMAC_FRAME_RECEIVED                                         (1 << 1)
 #define EMAC_RX_BUFFER_NOT_AVAIL                                    (1 << 0)
@@ -239,6 +247,7 @@
 
 #define EMAC_RX_DESC_CSUM_OFFLOAD_IDX                               (22)
 #define EMAC_RX_DESC_CSUM_OFFLOAD_MASK                              (0x3 << EMAC_RX_DESC_CSUM_OFFLOAD_IDX)
+#define EMAC_RX_DESC_VLAN_TAG                                       (1 << 21)
 #define EMAC_RX_DESC_END_OF_FRAME                                   (1 << 15)
 #define EMAC_RX_DESC_START_OF_FRAME                                 (1 << 14)
 #define EMAC_RX_DESC_LENGTH_MASK                                    (0x1FFF)
diff -Naur pico_2.6.28/drivers/net/pc302_i2c_phy.c ipa_2.6.28/drivers/net/pc302_i2c_phy.c
--- pico_2.6.28/drivers/net/pc302_i2c_phy.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/net/pc302_i2c_phy.c	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,369 @@
+/* 
+ *****************************************************************************
+ * 
+ * Copyright (c) 2010 ip.access Ltd.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *****************************************************************************
+ */
+#ifdef CONFIG_PC302_MICREL_VLAN_SWITCH
+
+#include <linux/kernel.h>
+#include <linux/autoconf.h>
+#include <linux/phy.h>
+#include <linux/i2c.h>
+#include <linux/device.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include "pc302_i2c_phy.h"
+
+
+#define MICREL_PORT1_CTRL12_REG 0x1C
+#define MICREL_PORT2_CTRL12_REG 0x2C
+
+#define MICREL_PORT1_STATUS_REG 0x1E
+#define MICREL_PORT2_STATUS_REG 0x2E
+#define MP1S_AN_DONE            (1 << 6)
+#define MP1S_LSTATUS            (1 << 5)
+#define MP1S_LPA_PAUSE_CAP      (1 << 4)
+#define MP1S_LPA_100FULL        (1 << 3)
+#define MP1S_LPA_100HALF        (1 << 2)
+#define MP1S_LPA_10FULL         (1 << 1)
+#define MP1S_LPA_10HALF         (1 << 0)
+
+struct micrel_phy_device {
+        struct phy_device *phy_device;
+        struct i2c_client *client;
+        int started;
+};
+
+static struct micrel_phy_device *i2c_phy_device;
+
+
+
+
+/**
+ * micrel_phy_config_aneg - restart auto-negotiation or write BMCR
+ * @phydev: target phy_device struct
+ *
+ * Description: If auto-negotiation is enabled, we configure the
+ *   advertising, and then restart auto-negotiation.  If it is not
+ *   enabled, then we write the BMCR.
+ */
+static int micrel_phy_config_aneg(struct phy_device *phydev)
+{
+        return 0;
+}
+
+
+/**
+ * micrel_phy_read_status - check the link status and update current link state
+ * @phydev: target phy_device struct
+ *
+ * Description: Check the link, then figure out the current state
+ *   by comparing what we advertise with what the link partner
+ *   advertises.  Start by checking the gigabit possibilities,
+ *   then move on to 10/100.
+ */
+static int micrel_phy_read_status(struct phy_device *phydev)
+{
+        struct micrel_phy_device *micrel_phy;
+	int lpa;
+
+        micrel_phy = phydev->priv;
+        if (micrel_phy->client == NULL) {
+                printk(KERN_WARNING "%s: i2c client ptr is NULL\n", __FUNCTION__);
+                return 0;
+        }
+
+	/* Read link status */
+        lpa = i2c_smbus_read_byte_data(micrel_phy->client, MICREL_PORT1_STATUS_REG);
+	if (lpa < 0)
+		return lpa;
+
+	if ((lpa & MP1S_LSTATUS) == 0)
+		phydev->link = 0;
+	else
+		phydev->link = 1;
+
+        phydev->speed = SPEED_10;
+        phydev->duplex = DUPLEX_HALF;
+        phydev->pause = phydev->asym_pause = 0;
+
+        if (lpa & (MP1S_LPA_100FULL | MP1S_LPA_100HALF)) {
+                phydev->speed = SPEED_100;
+			
+                if (lpa & MP1S_LPA_100FULL) {
+                        phydev->duplex = DUPLEX_FULL;
+                }
+        } else {
+                if (lpa & MP1S_LPA_10FULL) {
+                        phydev->duplex = DUPLEX_FULL;
+                }
+        }
+
+        if (phydev->duplex == DUPLEX_FULL) {
+                phydev->pause = lpa & MP1S_LPA_PAUSE_CAP ? 1 : 0;
+        }
+
+        return 0;
+}
+
+
+static int micrel_phy_config_init(struct phy_device *phydev)
+{
+	u32 features;
+
+        /* Only advertise minimal features to the net dev */
+	features = (SUPPORTED_MII);
+        features |= SUPPORTED_100baseT_Full;
+        features |= SUPPORTED_100baseT_Half;
+        features |= SUPPORTED_10baseT_Full;
+        features |= SUPPORTED_10baseT_Half;
+
+	phydev->supported = features;
+	phydev->advertising = features;
+
+	return 0;
+}
+
+
+
+
+        
+static struct phy_driver micrel_phy_driver = {
+	.phy_id		= 0xffffffff,
+	.phy_id_mask	= 0xffffffff,
+	.name		= "Micrel I2C PHY",
+	.config_init	= micrel_phy_config_init,
+	.features	= 0,
+	.config_aneg	= micrel_phy_config_aneg,
+	.read_status	= micrel_phy_read_status,
+	.driver		= {.owner= THIS_MODULE, },
+};
+
+
+static struct micrel_phy_device *get_micrel_phy(const char *bus_id)
+{
+        return i2c_phy_device;
+}
+
+
+/* 
+ * This is called from both the netdev side and the I2C side.
+ * When both have been configured, we start the PHY state machine.
+ */
+static void start_phy(struct micrel_phy_device *micrel_phy)
+{
+        if (!micrel_phy->started)
+        {
+                struct phy_device *phydev = micrel_phy->phy_device;
+                
+                if (phydev->attached_dev && micrel_phy->client)
+                {
+                        phy_start_machine(phydev, NULL);
+
+                        micrel_phy->started = 1;
+                }
+        }
+}
+
+
+
+/**
+ * Create an instance of a I2C PHY device
+ */
+struct micrel_phy_device * i2c_phy_create(int addr, u32 phy_id)
+{
+	struct micrel_phy_device *i2cphydev;
+	struct phy_device *phydev;
+
+        i2cphydev = kzalloc(sizeof(*i2cphydev), GFP_KERNEL);
+	if (NULL == i2cphydev)
+		return NULL;
+
+        phydev = phy_device_create(NULL, addr, phy_id);
+        if (IS_ERR(phydev)) {
+                kfree(i2cphydev);
+		return NULL;
+        }
+
+        phydev->drv = &micrel_phy_driver;
+        phydev->interface = PHY_INTERFACE_MODE_MII;
+        phydev->autoneg = AUTONEG_DISABLE;
+        phydev->irq = PHY_POLL;
+
+        /* Assume PHY is up from bot */
+        phydev->state = PHY_RUNNING;
+
+        i2cphydev->phy_device = phydev;
+        phydev->priv = i2cphydev;
+
+	return i2cphydev;
+}
+EXPORT_SYMBOL(i2c_phy_create);
+
+
+int i2c_phy_attach(struct phy_device *phydev, struct net_device *dev,
+                                  const char *bus_id, u32 flags, phy_interface_t interface)
+{
+	if (phydev->attached_dev) {
+		printk(KERN_ERR "micrel phy is already attached\n");
+		return -EBUSY;
+	}
+
+	phydev->attached_dev = dev;
+
+	phydev->dev_flags = flags;
+
+	phydev->interface = interface;
+
+	/* Do initial configuration here, now that
+	 * we have certain key parameters
+	 * (dev_flags and interface) */
+	if (phydev->drv->config_init) {
+		int err;
+
+		err = phydev->drv->config_init(phydev);
+
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(i2c_phy_attach);
+
+
+/**
+ * i2c_phy_connect - connect an ethernet device to a PHY device
+ * @dev: the network device to connect
+ * @bus_id: the id string of the PHY device to connect
+ * @handler: callback function for state change notifications
+ * @flags: PHY device's dev_flags
+ * @interface: PHY device's interface
+ *
+ * Description: Convenience function for connecting ethernet
+ *   devices to PHY devices.  The default behavior is for
+ *   the PHY infrastructure to handle everything, and only notify
+ *   the connected driver when the link status changes.  If you
+ *   don't want, or can't use the provided functionality, you may
+ *   choose to call only the subset of functions which provide
+ *   the desired functionality.
+ */
+struct phy_device *
+i2c_phy_connect(struct net_device *dev, const char *bus_id,
+		void (*handler)(struct net_device *), u32 flags,
+		phy_interface_t interface)
+{
+	struct micrel_phy_device *micrel_phy;
+        int err;
+
+        micrel_phy = get_micrel_phy(bus_id);
+        if (micrel_phy == NULL)
+	{
+		printk(KERN_ERR "%s: no i2c Phy found\n", __FUNCTION__);
+		return ERR_PTR(-ENODEV);
+	}
+
+	err = i2c_phy_attach(micrel_phy->phy_device, dev, bus_id, flags, interface);
+	if (err)
+		return ERR_PTR(err);
+
+        phy_prepare_link(micrel_phy->phy_device, handler);
+
+        start_phy(micrel_phy);
+
+	return micrel_phy->phy_device;
+}
+EXPORT_SYMBOL(i2c_phy_connect);
+
+
+/* Addresses to scan */
+static const unsigned short normal_i2c[] = { 0x5F, I2C_CLIENT_END };
+
+/* Insmod parameters */
+I2C_CLIENT_INSMOD_1(i2c_phy);
+
+static const struct i2c_device_id i2c_phy_id[] = {
+	{ "micrel", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, i2c_phy_id);
+
+
+
+static int i2c_phy_probe(struct i2c_client *client,
+                         const struct i2c_device_id *id)
+{
+	int ret = 0;
+
+	dev_info(&client->dev, "i2c_phy: %s chip found\n", client->name);
+
+        if (i2c_phy_device)
+        {
+                i2c_set_clientdata(client, i2c_phy_device);
+                i2c_phy_device->client = client;
+
+                start_phy(i2c_phy_device);
+        }
+        else
+        {
+                printk(KERN_WARNING "%s: phy device is NULL\n", __FUNCTION__);
+        }
+	return ret;
+}
+
+static int i2c_phy_remove(struct i2c_client *client)
+{
+        struct phy_device *phydev;
+
+        phydev = i2c_get_clientdata(client);
+        phy_device_free(phydev);
+        i2c_set_clientdata(client, NULL);
+
+	return 0;
+}
+
+
+static struct i2c_driver micrel_i2c_driver = {
+	.class		= I2C_CLASS_ALL,
+	.driver = {
+		.name	= "micrel_i2c_phy",
+	},
+	.probe		= i2c_phy_probe,
+	.remove		= i2c_phy_remove,
+	.id_table	= i2c_phy_id,
+	.address_data	= &addr_data,
+};
+
+
+
+
+int
+pc302_i2c_phy_init(void)
+{
+        /* ID of Micrel PHY */
+        const u32 phy_id = 0x00221430;
+
+        i2c_phy_device = i2c_phy_create(1, phy_id);
+        if (i2c_phy_device == NULL) {
+                printk(KERN_ERR "Failed to allocate micrel phy struct\n");
+                return -ENOMEM;
+        }
+
+        return i2c_add_driver(&micrel_i2c_driver);
+}
+
+void
+pc302_i2c_phy_uninit(void)
+{
+        i2c_del_driver(&micrel_i2c_driver);
+}
+
+#endif /* CONFIG_PC302_MICREL_VLAN_SWITCH */
diff -Naur pico_2.6.28/drivers/net/pc302_i2c_phy.h ipa_2.6.28/drivers/net/pc302_i2c_phy.h
--- pico_2.6.28/drivers/net/pc302_i2c_phy.h	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/net/pc302_i2c_phy.h	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,33 @@
+/* 
+ *****************************************************************************
+ * 
+ * Copyright (c) 2010 ip.access Ltd.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *****************************************************************************
+ */
+#ifndef PC302_I2C_PHY_H
+#define PC302_I2C_PHY_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif  /* __cplusplus */
+
+
+int pc302_i2c_phy_init(void);
+void pc302_i2c_phy_uninit(void);
+
+struct phy_device * i2c_phy_connect(
+    struct net_device *dev, const char *bus_id,
+    void (*handler)(struct net_device *), u32 flags,
+    phy_interface_t interface);
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif /* PC302_I2C_PHY_H */
diff -Naur pico_2.6.28/drivers/net/phy/phy_device.c ipa_2.6.28/drivers/net/phy/phy_device.c
--- pico_2.6.28/drivers/net/phy/phy_device.c	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/drivers/net/phy/phy_device.c	2011-04-26 14:51:35.000000000 +0100
@@ -227,8 +227,8 @@
 	if (r)
 		return ERR_PTR(r);
 
-	/* If the phy_id is all Fs, there is no device there */
-	if (0xffffffff == phy_id)
+	/* If the phy_id is all Fs or all 0s, there is no device there */
+	if ((0xffff == (phy_id & 0xffff)) || (0x00 == (phy_id & 0xffff)))
 		return NULL;
 
 	dev = phy_device_create(bus, addr, phy_id);
diff -Naur pico_2.6.28/drivers/picochip/dma_fifo.c ipa_2.6.28/drivers/picochip/dma_fifo.c
--- pico_2.6.28/drivers/picochip/dma_fifo.c	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/drivers/picochip/dma_fifo.c	2011-04-26 14:51:35.000000000 +0100
@@ -28,6 +28,7 @@
 
 #include "picoif_module.h"
 #include "dma_fifo_internal.h"
+#include "picoif_internal.h"
 
 /*! The maximum number of bytes that can be copied to user in a single transfer */
 #define DMA_MAX_TRANSFER_SIZE ( 4096 )
@@ -54,8 +55,13 @@
     if ( !(*fifo) )
         return -ENOMEM;
  
+#if defined(CONFIG_PICOIF_DMAPOOL)
+    (*fifo)->buf = picoif_alloc_coherent( size, 
+            &((*fifo)->physaddr), GFP_KERNEL );
+#else /* !defined(CONFIG_PICOIF_DMAPOOL) */
     (*fifo)->buf = dma_alloc_coherent( NULL, size, 
             &((*fifo)->physaddr), GFP_KERNEL );
+#endif /* CONFIG_PICOIF_DMAPOOL */
 
     if ( (*fifo)->buf == NULL )
     {
@@ -77,8 +83,13 @@
 dma_fifo_destroy( struct dma_fifo_t *fifo )
 {
     if ( fifo->buf != NULL )
+#if defined(CONFIG_PICOIF_DMAPOOL)
+        picoif_free_coherent( fifo->bufsize, fifo->buf,
+               fifo->physaddr );
+#else /* !defined(CONFIG_PICOIF_DMAPOOL) */
         dma_free_coherent( NULL, fifo->bufsize, fifo->buf,
                fifo->physaddr );
+#endif /* CONFIG_PICOIF_DMAPOOL */
 
    if ( fifo )
        kfree ( fifo );
diff -Naur pico_2.6.28/drivers/picochip/hwif2.c ipa_2.6.28/drivers/picochip/hwif2.c
--- pico_2.6.28/drivers/picochip/hwif2.c	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/drivers/picochip/hwif2.c	2011-04-26 14:51:35.000000000 +0100
@@ -481,6 +481,12 @@
     struct pico_resource *chan = NULL;
     enum picoarray_device_type dev_type;
     struct pico_resource *its_irq = NULL;
+    struct pico_resource *its_gpr = NULL;
+    struct pico_resource *itm_gpr = NULL;
+    unsigned interrupt_bit = 0;
+
+    if ( !ctx )
+        goto bad_ctx;
 
     ret = picoif_buf_copy_from( &gparams, params, 0,
                                 sizeof( gparams ) );
@@ -517,19 +523,22 @@
 
     /* Check that the interrupt number is valid */
     if (gparams.dev_num >= HWIF2_MAX_INTERRUPT_NUM)
-        goto out;
+        goto bad_dev_num;
 
     /* If this is the first transport on the device, set the context
        parameters */
     if ( !hwif2_mod.params[gparams.dev_num].interrupts_set )
     {
-        struct pico_resource *its_gpr = pa->ops->get_resource( pa,
+        its_gpr = pa->ops->get_resource( pa,
             PICO_RES_GPR, gparams.its_gpr, 1 );
-        struct pico_resource *itm_gpr = pa->ops->get_resource( pa,
+        itm_gpr = pa->ops->get_resource( pa,
             PICO_RES_GPR, gparams.itm_gpr, 1 );
 
-        its_irq = pa->ops->get_resource( pa, PICO_RES_IRQ, 
-                its_gpr->metadata, 1 );
+        if ( its_gpr )
+        {
+            its_irq = pa->ops->get_resource( pa, PICO_RES_IRQ, 
+                    its_gpr->metadata, 1 );
+        }
 
         ret = -EBUSY;
         if (( !its_gpr ) || ( !itm_gpr ) || ( !its_irq ))
@@ -552,10 +561,11 @@
             else
                 pa->ops->put_resource( pa, its_irq );
              
-            goto out;
+            goto bad_gpr;
         }
 
-        hwif2_mod.params[gparams.dev_num].interrupts_set |= (1 << gparams.int_num);
+        interrupt_bit = (((uint32_t)1) << gparams.int_num);
+        hwif2_mod.params[gparams.dev_num].interrupts_set |= interrupt_bit;
         hwif2_mod.params[gparams.dev_num].its_gpr = gparams.its_gpr;
         hwif2_mod.params[gparams.dev_num].itm_gpr = gparams.itm_gpr;
         hwif2_mod.params[gparams.dev_num].its = its_gpr;
@@ -569,19 +579,17 @@
             ( gparams.itm_gpr != hwif2_mod.params[gparams.dev_num].itm_gpr ) ||
             ( hwif2_mod.params[gparams.dev_num].interrupts_set &
                                                         (1 << gparams.int_num) ))
-            goto out;
+            goto bad_gpr;
 
-        hwif2_mod.params[gparams.dev_num].interrupts_set |= (1 << gparams.int_num); 
+        interrupt_bit = (((uint32_t)1) << gparams.int_num);
+        hwif2_mod.params[gparams.dev_num].interrupts_set |= interrupt_bit;
     }
 
-    if ( !ctx )
-        goto out;
-
     /* Allocate the new channel and initialise the data members. */
     ret = -ENOMEM;
     channel = kmalloc( sizeof( dma_channel ), GFP_KERNEL );
     if (!channel)
-        goto out;
+        goto bad_channel;
     ctx->private_data = channel;
  
     ret = dma_fifo_create( &channel->fifo, gparams.buf_size );
@@ -618,7 +626,7 @@
     if ( ret )
     {
         PRINTD( COMPONENT_HWIF2, DBG_ERROR, "failed to open DMA channel" );
-        goto bad_description;
+        goto bad_dma_open;
     }
 
     if ( its_irq )
@@ -633,25 +641,32 @@
         }
     }
 
-    ret = 0;
-    goto out;
+    return ctx;
 
-bad_description:
 handler_reg_failed:
-   dma_fifo_destroy( channel->fifo );
-
+    pa->ops->dma_close( pa, chan );
+bad_dma_open:
+bad_description:
+    hwif2_mod.params[gparams.dev_num].channel[gparams.int_num] = NULL;
+    dma_fifo_destroy( channel->fifo );
 bad_fifo_alloc:
     kfree( channel );
-
+bad_channel:
+    hwif2_mod.params[gparams.dev_num].interrupts_set &= ~interrupt_bit;
+    if ( its_gpr )
+        pa->ops->put_resource( pa, its_gpr );
+    if ( itm_gpr )
+        pa->ops->put_resource( pa, itm_gpr );
+    if ( its_irq )
+        pa->ops->put_resource( pa, its_irq );
+bad_gpr:
+bad_dev_num:
+    pa->ops->put_resource(  pa, chan );
 out:
-    if ( ret )
-    {
-        kfree( ctx );
-        if ( chan )
-            pa->ops->put_resource(  pa, chan );
-    }
+    kfree( ctx );
+bad_ctx:
 
-    return ret ? ERR_PTR( ret ) : ctx;
+    return ERR_PTR( ret );
 }
 
 /*!
@@ -675,7 +690,7 @@
     pa->ops->put_resource( pa, channel->chan );
     dma_fifo_destroy( channel->fifo );
 
-    params->interrupts_set &= ( !interrupt_bit );
+    params->interrupts_set &= ( ~interrupt_bit );
     params->channel[channel->interruptNumber] = NULL;
 
     if ( !params->interrupts_set )
diff -Naur pico_2.6.28/drivers/picochip/hwif.c ipa_2.6.28/drivers/picochip/hwif.c
--- pico_2.6.28/drivers/picochip/hwif.c	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/drivers/picochip/hwif.c	2011-04-26 14:51:35.000000000 +0100
@@ -853,7 +853,7 @@
     if ( channel->fifo )
         dma_fifo_destroy( channel->fifo );
 
-    params->interrupts_set &= ( !interrupt_bit );
+    params->interrupts_set &= ( ~interrupt_bit );
 
     if ( !params->interrupts_set )
     {
diff -Naur pico_2.6.28/drivers/picochip/Kconfig ipa_2.6.28/drivers/picochip/Kconfig
--- pico_2.6.28/drivers/picochip/Kconfig	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/drivers/picochip/Kconfig	2011-04-26 14:51:35.000000000 +0100
@@ -29,6 +29,13 @@
       This driver provides a kernelspace API for accessing picoArray devices
       and a userspace interface through /dev/picoif
 
+config PICOIF_DMAPOOL
+    bool "Picoif DMA buffer pooling"
+    depends on PICOIF
+    ---help---
+      This option enables pooling and reuse of a number of DMA coherent memory
+      buffers by the transport channels.
+
 config PICOIF_PC203
     bool "PC203 picoIf support"
     select FSL_DMA
diff -Naur pico_2.6.28/drivers/picochip/pc202.c ipa_2.6.28/drivers/picochip/pc202.c
--- pico_2.6.28/drivers/picochip/pc202.c	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/drivers/picochip/pc202.c	2011-04-26 14:51:35.000000000 +0100
@@ -40,6 +40,7 @@
 #include "soft_reset.h"
 #include "utilities_internal.h"
 #include "procif.h"
+#include <mach/hardware.h>
 
 /*! The offset of the data register for a virtual port in the AHB2Pico. */
 #define AHB2PICO_VP_DATA            ( 0x08 )
@@ -516,13 +517,32 @@
 {
     struct pc202 *dev = to_pc202( pa );
     unsigned long flags;
+    u32 mask;
 
     PRINTD( COMPONENT_PC202, DBG_TRACE, "pa[%u]: reset", pa->dev_num );
 
+    /* Disable all interrupts apart from the tick timer by masking them.  In
+     * particular, we are disabling all the interrupts from the picoArray and
+     * the DMA engines to prevent us from re-entering this driver.
+     * Since the timer tick is enabled we will prevent the kernel from using
+     * that to preempt the soft reset, just in case that lets another task
+     * access the picoArray. */
+    preempt_disable();
+    
     spin_lock_irqsave( &pa->lock, flags );
+    mask = ioread32(__io(IO_ADDRESS(PC20X_VIC_BASE + VIC_ENABLE_REG_OFFSET)));
+    iowrite32(mask & (1<<IRQ_TIMER_0), __io(IO_ADDRESS(PC20X_VIC_BASE + VIC_ENABLE_REG_OFFSET)));
+    spin_unlock_irqrestore( &pa->lock, flags );
+
     picoArraySoftReset( dev->reg_base, dev->ahb_base );
+    
+    /* Re-enable previously active interrupts. */
+    spin_lock_irqsave( &pa->lock, flags );
+    iowrite32(mask, __io(IO_ADDRESS(PC20X_VIC_BASE + VIC_ENABLE_REG_OFFSET)));
     spin_unlock_irqrestore( &pa->lock, flags );
 
+    preempt_enable();
+    
     return 0;
 }
 
@@ -878,6 +898,7 @@
         if ( handler->irq == irq )
         {
             list_del( pos );
+            kfree( handler );
             found = 1;
             break;
         }
@@ -892,6 +913,7 @@
         if ( handler->irq == irq )
         {
             list_del( pos );
+            kfree( handler );
             found = 1;
             break;
         }
diff -Naur pico_2.6.28/drivers/picochip/pc203.c ipa_2.6.28/drivers/picochip/pc203.c
--- pico_2.6.28/drivers/picochip/pc203.c	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/drivers/picochip/pc203.c	2011-04-26 14:51:35.000000000 +0100
@@ -522,6 +522,7 @@
         if ( handler->irq == irq )
         {
             list_del( pos );
+            kfree( handler );
             found = 1;
             break;
         }
diff -Naur pico_2.6.28/drivers/picochip/pc302.c ipa_2.6.28/drivers/picochip/pc302.c
--- pico_2.6.28/drivers/picochip/pc302.c	2011-11-29 18:53:41.000000000 +0000
+++ ipa_2.6.28/drivers/picochip/pc302.c	2011-11-29 18:57:59.000000000 +0000
@@ -82,6 +82,9 @@
 /*! The offset of the start request bit in the operation request register. */
 #define PC302_AXI2CFG_OP_REQ_START   ( 1 << 1 )
 
+/*! The offset of the start bit in the operation status register */
+#define PC302_AXI2CFG_OP_STATUS_RUNNING  ( 1 << 1 )
+
 /*! The position of the interrupt enable bit in a virtual port config
  *  register. */
 #define AXI2PICO_INT_EN             ( 1 << 0 )
@@ -376,6 +379,18 @@
     return 0;
 }
 
+static int
+pc3xx_is_running( struct picoarray *pa )
+{
+    u16 val;
+
+    if ( 1 != pa->ops->config_read( pa, PC302_AXI2CFG_CAEID,
+                                   PC302_AXI2CFG_OP_REQ_OFFSET, 1, &val ) )
+        return 0;
+
+    return val & ( PC302_AXI2CFG_OP_STATUS_RUNNING );
+}
+
 /*!
  * Start the PC302 device running.
  *
@@ -386,11 +401,15 @@
 pc302_start( struct picoarray *pa )
 {
     u16 val;
-    int ret = pa->ops->config_read( pa, PC302_AXI2CFG_CAEID,
-                                    PC302_AXI2CFG_OP_REQ_OFFSET, 1, &val );
-    if ( 1 != ret )
+    int ret = 0;
+
+    if ( pc3xx_is_running( pa ) )
+    {
+        PRINTD( COMPONENT_PC302, DBG_WARN, "system already running");
         goto out;
-    val |= PC302_AXI2CFG_OP_REQ_START;
+    }
+
+    val = PC302_AXI2CFG_OP_REQ_START;
     ret = pa->ops->config_write( pa, PC302_AXI2CFG_CAEID,
                                  PC302_AXI2CFG_OP_REQ_OFFSET, 1, &val );
     if ( 1 != ret )
@@ -411,11 +430,15 @@
 pc302_stop( struct picoarray *pa )
 {
     u16 val;
-    int ret = pa->ops->config_read( pa, PC302_AXI2CFG_CAEID,
-                                    PC302_AXI2CFG_OP_REQ_OFFSET, 1, &val );
-    if ( 1 != ret )
+    int ret = 0;
+
+    if ( !pc3xx_is_running( pa ) )
+    {
+        PRINTD( COMPONENT_PC302, DBG_WARN, "system is not running" );
         goto out;
-    val &= ~PC302_AXI2CFG_OP_REQ_START;
+    }
+
+    val = 0;
     ret = pa->ops->config_write( pa, PC302_AXI2CFG_CAEID,
                                  PC302_AXI2CFG_OP_REQ_OFFSET, 1, &val );
     if ( 1 != ret )
@@ -542,6 +565,9 @@
          reg->value > PC302_GPR_AXI2PICO_23 )
         return -EINVAL;
 
+    if ( !pc3xx_is_running( pa ) )
+        return -EPERM;
+
     pc302_axi2pico_reg_read( dev, reg->offset + AXI2PICO_VP_STATUS_OFFSET,
                              &gprStatus );
     if ((!IS_PORT_ENABLED(gprStatus)) ||
@@ -578,6 +604,9 @@
          reg->value > PC302_GPR_AXI2PICO_23 )
         return -EINVAL;
 
+    if ( !pc3xx_is_running( pa ) )
+        return -EPERM;
+
     pc302_axi2pico_reg_read( dev, reg->offset + AXI2PICO_VP_STATUS_OFFSET,
           &gprStatus );
     if ((!IS_PORT_ENABLED(gprStatus)) ||
@@ -910,6 +939,7 @@
         if ( handler->irq == irq )
         {
             list_del( pos );
+            kfree( handler );
             break;
         }
     }
diff -Naur pico_2.6.28/drivers/picochip/picoif_internal.h ipa_2.6.28/drivers/picochip/picoif_internal.h
--- pico_2.6.28/drivers/picochip/picoif_internal.h	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/drivers/picochip/picoif_internal.h	2011-04-26 14:51:35.000000000 +0100
@@ -181,4 +181,23 @@
 #endif /* __LITTLE_ENDIAN */
 }
 
+/*!
+ * Ask picoif for a DMA coherent buffer.
+ *
+ * @param size The number of bytes to allocate.
+ * @param dma_handle Pointer to location where the bus address will be saved
+ * @param flag Flags to pass to dma_alloc_buffer if required
+ * @return Returns the virtual address of the buffer or NULL.
+ */
+void* picoif_alloc_coherent(size_t size, dma_addr_t *dma_handle, int flag);
+
+/*!
+ * Pass a DMA coherent buffer back to picoif.
+ *
+ * @param size The number of bytes that were allocated for the buffer.
+ * @param vaddr The virtual address of the buffer.
+ * @param dma_handle The bus address of the buffer.
+ */
+void picoif_free_coherent(size_t size, void *vaddr, dma_addr_t dma_handle);
+
 #endif /* !__PICOIF_PICOIF_INTERNAL_H__ */
diff -Naur pico_2.6.28/drivers/picochip/picoif_main.c ipa_2.6.28/drivers/picochip/picoif_main.c
--- pico_2.6.28/drivers/picochip/picoif_main.c	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/drivers/picochip/picoif_main.c	2011-04-26 14:51:35.000000000 +0100
@@ -55,6 +55,27 @@
  *  any DMA tranaction limits that exist if DMA is being used */
 #define PICOIF_MAX_TRANSFER_SIZE ( 4096 )
 
+#ifdef CONFIG_PICOIF_DMAPOOL
+/*
+ * We keep at most PICOIF_MAX_NUM_DMA_BUFFERS buffers in a pool ready to be
+ * re-used for DMA coherent access.  The size of each of these buffers
+ * will be exactly PICOIF_DMA_POOL_BUFFER_SIZE bytes.
+ *
+ * We have six transports, 2 each (uplink/downlink) for the Control and User
+ * planes and two for the RSE.  64K is big enough for most situations.
+ */
+#define PICOIF_MAX_NUM_DMA_BUFFERS   6
+#define PICOIF_DMA_POOL_BUFFER_SIZE  65536
+
+/*!
+ * \brief Structure to store information recycled DMA coherent buffers
+ */
+struct picoif_dmabuf_t {
+    dma_addr_t  phys;
+    void       *virt;
+};
+#endif /* CONFIG_PICOIF_DMAPOOL */
+
 /*!
  * \brief Structure to store devices in the system and any other data private
  * to the driver.
@@ -77,6 +98,12 @@
     /*! The entry in /debug/picoif for the debug log. */
     struct dentry               *debug_log;
 #endif /* CONFIG_DEBUG_FS */
+
+#ifdef CONFIG_PICOIF_DMAPOOL
+    struct picoif_dmabuf_t      dma_buffers[PICOIF_MAX_NUM_DMA_BUFFERS];
+    int                         active_dma_buffers;
+    spinlock_t                  dma_buffers_lock;
+#endif /* CONFIG_PICOIF_DMAPOOL */
 };
 
 static int
@@ -150,7 +177,7 @@
     .miscdev    =  {
         .fops   = &picoif_fops,
         .name   = "picoif",
-        .minor  = MISC_DYNAMIC_MINOR,
+        .minor  = PICOIF_MINOR,  /* Our /dev is read only, so use a fixed value */
     },
 };
 
@@ -1378,6 +1405,113 @@
     }
 }
 
+#ifdef CONFIG_PICOIF_DMAPOOL
+
+/*!
+ * DMA coherent buffer control.  We'll keep at most PICOIF_MAX_NUM_DMA_BUFFERS
+ * buffers in a pool ready to be re-used.  The size of each of these buffers
+ * will be exactly PICOIF_DMA_POOL_BUFFER_SIZE bytes.  Initially we have no
+ * buffers in the pool.  When the client asks for a buffer and we can't use a
+ * buffer from the pool, then we allocate it using dma_alloc_coherent().  If
+ * the buffer request asks for less than PICOIF_DMA_POOL_BUFFER_SIZE bytes,
+ * then we round it up to that.  If the request is for more, then we allocate
+ * exactly the size asked for.
+ *
+ *    Luckily, when the client returns the buffer it lets us know how big a buffer
+ * it asked for.  Therefore, we know that if the size that was asked for was less
+ * than PICOIF_DMA_POOL_BUFFER_SIZE we actually allocated a buffer that was exactly
+ * PICOIF_DMA_POOL_BUFFER_SIZE bytes.  This is suitable for keeping in the pool.
+ * Anything bigger than that should be freed immediately.
+ *
+ *    If the client asks for more than PICOIF_MAX_NUM_DMA_BUFFERS and returns them,
+ * we only keep that number in the pool.  After the pool has that many buffers we
+ * just free any more that are passed to us.
+ */
+void* picoif_alloc_coherent(size_t size, dma_addr_t *dma_handle, int flag)
+{
+    unsigned long  flags;
+    void          *vaddr = NULL;
+
+    /* Check first for a pool buffer that we have already allocated */
+    spin_lock_irqsave(&(picoif_core.dma_buffers_lock), flags);
+
+    if ((size <= PICOIF_DMA_POOL_BUFFER_SIZE) && (picoif_core.active_dma_buffers != 0))
+    {
+        picoif_core.active_dma_buffers--;
+
+        *dma_handle = picoif_core.dma_buffers[picoif_core.active_dma_buffers].phys;
+        vaddr       = picoif_core.dma_buffers[picoif_core.active_dma_buffers].virt;
+
+        PRINTD( COMPONENT_PICOIF, DBG_TRACE, "load pool p=%p v=%p s=%d\n",
+            *dma_handle, vaddr, size);
+    }
+
+    spin_unlock_irqrestore(&(picoif_core.dma_buffers_lock), flags);
+
+    /* If no suitable pool buffer then ask the kernel for a new one */
+    if (vaddr == NULL)
+    {
+        /* Always allocate at least the pool buffer size, that way any returned buffer
+         * that's less than this can always be pooled safely.
+         */
+        if (size < PICOIF_DMA_POOL_BUFFER_SIZE)
+        {
+            size = PICOIF_DMA_POOL_BUFFER_SIZE;
+        }
+
+        vaddr = dma_alloc_coherent(NULL, size, dma_handle, flag);
+
+        PRINTD( COMPONENT_PICOIF, DBG_TRACE, "alloc dma p=%p v=%p s=%d\n",
+            *dma_handle, vaddr, size);
+    }
+
+    return vaddr;
+}
+EXPORT_SYMBOL(picoif_alloc_coherent);
+
+/*!
+ * picoif DMA memory pool de-allocation function   This function will
+ * hold on to a DMA coherent buffer for later re-use.
+ */
+void picoif_free_coherent(size_t size, void *vaddr, dma_addr_t dma_handle)
+{
+    unsigned long flags;
+
+    spin_lock_irqsave(&(picoif_core.dma_buffers_lock), flags);
+
+    /* If we can return the buffer to the pool then do so */
+    if ((size <= PICOIF_DMA_POOL_BUFFER_SIZE) && (picoif_core.active_dma_buffers < PICOIF_MAX_NUM_DMA_BUFFERS))
+    {
+        PRINTD( COMPONENT_PICOIF, DBG_TRACE, "save pool p=%p v=%p s=%d\n",
+            dma_handle, vaddr, size);
+
+        picoif_core.dma_buffers[picoif_core.active_dma_buffers].phys = dma_handle;
+        picoif_core.dma_buffers[picoif_core.active_dma_buffers].virt = vaddr;
+
+        picoif_core.active_dma_buffers++;
+
+        vaddr = NULL;
+    }
+
+    spin_unlock_irqrestore(&(picoif_core.dma_buffers_lock), flags);
+
+    /* If buffer was not returned to the pool then free it */
+    if (vaddr != NULL)
+    {
+        if (size < PICOIF_DMA_POOL_BUFFER_SIZE)
+        {
+            size = PICOIF_DMA_POOL_BUFFER_SIZE;
+        }
+
+        PRINTD( COMPONENT_PICOIF, DBG_TRACE, "free dma p=%p v=%p s=%d\n",
+            dma_handle, vaddr, size);
+
+        dma_free_coherent(NULL, size, vaddr, dma_handle);
+    }
+}
+EXPORT_SYMBOL(picoif_free_coherent);
+#endif /* CONFIG_PICOIF_DMAPOOL */
+
 /*!
  * picoif module initialisation. This function registers the misc device
  * and performs any initialisation necessary to allow users to use the
@@ -1388,6 +1522,9 @@
 static int
 picoif_init( void )
 {
+#ifdef CONFIG_PICOIF_DMAPOOL
+    int i;
+#endif
     int ret = misc_register( &picoif_core.miscdev );
     if ( ret )
     {
@@ -1414,6 +1551,29 @@
     }
 #endif /* CONFIG_DEBUG_FS */
 
+#ifdef CONFIG_PICOIF_DMAPOOL
+    spin_lock_init(&(picoif_core.dma_buffers_lock));
+    picoif_core.active_dma_buffers = 0;
+    
+    /* Preallocate the buffers to ensure that apps that run before the
+     * transport channels are opened can't fragment it before we get a
+     * chance to allocate the DMA buffers
+     */
+    for (i=0; i<PICOIF_MAX_NUM_DMA_BUFFERS; i++)
+    {
+        dma_addr_t dma_handle;
+        void       *vaddr;
+        
+        vaddr = dma_alloc_coherent(NULL, PICOIF_DMA_POOL_BUFFER_SIZE, &dma_handle, GFP_KERNEL);
+        if (vaddr)
+        {
+            picoif_core.dma_buffers[picoif_core.active_dma_buffers].phys = dma_handle;
+            picoif_core.dma_buffers[picoif_core.active_dma_buffers].virt = vaddr;
+            picoif_core.active_dma_buffers++;
+        }
+    }
+#endif /* CONFIG_PICOIF_DMAPOOL */
+
 #ifdef CONFIG_PICOIF_PC202
     ret = pc202_init();
     if ( ret )
@@ -1501,6 +1661,26 @@
     picoif_remove_devices();
     picoif_remove_modules();
 
+#ifdef CONFIG_PICOIF_DMAPOOL
+    while (picoif_core.active_dma_buffers > 0)
+    {
+        size_t      size;
+        void*       vaddr;
+        dma_addr_t  dma_handle;
+
+        picoif_core.active_dma_buffers--;
+
+        size       = PICOIF_DMA_POOL_BUFFER_SIZE;
+        vaddr      = picoif_core.dma_buffers[picoif_core.active_dma_buffers].virt;
+        dma_handle = picoif_core.dma_buffers[picoif_core.active_dma_buffers].phys;
+
+        /* The debug ring buffer is about to be discarded so PRINTD is pointless. */
+        printk("cleanup dma p=%d v=%p s=%d\n", dma_handle, vaddr, size);
+
+        dma_free_coherent(NULL, size, vaddr, dma_handle);
+    }
+#endif /* CONFIG_PICOIF_DMAPOOL */
+    
     misc_deregister( &picoif_core.miscdev );
 
 #ifdef CONFIG_DEBUG_FS
diff -Naur pico_2.6.28/drivers/serial/8250.c ipa_2.6.28/drivers/serial/8250.c
--- pico_2.6.28/drivers/serial/8250.c	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/drivers/serial/8250.c	2011-04-26 14:51:35.000000000 +0100
@@ -7,6 +7,8 @@
  *
  *  Copyright (C) 2001 Russell King.
  *
+ * Additional PC202 (firecracker) fixes Copyright (C) 2010 ip.access Ltd
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
@@ -44,6 +46,8 @@
 
 #include "8250.h"
 
+#define IPA_VERSION "(3) "
+
 #ifdef CONFIG_SPARC
 #include "suncore.h"
 #endif
@@ -522,6 +526,45 @@
 		_serial_dl_write(up, value);
 	}
 }
+#elif defined(CONFIG_SERIAL_8250_FIRECRACKER) || defined(CONFIG_ARCH_PC302)
+
+/* Don't worry about serial_dl_read - its only used in autoconf */
+#define serial_dl_read(up) _serial_dl_read(up)
+
+static void serial_dl_write(struct uart_8250_port *up, int value)
+{
+	unsigned int lo=0, hi=0;
+	unsigned int out_lo = value & 0xff;
+	unsigned int out_hi = value >> 8 & 0xff;
+	unsigned int v;
+
+	v = serial_inp(up, UART_LCR);
+	if ((v & 0x80) == 0) {
+		/* LCR bit 7 must be 1 to write DL regs */
+		if (up->port.irq != 9) printk("8250.c: serial_dl_write: LCR=%02X\n", v);
+		return;
+	}
+
+	v = serial_inp(up, UART_FIRECRACKER_USR);
+	if (v & 0x01) {
+		/* USR bit 0 must be 0 to write DL regs */
+		if (up->port.irq != 9) printk("8250.c: serial_dl_write: USR=%02X\n", v);
+	}
+
+	serial_outp(up, UART_DLL, out_lo);
+	serial_outp(up, UART_DLM, out_hi);
+
+	lo = serial_inp(up, UART_DLL);
+	hi = serial_inp(up, UART_DLM);
+
+	/* verify */
+	if ((lo != out_lo) || (hi != out_hi)) {
+		if (up->port.irq != 9)
+			printk("8250.c: serial_dl_write: couldn't write DL regs, wrote %02X,%02X, read %02X,%02X\n",
+			      out_hi, out_lo, hi, lo);
+	}
+
+}
 #else
 #define serial_dl_read(up) _serial_dl_read(up)
 #define serial_dl_write(up, value) _serial_dl_write(up, value)
@@ -583,6 +626,134 @@
 	}
 }
 
+#if defined(CONFIG_SERIAL_8250_FIRECRACKER) || defined(CONFIG_ARCH_PC302)
+/* Wait for UART to go to idle */
+#define FIRECRACKER_IDLE_TIMEOUT ((HZ+9)/10)
+static unsigned int firecracker_wait_for_idle(struct uart_8250_port *up)
+{
+	unsigned int count=0;
+	unsigned long j;
+	unsigned int lsr=0, usr=0, iir=0;
+
+	j = jiffies;
+	while (1) {
+		/* We seem to need all these register reads to get UART to go IDLE */
+		lsr = serial_inp(up, UART_LSR);
+		(void)serial_inp(up, UART_RX);
+		iir = serial_inp(up, UART_IIR);
+		usr = serial_inp(up, UART_FIRECRACKER_USR);
+
+		if ((usr & 1) == 0) {
+			break;
+		}
+
+		if ((jiffies - j) > FIRECRACKER_IDLE_TIMEOUT) {
+			if (up->port.irq != 9) {
+			    printk("8250.c: timeout waiting for UART idle, lsr=%02X usr=%02X, iir=%02X\n",
+				   lsr, usr, iir);
+			}
+			break;
+		}
+		count++;
+		udelay(1);
+	}
+
+	return count;
+}
+
+
+#define FIRECRACKER_RESET_TIMEOUT ((HZ+99)/100)
+static void firecracker_reset_uart(struct uart_8250_port *up)
+{
+	unsigned int lcr, lsr;
+	unsigned long j;
+
+	/* Reset as much as we can and put into loop back mode */
+	/* This seems necessary to get UART to go to IDLE */
+	serial_outp(up, UART_MCR, UART_MCR_LOOP);
+	serial_outp(up, UART_IER, 0);
+	/* clear any break condition in tx (this bit DOES work!) */
+	lcr = serial_inp(up, UART_LCR);
+	serial_outp(up, UART_LCR, lcr & ~UART_LCR_SBC);
+	serial_outp(up, UART_FCR, 6);
+
+	/* 
+	 * The UART could have just started processing a rx character and
+	 * it won't show in the USR BUSY bit for half a character time.
+	 * So we need to pause for at least that long.
+	 * Half a bit time @ 600 baud is 0.4 ms.
+	 * NOTE: I increased this to 10 before adding the drain loop below, so
+	 * it could probably be reduced back down to 1ms, but there isn't time
+	 * for another round of testing.
+	 */
+	mdelay(10);
+
+	/* Drain any chars in rx or tx buffers */	
+	j = jiffies;
+	while (1) {
+		lsr = serial_inp(up, UART_LSR);
+		serial_inp(up, UART_RX);
+		serial_inp(up, UART_IIR);
+
+		/* 
+		 * We're looking for:
+		 *	TEMT=1
+		 *	THRE=1
+		 *	BI  =0
+		 *	DR  =0
+		 */
+#define FIRECRACKER_LSR_IDLE_MASK  (UART_LSR_TEMT | UART_LSR_THRE | UART_LSR_BI | UART_LSR_DR)
+#define FIRECRACKER_LSR_IDLE_VALUE (UART_LSR_TEMT | UART_LSR_THRE)
+		if ((lsr & FIRECRACKER_LSR_IDLE_MASK) == FIRECRACKER_LSR_IDLE_VALUE)
+		{
+		    break;
+		}
+
+		/* Safety timeout check so we don't spin for ever */
+		if ((jiffies - j) > FIRECRACKER_RESET_TIMEOUT)
+		{
+			if (up->port.irq != 9) {
+			    printk("8250.c: timeout draining UART, lsr=%02X\n", lsr);
+			}
+			break;
+		}
+	}
+}
+
+#define FIRECRACKER_LCR_MAX_RETRIES 10
+static void firecracker_set_lcr(struct uart_8250_port *up, unsigned int cval)
+{
+	unsigned int v;
+	int try;
+
+	/* Mask out reserved bit (just being cautious) */
+	cval &= 0xDF;
+
+	/* 
+	 * The loop is defensive, if the other measures to detect
+	 * UART Busy have worked, we should successfully write LCR first time.
+	 */
+	for (try = 0; try < FIRECRACKER_LCR_MAX_RETRIES; try++) {
+		firecracker_wait_for_idle(up);
+		serial_outp(up, UART_LCR, cval);
+		/* verify */
+		v = serial_inp(up, UART_LCR);
+		if (v == cval) {
+			/* Success! */
+			break;
+		}
+
+		/* Failed, try resetting again */
+		if (up->port.irq != 9) {
+			printk("Failed to write LCR: tried %02X, actual %02X, usr=%02X\n",
+			       cval, v, serial_inp(up, UART_FIRECRACKER_USR));
+		}
+		firecracker_reset_uart(up);
+	}
+}
+#endif /* CONFIG_SERIAL_8250_FIRECRACKER || CONFIG_ARCH_PC302 */
+
+
 #ifdef CONFIG_SERIAL_8250_RSA
 /*
  * Attempts to turn on the RSA FIFO.  Returns zero on failure.
@@ -2225,7 +2396,31 @@
 	 * Ok, we're now changing the port state.  Do it with
 	 * interrupts disabled.
 	 */
+#if defined(CONFIG_SERIAL_8250_FIRECRACKER) || defined(CONFIG_ARCH_PC302)
+	/* 
+	 * We must disable interrupts to prevent the UART starting up again
+	 * if an application writes data to the device.
+	 * Also programming the LCR can take a long time (1 character time).
+	 * So we disable just the UART interrupt to allow the rest of the 
+	 * kernel to continue to operate.
+	 */
+	disable_irq(up->port.irq);
+
+	/* Should be safe to lock unconditionally with interrupts disabled */
+	spin_lock(&up->port.lock);
+
+	/* 
+	 * Do a software reset. This will clear all regs and stop the UART
+	 * so its not busy when we write to the DLL, DLH and LCR registers.
+	 * The rest of the code fully reconfigures the UART.
+	 */
+	firecracker_reset_uart(up);
+
+	/* Silence compiler warning */
+	(void)flags;
+#else
 	spin_lock_irqsave(&up->port.lock, flags);
+#endif /* CONFIG_SERIAL_8250_FIRECRACKER || CONFIG_ARCH_PC302 */
 
 	/*
 	 * Update the per-port timeout.
@@ -2297,12 +2492,16 @@
 	}
 #endif
 
+#if defined(CONFIG_SERIAL_8250_FIRECRACKER) || defined(CONFIG_ARCH_PC302)
+	firecracker_set_lcr(up, cval | UART_LCR_DLAB);/* set DLAB */
+#else
 	if (up->capabilities & UART_NATSEMI) {
 		/* Switch to bank 2 not bank 1, to avoid resetting EXCR2 */
 		serial_outp(up, UART_LCR, 0xe0);
 	} else {
 		serial_outp(up, UART_LCR, cval | UART_LCR_DLAB);/* set DLAB */
 	}
+#endif /* CONFIG_SERIAL_8250_FIRECRACKER || CONFIG_ARCH_PC302 */
 
 	serial_dl_write(up, quot);
 
@@ -2313,7 +2512,11 @@
 	if (up->port.type == PORT_16750)
 		serial_outp(up, UART_FCR, fcr);
 
+#if defined(CONFIG_SERIAL_8250_FIRECRACKER) || defined(CONFIG_ARCH_PC302)
+	firecracker_set_lcr(up, cval);			/* reset DLAB */
+#else
 	serial_outp(up, UART_LCR, cval);		/* reset DLAB */
+#endif /* CONFIG_SERIAL_8250_FIRECRACKER || CONFIG_ARCH_PC302 */
 	up->lcr = cval;					/* Save LCR */
 	if (up->port.type != PORT_16750) {
 		if (fcr & UART_FCR_ENABLE_FIFO) {
@@ -2323,7 +2526,12 @@
 		serial_outp(up, UART_FCR, fcr);		/* set fcr */
 	}
 	serial8250_set_mctrl(&up->port, up->port.mctrl);
+#if defined(CONFIG_SERIAL_8250_FIRECRACKER) || defined(CONFIG_ARCH_PC302)
+	spin_unlock(&up->port.lock);
+	enable_irq(up->port.irq);
+#else
 	spin_unlock_irqrestore(&up->port.lock, flags);
+#endif /* CONFIG_SERIAL_8250_FIRECRACKER || CONFIG_ARCH_PC302 */
 	/* Don't rewrite B0 */
 	if (tty_termios_baud_rate(termios))
 		tty_termios_encode_baud_rate(termios, baud, baud);
@@ -2993,6 +3201,11 @@
 		if (port->dev)
 			uart->port.dev = port->dev;
 
+#if defined(CONFIG_SERIAL_8250_FIRECRACKER) || defined(CONFIG_ARCH_PC302)
+		/* Only allow loopback bit to be set */
+		uart->mcr_mask = 0x10;
+#endif /* CONFIG_SERIAL_8250_FIRECRACKER || CONFIG_ARCH_PC302 */
+
 		ret = uart_add_one_port(&serial8250_reg, &uart->port);
 		if (ret == 0)
 			ret = uart->port.line;
@@ -3035,7 +3248,7 @@
 	if (nr_uarts > UART_NR)
 		nr_uarts = UART_NR;
 
-	printk(KERN_INFO "Serial: 8250/16550 driver"
+	printk(KERN_INFO "Serial: 8250/16550 driver" IPA_VERSION
 		"%d ports, IRQ sharing %sabled\n", nr_uarts,
 		share_irqs ? "en" : "dis");
 
diff -Naur pico_2.6.28/drivers/spi/Kconfig ipa_2.6.28/drivers/spi/Kconfig
--- pico_2.6.28/drivers/spi/Kconfig	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/drivers/spi/Kconfig	2011-04-26 14:51:35.000000000 +0100
@@ -168,6 +168,21 @@
 	help
 	  Enables using the SPI master controller the on picoChip PC302 device.
           
+config SPI_PC302_GPIO
+	tristate "PC302 SPI by GPIO"
+	depends on SPI_MASTER && ARCH_PC302 && EXPERIMENTAL
+	select SPI_BITBANG
+	help
+	  SPI driver for picoChip PC302 series ARM SoCs using
+	  GPIO lines to provide the SPI bus.
+
+config SPI_PC302_IPA
+	tristate "PC302 SPI for IPA boards"
+	depends on SPI_MASTER && ARCH_PC302 && EXPERIMENTAL
+	help
+	  SPI driver for picoChip PC302 series ARM SoCs using
+	  the integrated SSI peripheral to perform the transfer.
+
 config SPI_PXA2XX
 	tristate "PXA2xx SSP SPI master"
 	depends on ARCH_PXA && EXPERIMENTAL
@@ -238,6 +253,22 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called at25.
 
+config SPI_DAC7512
+	tristate "Burr-Brown DAC7512"
+	depends on SYSFS
+	help
+	  SPI driver for the Burr-Brown DAC7512 DAC (dac7512).
+	  This provides both a sysfs interface and a misc device that
+	  can be controlled via ioctls.
+
+config SPI_MAX6662
+	tristate "Maxim MAX6662"
+	depends on SYSFS
+	help
+	  SPI driver for the MAX6662 Temperature Sensor (max6662).
+	  This provides both a sysfs interface and a misc device that
+	  can be controlled via ioctls.
+
 config SPI_SPIDEV
 	tristate "User mode SPI device driver support"
 	depends on EXPERIMENTAL
diff -Naur pico_2.6.28/drivers/spi/Makefile ipa_2.6.28/drivers/spi/Makefile
--- pico_2.6.28/drivers/spi/Makefile	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/drivers/spi/Makefile	2011-04-26 14:51:35.000000000 +0100
@@ -31,12 +31,16 @@
 obj-$(CONFIG_SPI_SH_SCI)		+= spi_sh_sci.o
 obj-$(CONFIG_SPI_FIRECRACKER)		+= spi_pc202_gpio.o
 obj-$(CONFIG_SPI_PC302)                 += pc302_spi.o
+obj-$(CONFIG_SPI_PC302_GPIO)		+= spi_pc302_gpio.o
+obj-$(CONFIG_SPI_PC302_IPA)		+= spi_pc302.o
 # 	... add above this line ...
 
 # SPI protocol drivers (device/link on bus)
 obj-$(CONFIG_SPI_AT25)		+= at25.o
 obj-$(CONFIG_SPI_SPIDEV)	+= spidev.o
 obj-$(CONFIG_SPI_TLE62X0)	+= tle62x0.o
+obj-$(CONFIG_SPI_MAX6662)	+= spi_max6662.o
+obj-$(CONFIG_SPI_DAC7512)	+= spi_dac7512.o
 # 	... add above this line ...
 
 # SPI slave controller drivers (upstream link)
diff -Naur pico_2.6.28/drivers/spi/spi_dac7512.c ipa_2.6.28/drivers/spi/spi_dac7512.c
--- pico_2.6.28/drivers/spi/spi_dac7512.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/spi/spi_dac7512.c	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,417 @@
+/*
+* dac7512.c -- support DAC7512 12-bit Digital to Analogue Converter
+*
+* Copyright (C) 2009 ip.access Ltd
+*
+* Based on at25.c
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*/
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/sched.h>
+#include <linux/ctype.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/miscdevice.h>
+#include <linux/spi/spi.h>
+
+#include <linux/ipa/dac7512.h>
+
+/* Writes to the DAC are always 16-bits */
+#define  DAC7512_TRANSFER_SIZE            (2)
+
+struct dac7512_data {
+	struct miscdevice      miscdev;
+	struct spi_device     *spi;                         /* SPI master we're using */
+	struct mutex           lock;                        /* Required for read-modify-write of config reg */
+	u8                     buf[DAC7512_TRANSFER_SIZE];  /* DMA safe buffer for SPI transfers */
+	int                    lastValue;
+};
+
+static struct dac7512_data  *dac7512_device = NULL;
+
+/* Writing to the DAC7512 requires a 16-bit command containing the output value */
+static int dac7512_writeRegister(struct dac7512_data *dac7512, u16 val)
+{
+	struct spi_transfer t = {
+	        .tx_buf     = dac7512->buf,
+	        .len        = DAC7512_TRANSFER_SIZE,
+	    };
+	struct spi_message  m;
+	int ret = 0;
+	
+	dac7512->buf[0] = (val >> 8) & 0xFF;
+	dac7512->buf[1] = val & 0xFF;
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t, &m);
+	
+	mutex_lock(&dac7512->lock);
+	
+	ret = spi_sync(dac7512->spi, &m);
+	
+	if (ret == 0)
+	{
+		dac7512->lastValue = val;
+	}
+	
+	mutex_unlock(&dac7512->lock);
+	
+	return ret;
+}
+
+/* Can't read from the device, but we can return the last value written. */
+static ssize_t dac7512_show_dac( struct device *dev, struct device_attribute *attr, char *buf )
+{
+	struct dac7512_data  *dac7512 = NULL;
+	int                   written = 0;
+	
+	dac7512 = dev_get_drvdata(dev);
+	
+	if (dac7512)
+	{
+		mutex_lock(&dac7512->lock);
+		
+		written = scnprintf( buf, PAGE_SIZE, "lastValue=%d\n", dac7512->lastValue );
+		
+		mutex_unlock(&dac7512->lock);
+	}
+	
+	return written;
+}
+
+static ssize_t dac7512_store_dac( struct device *dev, struct device_attribute *attr, const char *buf, size_t count )
+{
+	u16  dacValue = 0;
+	int  valid    = 0;
+	int  remain   = count;
+	u16  dacLimit = 0xFFF;
+	
+	/* Skip initial space. */
+	while (remain && isspace(*buf))
+	{
+		buf++;
+		remain--;
+	}
+	
+	/* Read digits. */
+	while (remain && isdigit(*buf))
+	{
+		if (dacValue < 0x1000)
+		{
+			dacValue *= 10;
+			dacValue += *buf - '0';
+			
+			/* Saw at least one digit */
+			valid = 1;
+		}
+		else
+		{
+			/* Saw too many digits, result will be too big. */
+			valid = 0;
+		}
+		
+		buf++;
+		remain--;
+	}
+	
+	/* Check that trailing characters are all space. */
+	while (remain && isspace(*buf))
+	{
+		buf++;
+		remain--;
+	}
+	
+	if (valid && (remain == 0) && (dacValue <= dacLimit))
+	{
+		struct dac7512_data  *dac7512 = dev_get_drvdata(dev);
+	
+		if (dac7512)
+		{
+			int  ret = dac7512_writeRegister(dac7512, dacValue);
+			
+			if (ret < 0)
+			{
+				printk("dac7512: write failed %d\n", ret);
+				return -EIO;
+			}
+		}
+	}
+	else
+	{
+		printk("dac7512: invalid value\n");
+		return -EINVAL;
+	}
+	
+	return count;
+}
+
+static DEVICE_ATTR( dac7512_dac, S_IRUGO | S_IWUSR, dac7512_show_dac, dac7512_store_dac );
+
+
+
+/* Baud rate */
+static ssize_t dac7512_show_baud( struct device *dev, struct device_attribute *attr, char *buf )
+{
+        struct dac7512_data  *dac7512 = NULL;
+
+        dac7512 = dev_get_drvdata(dev);
+
+        if (dac7512)
+        {
+                return scnprintf( buf, PAGE_SIZE, "%d\n", dac7512->spi->max_speed_hz );
+        }
+        else
+        {
+                return scnprintf( buf, PAGE_SIZE, "???\n" );
+        }
+}
+
+static ssize_t dac7512_store_baud( struct device *dev, struct device_attribute *attr, const char *buf, size_t count )
+{
+        struct dac7512_data  *dac7512 = NULL;
+        int                   speed;
+
+        if ((1 != sscanf(buf, "%d", &speed)) || (speed > 100000000) || (speed < 3052))
+        {
+                return -EINVAL;
+        }
+
+        dac7512 = dev_get_drvdata(dev);
+        if (!dac7512)
+        {
+                return -EIO;
+        }
+
+        dac7512->spi->max_speed_hz = speed;
+
+        spi_setup(dac7512->spi);
+
+        return count;
+}
+
+static DEVICE_ATTR( dac7512_baud, S_IRUGO | S_IWUSR, dac7512_show_baud, dac7512_store_baud );
+
+
+
+/* SPI mode */
+static ssize_t dac7512_show_mode( struct device *dev, struct device_attribute *attr, char *buf )
+{
+        struct dac7512_data  *dac7512 = NULL;
+
+        dac7512 = dev_get_drvdata(dev);
+
+        if (dac7512)
+        {
+                return scnprintf( buf, PAGE_SIZE, "%d\n", dac7512->spi->mode & 3 );
+        }
+        else
+        {
+                return scnprintf( buf, PAGE_SIZE, "???\n" );
+        }
+}
+
+static ssize_t dac7512_store_mode( struct device *dev, struct device_attribute *attr, const char *buf, size_t count )
+{
+        struct dac7512_data  *dac7512 = NULL;
+        int                   mode;
+
+        if ((1 != sscanf(buf, "%d", &mode)) || (mode > 3) || (mode < 0))
+        {
+                return -EINVAL;
+        }
+
+        dac7512 = dev_get_drvdata(dev);
+        if (!dac7512)
+        {
+                return -EIO;
+        }
+
+        dac7512->spi->mode &= ~3;
+        dac7512->spi->mode |= mode;
+
+        spi_setup(dac7512->spi);
+
+        return count;
+}
+
+static DEVICE_ATTR( dac7512_mode, S_IRUGO | S_IWUSR, dac7512_show_mode, dac7512_store_mode );
+
+
+
+
+static int dac7512_open(struct inode *inode, struct file *filp)
+{
+	int                   result = 0;
+	
+	filp->private_data  = dac7512_device;
+	
+	return result;
+}
+
+static int dac7512_release(struct inode *inode, struct file *filp)
+{
+	if (filp->private_data)
+	{
+		filp->private_data = 0;
+	}
+	
+	return 0;
+}
+
+static int dac7512_ioctl(struct inode   *inode_p,
+                struct file    *filp,
+                unsigned int   cmd,
+                unsigned long  arg)
+{
+	struct dac7512_data  *dac7512 = NULL;
+	int                   ret     = 0;
+
+	/* don't even decode wrong cmds: better returning  ENOTTY than EFAULT */
+	if (_IOC_TYPE(cmd) != DAC7512_IOCTL_MAGIC) return -ENOTTY;
+	if (_IOC_NR(cmd)    > DAC7512_IOCTL_MAXNR) return -ENOTTY;
+	
+	dac7512 = filp->private_data;
+	
+	switch (cmd)
+	{
+	case DAC7512_IOCTL_WRITE_VALUE:
+		ret = dac7512_writeRegister(dac7512, arg);
+		break;
+		
+		
+	default:  /* redundant, as cmd was checked against MAXNR */
+		ret = -ENOTTY;
+	}
+	
+	return ret;
+}
+
+static struct file_operations dac7512_fops = {
+	.owner      = THIS_MODULE,
+	.open       = dac7512_open,
+	.release    = dac7512_release,
+	.ioctl      = dac7512_ioctl,
+};
+
+
+static int dac7512_probe(struct spi_device *spi)
+{
+	struct dac7512_data  *dac7512 = NULL;
+	int                   err;
+	
+	if (dac7512_device != NULL)
+	{
+		err = -EBUSY;
+		goto err_no_dac7512_data;
+	}
+	
+	if (!(dac7512 = kzalloc(sizeof *dac7512, GFP_KERNEL))) {
+		err = -ENOMEM;
+		goto err_no_dac7512_data;
+	}
+
+	dac7512->lastValue = -1;
+	
+	dac7512->miscdev.fops   = &dac7512_fops,
+	dac7512->miscdev.name   = "dac7512",
+	dac7512->miscdev.minor  =  DAC7512_MINOR,  /* Our /dev is read only, so use a fixed value */
+	
+	err = misc_register( &dac7512->miscdev );
+	if ( err )
+	{
+		printk( KERN_INFO "failed to register dac7512 misc device\n" );
+		goto err_no_misc_device;
+	}
+	
+	mutex_init(&dac7512->lock);
+	dac7512->spi = spi_dev_get(spi);
+	dev_set_drvdata(&spi->dev, dac7512);
+	
+	err = device_create_file(&spi->dev, &dev_attr_dac7512_dac);
+	if (err)
+	{
+		goto err_no_sysfs_dac;
+	}
+	
+	err = device_create_file(&spi->dev, &dev_attr_dac7512_baud);
+	if (err)
+	{
+		goto err_no_sysfs_baud;
+	}
+	
+	err = device_create_file(&spi->dev, &dev_attr_dac7512_mode);
+	if (err)
+	{
+		goto err_no_sysfs_mode;
+	}
+	
+	dac7512_device = dac7512;
+	
+	return 0;
+	
+
+err_no_sysfs_mode:
+	device_remove_file( &spi->dev, &dev_attr_dac7512_baud);
+err_no_sysfs_baud:
+	device_remove_file( &spi->dev, &dev_attr_dac7512_dac);
+err_no_sysfs_dac:
+	misc_deregister( &dac7512->miscdev );
+err_no_misc_device:
+	kfree(dac7512);
+err_no_dac7512_data:
+	
+	return err;
+}
+
+static int __devexit dac7512_remove(struct spi_device *spi)
+{
+	struct dac7512_data	*dac7512;
+	
+	dac7512 = dev_get_drvdata(&spi->dev);
+	device_remove_file( &spi->dev, &dev_attr_dac7512_mode);
+	device_remove_file( &spi->dev, &dev_attr_dac7512_baud);
+	device_remove_file( &spi->dev, &dev_attr_dac7512_dac);
+	misc_deregister( &dac7512->miscdev );
+	kfree(dac7512);
+	dac7512_device = NULL;
+	
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static struct spi_driver dac7512_driver = {
+	.driver = {
+		.name		= "dac7512",
+		.owner		= THIS_MODULE,
+	},
+	.probe		= dac7512_probe,
+	.remove		= __devexit_p(dac7512_remove),
+};
+
+static int __init dac7512_init(void)
+{
+	return spi_register_driver(&dac7512_driver);
+}
+module_init(dac7512_init);
+
+static void __exit dac7512_exit(void)
+{
+	spi_unregister_driver(&dac7512_driver);
+}
+module_exit(dac7512_exit);
+
+MODULE_DESCRIPTION("Driver for DAC7512");
+MODULE_AUTHOR("ip.access Ltd");
+MODULE_LICENSE("GPL");
+
diff -Naur pico_2.6.28/drivers/spi/spi_max6662.c ipa_2.6.28/drivers/spi/spi_max6662.c
--- pico_2.6.28/drivers/spi/spi_max6662.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/spi/spi_max6662.c	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,1179 @@
+/*
+* max6662.c -- support Maxim 6662 Temperature Sensor
+*
+* Copyright (C) 2009 ip.access Ltd
+*
+* Based on at25.c
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*/
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/sched.h>
+#include <linux/ctype.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/miscdevice.h>
+#include <linux/spi/spi.h>
+#include <asm/uaccess.h>
+
+#ifdef CONFIG_ARCH_PC302
+#include <mach/gpio.h>
+#endif
+
+#include <linux/ipa/max6662.h>
+
+#define  MAX6662_TRANSFER_SIZE             (3)
+
+#define  MAX6662_LIMIT_REG_MIN             (-256)
+#define  MAX6662_LIMIT_REG_MAX             (255)
+
+#define  MAX6662_READ_TEMP_CMD             (0xC1)
+
+#define  MAX6662_READ_CONFIG_CMD           (0xC3)
+#define  MAX6662_WRITE_CONFIG_CMD          (0x83)
+
+#define  MAX6662_READ_THYST_CMD            (0xC5)
+#define  MAX6662_WRITE_THYST_CMD           (0x85)
+
+#define  MAX6662_READ_TMAX_CMD             (0xC7)
+#define  MAX6662_WRITE_TMAX_CMD            (0x87)
+
+#define  MAX6662_READ_TLOW_CMD             (0xC9)
+#define  MAX6662_WRITE_TLOW_CMD            (0x89)
+
+#define  MAX6662_READ_THIGH_CMD            (0xCB)
+#define  MAX6662_WRITE_THIGH_CMD           (0x8B)
+
+#define  MAX6662_CONFIG_SHUTDOWN_MODE      (1 <<  8)
+#define  MAX6662_CONFIG_INTERRUPT_MODE     (1 <<  9)
+#define  MAX6662_CONFIG_OVER_TEMP_POLARITY (1 << 10)
+#define  MAX6662_CONFIG_ALERT_POLARITY     (1 << 11)
+#define  MAX6662_CONFIG_FAULT_QUEUE        (1 << 12)
+
+#define  MAX6662_STATUS_TLOW               (1 <<  0)
+#define  MAX6662_STATUS_THIGH              (1 <<  1)
+#define  MAX6662_STATUS_TOVER              (1 <<  2)
+
+
+struct max6662_data {
+	struct miscdevice      miscdev;
+	struct spi_device     *spi;                         /* SPI master we're using */
+	struct mutex           lock;                        /* Required for read-modify-write of config reg */
+	u16                    buf[MAX6662_TRANSFER_SIZE];  /* DMA safe buffer for SPI transfers */
+};
+
+static struct max6662_data  *max6662_device = NULL;
+
+/* Writing to the MAX6662 requires an 8-bit command and a 16-bit value */
+static int max6662_writeRegister(struct max6662_data *max6662, u8 cmd, u16 val)
+{
+	struct spi_transfer t = {
+	        .rx_buf  = NULL,
+	        .tx_buf  = max6662->buf,
+	    };
+	struct spi_message  m;
+	
+	/* In 3Wire mode we'll use Microwire and pass a command and a single
+	 * 16-bit data word.  Otherwise, we'll use SPI mode and pass three
+	 * 8-bit words.  Note that the length is always specified in bytes,
+	 * so two 16-bit words needs 4 bytes.  Data is passed MSB first.
+	 */
+	if (max6662->spi->mode & SPI_3WIRE)
+	{
+		t.len           = 4,
+		t.bits_per_word = 16;
+		
+		max6662->buf[0] = cmd;
+		max6662->buf[1] = val;
+	}
+	else
+	{
+		u8 *p = (u8*)max6662->buf;
+		
+		t.len           = 3,
+		t.bits_per_word = 8;
+		
+		p[0] = cmd;
+		p[1] = (val >> 8) & 0xFF;
+		p[2] = val & 0xFF ;
+	}
+	
+	spi_message_init(&m);
+	spi_message_add_tail(&t, &m);
+	
+	return spi_sync(max6662->spi, &m);
+}
+
+/* Reading from the MAX6662 requires an 8-bit command and returns a 16-bit value */
+static int max6662_readRegister(struct max6662_data *max6662, u8 cmd, u16 *val_p)
+{
+	struct spi_transfer t = {
+	        .rx_buf  = max6662->buf,
+	        .tx_buf  = max6662->buf,
+	    };
+	struct spi_message  m;
+	int                 ret;
+	u16                 val;
+	
+	/* In 3Wire mode we'll use Microwire and pass a command and read a
+	 * single 16-bit data word.  Otherwise, we'll use SPI mode and transfer
+	 * three 8-bit words, one out, two in.  Note that the length is always
+	 * specified in bytes, so two 16-bit words needs 4 bytes.  Data is
+	 * passed MSB first.
+	 */
+	if (max6662->spi->mode & SPI_3WIRE)
+	{
+		t.len           = 4,
+		t.bits_per_word = 16;
+		
+		max6662->buf[0] = cmd;
+		max6662->buf[1] = 0xFFFF;
+	}
+	else
+	{
+		u8 *p = (u8*)max6662->buf;
+		
+		t.len           = 3,
+		t.bits_per_word = 8;
+		
+		p[0] = cmd;
+		p[1] = 0xFF;
+		p[2] = 0xFF;
+	}
+	
+	spi_message_init(&m);
+	spi_message_add_tail(&t, &m);
+	
+	ret = spi_sync(max6662->spi, &m);
+	if (ret < 0)
+	{
+		return ret;
+	}
+	
+	if (max6662->spi->mode & SPI_3WIRE)
+	{
+		val = max6662->buf[1];
+	}
+	else
+	{
+		u8 *p = (u8*)max6662->buf;
+		
+		val   = p[1];
+		val <<= 8;
+		val  |= p[2];
+	}
+	
+	if (val_p)
+	{
+		*val_p = val;
+	}
+	
+	return 0;
+}
+
+/* Temperature register.  Read only. */
+static ssize_t max6662_show_temp( struct device *dev, struct device_attribute *attr, char *buf )
+{
+	struct max6662_data  *max6662 = NULL;
+	u16                   value;
+	int                   ret;
+	int                   written = 0;
+	
+	max6662 = dev_get_drvdata(dev);
+	
+	if (max6662)
+	{
+		mutex_lock(&max6662->lock);
+		
+		ret = max6662_readRegister(max6662, MAX6662_READ_TEMP_CMD, &value);
+		
+		mutex_unlock(&max6662->lock);
+		
+		if (ret < 0)
+		{
+			written = scnprintf( buf, PAGE_SIZE, "read failure %d\n", ret );
+		}
+		else
+		{
+			int units     = (value >> 3) & 0x1FFF;
+			int fract     = 0;
+			int negative  = 0;
+			
+			/* Convert -ve to +ve and hold a sign flag */
+			if (units & 0x1000)
+			{
+				units = 0x2000 - units;
+				negative  = 1;
+			}
+	
+			/* Each code corresponds to 0.0625 degrees C */
+			units *= 625;
+			
+			/* Round from 4 decimal places to 2 decimal places */
+			units += 50;
+			units /= 100;
+	
+			/* Split whole and fractional parts */
+			fract = units % 100;
+			units /= 100;
+			
+			written = scnprintf( buf, PAGE_SIZE, "%s%d.%02d Tover=%d Thigh=%d Tlow=%d\n",
+			                     negative ? "-" : "", units, fract,
+			                     !!(value & MAX6662_STATUS_TOVER),
+			                     !!(value & MAX6662_STATUS_THIGH),
+			                     !!(value & MAX6662_STATUS_TLOW)
+			                   );
+		}
+	}
+	
+	return written;
+}
+
+static ssize_t max6662_store_temp( struct device *dev, struct device_attribute *attr, const char *buf, size_t count )
+{
+	return -EIO;
+}
+
+static DEVICE_ATTR( max6662_temp, S_IRUGO | S_IWUSR, max6662_show_temp, max6662_store_temp   );
+
+
+
+/* Configuration register */
+static ssize_t max6662_show_config( struct device *dev, struct device_attribute *attr, char *buf )
+{
+	struct max6662_data  *max6662 = NULL;
+	u16                   value;
+	int                   written = 0;
+	char                  a;
+	char                  f;
+	char                  i;
+	char                  o;
+	char                  s;
+	
+	max6662 = dev_get_drvdata(dev);
+	
+	if (max6662)
+	{
+		int  ret;
+			
+		mutex_lock(&max6662->lock);
+		
+		ret = max6662_readRegister(max6662, MAX6662_READ_CONFIG_CMD, &value);
+		
+		mutex_unlock(&max6662->lock);
+	
+		if (ret < 0)
+		{
+			written = scnprintf( buf, PAGE_SIZE, "read failure %d\n", ret );
+		}
+		else
+		{
+			a = (value & MAX6662_CONFIG_ALERT_POLARITY)     ? 'A' : 'a';
+			f = (value & MAX6662_CONFIG_FAULT_QUEUE)        ? 'F' : 'f';
+			i = (value & MAX6662_CONFIG_INTERRUPT_MODE)     ? 'I' : 'i';
+			o = (value & MAX6662_CONFIG_OVER_TEMP_POLARITY) ? 'O' : 'o';
+			s = (value & MAX6662_CONFIG_SHUTDOWN_MODE)      ? 'S' : 's';
+			
+			written = scnprintf( buf, PAGE_SIZE,
+			        "%c:alert polarity %s\n"
+			        "%c:fault queue %s\n"
+			        "%c:interrupt mode %s\n"
+			        "%c:over temperature polarity %s\n"
+			        "%c:shutdown mode %s\n",
+			        a, isupper(a)?"ON":"OFF",
+			        f, isupper(f)?"ON":"OFF",
+			        i, isupper(i)?"ON":"OFF",
+			        o, isupper(o)?"ON":"OFF",
+			        s, isupper(s)?"ON":"OFF"
+			    );
+		}
+	}
+	
+	return written;
+}
+
+static ssize_t max6662_store_config( struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct max6662_data  *max6662     = NULL;
+	int                   ret         = 0;
+	u16                   configMask  = 0;
+	u16                   configValue = 0;
+	u16                   value;
+	int                   i;
+	
+	for (i=0; i<count; ++i)
+	{
+		char c = buf[i];
+				
+		if (c == 0)
+		{
+			break;
+		}
+	
+		/* Accept lower case to clear a flag and upper case to set it */        
+		switch (c)
+		{
+		case 'A':
+			configMask  |=  MAX6662_CONFIG_ALERT_POLARITY;
+			configValue |=  MAX6662_CONFIG_ALERT_POLARITY;
+			break;
+			
+		case 'a':
+			configMask  |=  MAX6662_CONFIG_ALERT_POLARITY;
+			configValue &= ~MAX6662_CONFIG_ALERT_POLARITY;
+			break;
+			
+		case 'F':
+			configMask  |=  MAX6662_CONFIG_FAULT_QUEUE;
+			configValue |=  MAX6662_CONFIG_FAULT_QUEUE;
+			break;
+			
+		case 'f':
+			configMask  |=  MAX6662_CONFIG_FAULT_QUEUE;
+			configValue &= ~MAX6662_CONFIG_FAULT_QUEUE;
+			break;
+			
+		case 'I':
+			configMask  |=  MAX6662_CONFIG_INTERRUPT_MODE;
+			configValue |=  MAX6662_CONFIG_INTERRUPT_MODE;
+			break;
+			
+		case 'i':
+			configMask  |=  MAX6662_CONFIG_INTERRUPT_MODE;
+			configValue &= ~MAX6662_CONFIG_INTERRUPT_MODE;
+			break;
+			
+		case 'O':
+			configMask  |=  MAX6662_CONFIG_OVER_TEMP_POLARITY;
+			configValue |=  MAX6662_CONFIG_OVER_TEMP_POLARITY;
+			break;
+			
+		case 'o':
+			configMask  |=  MAX6662_CONFIG_OVER_TEMP_POLARITY;
+			configValue &= ~MAX6662_CONFIG_OVER_TEMP_POLARITY;
+			break;
+			
+		case 'S':
+			configMask  |=  MAX6662_CONFIG_SHUTDOWN_MODE;
+			configValue |=  MAX6662_CONFIG_SHUTDOWN_MODE;
+			break;
+			
+		case 's':
+			configMask  |=  MAX6662_CONFIG_SHUTDOWN_MODE;
+			configValue &= ~MAX6662_CONFIG_SHUTDOWN_MODE;
+			break;
+			
+		case ' ':
+		case '\t':
+		case '\n':
+		case '\r':
+			break;
+			
+		default:
+			printk("max6662 config invalid char[%d]=%d\n", i, c);
+			return -EINVAL;
+		}
+	}
+	
+	max6662 = dev_get_drvdata(dev);
+	
+	if (max6662)
+	{
+		mutex_lock(&max6662->lock);
+	
+		ret = max6662_readRegister(max6662, MAX6662_READ_CONFIG_CMD, &value);
+		if (ret)
+		{
+			printk("max6662:config failed to read %d\n", ret);
+			return -EIO;
+		}
+		else
+		{
+			value &= ~configMask;
+			value |= configValue;
+			
+			ret = max6662_writeRegister(max6662, MAX6662_WRITE_CONFIG_CMD, value);
+			if (ret)
+			{
+				printk("max6662:config failed to write %d\n", ret);
+				return -EIO;
+			}
+		}
+	
+		mutex_unlock(&max6662->lock);
+	}
+	
+	return count;
+}
+
+static DEVICE_ATTR( max6662_config, S_IRUGO | S_IWUSR, max6662_show_config, max6662_store_config );
+
+
+static int max6662_extractLimitValue(u16 value)
+{
+	int temp = (value >> 7) & 0x1FF;
+	
+	if (value & 0x8000)
+	{
+		temp -= 0x200;
+	}
+	
+	return temp;
+}
+
+/* The limit registers are 9-bit twos-complement in the MSBs.  The 7 LSBs are not used.
+* The value is in degrees C.
+*/
+static ssize_t max6662_show_limit_register( struct device *dev, char *buf, u8 regReadCmd )
+{
+	struct max6662_data  *max6662 = NULL;
+	u16                   value;
+	int                   ret;
+	int                   written = 0;
+	
+	max6662 = dev_get_drvdata(dev);
+	
+	if (max6662)
+	{
+		mutex_lock(&max6662->lock);
+	
+		ret = max6662_readRegister(max6662, regReadCmd, &value);
+		
+		mutex_unlock(&max6662->lock);
+		
+		if (ret < 0)
+		{
+			written = scnprintf( buf, PAGE_SIZE, "read failure %d\n", ret );
+		}
+		else
+		{
+			int temp = max6662_extractLimitValue(value);
+			
+			written = scnprintf( buf, PAGE_SIZE, "%d\n", temp );
+		}
+	}
+	
+	return written;
+}
+    
+/* The limit registers are 9-bit twos-complement in the MSBs.  The 7 LSBs are not used.
+* The value is in degrees C.
+*/
+static ssize_t max6662_store_limit_register( struct device *dev, const char *buf,
+                                            size_t count, u8 regWriteCmd )
+{
+	u16  t        = 0;
+	int  valid    = 0;
+	int  negative = 0;
+	int  remain   = count;
+	u16  limit    = MAX6662_LIMIT_REG_MAX;
+	
+	/* Skip initial space. */
+	while (remain && isspace(*buf))
+	{
+		buf++;
+		remain--;
+	}
+	
+	/* Check for sign */    
+	if (remain && (*buf == '-'))
+	{
+		negative  = 1;
+		limit = -MAX6662_LIMIT_REG_MIN;
+		
+		buf++;
+		remain--;
+	}
+	
+	/* Read digits. */
+	while (remain && isdigit(*buf))
+	{
+		if (t < 0x1000)
+		{
+			t *= 10;
+			t += *buf - '0';
+			
+			/* Saw at least one digit */
+			valid = 1;
+		}
+		else
+		{
+			/* Saw too many digits, result will be too big. */
+			valid = 0;
+		}
+		
+		buf++;
+		remain--;
+	}
+	
+	/* Check that trailing characters are all space. */
+	while (remain && isspace(*buf))
+	{
+		buf++;
+		remain--;
+	}
+	
+	if (valid && (remain == 0) && (t <= limit))
+	{
+		struct max6662_data  *max6662 = NULL;
+	
+		if (negative)
+		{
+			t = 0x200 - t;
+		}
+		
+		t <<= 7;
+				
+		max6662 = dev_get_drvdata(dev);
+	
+		if (max6662)
+		{
+			int  ret;
+			
+			mutex_lock(&max6662->lock);
+	
+			ret = max6662_writeRegister(max6662, regWriteCmd, t);
+			
+			mutex_unlock(&max6662->lock);
+			
+			if (ret < 0)
+			{
+				printk("max6662:store limit, failed to write %d\n", ret);
+				return -EIO;
+			}
+		}
+	}
+	else
+	{
+		printk("max6662:store limit, invalid value\n");
+		return -EINVAL;
+	}
+	
+	return count;
+}
+
+
+/* Hyst limit register */
+static ssize_t max6662_show_thyst( struct device *dev, struct device_attribute *attr, char *buf )
+{
+	return max6662_show_limit_register( dev, buf, MAX6662_READ_THYST_CMD );
+}
+
+static ssize_t max6662_store_thyst( struct device *dev, struct device_attribute *attr, const char *buf, size_t count )
+{
+	return max6662_store_limit_register( dev, buf, count, MAX6662_WRITE_THYST_CMD );
+}
+
+static DEVICE_ATTR( max6662_thyst, S_IRUGO | S_IWUSR, max6662_show_thyst, max6662_store_thyst  );
+
+
+
+/* Max limit register */
+static ssize_t max6662_show_tmax( struct device *dev, struct device_attribute *attr, char *buf )
+{
+	return max6662_show_limit_register( dev, buf, MAX6662_READ_TMAX_CMD );
+}
+
+static ssize_t max6662_store_tmax( struct device *dev, struct device_attribute *attr, const char *buf, size_t count )
+{
+	return max6662_store_limit_register( dev, buf, count, MAX6662_WRITE_TMAX_CMD );
+}
+
+static DEVICE_ATTR( max6662_tmax, S_IRUGO | S_IWUSR, max6662_show_tmax, max6662_store_tmax   );
+
+
+
+/* Low limit register */
+static ssize_t max6662_show_tlow( struct device *dev, struct device_attribute *attr, char *buf )
+{
+	return max6662_show_limit_register( dev, buf, MAX6662_READ_TLOW_CMD );
+}
+
+static ssize_t max6662_store_tlow( struct device *dev, struct device_attribute *attr, const char *buf, size_t count )
+{
+	return max6662_store_limit_register( dev, buf, count, MAX6662_WRITE_TLOW_CMD );
+}
+
+static DEVICE_ATTR( max6662_tlow, S_IRUGO | S_IWUSR, max6662_show_tlow, max6662_store_tlow   );
+
+
+
+/* High limit register */
+static ssize_t max6662_show_thigh( struct device *dev, struct device_attribute *attr, char *buf )
+{
+	return max6662_show_limit_register( dev, buf, MAX6662_READ_THIGH_CMD );
+}
+
+static ssize_t max6662_store_thigh( struct device *dev, struct device_attribute *attr, const char *buf, size_t count )
+{
+	return max6662_store_limit_register( dev, buf, count, MAX6662_WRITE_THIGH_CMD );
+}
+
+static DEVICE_ATTR( max6662_thigh, S_IRUGO | S_IWUSR, max6662_show_thigh, max6662_store_thigh  );
+
+
+
+/* Baud rate */
+static ssize_t max6662_show_baud( struct device *dev, struct device_attribute *attr, char *buf )
+{
+	struct max6662_data  *max6662 = NULL;
+	
+	max6662 = dev_get_drvdata(dev);
+	
+	if (max6662)
+	{
+		return scnprintf( buf, PAGE_SIZE, "%d\n", max6662->spi->max_speed_hz );
+	}
+	else
+	{
+		return scnprintf( buf, PAGE_SIZE, "???\n" );
+	}
+}
+
+static ssize_t max6662_store_baud( struct device *dev, struct device_attribute *attr, const char *buf, size_t count )
+{
+	struct max6662_data  *max6662 = NULL;
+	int                   speed;
+
+	if ((1 != sscanf(buf, "%d", &speed)) || (speed > 100000000) || (speed < 3052))
+	{
+		return -EINVAL;
+	}
+
+	max6662 = dev_get_drvdata(dev);
+	if (!max6662)
+	{
+		return -EIO;
+	}
+
+	max6662->spi->max_speed_hz = speed;
+	
+	spi_setup(max6662->spi);
+	
+	return count;
+}
+
+static DEVICE_ATTR( max6662_baud, S_IRUGO | S_IWUSR, max6662_show_baud, max6662_store_baud );
+
+
+
+/* SPI mode */
+static ssize_t max6662_show_mode( struct device *dev, struct device_attribute *attr, char *buf )
+{
+	struct max6662_data  *max6662 = NULL;
+	
+	max6662 = dev_get_drvdata(dev);
+	
+	if (max6662)
+	{
+		return scnprintf( buf, PAGE_SIZE, "%d\n", max6662->spi->mode & 3 );
+	}
+	else
+	{
+		return scnprintf( buf, PAGE_SIZE, "???\n" );
+	}
+}
+
+static ssize_t max6662_store_mode( struct device *dev, struct device_attribute *attr, const char *buf, size_t count )
+{
+	struct max6662_data  *max6662 = NULL;
+	int                   mode;
+
+	if ((1 != sscanf(buf, "%d", &mode)) || (mode > 3) || (mode < 0))
+	{
+		return -EINVAL;
+	}
+
+	max6662 = dev_get_drvdata(dev);
+	if (!max6662)
+	{
+		return -EIO;
+	}
+
+	max6662->spi->mode &= ~3;
+	max6662->spi->mode |= mode;
+
+	spi_setup(max6662->spi);
+
+	return count;
+}
+
+static DEVICE_ATTR( max6662_mode, S_IRUGO | S_IWUSR, max6662_show_mode, max6662_store_mode );
+
+
+
+/* SPI 3-Wire */
+static ssize_t max6662_show_3wire( struct device *dev, struct device_attribute *attr, char *buf )
+{
+	struct max6662_data  *max6662 = NULL;
+	
+	max6662 = dev_get_drvdata(dev);
+	
+	if (max6662)
+	{
+		return scnprintf( buf, PAGE_SIZE, "%d\n", (max6662->spi->mode & SPI_3WIRE) ? 1 : 0 );
+	}
+	else
+	{
+		return scnprintf( buf, PAGE_SIZE, "???\n" );
+	}
+}
+
+static ssize_t max6662_store_3wire( struct device *dev, struct device_attribute *attr, const char *buf, size_t count )
+{
+	struct max6662_data  *max6662 = NULL;
+	int                   threeWire;
+
+	if ((1 != sscanf(buf, "%d", &threeWire)) || (threeWire > 1) || (threeWire < 0))
+	{
+		return -EINVAL;
+	}
+
+	max6662 = dev_get_drvdata(dev);
+	if (!max6662)
+	{
+		return -EIO;
+	}
+
+	if (threeWire)
+	{
+		max6662->spi->mode |= SPI_3WIRE;
+	}
+	else
+	{
+		max6662->spi->mode &= ~SPI_3WIRE;
+	}
+
+	spi_setup(max6662->spi);
+
+	return count;
+}
+
+static DEVICE_ATTR( max6662_3wire, S_IRUGO | S_IWUSR, max6662_show_3wire, max6662_store_3wire );
+
+
+
+
+
+static int max6662_open(struct inode *inode, struct file *filp)
+{
+	int                   result = 0;
+	
+	filp->private_data  = max6662_device;
+	
+	return result;
+}
+
+static int max6662_release(struct inode *inode, struct file *filp)
+{
+	if (filp->private_data)
+	{
+		filp->private_data = 0;
+	}
+	
+	return 0;
+}
+
+static int max6662_writeLimitRegister(struct max6662_data *max6662, u8 cmd, int temp)
+{
+	int  ret = 0;
+	
+	if (temp != MAX6662_DONT_UPDATE_LIMIT)
+	{
+		if ((temp < MAX6662_LIMIT_REG_MIN) || (temp > MAX6662_LIMIT_REG_MAX))
+		{
+			ret = -EINVAL;
+		}
+		else
+		{
+			u16 regVal;
+			 
+			if (temp < 0)
+			{
+				regVal = 0x200 + temp;
+			}
+			else
+			{
+				regVal = temp;
+			}
+			 
+			regVal <<= 7;
+			
+			ret = max6662_writeRegister(max6662, cmd, regVal);
+		}
+	}
+	
+	return ret;
+}
+
+static int max6662_readLimitRegister(struct max6662_data *max6662, u8 cmd, int* temp)
+{
+	int  ret = 0;
+	u16  regVal;
+	
+	ret = max6662_readRegister(max6662, cmd, &regVal);
+	if (ret)
+	{
+		return ret;
+	}
+	
+	*temp = max6662_extractLimitValue(regVal);
+	
+	return 0;
+}
+
+static int max6662_ioctl(struct inode   *inode_p,
+                struct file    *filp,
+                unsigned int   cmd,
+                unsigned long  arg)
+{
+	struct max6662_data  *max6662 = NULL;
+	int                   ret     = 0;
+
+	/* don't even decode wrong cmds: better returning  ENOTTY than EFAULT */
+	if (_IOC_TYPE(cmd) != MAX6662_IOCTL_MAGIC) return -ENOTTY;
+	if (_IOC_NR(cmd)    > MAX6662_IOCTL_MAXNR) return -ENOTTY;
+	
+	max6662 = filp->private_data;
+	
+	switch (cmd)
+	{
+	case MAX6662_IOCTL_READ_TEMP:
+		{
+			Max6662Status  status;
+			u16            value;
+			
+			ret = max6662_readRegister(max6662, MAX6662_READ_TEMP_CMD, &value);
+			if (ret)
+			{
+				break;
+			}
+			
+			status.flags   = value & 7;
+			
+			status.scaledCelcius = (value >> 3) & 0x1FFF;
+			if (status.scaledCelcius & 0x1000)
+			{
+				status.scaledCelcius = 0x2000 - status.scaledCelcius;
+			}
+			
+			if (copy_to_user((void*)arg, &status, sizeof(status)))
+			{
+				ret = -EFAULT;
+			}
+		}
+		break;
+	
+	case MAX6662_IOCTL_WRITE_CONFIG:
+		{
+			Max6662Config  config;
+			
+			if (copy_from_user(&config, (void*)arg, sizeof(config)))
+			{
+				ret = -EFAULT;
+				break;
+			}
+		
+			ret = max6662_writeRegister(max6662, MAX6662_WRITE_CONFIG_CMD, config.flags);
+		}
+		break;
+		
+	case MAX6662_IOCTL_READ_CONFIG:
+		{
+			Max6662Config  config;
+			u16            value;
+			
+			ret = max6662_readRegister(max6662, MAX6662_READ_CONFIG_CMD, &value);
+			if (ret)
+			{
+				break;
+			}
+			
+			config.flags = value;
+			
+			if (copy_to_user((void*)arg, &config, sizeof(config)))
+			{
+				ret = -EFAULT;
+			}
+		}
+		break;
+		
+	case MAX6662_IOCTL_WRITE_LIMITS:
+		{
+			Max6662Limits  limits;
+			
+			if (copy_from_user(&limits, (void*)arg, sizeof(limits)))
+			{
+				ret = -EFAULT;
+				break;
+			}
+			
+			ret = max6662_writeLimitRegister(max6662, MAX6662_WRITE_THIGH_CMD, limits.thigh);
+			if (ret)
+			{
+				break;
+			}
+			
+			ret = max6662_writeLimitRegister(max6662, MAX6662_WRITE_TLOW_CMD, limits.tlow);
+			if (ret)
+			{
+				break;
+			}
+			
+			ret = max6662_writeLimitRegister(max6662, MAX6662_WRITE_TMAX_CMD, limits.tmax);
+			if (ret)
+			{
+				break;
+			}
+			
+			ret = max6662_writeLimitRegister(max6662, MAX6662_WRITE_THYST_CMD, limits.thyst);
+		}
+		break;
+		
+	case MAX6662_IOCTL_READ_LIMITS:
+		{
+			Max6662Limits  limits;
+			
+			ret = max6662_readLimitRegister(max6662, MAX6662_READ_THIGH_CMD, &limits.thigh);
+			if (ret)
+			{
+				break;
+			}
+			
+			ret = max6662_readLimitRegister(max6662, MAX6662_READ_TLOW_CMD, &limits.tlow);
+			if (ret)
+			{
+				break;
+			}
+			
+			ret = max6662_readLimitRegister(max6662, MAX6662_READ_TMAX_CMD, &limits.tmax);
+			if (ret)
+			{
+				break;
+			}
+			
+			ret = max6662_readLimitRegister(max6662, MAX6662_READ_THYST_CMD, &limits.thyst);
+			if (ret)
+			{
+				break;
+			}
+			
+			if (copy_to_user((void*)arg, &limits, sizeof(limits)))
+			{
+				ret = -EFAULT;
+			}
+		}
+		break;
+		
+	default:  /* redundant, as cmd was checked against MAXNR */
+		ret = -ENOTTY;
+	}
+	
+	return ret;
+}
+
+static struct file_operations max6662_fops = {
+	.owner      = THIS_MODULE,
+	.open       = max6662_open,
+	.release    = max6662_release,
+	.ioctl      = max6662_ioctl,
+};
+
+
+static int max6662_probe(struct spi_device *spi)
+{
+	struct max6662_data  *max6662 = NULL;
+	int                   err;
+	
+	if (max6662_device != NULL)
+	{
+		err = -EBUSY;
+		goto err_no_max6662_data;
+	}
+	
+	if (!(max6662 = kzalloc(sizeof *max6662, GFP_KERNEL))) {
+		err = -ENOMEM;
+		goto err_no_max6662_data;
+	}
+	
+	max6662->miscdev.fops   = &max6662_fops;
+	max6662->miscdev.name   = "max6662";
+	max6662->miscdev.minor  =  MAX6662_MINOR;  /* Our /dev is read only, so use a fixed value */
+	
+	err = misc_register( &max6662->miscdev );
+	if ( err )
+	{
+		printk( KERN_INFO "failed to register max6662 misc device\n" );
+		goto err_no_misc_device;
+	}
+	
+	mutex_init(&max6662->lock);
+	max6662->spi = spi_dev_get(spi);
+	dev_set_drvdata(&spi->dev, max6662);
+
+#ifdef CONFIG_ARCH_PC302
+	/* Just in case we can't use the SSI block's chip selects, we'll allow
+	 * the platform to specify a GPIO line to use as a chip select via the
+	 * platform_data pointer.  This will be the number of the GPIO to use.
+	 */
+	if (spi->dev.platform_data)
+	{
+		err = gpio_request((unsigned)(spi->dev.platform_data), "max_cs");
+		if (err)
+		{
+			printk( KERN_INFO "failed to request max6662 gpio CS\n" );
+			goto err_request_max_cs;
+		}
+
+		gpio_direction_output((unsigned)(spi->dev.platform_data), (spi->mode & SPI_CS_HIGH) ? 0 : 1);
+		gpio_set_value((unsigned)(spi->dev.platform_data), (spi->mode & SPI_CS_HIGH) ? 0 : 1);
+	}
+#endif
+	
+	err = device_create_file(&spi->dev, &dev_attr_max6662_temp);
+	if (err)
+	{
+		goto err_no_sysfs_temp;
+	}
+	err = device_create_file(&spi->dev, &dev_attr_max6662_config);
+	if (err)
+	{
+		goto err_no_sysfs_config;
+	}
+	err = device_create_file(&spi->dev, &dev_attr_max6662_thyst);
+	if (err)
+	{
+		goto err_no_sysfs_thyst;
+	}
+	err = device_create_file(&spi->dev, &dev_attr_max6662_tmax);
+	if (err)
+	{
+		goto err_no_sysfs_tmax;
+	}
+	err = device_create_file(&spi->dev, &dev_attr_max6662_tlow);
+	if (err)
+	{
+		goto err_no_sysfs_tlow;
+	}
+	err = device_create_file(&spi->dev, &dev_attr_max6662_thigh);
+	if (err)
+	{
+		goto err_no_sysfs_thigh;
+	}
+	err = device_create_file(&spi->dev, &dev_attr_max6662_baud);
+	if (err)
+	{
+		goto err_no_sysfs_baud;
+	}
+	err = device_create_file(&spi->dev, &dev_attr_max6662_mode);
+	if (err)
+	{
+		goto err_no_sysfs_mode;
+	}
+	
+	err = device_create_file(&spi->dev, &dev_attr_max6662_3wire);
+	if (err)
+	{
+		goto err_no_sysfs_3wire;
+	}
+	
+	max6662_device = max6662;
+	
+	return 0;
+	
+
+err_no_sysfs_3wire:
+	device_remove_file( &spi->dev, &dev_attr_max6662_mode);
+err_no_sysfs_mode:
+	device_remove_file( &spi->dev, &dev_attr_max6662_baud);
+err_no_sysfs_baud:
+	device_remove_file( &spi->dev, &dev_attr_max6662_thigh);
+err_no_sysfs_thigh:
+	device_remove_file( &spi->dev, &dev_attr_max6662_tlow);
+err_no_sysfs_tlow:
+	device_remove_file( &spi->dev, &dev_attr_max6662_tmax);
+err_no_sysfs_tmax:
+	device_remove_file( &spi->dev, &dev_attr_max6662_thyst);
+err_no_sysfs_thyst:
+	device_remove_file( &spi->dev, &dev_attr_max6662_config);
+err_no_sysfs_config:
+	device_remove_file( &spi->dev, &dev_attr_max6662_temp);
+err_no_sysfs_temp:
+#ifdef CONFIG_ARCH_PC302
+	if (spi->dev.platform_data)
+	{
+		gpio_free((unsigned)(spi->dev.platform_data));
+	}
+err_request_max_cs:
+#endif
+	misc_deregister( &max6662->miscdev );
+err_no_misc_device:
+	kfree(max6662);
+err_no_max6662_data:
+	
+	return err;
+}
+
+static int __devexit max6662_remove(struct spi_device *spi)
+{
+	struct max6662_data	*max6662;
+	
+	max6662 = dev_get_drvdata(&spi->dev);
+	device_remove_file( &spi->dev, &dev_attr_max6662_3wire);
+	device_remove_file( &spi->dev, &dev_attr_max6662_mode);
+	device_remove_file( &spi->dev, &dev_attr_max6662_baud);
+	device_remove_file( &spi->dev, &dev_attr_max6662_thigh);
+	device_remove_file( &spi->dev, &dev_attr_max6662_tlow);
+	device_remove_file( &spi->dev, &dev_attr_max6662_tmax);
+	device_remove_file( &spi->dev, &dev_attr_max6662_thyst);
+	device_remove_file( &spi->dev, &dev_attr_max6662_config);
+	device_remove_file( &spi->dev, &dev_attr_max6662_temp);
+#ifdef CONFIG_ARCH_PC302
+	if (spi->dev.platform_data)
+	{
+		gpio_free((unsigned)(spi->dev.platform_data));
+	}
+#endif
+	misc_deregister( &max6662->miscdev );
+	kfree(max6662);
+	max6662_device = NULL;
+	
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static struct spi_driver max6662_driver = {
+	.driver = {
+		.name		= "max6662",
+		.owner		= THIS_MODULE,
+	},
+	.probe		= max6662_probe,
+	.remove		= __devexit_p(max6662_remove),
+};
+
+static int __init max6662_init(void)
+{
+	return spi_register_driver(&max6662_driver);
+}
+module_init(max6662_init);
+
+static void __exit max6662_exit(void)
+{
+	spi_unregister_driver(&max6662_driver);
+}
+module_exit(max6662_exit);
+
+MODULE_DESCRIPTION("Driver for Maxim 6662");
+MODULE_AUTHOR("ip.access Ltd");
+MODULE_LICENSE("GPL");
+
diff -Naur pico_2.6.28/drivers/spi/spi_pc302.c ipa_2.6.28/drivers/spi/spi_pc302.c
--- pico_2.6.28/drivers/spi/spi_pc302.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/spi/spi_pc302.c	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,890 @@
+/*
+ * spi_pc302.c - PC302 SPI controller driver.
+ *
+ * Based on linux/device/spi/spi_txx9.c
+ * Copyright (C) 2009 ip.access Ltd
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ *
+ * Convert to generic SPI framework - Atsushi Nemoto (anemo@mba.ocn.ne.jp)
+ */
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/spi/spi.h>
+#include <linux/err.h>
+#include <linux/io.h>
+
+#include <mach/spi-gpio.h>
+
+#ifdef CONFIG_ARCH_PC302
+
+#include <mach/gpio.h>
+#include <mach/pc302/axi2cfg.h>
+#include <mach/pc302/ssi.h>
+#include <mach/pc302/pc302.h>
+
+#else
+
+/* Test version for PC202 with printk to indicate HW access */
+
+#define SSI_CTRL_REG_0_REG_OFFSET                   0x00
+#define SSI_CTRL_REG_1_REG_OFFSET                   0x04
+#define SSI_ENABLE_REG_REG_OFFSET                   0x08
+#define SSI_MW_CTRL_REG_OFFSET                      0x0C
+#define SSI_SLAVE_ENABLE_REG_OFFSET                 0x10
+#define SSI_BAUD_RATE_SEL_REG_OFFSET                0x14
+#define SSI_TX_FIFO_THRESHOLD_REG_OFFSET            0x18
+#define SSI_RX_FIFO_THRESHOLD_REG_OFFSET            0x1C
+#define SSI_IMR_REG_OFFSET                          0x2C
+#define SSI_STATUS_REG_OFFSET                       0x28
+#define SSI_ISR_REG_OFFSET                          0x30
+#define SSI_DATA_REG_OFFSET                         0x60                        
+
+#define PC302_TIMER_FREQ        200000000   /* 200 MHz */
+
+#define AXI2CFG_DECODE_MUX_3_IDX           11
+#define AXI2CFG_DECODE_MUX_2_IDX           10
+#define AXI2CFG_DECODE_MUX_1_IDX            9
+#define AXI2CFG_DECODE_MUX_0_IDX            8
+
+#define AXI2CFG_DECODE_MUX_3                1 << AXI2CFG_DECODE_MUX_3_IDX
+#define AXI2CFG_DECODE_MUX_2                1 << AXI2CFG_DECODE_MUX_2_IDX
+#define AXI2CFG_DECODE_MUX_1                1 << AXI2CFG_DECODE_MUX_1_IDX
+#define AXI2CFG_DECODE_MUX_0                1 << AXI2CFG_DECODE_MUX_0_IDX
+
+#define AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_MASK   \
+      (AXI2CFG_DECODE_MUX_0 | AXI2CFG_DECODE_MUX_1 | AXI2CFG_DECODE_MUX_2 | AXI2CFG_DECODE_MUX_3)
+
+#endif
+
+#define PC302_SPI_FIFO_SIZE                   (8)
+
+/* Baud rate divisor is 16 bits, but must be even */
+#define PC302_SPI_MIN_CLK_DIVIDER             (2)
+#define PC302_SPI_MAX_CLK_DIVIDER             (65534)
+
+/* SSI_CTRL_REG_0_REG_OFFSET bites */
+#define PC302_SPI_MW_CTRL_WORD_8_BIT          (7 << 12)
+#define PC302_SPI_MW_CTRL_WORD_7_BIT          (6 << 12)
+#define PC302_SPI_NORMAL_MODE                 (0 << 11)
+#define PC302_SPI_LOOPBACK_MODE               (1 << 11)
+#define PC302_SPI_TMOD_TX_RX                  (0 <<  8)
+#define PC302_SPI_TMOD_TX                     (1 <<  8)
+#define PC302_SPI_TMOD_RX                     (2 <<  8)
+#define PC302_SPI_TMOD_EEPROM_RX              (3 <<  8)
+#define PC302_SPI_SCPOL                       (1 <<  7)
+#define PC302_SPI_SCPH                        (1 <<  6)
+#define PC302_SPI_MOTO_SPI_FORMAT             (0x0 << 4)
+#define PC302_SPI_TI_SSP_FORMAT               (0x1 << 4)
+#define PC302_SPI_NI_MW_FORMAT                (0x2 << 4)
+#define PC302_SPI_DATA_FRM_16_BIT             (15)
+#define PC302_SPI_DATA_FRM_8_BIT              (7)
+
+/* SSI_MW_CTRL_REG_OFFSET bits */
+#define PC302_SPI_MICROWIRE_HANDSHAKE         (1 << 2)
+#define PC302_SPI_MICROWIRE_READ              (0 << 1)
+#define PC302_SPI_MICROWIRE_WRITE             (1 << 1)
+#define PC302_SPI_MICROWIRE_DISCONTINUOUS     (0 << 0)
+#define PC302_SPI_MICROWIRE_CONTINUOUS        (1 << 0)
+
+/* SSI_ENABLE_REG_REG_OFFSET bits */
+#define PC302_SPI_ENABLE                      (1)
+#define PC302_SPI_DISABLE                     (0)
+
+/* SSI_SLAVE_ENABLE_REG_OFFSET bits */
+#define PC302_SPI_SLAVES_DISABLE              (0)
+
+/* SSI_STATUS_REG_OFFSET bits */
+#define PC302_SPI_STATUS_TX_ERROR             (1 << 5)
+#define PC302_SPI_STATUS_RX_FIFO_FULL         (1 << 4)
+#define PC302_SPI_STATUS_RX_FIFO_NOT_EMPTY    (1 << 3)
+#define PC302_SPI_STATUS_TX_FIFO_EMPTY        (1 << 2)
+#define PC302_SPI_STATUS_TX_FIFO_NOT_FULL     (1 << 1)
+#define PC302_SPI_STATUS_BUSY                 (1 << 0)
+
+/* SSI_IMR_REG_RESET bits */
+#define PC302_SPI_MASK_ALL_INTS               (0)
+#define PC302_SPI_TX_FIFO_EMPTY_INT           (1 << 0)
+#define PC302_SPI_RX_FIFO_FULL_INT            (1 << 4)
+
+
+struct pc302spi {
+	struct workqueue_struct*    workqueue;
+	struct work_struct          work;
+	spinlock_t                  lock; /* protect 'queue' */
+	struct list_head            queue;
+	wait_queue_head_t           waitq;
+	void __iomem*               membase_p;
+	int                         baseclk;
+	u32                         max_speed_hz;
+	u32                         min_speed_hz;
+	struct pc302_spi_info*      info;
+	const u8*                   activeTxBuf8_p;
+	const u16*                  activeTxBuf16_p;
+	s32                         activeTxLen;
+	u8*                         activeRxBuf8_p;
+	u16*                        activeRxBuf16_p;
+	s32                         activeRxLen;
+};
+
+static inline u16 pc302spi_rd(struct pc302spi *c, int reg)
+{
+#ifdef CONFIG_ARCH_PC302
+	return __raw_readw((u16*)((u8*)c->membase_p + reg));
+#else
+	printk("Read from SPI reg %p+%x (Always 0)\n", c->membase_p, reg);
+	return 0;
+#endif
+}
+
+static inline void pc302spi_wr(struct pc302spi *c, u16 val, int reg)
+{
+#ifdef CONFIG_ARCH_PC302
+	__raw_writew(val, (u16*)((u8*)c->membase_p + reg));
+#else
+	printk("Write 0x%08X to SPI reg %p+%x\n", val, c->membase_p, reg);
+#endif
+}
+
+static void pc302spi_wr_n(struct pc302spi *c, u16 *val_p, int reg, int count)
+{
+	u16*  addr = (u16*)((u8*)c->membase_p + reg);
+
+	while (count > 0)
+	{
+		count--;
+#ifdef CONFIG_ARCH_PC302
+		__raw_writew(*val_p++, addr);
+#else
+		printk("Write(%d) 0x%08X to SPI reg %p\n", count, *val_p++, addr);
+#endif
+	}
+}
+
+static int pc302spi_setup(struct spi_device *spi)
+{
+	struct pc302spi *c = spi_master_get_devdata(spi->master);
+	u8 bits_per_word;
+	
+	if (spi->mode & ~(SPI_CPOL|SPI_CPHA|SPI_3WIRE|SPI_CS_HIGH))
+		return -EINVAL;
+	
+	if (!spi->max_speed_hz
+			|| spi->max_speed_hz > c->max_speed_hz
+			|| spi->max_speed_hz < c->min_speed_hz)
+		return -EINVAL;
+	
+	bits_per_word = spi->bits_per_word ? : 8;
+	if ((bits_per_word != 8) && (bits_per_word != 16))
+		return -EINVAL;
+	
+	return 0;
+}
+
+#ifdef CONFIG_ARCH_PC302
+static irqreturn_t pc302spi_interrupt(int irq, void *dev_id)
+{
+	struct pc302spi *c = dev_id;
+	u16              isrStatus;
+	
+	isrStatus = pc302spi_rd(c, SSI_ISR_REG_OFFSET);
+	
+	while (isrStatus & PC302_SPI_RX_FIFO_FULL_INT)
+	{
+		/* There's data available in the RX FIFO */
+		u16  data = pc302spi_rd(c, SSI_DATA_REG_OFFSET);
+
+		/* The activeRxLen is either the number of bytes or words left
+		 * to read.  Only one of the pointers (8 vs 16-bit) will be
+		 * active at any time, and it's possible that neither is active
+		 */
+		if (c->activeRxLen > 0)
+		{
+			c->activeRxLen--;
+			
+			if (c->activeRxBuf8_p)
+			{
+				*(c->activeRxBuf8_p)++ = data;
+			}
+			else if (c->activeRxBuf16_p)
+			{
+				*(c->activeRxBuf16_p)++ = data;
+			}
+		}
+		
+		if (c->activeRxLen <= 0)
+		{
+			/* Disable further Rx interrupts */
+			u16  mask;
+				
+			mask = pc302spi_rd(c, SSI_IMR_REG_OFFSET);
+			mask &= ~PC302_SPI_RX_FIFO_FULL_INT;
+			pc302spi_wr(c, mask, SSI_IMR_REG_OFFSET);
+			
+			/* Inform the upper layers when we've finished */
+			if (c->activeTxLen <= 0)
+			{
+				wake_up(&c->waitq);
+			}
+		}
+	
+		isrStatus = pc302spi_rd(c, SSI_ISR_REG_OFFSET);
+	}
+	
+	while (isrStatus & PC302_SPI_TX_FIFO_EMPTY_INT)
+	{
+		/* Transmit FIFO can accept more data */
+		
+		/* The activeTxLen is either the number of bytes or words left
+		 * to write.  Only one of the pointers (8 vs 16-bit) will be
+		 * active at any time, and it's possible that neither is active
+		 */
+		if (c->activeTxLen > 0)
+		{
+			u16  data = 0xFFFF;
+			
+			c->activeTxLen--;
+			
+			if (c->activeTxBuf8_p)
+			{
+				data = *(c->activeTxBuf8_p)++;
+			}
+			else if (c->activeTxBuf16_p)
+			{
+				data = *(c->activeTxBuf16_p)++;
+			}
+			
+			pc302spi_wr(c, data, SSI_DATA_REG_OFFSET);
+		}
+		
+		if (c->activeTxLen <= 0)
+		{
+			/* Disable further Tx interrupts */
+			u16  mask;
+			
+			mask = pc302spi_rd(c, SSI_IMR_REG_OFFSET);
+			mask &= ~PC302_SPI_TX_FIFO_EMPTY_INT;
+			pc302spi_wr(c, mask, SSI_IMR_REG_OFFSET);
+			
+			if (c->activeRxLen <= 0)
+			{
+				wake_up(&c->waitq);
+			}
+		}
+	
+		isrStatus = pc302spi_rd(c, SSI_ISR_REG_OFFSET);
+	}
+	
+	return IRQ_HANDLED;
+}
+#endif
+
+static void pc302spi_work_one(struct pc302spi *c, struct spi_message *m)
+{
+	struct spi_device    *spi = m->spi;
+	struct spi_transfer  *t;
+	u16                   ctrlr0;
+	u16                   ctrlr1;
+	u16                   mwcr;
+	u32                   prev_speed_hz = 0;
+	u16                   status;
+	unsigned long         flags;
+	
+	/* Wait until any previous transfer has completed. */
+	do
+	{
+		status = pc302spi_rd(c, SSI_STATUS_REG_OFFSET);
+		status &= PC302_SPI_STATUS_BUSY;
+		if (status)
+		{
+			cpu_relax();
+		}
+	}
+	while (status);
+	
+	pc302spi_wr(c, PC302_SPI_DISABLE, SSI_ENABLE_REG_REG_OFFSET);
+	
+	/* Enable the appropriate chip select */
+	pc302spi_wr(c, 1 << spi->chip_select, SSI_SLAVE_ENABLE_REG_OFFSET);
+		
+	/* Perform each transfer in the message */
+	list_for_each_entry (t, &m->transfers, transfer_list) {
+	
+		u8    bits_per_word = t->bits_per_word ? : spi->bits_per_word;
+		u32   speed_hz      = t->speed_hz      ? : spi->max_speed_hz;
+		u16   intMask;
+		int   i;
+		int   n;
+		int   ret;
+		u32   timeout;
+		u16   data[PC302_SPI_FIFO_SIZE];
+		int   shiftCmd = 0;   /* We might have to fiddle with the command we send */
+
+		bits_per_word = bits_per_word ? : 8;
+		
+		/* Ensure interrupts are disabled to begin with */
+		pc302spi_wr(c, 0, SSI_IMR_REG_OFFSET);
+		
+		/* Set baud rate */    
+		if (prev_speed_hz != speed_hz)
+		{
+			u32 clkDiv;
+			
+			/* Calculate the divisor.  This must be even and we must always
+			 * round the divisor up to avoid exceeding the maximum requested
+			 */
+			clkDiv = (c->baseclk + speed_hz - 1) / speed_hz;
+			clkDiv += clkDiv & 1;
+			
+			if (clkDiv < PC302_SPI_MIN_CLK_DIVIDER)
+			{
+				clkDiv = PC302_SPI_MIN_CLK_DIVIDER;
+			}
+			else if (clkDiv > PC302_SPI_MAX_CLK_DIVIDER)
+			{
+				clkDiv = PC302_SPI_MAX_CLK_DIVIDER;
+			}
+			
+			pc302spi_wr(c, clkDiv, SSI_BAUD_RATE_SEL_REG_OFFSET);
+			
+			prev_speed_hz = speed_hz;
+		}
+
+		/* Configure the transfer mode */
+		ctrlr0 = PC302_SPI_NORMAL_MODE | PC302_SPI_TMOD_TX_RX;
+		ctrlr1 = 0;
+		
+		if (spi->mode & SPI_CPOL)
+		{
+			ctrlr0 |= PC302_SPI_SCPOL;
+		}
+		if (spi->mode & SPI_CPHA)
+		{
+			ctrlr0 |= PC302_SPI_SCPH;
+		}
+
+		/* Get local copies of the lengths and pointers to the buffers for use
+		 * by the interrupt service routine.
+		 */
+		c->activeTxBuf8_p  = NULL;
+		c->activeRxBuf8_p  = NULL;
+		c->activeTxBuf16_p = NULL;
+		c->activeRxBuf16_p = NULL;
+
+		/* We can perform 8-bit or 16-bit transfers.  The t->len field
+		 * is the number of bytes in either case.  If not specified then
+		 * default to 8-bit words.
+		 */
+		if (bits_per_word == 16)
+		{
+			c->activeTxLen   = t->len / 2;
+			c->activeRxLen   = t->len / 2;
+		
+			c->activeTxBuf16_p = t->tx_buf;
+			c->activeRxBuf16_p = t->rx_buf;
+			
+			ctrlr0 |= PC302_SPI_DATA_FRM_16_BIT;
+		}
+		else
+		{
+			c->activeTxLen   = t->len;
+			c->activeRxLen   = t->len;
+		
+			c->activeTxBuf8_p  = t->tx_buf;
+			c->activeRxBuf8_p  = t->rx_buf;
+			
+			ctrlr0 |= PC302_SPI_DATA_FRM_8_BIT;
+		}
+		
+		mwcr = 0;
+
+		/* There have been problems running the SSI block in Mode 0, the chip
+		 * select is deselected between words so, as a workaround, Microwire
+		 * mode is being used instead for now.  This is not documented yet and
+		 * it also has issues, described below.
+		 */
+		if (spi->mode & SPI_3WIRE)
+		{
+			/* Send an 8-bit control word.  Then send or receive 16-bits.
+			 * The length passed in is the combined Tx and Rx, so adjust
+			 * the Rx buffer length and pointer to allow a single buffer
+			 * for both Tx and Rx.
+			 */
+			
+			/* The SSI block inserts an extra clock pulse between the cmd and data
+			 * on a read, but not on a write.  That extra clock corresponds to the
+			 * first bit of the reply from the MAX6662, so we lose that.  To avoid
+			 * missing data the command has to be reduced from 8 to 7 bits.  Then the
+			 * MAX6662 sees the extra clock as the final command bit.  Now, the final
+			 * command bit is always 1, so it's not needed to decide what the command
+			 * is.  However, reducing the command to 7-bits causes it to be sent as
+			 * a 0.  There's no reason to believe that this will work, but it appears
+			 * to.  If we are sending a 7-bit command we have to right justify the
+			 * command by shifting it right one bit.
+			 */
+			if (c->activeRxBuf8_p)
+			{
+				/* 8-bit data transfers, but always a single 8-bit command. */
+				c->activeTxLen = 1;
+				c->activeRxLen--;
+				c->activeRxBuf8_p++;
+				mwcr = PC302_SPI_MICROWIRE_READ | PC302_SPI_MICROWIRE_CONTINUOUS | PC302_SPI_MICROWIRE_HANDSHAKE;
+				ctrlr0 |= PC302_SPI_NI_MW_FORMAT | PC302_SPI_MW_CTRL_WORD_7_BIT;
+				shiftCmd = 1;
+			}
+			else if (c->activeRxBuf16_p)
+			{
+				/* 16-bit data transfers, but always a single 8-bit command. */
+				c->activeTxLen = 1;
+				c->activeRxLen--;
+				c->activeRxBuf16_p++;
+				mwcr = PC302_SPI_MICROWIRE_READ | PC302_SPI_MICROWIRE_CONTINUOUS | PC302_SPI_MICROWIRE_HANDSHAKE;
+				ctrlr0 |= PC302_SPI_NI_MW_FORMAT | PC302_SPI_MW_CTRL_WORD_7_BIT;
+				shiftCmd = 1;
+			}
+			else
+			{
+				/* Don't read any data, but we have to wait till the transmit is complete,
+				 * so set the activeRxLen to -1.  That will prevent the wait condition
+				 * later on from passing immediately (since it's not 0) and force us to
+				 * timeout.  If we didn't wait for the timeout in this case, then the
+				 * SSI block would be disabled before the transfer was completed.
+				 */
+				c->activeRxLen=-1;
+				mwcr = PC302_SPI_MICROWIRE_WRITE | PC302_SPI_MICROWIRE_CONTINUOUS;
+				ctrlr0 |= PC302_SPI_NI_MW_FORMAT | PC302_SPI_MW_CTRL_WORD_8_BIT;
+			}
+		}
+		else
+		{
+			ctrlr0 |= PC302_SPI_MOTO_SPI_FORMAT;
+		}
+		
+		/* Configure the transfer */
+		pc302spi_wr(c, ctrlr0, SSI_CTRL_REG_0_REG_OFFSET);
+		pc302spi_wr(c, ctrlr1, SSI_CTRL_REG_1_REG_OFFSET);
+		pc302spi_wr(c, mwcr,   SSI_MW_CTRL_REG_OFFSET);
+		
+		/* Interrupt when the TX FIFO has at least one space. */
+		pc302spi_wr(c, PC302_SPI_FIFO_SIZE-1, SSI_TX_FIFO_THRESHOLD_REG_OFFSET);
+		
+		/* Interrupt when the RX FIFO has at least one word. PC302 Programmers Guide
+		 * section G.5.3 says this triggers an interrupt when the number of FIFO entries
+		 * is >= to the value written here + 1
+		 */
+		pc302spi_wr(c, 0, SSI_RX_FIFO_THRESHOLD_REG_OFFSET);
+				
+		/* RX interrupts will fill the RX buffer */
+		intMask = PC302_SPI_RX_FIFO_FULL_INT;
+		
+		/* How many words should we write to the FIFO to kick things off */
+		n = c->activeTxLen;
+
+		if (n > PC302_SPI_FIFO_SIZE)
+		{
+			n = PC302_SPI_FIFO_SIZE;
+
+			/* We'll still have data to send.  We must use Tx interrupts to
+			 * keep the FIFO fed.
+			 */
+			intMask |= PC302_SPI_TX_FIFO_EMPTY_INT;
+		}
+
+		c->activeTxLen -= n;
+
+		/* To avoid stalling during the attempt to write to the FIFO.  We
+		 * will get a local copy of the the data and perform the initial
+		 * Tx writes with interrupts off, that should ensure the FIFO doesn't
+		 * empty and turn off the chip select in the middle of the transfer.
+		 */
+		spin_lock_irqsave(&c->lock, flags);
+
+		/* If we have enough to send, then fill the Tx FIFO */
+		for (i=0; i<n; i++)
+		{
+			if (c->activeTxBuf8_p)
+			{
+				if (shiftCmd)
+				{
+					shiftCmd = 0;
+					data[i] = (*(c->activeTxBuf8_p)++) >> 1;
+				}
+				else
+				{
+					data[i] = *(c->activeTxBuf8_p)++;
+				}
+			}
+			else if (c->activeTxBuf16_p)
+			{
+				if (shiftCmd)
+				{
+					shiftCmd = 0;
+					data[i] = (*(c->activeTxBuf16_p)++) >> 1;
+				}
+				else
+				{
+					data[i] = *(c->activeTxBuf16_p)++;
+				}
+			}
+			else
+			{
+				data[i] = 0xFFFF;
+			}
+		}
+		
+		pc302spi_wr(c, PC302_SPI_ENABLE, SSI_ENABLE_REG_REG_OFFSET);
+	
+#ifdef CONFIG_ARCH_PC302
+		if (spi->dev.platform_data)
+		{
+			gpio_set_value((unsigned)(spi->dev.platform_data), (spi->mode & SPI_CS_HIGH) ? 1 : 0);
+		}
+#endif
+
+		pc302spi_wr_n(c, data, SSI_DATA_REG_OFFSET, n);
+
+		pc302spi_wr(c, intMask, SSI_IMR_REG_OFFSET);
+		
+		spin_unlock_irqrestore(&c->lock, flags);
+		
+#ifdef CONFIG_ARCH_PC302
+		/* wait until all tx data has been sent and all rx data has been read */
+		timeout = 2 + (2 * t->len * 8 * HZ) / speed_hz;
+		ret = wait_event_timeout(c->waitq, (c->activeTxLen == 0) && (c->activeRxLen == 0), timeout);
+		
+		if ((c->activeTxLen > 0) || (c->activeRxLen > 0))
+		{
+			printk("SPI timeout after %d jiffies tx=%d rx=%d\n", timeout, c->activeTxLen, c->activeRxLen);
+		}
+
+		if (spi->dev.platform_data)
+		{
+			gpio_set_value((unsigned)(spi->dev.platform_data), (spi->mode & SPI_CS_HIGH) ? 0 : 1);
+		}
+#else
+		/* Pretend to write the remaining data */
+		while (c->activeTxLen > 0)
+		{
+			u8 data = 0;
+			
+			if (c->activeTxBuf8_p)
+			{
+				data = *(c->activeTxBuf8_p)++;
+			}
+			else if (c->activeTxBuf16_p)
+			{
+				data = *(c->activeTxBuf16_p)++;
+			}
+			
+			pc302spi_wr(c, data, SSI_DATA_REG_OFFSET);
+			
+			c->activeTxLen--;
+		}
+		/* Pretend to read the data */
+		while (c->activeRxLen > 0)
+		{
+			u16  data = pc302spi_rd(c, SSI_DATA_REG_OFFSET);
+			
+			data = 0x5555;
+			
+			if (c->activeRxBuf8_p)
+			{
+				*(c->activeRxBuf8_p)++ = data;
+			}
+			else if (c->activeRxBuf16_p)
+			{
+				*(c->activeRxBuf16_p)++ = data;
+			}
+			
+			c->activeRxLen--;
+		}
+#endif
+		
+		/* Ensure interrupts are disabled from the SPI block */
+		pc302spi_wr(c, PC302_SPI_MASK_ALL_INTS, SSI_IMR_REG_OFFSET);
+		
+		pc302spi_wr(c, PC302_SPI_DISABLE, SSI_ENABLE_REG_REG_OFFSET);
+	
+		m->actual_length += t->len;
+		
+		if (t->delay_usecs)
+			udelay(t->delay_usecs);
+	
+		if (t->transfer_list.next == &m->transfers)
+			break;
+	}
+	
+	m->status = 0;
+	m->complete(m->context);
+	
+	pc302spi_wr(c, PC302_SPI_DISABLE, SSI_ENABLE_REG_REG_OFFSET);
+	pc302spi_wr(c, PC302_SPI_SLAVES_DISABLE, SSI_SLAVE_ENABLE_REG_OFFSET);
+}
+
+static void pc302spi_work(struct work_struct *work)
+{
+	struct pc302spi *c = container_of(work, struct pc302spi, work);
+	unsigned long flags;
+
+	spin_lock_irqsave(&c->lock, flags);
+	while (!list_empty(&c->queue)) {
+		struct spi_message *m;
+
+		m = container_of(c->queue.next, struct spi_message, queue);
+		list_del_init(&m->queue);
+		spin_unlock_irqrestore(&c->lock, flags);
+
+		pc302spi_work_one(c, m);
+
+		spin_lock_irqsave(&c->lock, flags);
+	}
+	spin_unlock_irqrestore(&c->lock, flags);
+}
+
+static int pc302spi_transfer(struct spi_device *spi, struct spi_message *m)
+{
+	struct spi_master    *master = spi->master;
+	struct pc302spi      *c = spi_master_get_devdata(master);
+	struct spi_transfer  *t;
+	unsigned long         flags;
+	u32                   enabled = 0;
+	
+	m->actual_length = 0;
+	
+	switch (spi->chip_select)
+	{
+	case 0:
+		enabled = c->info->cs0_active;
+		break;
+	case 1:
+		enabled = c->info->cs1_active;
+		break;
+	case 2:
+		enabled = c->info->cs2_active;
+		break;
+	case 3:
+		enabled = c->info->cs3_active;
+		break;
+	default:
+		enabled = 0;
+		break;
+	}
+	
+	if ( ! enabled)
+	{
+		return -EINVAL;
+	}
+	
+	/* check the parameters for each transfer in the message */
+	list_for_each_entry (t, &m->transfers, transfer_list) {
+		u32 speed_hz     = t->speed_hz      ? : spi->max_speed_hz;
+		u8 bits_per_word = t->bits_per_word ? : spi->bits_per_word;
+	
+		bits_per_word = bits_per_word ? : 8;
+		if (!t->tx_buf && !t->rx_buf && t->len)
+			return -EINVAL;
+		if ((bits_per_word != 8) && (bits_per_word != 16))
+			return -EINVAL;
+		if (speed_hz < c->min_speed_hz)
+			return -EINVAL;
+//TODO: We could always just run slower, it's unlikely to be a problem.
+//        if (speed_hz > c->max_speed_hz)
+//			return -EINVAL;
+	}
+
+	spin_lock_irqsave(&c->lock, flags);
+	list_add_tail(&m->queue, &c->queue);
+	queue_work(c->workqueue, &c->work);
+	spin_unlock_irqrestore(&c->lock, flags);
+
+	return 0;
+}
+
+static int __init pc302spi_probe(struct platform_device *dev)
+{
+	struct spi_master *master;
+	struct pc302spi   *c;
+	struct resource   *res;
+	u32                system_config;
+	int                ret = -ENODEV;
+	int                irq;
+	int                i;
+	
+	master = spi_alloc_master(&dev->dev, sizeof(*c));
+	if (!master)
+	{
+		return ret;
+	}
+	
+	c = spi_master_get_devdata(master);
+	platform_set_drvdata(dev, master);
+	
+	/* copy in the platform data */
+	c->info = dev->dev.platform_data;
+	
+	INIT_WORK(&c->work, pc302spi_work);
+	spin_lock_init(&c->lock);
+	INIT_LIST_HEAD(&c->queue);
+	init_waitqueue_head(&c->waitq);
+	
+	c->baseclk      = PC302_TIMER_FREQ;
+	c->min_speed_hz = (PC302_TIMER_FREQ + PC302_SPI_MAX_CLK_DIVIDER - 1)/ PC302_SPI_MAX_CLK_DIVIDER;
+	c->max_speed_hz = PC302_TIMER_FREQ / PC302_SPI_MIN_CLK_DIVIDER;
+	
+	res = platform_get_resource(dev, IORESOURCE_MEM, 0);
+	if (!res)
+	{
+		goto exit_busy;
+	}
+	
+#ifdef CONFIG_ARCH_PC302
+	if (!devm_request_mem_region(&dev->dev, res->start, res->end - res->start + 1, "spi_pc302"))
+	{
+		goto exit_busy;
+	}
+	
+	c->membase_p = devm_ioremap(&dev->dev, res->start, res->end - res->start + 1);
+	if (!c->membase_p)
+	{
+		goto exit_busy;
+	}
+#else
+	c->membase_p = (void*)res->start;
+#endif
+
+	/* Disable the SPI and ensure all chip selects are inactive */
+	pc302spi_wr(c, PC302_SPI_DISABLE, SSI_ENABLE_REG_REG_OFFSET);
+	pc302spi_wr(c, PC302_SPI_SLAVES_DISABLE, SSI_SLAVE_ENABLE_REG_OFFSET);
+	
+	/* Give the SPI bus control of the required chip select pins */
+	system_config = 0;
+	if ( ! c->info->cs0_active )
+	{
+		system_config |= AXI2CFG_DECODE_MUX_0;
+	}
+	if ( ! c->info->cs1_active )
+	{
+		system_config |= AXI2CFG_DECODE_MUX_1;
+	}
+	if ( ! c->info->cs2_active )
+	{
+		system_config |= AXI2CFG_DECODE_MUX_2;
+	}
+	if ( ! c->info->cs3_active )
+	{
+		system_config |= AXI2CFG_DECODE_MUX_3;
+	}
+#ifdef CONFIG_ARCH_PC302
+	syscfg_update( AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_MASK, system_config );
+#else
+	printk("Updating SYS_CONFIG mask=0x%08X, value=0x%08X\n", AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_MASK, system_config);
+#endif
+
+	irq = platform_get_irq(dev, 0);
+	if (irq < 0)
+	{
+		goto exit_busy;
+	}
+#ifdef CONFIG_ARCH_PC302
+	ret = devm_request_irq(&dev->dev, irq, pc302spi_interrupt, 0, "spi_pc302", c);
+	if (ret)
+	{
+		goto exit;
+	}
+#else
+	printk("Register irq %d for spi_pc302 with pc302spi_interrupt\n", irq);
+#endif
+	
+	c->workqueue = create_singlethread_workqueue(master->dev.parent->bus_id);
+	if (!c->workqueue)
+	{
+		goto exit_busy;
+	}
+	
+	master->bus_num        = dev->id;
+	master->setup          = pc302spi_setup;
+	master->transfer       = pc302spi_transfer;
+	master->num_chipselect = 4;
+	
+	ret = spi_register_master(master);
+	if (ret)
+	{
+		goto exit;
+	}
+	
+	/* register the chips to go with the board */
+	for (i = 0; i < c->info->board_size; i++) {
+		dev_info(&dev->dev, "registering %p: %s\n",
+		         &c->info->board_info[i],
+		          c->info->board_info[i].modalias);
+	
+		c->info->board_info[i].controller_data = c;
+		spi_new_device(master, c->info->board_info + i);
+	}
+	
+	return 0;
+	
+exit_busy:
+	ret = -EBUSY;
+	
+exit:
+	if (c->workqueue)
+	{
+		destroy_workqueue(c->workqueue);
+	}
+	
+	platform_set_drvdata(dev, NULL);
+	spi_master_put(master);
+	
+	return ret;
+}
+
+static int __exit pc302spi_remove(struct platform_device *dev)
+{
+	struct spi_master *master = spi_master_get(platform_get_drvdata(dev));
+	struct pc302spi   *c      = spi_master_get_devdata(master);
+
+	spi_unregister_master(master);
+	platform_set_drvdata(dev, NULL);
+	destroy_workqueue(c->workqueue);
+	spi_master_put(master);
+	return 0;
+}
+
+/* work with hotplug and coldplug */
+//MODULE_ALIAS("platform:spi_pc302");
+
+static struct platform_driver pc302spi_driver = {
+	.remove = __exit_p(pc302spi_remove),
+	.driver = {
+		.name = "pc302-spi",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init pc302spi_init(void)
+{
+	return platform_driver_probe(&pc302spi_driver, pc302spi_probe);
+}
+subsys_initcall(pc302spi_init);
+
+static void __exit pc302spi_exit(void)
+{
+	platform_driver_unregister(&pc302spi_driver);
+}
+module_exit(pc302spi_exit);
+
+MODULE_DESCRIPTION("PC302 SPI Driver");
+MODULE_LICENSE("GPL");
diff -Naur pico_2.6.28/drivers/spi/spi_pc302_gpio.c ipa_2.6.28/drivers/spi/spi_pc302_gpio.c
--- pico_2.6.28/drivers/spi/spi_pc302_gpio.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/drivers/spi/spi_pc302_gpio.c	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,306 @@
+/* linux/drivers/spi/spi_pc302_gpio.c
+ *
+ *
+ * Based on spi_firecracker_gpio.c which was taken from spi_s3c24xx_gpio.c;
+ *
+ * Copyright (c) 2009 ip.access Ltd
+ *
+ * PC302 GPIO based SPI driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/platform_device.h>
+
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_bitbang.h>
+
+#include <linux/picochip/gpio.h>
+
+#include <mach/hardware.h>
+#include <mach/spi-gpio.h>
+#include <mach/gpio.h>
+
+/* ENABLE_DEBUG - to add printf's showing activity on the SPI interface */
+#undef ENABLE_DEBUG
+
+/* Internal state data structure */
+struct pc302_spigpio {
+    /* Bitbang helper context */
+    struct spi_bitbang bitbang;
+
+    /* platform data passed at probe time */
+    struct pc7302_spigpio_info *info;
+};
+
+/* Get out internal state from the spi device */
+static inline struct pc302_spigpio *spidev_to_sg(struct spi_device *spi)
+{
+    return spi->controller_data;
+}
+
+/* Called by the bitbanged code to set the clock pin */
+static inline void setsck(struct spi_device *dev, int on)
+{
+    struct pc302_spigpio *sg = spidev_to_sg(dev);
+    if (on) {
+        gpio_set_value(sg->info->pin_clk, 1);
+    }
+    else {
+        gpio_set_value(sg->info->pin_clk, 0);
+    }
+}
+
+/* Called by the bitbanged code to set the mosi pin */
+static inline void setmosi(struct spi_device *dev, int on)
+{
+    struct pc302_spigpio *sg = spidev_to_sg(dev);
+    if (on) {
+        gpio_set_value(sg->info->pin_mosi, 1);
+    }
+    else {
+        gpio_set_value(sg->info->pin_mosi, 0);
+    }
+}
+
+/* Called by the bitbanged code to get the miso pin */
+static inline u32 getmiso(struct spi_device *dev)
+{
+    (void)dev;
+    return 0;
+}
+
+/* Called by the bitbanged code to do a delay */
+#define spidelay(x) ndelay(x)
+
+/* Include the bitbanged code */
+#define EXPAND_BITBANG_TXRX
+#include <linux/spi/spi_bitbang.h>
+
+/* Called by the bitbanged code to send and receive in mode 0 or 2. This
+ * function relies on bitbanged code for its operation
+ */
+static u32 pc302_spigpio_txrx_mode0(struct spi_device *spi,
+        unsigned nsecs, u32 word, u8 bits)
+{
+    /* TODO Debug, remove */
+#ifdef ENABLE_DEBUG
+    printk("spi txrx0 mode%u word = 0x%08x, bits=%u\n", spi->mode, word, bits);
+#endif
+    return bitbang_txrx_be_cpha0(
+            spi, nsecs, (spi->mode & SPI_CPOL) ? 1 : 0, word, bits);
+}
+
+/* Called by the bitbanged code to send and receive in mode 1 or 3. This
+ * function relies on bitbanged code for its operation
+ */
+static u32 pc302_spigpio_txrx_mode1(struct spi_device *spi,
+        unsigned nsecs, u32 word, u8 bits)
+{
+    /* TODO Debug, remove */
+#ifdef ENABLE_DEBUG
+    printk("spi txrx1 mode%u word = 0x%08x, bits=%u\n", spi->mode, word, bits);
+#endif
+    return bitbang_txrx_be_cpha1(
+            spi, nsecs, (spi->mode & SPI_CPOL) ? 1 : 0, word, bits);
+}
+
+/* Called by the bitbanged code to select the chip */
+static void pc302_spigpio_chipselect(struct spi_device *dev, int value)
+{
+    struct pc302_spigpio *sg = spidev_to_sg(dev);
+    int gpio_pin = dev->chip_select == 0 ? sg->info->pin_cs_0 : sg->info->pin_cs_1;
+
+    /* Reset any active chip selects */
+    gpio_set_value(sg->info->pin_cs_0, 1);
+    gpio_set_value(sg->info->pin_cs_1, 1);
+
+    /* If the chip is to be activated, set its chip select pattern */
+    if (value == BITBANG_CS_ACTIVE) {
+
+#ifdef ENABLE_DEBUG
+        printk("spi CS 0x%02x asserted\n", dev->chip_select);
+#endif
+
+        gpio_set_value(gpio_pin, 0);
+    }
+    else {
+
+#ifdef ENABLE_DEBUG
+        printk("spi CS de-asserted\n");
+#endif
+        /* Provide one clock cycle to reset the SPI transfer */
+        setsck(dev, 0);
+        setsck(dev, 1);
+    }
+}
+
+
+/* Probe function for the GPIO bitbashed SPI. This uses the bitbash helper
+ * code for its implementation.
+ */
+static int pc302_spigpio_probe(struct platform_device *dev)
+{
+    struct spi_master   *master;
+    struct pc302_spigpio  *sp;
+    int ret = 0;
+    int i;
+
+    master = spi_alloc_master(&dev->dev, sizeof(struct pc302_spigpio));
+    if (master == NULL) {
+        dev_err(&dev->dev, "failed to allocate spi master\n");
+        ret = -ENOMEM;
+        goto err;
+    }
+
+    sp = spi_master_get_devdata(master);
+
+    platform_set_drvdata(dev, sp);
+
+    /* We have 2 chip selects. */
+    master->num_chipselect = 2;
+    master->bus_num = 0;
+
+    /* copy in the platform data */
+    sp->info = dev->dev.platform_data;
+
+    /* setup spi bitbang adaptor */
+    sp->bitbang.master = spi_master_get(master);
+    sp->bitbang.chipselect = pc302_spigpio_chipselect;
+
+    sp->bitbang.txrx_word[SPI_MODE_0] = pc302_spigpio_txrx_mode0;
+    sp->bitbang.txrx_word[SPI_MODE_1] = pc302_spigpio_txrx_mode1;
+    sp->bitbang.txrx_word[SPI_MODE_2] = pc302_spigpio_txrx_mode0;
+    sp->bitbang.txrx_word[SPI_MODE_3] = pc302_spigpio_txrx_mode1;
+
+    /* set state of spi pins */
+    ret = gpio_request(sp->info->pin_mosi, "PC302 BB SPI MOSI");
+    if (ret)
+    {
+        goto err_no_mosi;
+    }
+    ret = gpio_request(sp->info->pin_clk,  "PC302 BB SPI CLK");
+    if (ret)
+    {
+        goto err_no_clk;
+    }
+    ret = gpio_request(sp->info->pin_cs_0, "PC302 BB SPI CS0");
+    if (ret)
+    {
+        goto err_no_cs0;
+    }
+    ret = gpio_request(sp->info->pin_cs_1, "PC302 BB SPI CS1");
+    if (ret)
+    {
+        goto err_no_cs1;
+    }
+
+    gpio_set_value(sp->info->pin_clk,  0);
+    gpio_set_value(sp->info->pin_mosi, 0);
+    gpio_set_value(sp->info->pin_cs_0, 1);
+    gpio_set_value(sp->info->pin_cs_1, 1);
+
+    gpio_direction_output(sp->info->pin_clk,  0);
+    gpio_direction_output(sp->info->pin_mosi, 0);
+    gpio_direction_output(sp->info->pin_cs_0, 1);
+    gpio_direction_output(sp->info->pin_cs_1, 1);
+
+    gpio_set_value(sp->info->pin_clk,  0);
+    gpio_set_value(sp->info->pin_mosi, 0);
+    gpio_set_value(sp->info->pin_cs_0, 1);
+    gpio_set_value(sp->info->pin_cs_1, 1);
+
+    ret = spi_bitbang_start(&sp->bitbang);
+    if (ret)
+        goto err_no_bitbang;
+
+    /* register the chips to go with the board */
+
+    for (i = 0; i < sp->info->board_size; i++) {
+        dev_info(&dev->dev, "registering %p: %s\n",
+                &sp->info->board_info[i],
+                sp->info->board_info[i].modalias);
+
+        sp->info->board_info[i].controller_data = sp;
+        spi_new_device(master, sp->info->board_info + i);
+    }
+
+    return 0;
+
+err_no_bitbang:
+    gpio_free(sp->info->pin_cs_1);
+err_no_cs1:
+    gpio_free(sp->info->pin_cs_0);
+err_no_cs0:
+    gpio_free(sp->info->pin_clk);
+err_no_clk:
+    gpio_free(sp->info->pin_mosi);
+err_no_mosi:
+    spi_master_put(sp->bitbang.master);
+err:
+    return ret;
+
+}
+
+/* Remove the GPIO bitbashed SPI interface */
+static int pc302_spigpio_remove(struct platform_device *dev)
+{
+    struct pc302_spigpio *sp = platform_get_drvdata(dev);
+
+    spi_bitbang_stop(&sp->bitbang);
+    spi_master_put(sp->bitbang.master);
+
+    gpio_free(sp->info->pin_cs_1);
+    gpio_free(sp->info->pin_cs_0);
+    gpio_free(sp->info->pin_clk);
+    gpio_free(sp->info->pin_mosi);
+    
+    return 0;
+}
+
+/* all gpio should be held over suspend/resume, so we should
+ * not need to deal with this
+ */
+
+#define pc302_spigpio_suspend NULL
+#define pc302_spigpio_resume NULL
+
+/* GPIO bitbashed SPI interface declaration structure */
+static struct platform_driver pc302_spigpio_drv = {
+    .probe      = pc302_spigpio_probe,
+    .remove     = pc302_spigpio_remove,
+    .suspend    = pc302_spigpio_suspend,
+    .resume     = pc302_spigpio_resume,
+    .driver     = {
+        .name   = "pc302-spi-gpio",
+        .owner  = THIS_MODULE,
+    },
+};
+
+/* Module initialisation, declare the SPI interface */
+static int __init pc302_spigpio_init(void)
+{
+    printk("pc302 SPI-GPIO driver, version 0.01 loaded\n");
+    return platform_driver_register(&pc302_spigpio_drv);
+}
+
+/* Module shut-down, remove the SPI interface */
+static void __exit pc302_spigpio_exit(void)
+{
+    platform_driver_unregister(&pc302_spigpio_drv);
+}
+
+module_init(pc302_spigpio_init);
+module_exit(pc302_spigpio_exit);
+
+MODULE_DESCRIPTION("pc302 bitbang SPI Driver");
+MODULE_LICENSE("GPL");
+
+
diff -Naur pico_2.6.28/fs/jffs2/acl.c ipa_2.6.28/fs/jffs2/acl.c
--- pico_2.6.28/fs/jffs2/acl.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/fs/jffs2/acl.c	2011-04-26 14:51:35.000000000 +0100
@@ -38,12 +38,12 @@
 	size_t s;
 
 	size -= sizeof(struct jffs2_acl_header);
-	s = size - 4 * sizeof(struct jffs2_acl_entry_short);
-	if (s < 0) {
+	if (size < 4 * sizeof(struct jffs2_acl_entry_short)) {
 		if (size % sizeof(struct jffs2_acl_entry_short))
 			return -1;
 		return size / sizeof(struct jffs2_acl_entry_short);
 	} else {
+		s = size - 4 * sizeof(struct jffs2_acl_entry_short);
 		if (s % sizeof(struct jffs2_acl_entry))
 			return -1;
 		return s / sizeof(struct jffs2_acl_entry) + 4;
@@ -502,14 +502,14 @@
 	return jffs2_acl_setxattr(inode, ACL_TYPE_DEFAULT, buffer, size);
 }
 
-struct xattr_handler jffs2_acl_access_xattr_handler = {
+const struct xattr_handler jffs2_acl_access_xattr_handler = {
 	.prefix	= POSIX_ACL_XATTR_ACCESS,
 	.list	= jffs2_acl_access_listxattr,
 	.get	= jffs2_acl_access_getxattr,
 	.set	= jffs2_acl_access_setxattr,
 };
 
-struct xattr_handler jffs2_acl_default_xattr_handler = {
+const struct xattr_handler jffs2_acl_default_xattr_handler = {
 	.prefix	= POSIX_ACL_XATTR_DEFAULT,
 	.list	= jffs2_acl_default_listxattr,
 	.get	= jffs2_acl_default_getxattr,
diff -Naur pico_2.6.28/fs/jffs2/acl.h ipa_2.6.28/fs/jffs2/acl.h
--- pico_2.6.28/fs/jffs2/acl.h	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/fs/jffs2/acl.h	2011-04-26 14:51:35.000000000 +0100
@@ -34,8 +34,8 @@
 extern int jffs2_init_acl_post(struct inode *);
 extern void jffs2_clear_acl(struct jffs2_inode_info *);
 
-extern struct xattr_handler jffs2_acl_access_xattr_handler;
-extern struct xattr_handler jffs2_acl_default_xattr_handler;
+extern const struct xattr_handler jffs2_acl_access_xattr_handler;
+extern const struct xattr_handler jffs2_acl_default_xattr_handler;
 
 #else
 
diff -Naur pico_2.6.28/fs/jffs2/background.c ipa_2.6.28/fs/jffs2/background.c
--- pico_2.6.28/fs/jffs2/background.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/fs/jffs2/background.c	2011-04-26 14:51:35.000000000 +0100
@@ -15,6 +15,7 @@
 #include <linux/completion.h>
 #include <linux/sched.h>
 #include <linux/freezer.h>
+#include <linux/kthread.h>
 #include "nodelist.h"
 
 
@@ -22,16 +23,15 @@
 
 void jffs2_garbage_collect_trigger(struct jffs2_sb_info *c)
 {
-	spin_lock(&c->erase_completion_lock);
+	assert_spin_locked(&c->erase_completion_lock);
 	if (c->gc_task && jffs2_thread_should_wake(c))
 		send_sig(SIGHUP, c->gc_task, 1);
-	spin_unlock(&c->erase_completion_lock);
 }
 
 /* This must only ever be called when no GC thread is currently running */
 int jffs2_start_garbage_collect_thread(struct jffs2_sb_info *c)
 {
-	pid_t pid;
+	struct task_struct *tsk;
 	int ret = 0;
 
 	BUG_ON(c->gc_task);
@@ -39,15 +39,16 @@
 	init_completion(&c->gc_thread_start);
 	init_completion(&c->gc_thread_exit);
 
-	pid = kernel_thread(jffs2_garbage_collect_thread, c, CLONE_FS|CLONE_FILES);
-	if (pid < 0) {
-		printk(KERN_WARNING "fork failed for JFFS2 garbage collect thread: %d\n", -pid);
+	tsk = kthread_run(jffs2_garbage_collect_thread, c, "jffs2_gcd_mtd%d", c->mtd->index);
+	if (IS_ERR(tsk)) {
+		printk(KERN_WARNING "fork failed for JFFS2 garbage collect thread: %ld\n", -PTR_ERR(tsk));
 		complete(&c->gc_thread_exit);
-		ret = pid;
+		ret = PTR_ERR(tsk);
 	} else {
 		/* Wait for it... */
-		D1(printk(KERN_DEBUG "JFFS2: Garbage collect thread is pid %d\n", pid));
+		D1(printk(KERN_DEBUG "JFFS2: Garbage collect thread is pid %d\n", tsk->pid));
 		wait_for_completion(&c->gc_thread_start);
+		ret = tsk->pid;
 	}
 
 	return ret;
@@ -71,7 +72,6 @@
 {
 	struct jffs2_sb_info *c = _c;
 
-	daemonize("jffs2_gcd_mtd%d", c->mtd->index);
 	allow_signal(SIGKILL);
 	allow_signal(SIGSTOP);
 	allow_signal(SIGCONT);
@@ -95,13 +95,22 @@
 			spin_unlock(&c->erase_completion_lock);
 			
 
-		/* This thread is purely an optimisation. But if it runs when
-		   other things could be running, it actually makes things a
-		   lot worse. Use yield() and put it at the back of the runqueue
-		   every time. Especially during boot, pulling an inode in
-		   with read_inode() is much preferable to having the GC thread
-		   get there first. */
-		yield();
+		/* Problem - immediately after bootup, the GCD spends a lot
+		 * of time in places like jffs2_kill_fragtree(); so much so
+		 * that userspace processes (like gdm and X) are starved
+		 * despite plenty of cond_resched()s and renicing.  Yield()
+		 * doesn't help, either (presumably because userspace and GCD
+		 * are generally competing for a higher latency resource -
+		 * disk).
+		 * This forces the GCD to slow the hell down.   Pulling an
+		 * inode in with read_inode() is much preferable to having
+		 * the GC thread get there first. */
+		schedule_timeout_interruptible(msecs_to_jiffies(50));
+
+		if (kthread_should_stop()) {
+			D1(printk(KERN_DEBUG "jffs2_garbage_collect_thread():  kthread_stop() called.\n"));
+			goto die;
+		}
 
 		/* Put_super will send a SIGKILL and then wait on the sem.
 		 */
diff -Naur pico_2.6.28/fs/jffs2/compr.c ipa_2.6.28/fs/jffs2/compr.c
--- pico_2.6.28/fs/jffs2/compr.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/fs/jffs2/compr.c	2011-04-26 14:51:35.000000000 +0100
@@ -177,7 +177,7 @@
 		spin_unlock(&jffs2_compressor_list_lock);
 		break;
 	default:
-		printk(KERN_ERR "JFFS2: unknow compression mode.\n");
+		printk(KERN_ERR "JFFS2: unknown compression mode.\n");
 	}
  out:
 	if (ret == JFFS2_COMPR_NONE) {
diff -Naur pico_2.6.28/fs/jffs2/compr_rubin.c ipa_2.6.28/fs/jffs2/compr_rubin.c
--- pico_2.6.28/fs/jffs2/compr_rubin.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/fs/jffs2/compr_rubin.c	2011-04-26 14:51:35.000000000 +0100
@@ -22,9 +22,7 @@
 
 
 #define BIT_DIVIDER_MIPS 1043
-static int bits_mips[8] = { 277,249,290,267,229,341,212,241}; /* mips32 */
-
-#include <linux/errno.h>
+static int bits_mips[8] = { 277, 249, 290, 267, 229, 341, 212, 241};
 
 struct pushpull {
 	unsigned char *buf;
@@ -43,7 +41,9 @@
 	int bits[8];
 };
 
-static inline void init_pushpull(struct pushpull *pp, char *buf, unsigned buflen, unsigned ofs, unsigned reserve)
+static inline void init_pushpull(struct pushpull *pp, char *buf,
+				 unsigned buflen, unsigned ofs,
+				 unsigned reserve)
 {
 	pp->buf = buf;
 	pp->buflen = buflen;
@@ -53,16 +53,14 @@
 
 static inline int pushbit(struct pushpull *pp, int bit, int use_reserved)
 {
-	if (pp->ofs >= pp->buflen - (use_reserved?0:pp->reserve)) {
+	if (pp->ofs >= pp->buflen - (use_reserved?0:pp->reserve))
 		return -ENOSPC;
-	}
 
-	if (bit) {
-		pp->buf[pp->ofs >> 3] |= (1<<(7-(pp->ofs &7)));
-	}
-	else {
-		pp->buf[pp->ofs >> 3] &= ~(1<<(7-(pp->ofs &7)));
-	}
+	if (bit)
+		pp->buf[pp->ofs >> 3] |= (1<<(7-(pp->ofs & 7)));
+	else
+		pp->buf[pp->ofs >> 3] &= ~(1<<(7-(pp->ofs & 7)));
+
 	pp->ofs++;
 
 	return 0;
@@ -97,6 +95,7 @@
 	rs->p = (long) (2 * UPPER_BIT_RUBIN);
 	rs->bit_number = (long) 0;
 	rs->bit_divider = div;
+
 	for (c=0; c<8; c++)
 		rs->bits[c] = bits[c];
 }
@@ -108,7 +107,8 @@
 	long i0, i1;
 	int ret;
 
-	while ((rs->q >= UPPER_BIT_RUBIN) || ((rs->p + rs->q) <= UPPER_BIT_RUBIN)) {
+	while ((rs->q >= UPPER_BIT_RUBIN) ||
+	       ((rs->p + rs->q) <= UPPER_BIT_RUBIN)) {
 		rs->bit_number++;
 
 		ret = pushbit(&rs->pp, (rs->q & UPPER_BIT_RUBIN) ? 1 : 0, 0);
@@ -119,12 +119,12 @@
 		rs->p <<= 1;
 	}
 	i0 = A * rs->p / (A + B);
-	if (i0 <= 0) {
+	if (i0 <= 0)
 		i0 = 1;
-	}
-	if (i0 >= rs->p) {
+
+	if (i0 >= rs->p)
 		i0 = rs->p - 1;
-	}
+
 	i1 = rs->p - i0;
 
 	if (symbol == 0)
@@ -157,11 +157,13 @@
 	/* behalve lower */
 	rs->rec_q = 0;
 
-	for (rs->bit_number = 0; rs->bit_number++ < RUBIN_REG_SIZE; rs->rec_q = rs->rec_q * 2 + (long) (pullbit(&rs->pp)))
+	for (rs->bit_number = 0; rs->bit_number++ < RUBIN_REG_SIZE;
+	     rs->rec_q = rs->rec_q * 2 + (long) (pullbit(&rs->pp)))
 		;
 }
 
-static void __do_decode(struct rubin_state *rs, unsigned long p, unsigned long q)
+static void __do_decode(struct rubin_state *rs, unsigned long p,
+			unsigned long q)
 {
 	register unsigned long lower_bits_rubin = LOWER_BITS_RUBIN;
 	unsigned long rec_q;
@@ -207,12 +209,11 @@
 		__do_decode(rs, p, q);
 
 	i0 = A * rs->p / (A + B);
-	if (i0 <= 0) {
+	if (i0 <= 0)
 		i0 = 1;
-	}
-	if (i0 >= rs->p) {
+
+	if (i0 >= rs->p)
 		i0 = rs->p - 1;
-	}
 
 	threshold = rs->q + i0;
 	symbol = rs->rec_q >= threshold;
@@ -234,14 +235,15 @@
 	struct rubin_state rs_copy;
 	rs_copy = *rs;
 
-	for (i=0;i<8;i++) {
-		ret = encode(rs, rs->bit_divider-rs->bits[i],rs->bits[i],byte&1);
+	for (i=0; i<8; i++) {
+		ret = encode(rs, rs->bit_divider-rs->bits[i],
+			     rs->bits[i], byte & 1);
 		if (ret) {
 			/* Failed. Restore old state */
 			*rs = rs_copy;
 			return ret;
 		}
-		byte=byte>>1;
+		byte >>= 1 ;
 	}
 	return 0;
 }
@@ -251,7 +253,8 @@
 	int i, result = 0, bit_divider = rs->bit_divider;
 
 	for (i = 0; i < 8; i++)
-		result |= decode(rs, bit_divider - rs->bits[i], rs->bits[i]) << i;
+		result |= decode(rs, bit_divider - rs->bits[i],
+				 rs->bits[i]) << i;
 
 	return result;
 }
@@ -259,7 +262,8 @@
 
 
 static int rubin_do_compress(int bit_divider, int *bits, unsigned char *data_in,
-		      unsigned char *cpage_out, uint32_t *sourcelen, uint32_t *dstlen)
+			     unsigned char *cpage_out, uint32_t *sourcelen,
+			     uint32_t *dstlen)
 	{
 	int outpos = 0;
 	int pos=0;
@@ -295,7 +299,8 @@
 int jffs2_rubinmips_compress(unsigned char *data_in, unsigned char *cpage_out,
 		   uint32_t *sourcelen, uint32_t *dstlen, void *model)
 {
-	return rubin_do_compress(BIT_DIVIDER_MIPS, bits_mips, data_in, cpage_out, sourcelen, dstlen);
+	return rubin_do_compress(BIT_DIVIDER_MIPS, bits_mips, data_in,
+				 cpage_out, sourcelen, dstlen);
 }
 #endif
 static int jffs2_dynrubin_compress(unsigned char *data_in,
@@ -316,9 +321,8 @@
 		return -1;
 
 	memset(histo, 0, 256);
-	for (i=0; i<mysrclen; i++) {
+	for (i=0; i<mysrclen; i++)
 		histo[data_in[i]]++;
-	}
 	memset(bits, 0, sizeof(int)*8);
 	for (i=0; i<256; i++) {
 		if (i&128)
@@ -346,7 +350,8 @@
 		cpage_out[i] = bits[i];
 	}
 
-	ret = rubin_do_compress(256, bits, data_in, cpage_out+8, &mysrclen, &mydstlen);
+	ret = rubin_do_compress(256, bits, data_in, cpage_out+8, &mysrclen,
+				&mydstlen);
 	if (ret)
 		return ret;
 
@@ -363,8 +368,10 @@
 	return 0;
 }
 
-static void rubin_do_decompress(int bit_divider, int *bits, unsigned char *cdata_in,
-			 unsigned char *page_out, uint32_t srclen, uint32_t destlen)
+static void rubin_do_decompress(int bit_divider, int *bits,
+				unsigned char *cdata_in, 
+				unsigned char *page_out, uint32_t srclen,
+				uint32_t destlen)
 {
 	int outpos = 0;
 	struct rubin_state rs;
@@ -372,9 +379,8 @@
 	init_pushpull(&rs.pp, cdata_in, srclen, 0, 0);
 	init_decode(&rs, bit_divider, bits);
 
-	while (outpos < destlen) {
+	while (outpos < destlen)
 		page_out[outpos++] = in_byte(&rs);
-	}
 }
 
 
@@ -383,7 +389,8 @@
 				      uint32_t sourcelen, uint32_t dstlen,
 				      void *model)
 {
-	rubin_do_decompress(BIT_DIVIDER_MIPS, bits_mips, data_in, cpage_out, sourcelen, dstlen);
+	rubin_do_decompress(BIT_DIVIDER_MIPS, bits_mips, data_in,
+			    cpage_out, sourcelen, dstlen);
 	return 0;
 }
 
@@ -398,52 +405,53 @@
 	for (c=0; c<8; c++)
 		bits[c] = data_in[c];
 
-	rubin_do_decompress(256, bits, data_in+8, cpage_out, sourcelen-8, dstlen);
+	rubin_do_decompress(256, bits, data_in+8, cpage_out, sourcelen-8,
+			    dstlen);
 	return 0;
 }
 
 static struct jffs2_compressor jffs2_rubinmips_comp = {
-    .priority = JFFS2_RUBINMIPS_PRIORITY,
-    .name = "rubinmips",
-    .compr = JFFS2_COMPR_DYNRUBIN,
-    .compress = NULL, /*&jffs2_rubinmips_compress,*/
-    .decompress = &jffs2_rubinmips_decompress,
+	.priority = JFFS2_RUBINMIPS_PRIORITY,
+	.name = "rubinmips",
+	.compr = JFFS2_COMPR_DYNRUBIN,
+	.compress = NULL, /*&jffs2_rubinmips_compress,*/
+	.decompress = &jffs2_rubinmips_decompress,
 #ifdef JFFS2_RUBINMIPS_DISABLED
-    .disabled = 1,
+	.disabled = 1,
 #else
-    .disabled = 0,
+	.disabled = 0,
 #endif
 };
 
 int jffs2_rubinmips_init(void)
 {
-    return jffs2_register_compressor(&jffs2_rubinmips_comp);
+	return jffs2_register_compressor(&jffs2_rubinmips_comp);
 }
 
 void jffs2_rubinmips_exit(void)
 {
-    jffs2_unregister_compressor(&jffs2_rubinmips_comp);
+	jffs2_unregister_compressor(&jffs2_rubinmips_comp);
 }
 
 static struct jffs2_compressor jffs2_dynrubin_comp = {
-    .priority = JFFS2_DYNRUBIN_PRIORITY,
-    .name = "dynrubin",
-    .compr = JFFS2_COMPR_RUBINMIPS,
-    .compress = jffs2_dynrubin_compress,
-    .decompress = &jffs2_dynrubin_decompress,
+	.priority = JFFS2_DYNRUBIN_PRIORITY,
+	.name = "dynrubin",
+	.compr = JFFS2_COMPR_RUBINMIPS,
+	.compress = jffs2_dynrubin_compress,
+	.decompress = &jffs2_dynrubin_decompress,
 #ifdef JFFS2_DYNRUBIN_DISABLED
-    .disabled = 1,
+	.disabled = 1,
 #else
-    .disabled = 0,
+	.disabled = 0,
 #endif
 };
 
 int jffs2_dynrubin_init(void)
 {
-    return jffs2_register_compressor(&jffs2_dynrubin_comp);
+	return jffs2_register_compressor(&jffs2_dynrubin_comp);
 }
 
 void jffs2_dynrubin_exit(void)
 {
-    jffs2_unregister_compressor(&jffs2_dynrubin_comp);
+	jffs2_unregister_compressor(&jffs2_dynrubin_comp);
 }
diff -Naur pico_2.6.28/fs/jffs2/dir.c ipa_2.6.28/fs/jffs2/dir.c
--- pico_2.6.28/fs/jffs2/dir.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/fs/jffs2/dir.c	2011-04-26 14:51:35.000000000 +0100
@@ -360,8 +360,8 @@
 		/* Eeek. Wave bye bye */
 		mutex_unlock(&f->sem);
 		jffs2_complete_reservation(c);
-		jffs2_clear_inode(inode);
-		return PTR_ERR(fn);
+		ret = PTR_ERR(fn);
+		goto fail;
 	}
 
 	/* We use f->target field to store the target path. */
@@ -370,8 +370,8 @@
 		printk(KERN_WARNING "Can't allocate %d bytes of memory\n", targetlen + 1);
 		mutex_unlock(&f->sem);
 		jffs2_complete_reservation(c);
-		jffs2_clear_inode(inode);
-		return -ENOMEM;
+		ret = -ENOMEM;
+		goto fail;
 	}
 
 	memcpy(f->target, target, targetlen + 1);
@@ -386,30 +386,24 @@
 	jffs2_complete_reservation(c);
 
 	ret = jffs2_init_security(inode, dir_i);
-	if (ret) {
-		jffs2_clear_inode(inode);
-		return ret;
-	}
+	if (ret)
+		goto fail;
+
 	ret = jffs2_init_acl_post(inode);
-	if (ret) {
-		jffs2_clear_inode(inode);
-		return ret;
-	}
+	if (ret)
+		goto fail;
 
 	ret = jffs2_reserve_space(c, sizeof(*rd)+namelen, &alloclen,
 				  ALLOC_NORMAL, JFFS2_SUMMARY_DIRENT_SIZE(namelen));
-	if (ret) {
-		/* Eep. */
-		jffs2_clear_inode(inode);
-		return ret;
-	}
+	if (ret)
+		goto fail;
 
 	rd = jffs2_alloc_raw_dirent();
 	if (!rd) {
 		/* Argh. Now we treat it like a normal delete */
 		jffs2_complete_reservation(c);
-		jffs2_clear_inode(inode);
-		return -ENOMEM;
+		ret = -ENOMEM;
+		goto fail;
 	}
 
 	dir_f = JFFS2_INODE_INFO(dir_i);
@@ -437,8 +431,8 @@
 		jffs2_complete_reservation(c);
 		jffs2_free_raw_dirent(rd);
 		mutex_unlock(&dir_f->sem);
-		jffs2_clear_inode(inode);
-		return PTR_ERR(fd);
+		ret = PTR_ERR(fd);
+		goto fail;
 	}
 
 	dir_i->i_mtime = dir_i->i_ctime = ITIME(je32_to_cpu(rd->mctime));
@@ -454,6 +448,11 @@
 
 	d_instantiate(dentry, inode);
 	return 0;
+
+ fail:
+	make_bad_inode(inode);
+	iput(inode);
+	return ret;
 }
 
 
@@ -519,8 +518,8 @@
 		/* Eeek. Wave bye bye */
 		mutex_unlock(&f->sem);
 		jffs2_complete_reservation(c);
-		jffs2_clear_inode(inode);
-		return PTR_ERR(fn);
+		ret = PTR_ERR(fn);
+		goto fail;
 	}
 	/* No data here. Only a metadata node, which will be
 	   obsoleted by the first data write
@@ -531,30 +530,24 @@
 	jffs2_complete_reservation(c);
 
 	ret = jffs2_init_security(inode, dir_i);
-	if (ret) {
-		jffs2_clear_inode(inode);
-		return ret;
-	}
+	if (ret)
+		goto fail;
+
 	ret = jffs2_init_acl_post(inode);
-	if (ret) {
-		jffs2_clear_inode(inode);
-		return ret;
-	}
+	if (ret)
+		goto fail;
 
 	ret = jffs2_reserve_space(c, sizeof(*rd)+namelen, &alloclen,
 				  ALLOC_NORMAL, JFFS2_SUMMARY_DIRENT_SIZE(namelen));
-	if (ret) {
-		/* Eep. */
-		jffs2_clear_inode(inode);
-		return ret;
-	}
+	if (ret)
+		goto fail;
 
 	rd = jffs2_alloc_raw_dirent();
 	if (!rd) {
 		/* Argh. Now we treat it like a normal delete */
 		jffs2_complete_reservation(c);
-		jffs2_clear_inode(inode);
-		return -ENOMEM;
+		ret = -ENOMEM;
+		goto fail;
 	}
 
 	dir_f = JFFS2_INODE_INFO(dir_i);
@@ -582,8 +575,8 @@
 		jffs2_complete_reservation(c);
 		jffs2_free_raw_dirent(rd);
 		mutex_unlock(&dir_f->sem);
-		jffs2_clear_inode(inode);
-		return PTR_ERR(fd);
+		ret = PTR_ERR(fd);
+		goto fail;
 	}
 
 	dir_i->i_mtime = dir_i->i_ctime = ITIME(je32_to_cpu(rd->mctime));
@@ -600,6 +593,11 @@
 
 	d_instantiate(dentry, inode);
 	return 0;
+
+ fail:
+	make_bad_inode(inode);
+	iput(inode);
+	return ret;
 }
 
 static int jffs2_rmdir (struct inode *dir_i, struct dentry *dentry)
@@ -693,8 +691,8 @@
 		/* Eeek. Wave bye bye */
 		mutex_unlock(&f->sem);
 		jffs2_complete_reservation(c);
-		jffs2_clear_inode(inode);
-		return PTR_ERR(fn);
+		ret = PTR_ERR(fn);
+		goto fail;
 	}
 	/* No data here. Only a metadata node, which will be
 	   obsoleted by the first data write
@@ -705,30 +703,24 @@
 	jffs2_complete_reservation(c);
 
 	ret = jffs2_init_security(inode, dir_i);
-	if (ret) {
-		jffs2_clear_inode(inode);
-		return ret;
-	}
+	if (ret)
+		goto fail;
+
 	ret = jffs2_init_acl_post(inode);
-	if (ret) {
-		jffs2_clear_inode(inode);
-		return ret;
-	}
+	if (ret)
+		goto fail;
 
 	ret = jffs2_reserve_space(c, sizeof(*rd)+namelen, &alloclen,
 				  ALLOC_NORMAL, JFFS2_SUMMARY_DIRENT_SIZE(namelen));
-	if (ret) {
-		/* Eep. */
-		jffs2_clear_inode(inode);
-		return ret;
-	}
+	if (ret)
+		goto fail;
 
 	rd = jffs2_alloc_raw_dirent();
 	if (!rd) {
 		/* Argh. Now we treat it like a normal delete */
 		jffs2_complete_reservation(c);
-		jffs2_clear_inode(inode);
-		return -ENOMEM;
+		ret = -ENOMEM;
+		goto fail;
 	}
 
 	dir_f = JFFS2_INODE_INFO(dir_i);
@@ -759,8 +751,8 @@
 		jffs2_complete_reservation(c);
 		jffs2_free_raw_dirent(rd);
 		mutex_unlock(&dir_f->sem);
-		jffs2_clear_inode(inode);
-		return PTR_ERR(fd);
+		ret = PTR_ERR(fd);
+		goto fail;
 	}
 
 	dir_i->i_mtime = dir_i->i_ctime = ITIME(je32_to_cpu(rd->mctime));
@@ -775,8 +767,12 @@
 	jffs2_complete_reservation(c);
 
 	d_instantiate(dentry, inode);
-
 	return 0;
+
+ fail:
+	make_bad_inode(inode);
+	iput(inode);
+	return ret;
 }
 
 static int jffs2_rename (struct inode *old_dir_i, struct dentry *old_dentry,
diff -Naur pico_2.6.28/fs/jffs2/erase.c ipa_2.6.28/fs/jffs2/erase.c
--- pico_2.6.28/fs/jffs2/erase.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/fs/jffs2/erase.c	2011-04-26 14:51:35.000000000 +0100
@@ -103,9 +103,10 @@
 	jffs2_erase_failed(c, jeb, bad_offset);
 }
 
-void jffs2_erase_pending_blocks(struct jffs2_sb_info *c, int count)
+int jffs2_erase_pending_blocks(struct jffs2_sb_info *c, int count)
 {
 	struct jffs2_eraseblock *jeb;
+	int work_done = 0;
 
 	mutex_lock(&c->erase_free_sem);
 
@@ -121,6 +122,7 @@
 			mutex_unlock(&c->erase_free_sem);
 			jffs2_mark_erased_block(c, jeb);
 
+			work_done++;
 			if (!--count) {
 				D1(printk(KERN_DEBUG "Count reached. jffs2_erase_pending_blocks leaving\n"));
 				goto done;
@@ -157,6 +159,7 @@
 	mutex_unlock(&c->erase_free_sem);
  done:
 	D1(printk(KERN_DEBUG "jffs2_erase_pending_blocks completed\n"));
+	return work_done;
 }
 
 static void jffs2_erase_succeeded(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)
@@ -165,10 +168,11 @@
 	mutex_lock(&c->erase_free_sem);
 	spin_lock(&c->erase_completion_lock);
 	list_move_tail(&jeb->list, &c->erase_complete_list);
+	/* Wake the GC thread to mark them clean */
+	jffs2_garbage_collect_trigger(c);
 	spin_unlock(&c->erase_completion_lock);
 	mutex_unlock(&c->erase_free_sem);
-	/* Ensure that kupdated calls us again to mark them clean */
-	jffs2_erase_pending_trigger(c);
+	wake_up(&c->erase_wait);
 }
 
 static void jffs2_erase_failed(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, uint32_t bad_offset)
@@ -479,21 +483,14 @@
 	return;
 
 filebad:
-	mutex_lock(&c->erase_free_sem);
-	spin_lock(&c->erase_completion_lock);
-	/* Stick it on a list (any list) so erase_failed can take it
-	   right off again.  Silly, but shouldn't happen often. */
-	list_move(&jeb->list, &c->erasing_list);
-	spin_unlock(&c->erase_completion_lock);
-	mutex_unlock(&c->erase_free_sem);
 	jffs2_erase_failed(c, jeb, bad_offset);
 	return;
 
 refile:
 	/* Stick it back on the list from whence it came and come back later */
-	jffs2_erase_pending_trigger(c);
 	mutex_lock(&c->erase_free_sem);
 	spin_lock(&c->erase_completion_lock);
+	jffs2_garbage_collect_trigger(c);
 	list_move(&jeb->list, &c->erase_complete_list);
 	spin_unlock(&c->erase_completion_lock);
 	mutex_unlock(&c->erase_free_sem);
diff -Naur pico_2.6.28/fs/jffs2/file.c ipa_2.6.28/fs/jffs2/file.c
--- pico_2.6.28/fs/jffs2/file.c	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/fs/jffs2/file.c	2011-04-26 14:51:35.000000000 +0100
@@ -99,7 +99,7 @@
 	kunmap(pg);
 
 	D2(printk(KERN_DEBUG "readpage finished\n"));
-	return 0;
+	return ret;
 }
 
 int jffs2_do_readpage_unlock(struct inode *inode, struct page *pg)
diff -Naur pico_2.6.28/fs/jffs2/fs.c ipa_2.6.28/fs/jffs2/fs.c
--- pico_2.6.28/fs/jffs2/fs.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/fs/jffs2/fs.c	2011-04-26 14:51:35.000000000 +0100
@@ -402,21 +402,6 @@
 	return 0;
 }
 
-void jffs2_write_super (struct super_block *sb)
-{
-	struct jffs2_sb_info *c = JFFS2_SB_INFO(sb);
-	sb->s_dirt = 0;
-
-	if (sb->s_flags & MS_RDONLY)
-		return;
-
-	D1(printk(KERN_DEBUG "jffs2_write_super()\n"));
-	jffs2_garbage_collect_trigger(c);
-	jffs2_erase_pending_blocks(c, 0);
-	jffs2_flush_wbuf_gc(c, 0);
-}
-
-
 /* jffs2_new_inode: allocate a new inode and inocache, add it to the hash,
    fill in the raw_inode while you're at it. */
 struct inode *jffs2_new_inode (struct inode *dir_i, int mode, struct jffs2_raw_inode *ri)
diff -Naur pico_2.6.28/fs/jffs2/gc.c ipa_2.6.28/fs/jffs2/gc.c
--- pico_2.6.28/fs/jffs2/gc.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/fs/jffs2/gc.c	2011-04-26 14:51:35.000000000 +0100
@@ -214,6 +214,19 @@
 		return ret;
 	}
 
+	/* If there are any blocks which need erasing, erase them now */
+	if (!list_empty(&c->erase_complete_list) ||
+	    !list_empty(&c->erase_pending_list)) {
+		spin_unlock(&c->erase_completion_lock);
+		D1(printk(KERN_DEBUG "jffs2_garbage_collect_pass() erasing pending blocks\n"));
+		if (jffs2_erase_pending_blocks(c, 1)) {
+			mutex_unlock(&c->alloc_sem);
+			return 0;
+		}
+		D1(printk(KERN_DEBUG "No progress from erasing blocks; doing GC anyway\n"));
+		spin_lock(&c->erase_completion_lock);
+	}
+
 	/* First, work out which block we're garbage-collecting */
 	jeb = c->gcblock;
 
@@ -222,7 +235,7 @@
 
 	if (!jeb) {
 		/* Couldn't find a free block. But maybe we can just erase one and make 'progress'? */
-		if (!list_empty(&c->erase_pending_list)) {
+		if (c->nr_erasing_blocks) {
 			spin_unlock(&c->erase_completion_lock);
 			mutex_unlock(&c->alloc_sem);
 			return -EAGAIN;
@@ -435,7 +448,7 @@
 		list_add_tail(&c->gcblock->list, &c->erase_pending_list);
 		c->gcblock = NULL;
 		c->nr_erasing_blocks++;
-		jffs2_erase_pending_trigger(c);
+		jffs2_garbage_collect_trigger(c);
 	}
 	spin_unlock(&c->erase_completion_lock);
 
@@ -700,7 +713,8 @@
 	struct jffs2_raw_inode ri;
 	struct jffs2_node_frag *last_frag;
 	union jffs2_device_node dev;
-	char *mdata = NULL, mdatalen = 0;
+	char *mdata = NULL;
+	int mdatalen = 0;
 	uint32_t alloclen, ilen;
 	int ret;
 
diff -Naur pico_2.6.28/fs/jffs2/malloc.c ipa_2.6.28/fs/jffs2/malloc.c
--- pico_2.6.28/fs/jffs2/malloc.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/fs/jffs2/malloc.c	2011-04-26 14:51:35.000000000 +0100
@@ -39,13 +39,13 @@
 
 	raw_dirent_slab = kmem_cache_create("jffs2_raw_dirent",
 					    sizeof(struct jffs2_raw_dirent),
-					    0, 0, NULL);
+					    0, SLAB_HWCACHE_ALIGN, NULL);
 	if (!raw_dirent_slab)
 		goto err;
 
 	raw_inode_slab = kmem_cache_create("jffs2_raw_inode",
 					   sizeof(struct jffs2_raw_inode),
-					   0, 0, NULL);
+					   0, SLAB_HWCACHE_ALIGN, NULL);
 	if (!raw_inode_slab)
 		goto err;
 
@@ -284,10 +284,9 @@
 struct jffs2_xattr_datum *jffs2_alloc_xattr_datum(void)
 {
 	struct jffs2_xattr_datum *xd;
-	xd = kmem_cache_alloc(xattr_datum_cache, GFP_KERNEL);
+	xd = kmem_cache_zalloc(xattr_datum_cache, GFP_KERNEL);
 	dbg_memalloc("%p\n", xd);
 
-	memset(xd, 0, sizeof(struct jffs2_xattr_datum));
 	xd->class = RAWNODE_CLASS_XATTR_DATUM;
 	xd->node = (void *)xd;
 	INIT_LIST_HEAD(&xd->xindex);
@@ -303,10 +302,9 @@
 struct jffs2_xattr_ref *jffs2_alloc_xattr_ref(void)
 {
 	struct jffs2_xattr_ref *ref;
-	ref = kmem_cache_alloc(xattr_ref_cache, GFP_KERNEL);
+	ref = kmem_cache_zalloc(xattr_ref_cache, GFP_KERNEL);
 	dbg_memalloc("%p\n", ref);
 
-	memset(ref, 0, sizeof(struct jffs2_xattr_ref));
 	ref->class = RAWNODE_CLASS_XATTR_REF;
 	ref->node = (void *)ref;
 	return ref;
diff -Naur pico_2.6.28/fs/jffs2/nodelist.h ipa_2.6.28/fs/jffs2/nodelist.h
--- pico_2.6.28/fs/jffs2/nodelist.h	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/fs/jffs2/nodelist.h	2011-04-26 14:51:35.000000000 +0100
@@ -366,9 +366,6 @@
 void jffs2_free_raw_node_refs(struct jffs2_sb_info *c);
 struct jffs2_node_frag *jffs2_lookup_node_frag(struct rb_root *fragtree, uint32_t offset);
 void jffs2_kill_fragtree(struct rb_root *root, struct jffs2_sb_info *c_delete);
-struct rb_node *rb_next(struct rb_node *);
-struct rb_node *rb_prev(struct rb_node *);
-void rb_replace_node(struct rb_node *victim, struct rb_node *new, struct rb_root *root);
 int jffs2_add_full_dnode_to_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f, struct jffs2_full_dnode *fn);
 uint32_t jffs2_truncate_fragtree (struct jffs2_sb_info *c, struct rb_root *list, uint32_t size);
 struct jffs2_raw_node_ref *jffs2_link_node_ref(struct jffs2_sb_info *c,
@@ -467,7 +464,7 @@
 int jffs2_do_mount_fs(struct jffs2_sb_info *c);
 
 /* erase.c */
-void jffs2_erase_pending_blocks(struct jffs2_sb_info *c, int count);
+int jffs2_erase_pending_blocks(struct jffs2_sb_info *c, int count);
 void jffs2_free_jeb_node_refs(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);
 
 #ifdef CONFIG_JFFS2_FS_WRITEBUFFER
diff -Naur pico_2.6.28/fs/jffs2/nodemgmt.c ipa_2.6.28/fs/jffs2/nodemgmt.c
--- pico_2.6.28/fs/jffs2/nodemgmt.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/fs/jffs2/nodemgmt.c	2011-04-26 14:51:35.000000000 +0100
@@ -117,9 +117,21 @@
 
 			ret = jffs2_garbage_collect_pass(c);
 
-			if (ret == -EAGAIN)
-				jffs2_erase_pending_blocks(c, 1);
-			else if (ret)
+			if (ret == -EAGAIN) {
+				spin_lock(&c->erase_completion_lock);
+				if (c->nr_erasing_blocks &&
+				    list_empty(&c->erase_pending_list) &&
+				    list_empty(&c->erase_complete_list)) {
+					DECLARE_WAITQUEUE(wait, current);
+					set_current_state(TASK_UNINTERRUPTIBLE);
+					add_wait_queue(&c->erase_wait, &wait);
+					D1(printk(KERN_DEBUG "%s waiting for erase to complete\n", __func__));
+					spin_unlock(&c->erase_completion_lock);
+
+					schedule();
+				} else
+					spin_unlock(&c->erase_completion_lock);
+			} else if (ret)
 				return ret;
 
 			cond_resched();
@@ -218,7 +230,7 @@
 			ejeb = list_entry(c->erasable_list.next, struct jffs2_eraseblock, list);
 			list_move_tail(&ejeb->list, &c->erase_pending_list);
 			c->nr_erasing_blocks++;
-			jffs2_erase_pending_trigger(c);
+			jffs2_garbage_collect_trigger(c);
 			D1(printk(KERN_DEBUG "jffs2_find_nextblock: Triggering erase of erasable block at 0x%08x\n",
 				  ejeb->offset));
 		}
@@ -470,7 +482,9 @@
 void jffs2_complete_reservation(struct jffs2_sb_info *c)
 {
 	D1(printk(KERN_DEBUG "jffs2_complete_reservation()\n"));
+	spin_lock(&c->erase_completion_lock);
 	jffs2_garbage_collect_trigger(c);
+	spin_unlock(&c->erase_completion_lock);
 	mutex_unlock(&c->alloc_sem);
 }
 
@@ -612,7 +626,7 @@
 				D1(printk(KERN_DEBUG "...and adding to erase_pending_list\n"));
 				list_add_tail(&jeb->list, &c->erase_pending_list);
 				c->nr_erasing_blocks++;
-				jffs2_erase_pending_trigger(c);
+				jffs2_garbage_collect_trigger(c);
 			} else {
 				/* Sometimes, however, we leave it elsewhere so it doesn't get
 				   immediately reused, and we spread the load a bit. */
@@ -733,6 +747,10 @@
 	int nr_very_dirty = 0;
 	struct jffs2_eraseblock *jeb;
 
+	if (!list_empty(&c->erase_complete_list) ||
+	    !list_empty(&c->erase_pending_list))
+		return 1;
+
 	if (c->unchecked_size) {
 		D1(printk(KERN_DEBUG "jffs2_thread_should_wake(): unchecked_size %d, checked_ino #%d\n",
 			  c->unchecked_size, c->checked_ino));
diff -Naur pico_2.6.28/fs/jffs2/os-linux.h ipa_2.6.28/fs/jffs2/os-linux.h
--- pico_2.6.28/fs/jffs2/os-linux.h	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/fs/jffs2/os-linux.h	2011-04-26 14:51:35.000000000 +0100
@@ -144,8 +144,7 @@
 
 #endif /* WRITEBUFFER */
 
-/* erase.c */
-static inline void jffs2_erase_pending_trigger(struct jffs2_sb_info *c)
+static inline void jffs2_dirty_trigger(struct jffs2_sb_info *c)
 {
 	OFNI_BS_2SFFJ(c)->s_dirt = 1;
 }
@@ -181,7 +180,6 @@
 struct inode *jffs2_new_inode (struct inode *dir_i, int mode,
 			       struct jffs2_raw_inode *ri);
 int jffs2_statfs (struct dentry *, struct kstatfs *);
-void jffs2_write_super (struct super_block *);
 int jffs2_remount_fs (struct super_block *, int *, char *);
 int jffs2_do_fill_super(struct super_block *sb, void *data, int silent);
 void jffs2_gc_release_inode(struct jffs2_sb_info *c,
diff -Naur pico_2.6.28/fs/jffs2/read.c ipa_2.6.28/fs/jffs2/read.c
--- pico_2.6.28/fs/jffs2/read.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/fs/jffs2/read.c	2011-04-26 14:51:35.000000000 +0100
@@ -164,12 +164,15 @@
 
 	/* XXX FIXME: Where a single physical node actually shows up in two
 	   frags, we read it twice. Don't do that. */
-	/* Now we're pointing at the first frag which overlaps our page */
+	/* Now we're pointing at the first frag which overlaps our page
+	 * (or perhaps is before it, if we've been asked to read off the
+	 * end of the file). */
 	while(offset < end) {
 		D2(printk(KERN_DEBUG "jffs2_read_inode_range: offset %d, end %d\n", offset, end));
-		if (unlikely(!frag || frag->ofs > offset)) {
+		if (unlikely(!frag || frag->ofs > offset ||
+			     frag->ofs + frag->size <= offset)) {
 			uint32_t holesize = end - offset;
-			if (frag) {
+			if (frag && frag->ofs > offset) {
 				D1(printk(KERN_NOTICE "Eep. Hole in ino #%u fraglist. frag->ofs = 0x%08x, offset = 0x%08x\n", f->inocache->ino, frag->ofs, offset));
 				holesize = min(holesize, frag->ofs - offset);
 			}
diff -Naur pico_2.6.28/fs/jffs2/readinode.c ipa_2.6.28/fs/jffs2/readinode.c
--- pico_2.6.28/fs/jffs2/readinode.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/fs/jffs2/readinode.c	2011-04-26 14:51:35.000000000 +0100
@@ -220,7 +220,7 @@
 				struct jffs2_tmp_dnode_info *tn)
 {
 	uint32_t fn_end = tn->fn->ofs + tn->fn->size;
-	struct jffs2_tmp_dnode_info *this;
+	struct jffs2_tmp_dnode_info *this, *ptn;
 
 	dbg_readinode("insert fragment %#04x-%#04x, ver %u at %08x\n", tn->fn->ofs, fn_end, tn->version, ref_offset(tn->fn->raw));
 
@@ -251,11 +251,18 @@
 	if (this) {
 		/* If the node is coincident with another at a lower address,
 		   back up until the other node is found. It may be relevant */
-		while (this->overlapped)
-			this = tn_prev(this);
-
-		/* First node should never be marked overlapped */
-		BUG_ON(!this);
+		while (this->overlapped) {
+			ptn = tn_prev(this);
+			if (!ptn) {
+				/*
+				 * We killed a node which set the overlapped
+				 * flags during the scan. Fix it up.
+				 */
+				this->overlapped = 0;
+				break;
+			}
+			this = ptn;
+		}
 		dbg_readinode("'this' found %#04x-%#04x (%s)\n", this->fn->ofs, this->fn->ofs + this->fn->size, this->fn ? "data" : "hole");
 	}
 
@@ -360,7 +367,17 @@
 			}
 			if (!this->overlapped)
 				break;
-			this = tn_prev(this);
+
+			ptn = tn_prev(this);
+			if (!ptn) {
+				/*
+				 * We killed a node which set the overlapped
+				 * flags during the scan. Fix it up.
+				 */
+				this->overlapped = 0;
+				break;
+			}
+			this = ptn;
 		}
 	}
 
@@ -456,8 +473,15 @@
 		eat_last(&rii->tn_root, &last->rb);
 		ver_insert(&ver_root, last);
 
-		if (unlikely(last->overlapped))
-			continue;
+		if (unlikely(last->overlapped)) {
+			if (pen)
+				continue;
+			/*
+			 * We killed a node which set the overlapped
+			 * flags during the scan. Fix it up.
+			 */
+			last->overlapped = 0;
+		}
 
 		/* Now we have a bunch of nodes in reverse version
 		   order, in the tree at ver_root. Most of the time,
@@ -543,7 +567,7 @@
 			else BUG();
 		}
 	}
-	list->rb_node = NULL;
+	*list = RB_ROOT;
 }
 
 static void jffs2_free_full_dirent_list(struct jffs2_full_dirent *fd)
@@ -907,7 +931,7 @@
  * Helper function for jffs2_get_inode_nodes().
  * The function detects whether more data should be read and reads it if yes.
  *
- * Returns: 0 on succes;
+ * Returns: 0 on success;
  * 	    negative error code on failure.
  */
 static int read_more(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref,
@@ -1260,7 +1284,7 @@
 				f->target = NULL;
 				mutex_unlock(&f->sem);
 				jffs2_do_clear_inode(c, f);
-				return -ret;
+				return ret;
 			}
 
 			f->target[je32_to_cpu(latest_node->csize)] = '\0';
diff -Naur pico_2.6.28/fs/jffs2/scan.c ipa_2.6.28/fs/jffs2/scan.c
--- pico_2.6.28/fs/jffs2/scan.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/fs/jffs2/scan.c	2011-04-26 14:51:35.000000000 +0100
@@ -130,9 +130,9 @@
 	if (jffs2_sum_active()) {
 		s = kzalloc(sizeof(struct jffs2_summary), GFP_KERNEL);
 		if (!s) {
-			kfree(flashbuf);
 			JFFS2_WARNING("Can't allocate memory for summary\n");
-			return -ENOMEM;
+			ret = -ENOMEM;
+			goto out;
 		}
 	}
 
@@ -196,7 +196,7 @@
 				if (c->nextblock) {
 					ret = file_dirty(c, c->nextblock);
 					if (ret)
-						return ret;
+						goto out;
 					/* deleting summary information of the old nextblock */
 					jffs2_sum_reset_collected(c->summary);
 				}
@@ -207,7 +207,7 @@
 			} else {
 				ret = file_dirty(c, jeb);
 				if (ret)
-					return ret;
+					goto out;
 			}
 			break;
 
@@ -260,7 +260,9 @@
 			ret = -EIO;
 			goto out;
 		}
-		jffs2_erase_pending_trigger(c);
+		spin_lock(&c->erase_completion_lock);
+		jffs2_garbage_collect_trigger(c);
+		spin_unlock(&c->erase_completion_lock);
 	}
 	ret = 0;
  out:
@@ -437,6 +439,8 @@
 	uint32_t hdr_crc, buf_ofs, buf_len;
 	int err;
 	int noise = 0;
+	int node_fault = 0;
+	int buffer_gap = 0;
 
 
 #ifdef CONFIG_JFFS2_FS_WRITEBUFFER
@@ -651,6 +655,16 @@
 					       empty_start, ofs);
 					if ((err = jffs2_scan_dirty_space(c, jeb, ofs-empty_start)))
 						return err;
+					if ((ofs | 63) != (empty_start | 63))
+					{
+						/* If the first erased byte and the next non-erased byte are
+						 * not part of the same write buffer region then something has
+						 * probably gone amiss with the erase/program of this sector.
+						 * We'd be better to clean it up, rather than allow JFFS2 to
+						 * write to an area that might not be properly erased.
+						 */
+						buffer_gap = 1;
+					}
 					goto scan_more;
 				}
 
@@ -664,8 +678,9 @@
 			   bail now */
 			if (buf_ofs == jeb->offset && jeb->used_size == PAD(c->cleanmarker_size) &&
 			    c->cleanmarker_size && !jeb->dirty_size && !ref_next(jeb->first_node)) {
-				D1(printk(KERN_DEBUG "%d bytes at start of block seems clean... assuming all clean\n", EMPTY_SCAN_SIZE(c->sector_size)));
-				return BLK_STATE_CLEANMARKER;
+				printk(KERN_DEBUG "%d bytes at start of block seems clean.  Checking remainder of block.\n", EMPTY_SCAN_SIZE(c->sector_size));
+				/* D1(printk(KERN_DEBUG "%d bytes at start of block seems clean... but not assuming all clean\n", EMPTY_SCAN_SIZE(c->sector_size)));
+				return BLK_STATE_CLEANMARKER; */
 			}
 			if (!buf_size && (scan_end != buf_len)) {/* XIP/point case */
 				scan_end = buf_len;
@@ -675,10 +690,23 @@
 			/* See how much more there is to read in this eraseblock... */
 			buf_len = min_t(uint32_t, buf_size, jeb->offset + c->sector_size - ofs);
 			if (!buf_len) {
-				/* No more to read. Break out of main loop without marking
-				   this range of empty space as dirty (because it's not) */
-				D1(printk(KERN_DEBUG "Empty flash at %08x runs to end of block. Treating as free_space\n",
-					  empty_start));
+				if (node_fault && buffer_gap) {
+					/* Although there's empty space at the end of this block there were
+					   signs of trouble before that, namely at least one node with the wrong
+					   Magic/CRC and a gap that couldn't be accounted for by an interrupted
+					   write using the write buffer; that fills from the top of the buffer
+					   on some devices.  Assume the block has unstable bits and mark the
+					   remaining free space as dirty. */
+					printk(KERN_WARNING "Empty flash at %08x runs to end of block. Treating as dirty due to previous errors\n",
+						  empty_start);
+					if ((err = jffs2_scan_dirty_space(c, jeb, ofs-empty_start)))
+						return err;
+				} else {
+					/* No more to read. Break out of main loop without marking
+					   this range of empty space as dirty (because it's not) */
+					D1(printk(KERN_DEBUG "Empty flash at %08x runs to end of block. Treating as free_space\n",
+						  empty_start));
+   				}
 				break;
 			}
 			/* point never reaches here */
@@ -696,6 +724,7 @@
 			if ((err = jffs2_scan_dirty_space(c, jeb, 4)))
 				return err;
 			ofs += 4;
+			node_fault = 1;
 			continue;
 		}
 		if (je16_to_cpu(node->magic) == JFFS2_DIRTY_BITMASK) {
@@ -703,6 +732,7 @@
 			if ((err = jffs2_scan_dirty_space(c, jeb, 4)))
 				return err;
 			ofs += 4;
+			node_fault = 1;
 			continue;
 		}
 		if (je16_to_cpu(node->magic) == JFFS2_OLD_MAGIC_BITMASK) {
@@ -711,6 +741,7 @@
 			if ((err = jffs2_scan_dirty_space(c, jeb, 4)))
 				return err;
 			ofs += 4;
+			node_fault = 1;
 			continue;
 		}
 		if (je16_to_cpu(node->magic) != JFFS2_MAGIC_BITMASK) {
@@ -721,6 +752,7 @@
 			if ((err = jffs2_scan_dirty_space(c, jeb, 4)))
 				return err;
 			ofs += 4;
+			node_fault = 1;
 			continue;
 		}
 		/* We seem to have a node of sorts. Check the CRC */
@@ -739,6 +771,7 @@
 			if ((err = jffs2_scan_dirty_space(c, jeb, 4)))
 				return err;
 			ofs += 4;
+			node_fault = 1;
 			continue;
 		}
 
@@ -750,6 +783,7 @@
 			if ((err = jffs2_scan_dirty_space(c, jeb, 4)))
 				return err;
 			ofs += 4;
+			node_fault = 1;
 			continue;
 		}
 
diff -Naur pico_2.6.28/fs/jffs2/security.c ipa_2.6.28/fs/jffs2/security.c
--- pico_2.6.28/fs/jffs2/security.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/fs/jffs2/security.c	2011-04-26 14:51:35.000000000 +0100
@@ -75,7 +75,7 @@
 	return retlen;
 }
 
-struct xattr_handler jffs2_security_xattr_handler = {
+const struct xattr_handler jffs2_security_xattr_handler = {
 	.prefix = XATTR_SECURITY_PREFIX,
 	.list = jffs2_security_listxattr,
 	.set = jffs2_security_setxattr,
diff -Naur pico_2.6.28/fs/jffs2/summary.c ipa_2.6.28/fs/jffs2/summary.c
--- pico_2.6.28/fs/jffs2/summary.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/fs/jffs2/summary.c	2011-04-26 14:51:35.000000000 +0100
@@ -23,7 +23,7 @@
 
 int jffs2_sum_init(struct jffs2_sb_info *c)
 {
-	uint32_t sum_size = max_t(uint32_t, c->sector_size, MAX_SUMMARY_SIZE);
+	uint32_t sum_size = min_t(uint32_t, c->sector_size, MAX_SUMMARY_SIZE);
 
 	c->summary = kzalloc(sizeof(struct jffs2_summary), GFP_KERNEL);
 
diff -Naur pico_2.6.28/fs/jffs2/super.c ipa_2.6.28/fs/jffs2/super.c
--- pico_2.6.28/fs/jffs2/super.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/fs/jffs2/super.c	2011-04-26 14:51:35.000000000 +0100
@@ -53,10 +53,23 @@
 	inode_init_once(&f->vfs_inode);
 }
 
+static void jffs2_write_super(struct super_block *sb)
+{
+	struct jffs2_sb_info *c = JFFS2_SB_INFO(sb);
+	sb->s_dirt = 0;
+
+	if (!(sb->s_flags & MS_RDONLY)) {
+		D1(printk(KERN_DEBUG "jffs2_write_super()\n"));
+		jffs2_flush_wbuf_gc(c, 0);
+	}
+}
+
 static int jffs2_sync_fs(struct super_block *sb, int wait)
 {
 	struct jffs2_sb_info *c = JFFS2_SB_INFO(sb);
 
+	jffs2_write_super(sb);
+
 	mutex_lock(&c->alloc_sem);
 	jffs2_flush_wbuf_pad(c);
 	mutex_unlock(&c->alloc_sem);
@@ -103,7 +116,7 @@
 	return d_obtain_alias(jffs2_iget(child->d_inode->i_sb, pino));
 }
 
-static struct export_operations jffs2_export_ops = {
+static const struct export_operations jffs2_export_ops = {
 	.get_parent = jffs2_get_parent,
 	.fh_to_dentry = jffs2_fh_to_dentry,
 	.fh_to_parent = jffs2_fh_to_parent,
@@ -174,6 +187,9 @@
 
 	D2(printk(KERN_DEBUG "jffs2: jffs2_put_super()\n"));
 
+	if (sb->s_dirt)
+		jffs2_write_super(sb);
+
 	mutex_lock(&c->alloc_sem);
 	jffs2_flush_wbuf_pad(c);
 	mutex_unlock(&c->alloc_sem);
diff -Naur pico_2.6.28/fs/jffs2/wbuf.c ipa_2.6.28/fs/jffs2/wbuf.c
--- pico_2.6.28/fs/jffs2/wbuf.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/fs/jffs2/wbuf.c	2011-04-26 14:51:35.000000000 +0100
@@ -84,7 +84,7 @@
 	struct jffs2_inodirty *new;
 
 	/* Mark the superblock dirty so that kupdated will flush... */
-	jffs2_erase_pending_trigger(c);
+	jffs2_dirty_trigger(c);
 
 	if (jffs2_wbuf_pending_for_ino(c, ino))
 		return;
@@ -121,7 +121,7 @@
 			D1(printk(KERN_DEBUG "...and adding to erase_pending_list\n"));
 			list_add_tail(&jeb->list, &c->erase_pending_list);
 			c->nr_erasing_blocks++;
-			jffs2_erase_pending_trigger(c);
+			jffs2_garbage_collect_trigger(c);
 		} else {
 			/* Sometimes, however, we leave it elsewhere so it doesn't get
 			   immediately reused, and we spread the load a bit. */
@@ -152,7 +152,7 @@
 		D1(printk("Refiling block at %08x to erase_pending_list\n", jeb->offset));
 		list_add(&jeb->list, &c->erase_pending_list);
 		c->nr_erasing_blocks++;
-		jffs2_erase_pending_trigger(c);
+		jffs2_garbage_collect_trigger(c);
 	}
 
 	if (!jffs2_prealloc_raw_node_refs(c, jeb, 1)) {
@@ -543,7 +543,7 @@
 		D1(printk(KERN_DEBUG "Failing block at %08x is now empty. Moving to erase_pending_list\n", jeb->offset));
 		list_move(&jeb->list, &c->erase_pending_list);
 		c->nr_erasing_blocks++;
-		jffs2_erase_pending_trigger(c);
+		jffs2_garbage_collect_trigger(c);
 	}
 
 	jffs2_dbg_acct_sanity_check_nolock(c, jeb);
@@ -1268,10 +1268,20 @@
 	if (!c->wbuf)
 		return -ENOMEM;
 
+#ifdef CONFIG_JFFS2_FS_WBUF_VERIFY
+	c->wbuf_verify = kmalloc(c->wbuf_pagesize, GFP_KERNEL);
+	if (!c->wbuf_verify) {
+		kfree(c->wbuf);
+		return -ENOMEM;
+	}
+#endif
 	return 0;
 }
 
 void jffs2_nor_wbuf_flash_cleanup(struct jffs2_sb_info *c) {
+#ifdef CONFIG_JFFS2_FS_WBUF_VERIFY
+	kfree(c->wbuf_verify);
+#endif
 	kfree(c->wbuf);
 }
 
diff -Naur pico_2.6.28/fs/jffs2/xattr.c ipa_2.6.28/fs/jffs2/xattr.c
--- pico_2.6.28/fs/jffs2/xattr.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/fs/jffs2/xattr.c	2011-04-26 14:51:35.000000000 +0100
@@ -31,7 +31,7 @@
  *   is used to release xattr name/value pair and detach from c->xattrindex.
  * reclaim_xattr_datum(c)
  *   is used to reclaim xattr name/value pairs on the xattr name/value pair cache when
- *   memory usage by cache is over c->xdatum_mem_threshold. Currentry, this threshold 
+ *   memory usage by cache is over c->xdatum_mem_threshold. Currently, this threshold 
  *   is hard coded as 32KiB.
  * do_verify_xattr_datum(c, xd)
  *   is used to load the xdatum informations without name/value pair from the medium.
@@ -626,7 +626,7 @@
 
 static int check_xattr_ref_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic)
 {
-	/* success of check_xattr_ref_inode() means taht inode (ic) dose not have
+	/* success of check_xattr_ref_inode() means that inode (ic) dose not have
 	 * duplicate name/value pairs. If duplicate name/value pair would be found,
 	 * one will be removed.
 	 */
@@ -904,7 +904,7 @@
  * do_jffs2_setxattr(inode, xprefix, xname, buffer, size, flags)
  *   is an implementation of setxattr handler on jffs2.
  * -------------------------------------------------- */
-struct xattr_handler *jffs2_xattr_handlers[] = {
+const struct xattr_handler *jffs2_xattr_handlers[] = {
 	&jffs2_user_xattr_handler,
 #ifdef CONFIG_JFFS2_FS_SECURITY
 	&jffs2_security_xattr_handler,
@@ -917,8 +917,8 @@
 	NULL
 };
 
-static struct xattr_handler *xprefix_to_handler(int xprefix) {
-	struct xattr_handler *ret;
+static const struct xattr_handler *xprefix_to_handler(int xprefix) {
+	const struct xattr_handler *ret;
 
 	switch (xprefix) {
 	case JFFS2_XPREFIX_USER:
@@ -955,7 +955,7 @@
 	struct jffs2_inode_cache *ic = f->inocache;
 	struct jffs2_xattr_ref *ref, **pref;
 	struct jffs2_xattr_datum *xd;
-	struct xattr_handler *xhandle;
+	const struct xattr_handler *xhandle;
 	ssize_t len, rc;
 	int retry = 0;
 
diff -Naur pico_2.6.28/fs/jffs2/xattr.h ipa_2.6.28/fs/jffs2/xattr.h
--- pico_2.6.28/fs/jffs2/xattr.h	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/fs/jffs2/xattr.h	2011-04-26 14:51:35.000000000 +0100
@@ -93,9 +93,9 @@
 extern int do_jffs2_setxattr(struct inode *inode, int xprefix, const char *xname,
 			     const char *buffer, size_t size, int flags);
 
-extern struct xattr_handler *jffs2_xattr_handlers[];
-extern struct xattr_handler jffs2_user_xattr_handler;
-extern struct xattr_handler jffs2_trusted_xattr_handler;
+extern const struct xattr_handler *jffs2_xattr_handlers[];
+extern const struct xattr_handler jffs2_user_xattr_handler;
+extern const struct xattr_handler jffs2_trusted_xattr_handler;
 
 extern ssize_t jffs2_listxattr(struct dentry *, char *, size_t);
 #define jffs2_getxattr		generic_getxattr
@@ -122,7 +122,7 @@
 
 #ifdef CONFIG_JFFS2_FS_SECURITY
 extern int jffs2_init_security(struct inode *inode, struct inode *dir);
-extern struct xattr_handler jffs2_security_xattr_handler;
+extern const struct xattr_handler jffs2_security_xattr_handler;
 #else
 #define jffs2_init_security(inode,dir)	(0)
 #endif /* CONFIG_JFFS2_FS_SECURITY */
diff -Naur pico_2.6.28/fs/jffs2/xattr_trusted.c ipa_2.6.28/fs/jffs2/xattr_trusted.c
--- pico_2.6.28/fs/jffs2/xattr_trusted.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/fs/jffs2/xattr_trusted.c	2011-04-26 14:51:35.000000000 +0100
@@ -45,7 +45,7 @@
 	return retlen;
 }
 
-struct xattr_handler jffs2_trusted_xattr_handler = {
+const struct xattr_handler jffs2_trusted_xattr_handler = {
 	.prefix = XATTR_TRUSTED_PREFIX,
 	.list = jffs2_trusted_listxattr,
 	.set = jffs2_trusted_setxattr,
diff -Naur pico_2.6.28/fs/jffs2/xattr_user.c ipa_2.6.28/fs/jffs2/xattr_user.c
--- pico_2.6.28/fs/jffs2/xattr_user.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/fs/jffs2/xattr_user.c	2011-04-26 14:51:35.000000000 +0100
@@ -45,7 +45,7 @@
 	return retlen;
 }
 
-struct xattr_handler jffs2_user_xattr_handler = {
+const struct xattr_handler jffs2_user_xattr_handler = {
 	.prefix = XATTR_USER_PREFIX,
 	.list = jffs2_user_listxattr,
 	.set = jffs2_user_setxattr,
diff -Naur pico_2.6.28/include/linux/i2c-id.h ipa_2.6.28/include/linux/i2c-id.h
--- pico_2.6.28/include/linux/i2c-id.h	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/include/linux/i2c-id.h	2011-04-26 14:51:35.000000000 +0100
@@ -82,6 +82,9 @@
 #define I2C_DRIVERID_M52790 	95      /* Mitsubishi M52790SP/FP AV switch */
 #define I2C_DRIVERID_CS5345	96	/* cs5345 audio processor	*/
 
+#define I2C_DRIVERID_AT97SC3204T	198	/* Atmel AT97SC3204T TPM	*/
+#define I2C_DRIVERID_AD7995		199	/* Analog Devices 7995 ADC	*/
+
 #define I2C_DRIVERID_OV7670 1048	/* Omnivision 7670 camera */
 
 /*
diff -Naur pico_2.6.28/include/linux/ipa/ad7995.h ipa_2.6.28/include/linux/ipa/ad7995.h
--- pico_2.6.28/include/linux/ipa/ad7995.h	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/include/linux/ipa/ad7995.h	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,43 @@
+/* -*- C -*-
+ * ad7995.h -- definitions for the Analog Devices AD7995 ADC
+ *
+ * Copyright (C) 2009 ip.access Ltd
+ *
+ */
+
+#include <linux/ioctl.h>
+
+
+/*
+ * Ioctl definitions
+ */
+
+/* Use 'A' as magic number */
+#define AD7995_IOCTL_MAGIC          'A'
+
+#define AD7995_IOCTL_READ_ADC       _IO(AD7995_IOCTL_MAGIC,   0)
+#define AD7995_IOCTL_WRITE_CONFIG   _IO(AD7995_IOCTL_MAGIC,   1)
+#define AD7995_IOCTL_READ_CONFIG    _IO(AD7995_IOCTL_MAGIC,   2)
+
+#define AD7995_IOCTL_MAXNR          2
+
+#define AD7995_CONFIG_SAMPLE_DELAY     0x01
+#define AD7995_CONFIG_BIT_TRIAL_DELAY  0x02
+#define AD7995_CONFIG_FILTER           0x04
+#define AD7995_CONFIG_REF_SELECT       0x08
+#define AD7995_CONFIG_CHAN_0           0x10
+#define AD7995_CONFIG_CHAN_1           0x20
+#define AD7995_CONFIG_CHAN_2           0x40
+#define AD7995_CONFIG_CHAN_3           0x80
+
+typedef struct Ad7995ConfigTag
+{
+	unsigned char  flags;
+	
+} Ad7995Config;
+
+typedef struct Ad7995SamplesTag
+{
+	int  adc[4];
+	
+} Ad7995Samples;
diff -Naur pico_2.6.28/include/linux/ipa/config_ipaccess.h ipa_2.6.28/include/linux/ipa/config_ipaccess.h
--- pico_2.6.28/include/linux/ipa/config_ipaccess.h	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/include/linux/ipa/config_ipaccess.h	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,33 @@
+/******************************************************************************
+ *
+ * Copyright (c) 2009 ip.access Ltd.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ * 22 Apr 2009 Created by Simon D Hughes.
+ *****************************************************************************
+ * Filename: 
+ *****************************************************************************/
+
+
+#ifndef _CONFIG_IPACCESS_H_
+
+
+#if    defined  (CONFIG_IPACCESS_IP202FF)\
+    || defined  (CONFIG_IPACCESS_IP202FF_XBPLUS)\
+    || defined  (CONFIG_IPACCESS_IP202FF_XC)\
+    || defined  (CONFIG_IPACCESS_I686_PC_LINUX_GNU)    
+
+#include "config_ipaccess_ip202ff.h"
+#endif 
+
+#ifdef CONFIG_IPACCESS_IP302FF
+#include "config_ipaccess_ip302ff.h"
+#endif 
+
+
+
+#endif /* _CONFIG_IPACCESS_H_ */
diff -Naur pico_2.6.28/include/linux/ipa/config_ipaccess_i686_pc_linux_gnu.h ipa_2.6.28/include/linux/ipa/config_ipaccess_i686_pc_linux_gnu.h
--- pico_2.6.28/include/linux/ipa/config_ipaccess_i686_pc_linux_gnu.h	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/include/linux/ipa/config_ipaccess_i686_pc_linux_gnu.h	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,27 @@
+/******************************************************************************
+ *
+ * Copyright (c) 2009 ip.access Ltd.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ * 22 Apr 2009 Created by Simon D Hughes.
+ *****************************************************************************
+ * Filename: 
+ *****************************************************************************/
+
+
+#ifndef _CONFIG_IPACCESS_I686_PC_LINUX_GNU_H_
+
+
+#ifdef __KERNEL__
+ /* add here variant kernel specific defines */
+#else 
+ /* add here variant user mode specific defines */
+
+#endif /*__KERNEL__*/
+
+
+#endif /* _CONFIG_IPACCESS_I686_PC_LINUX_GNU_H_ */
diff -Naur pico_2.6.28/include/linux/ipa/config_ipaccess_ip202ff.h ipa_2.6.28/include/linux/ipa/config_ipaccess_ip202ff.h
--- pico_2.6.28/include/linux/ipa/config_ipaccess_ip202ff.h	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/include/linux/ipa/config_ipaccess_ip202ff.h	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,44 @@
+/******************************************************************************
+ *
+ * Copyright (c) 2009 ip.access Ltd.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ * 22 Apr 2009 Created by Simon D Hughes.
+ *****************************************************************************
+ * Filename: 
+ *****************************************************************************/
+
+
+#ifndef _CONFIG_IPACCESS_IP202FF_H_
+
+
+#ifdef CONFIG_IPACCESS_IP202FF_XBPLUS
+#include "config_ipaccess_ip202ff_xbplus.h"
+#endif 
+
+#ifdef CONFIG_IPACCESS_IP202FF_XC
+#include "config_ipaccess_ip202ff_xc.h"
+#endif 
+
+#ifdef CONFIG_IPACCESS_IP202FF_XE
+#include "config_ipaccess_ip202ff_xe.h"
+#endif 
+
+#ifdef CONFIG_IPACCESS_I686_PC_LINUX_GNU
+#include "config_ipaccess_i686_pc_linux_gnu.h"
+#endif 
+
+
+#ifdef __KERNEL__
+ /* add here common variant kernel specific defines */
+#else 
+ /* add here common variant user mode specific defines */
+
+#endif /*__KERNEL__*/
+
+
+#endif /* _CONFIG_IPACCESS_IP202FF_H_ */
diff -Naur pico_2.6.28/include/linux/ipa/config_ipaccess_ip202ff_xbplus.h ipa_2.6.28/include/linux/ipa/config_ipaccess_ip202ff_xbplus.h
--- pico_2.6.28/include/linux/ipa/config_ipaccess_ip202ff_xbplus.h	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/include/linux/ipa/config_ipaccess_ip202ff_xbplus.h	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,27 @@
+/******************************************************************************
+ *
+ * Copyright (c) 2009 ip.access Ltd.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ * 22 Apr 2009 Created by Simon D Hughes.
+ *****************************************************************************
+ * Filename: 
+ *****************************************************************************/
+
+
+#ifndef _CONFIG_IPACCESS_IP202FF_XBPLUS_H_
+
+
+#ifdef __KERNEL__
+ /* add here variant kernel specific defines */
+#else 
+ /* add here variant user mode specific defines */
+
+#endif /*__KERNEL__*/
+
+
+#endif /* _CONFIG_IPACCESS_IP202FF_XBPLUS_H_ */
diff -Naur pico_2.6.28/include/linux/ipa/config_ipaccess_ip202ff_xc.h ipa_2.6.28/include/linux/ipa/config_ipaccess_ip202ff_xc.h
--- pico_2.6.28/include/linux/ipa/config_ipaccess_ip202ff_xc.h	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/include/linux/ipa/config_ipaccess_ip202ff_xc.h	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,27 @@
+/******************************************************************************
+ *
+ * Copyright (c) 2009 ip.access Ltd.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ * 22 Apr 2009 Created by Simon D Hughes.
+ *****************************************************************************
+ * Filename: 
+ *****************************************************************************/
+
+
+#ifndef _CONFIG_IPACCESS_IP202FF_XC_H_
+
+
+#ifdef __KERNEL__
+ /* add here variant kernel specific defines */
+#else 
+ /* add here variant user mode specific defines */
+
+#endif /*__KERNEL__*/
+
+
+#endif /* _CONFIG_IPACCESS_IP202FF_XC_H_ */
diff -Naur pico_2.6.28/include/linux/ipa/config_ipaccess_ip302ff.h ipa_2.6.28/include/linux/ipa/config_ipaccess_ip302ff.h
--- pico_2.6.28/include/linux/ipa/config_ipaccess_ip302ff.h	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/include/linux/ipa/config_ipaccess_ip302ff.h	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,21 @@
+/******************************************************************************
+ *
+ * Copyright (c) 2009 ip.access Ltd.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ * 22 Apr 2009 Created by Simon D Hughes.
+ *****************************************************************************
+ * Filename: 
+ *****************************************************************************/
+
+
+#ifndef _CONFIG_IPACCESS_IP302FF_H_
+
+
+
+
+#endif /* _CONFIG_IPACCESS_IP202FF_H_ */
diff -Naur pico_2.6.28/include/linux/ipa/cpetd.h ipa_2.6.28/include/linux/ipa/cpetd.h
--- pico_2.6.28/include/linux/ipa/cpetd.h	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/include/linux/ipa/cpetd.h	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,152 @@
+/* -*- C -*-
+ * cpetd.h -- definitions for the CPE Timebase Device driver module
+ *
+ * Copyright (C) 2007 ip.access Ltd
+ *
+ */
+
+#include <linux/ioctl.h>
+
+
+#define noCPETD_TEST              1       /* define if doing a build to work with cpetd_test */
+#define CPETD_PERIOD            5       /* default device file timebase interval (ms)
+                                         * must be multiple of CPETD_BASE_INTERVAL defined
+                                         * in cpetd_main.c*/
+#define CPETD_MAX_INTERVAL      63      /* maximum timebase interval (period) supported */
+#define CPETD_MAX_NUM_DEVICES   4       /* maximum number of devices allowed */
+
+
+/*
+ * Ioctl definitions
+ */
+
+/* Use 'K' as magic number */
+#define CPETD_IOC_MAGIC    'K'
+
+#define CPETD_IOCRESET     _IO(CPEMSB_IOC_MAGIC, 0)
+
+/*
+ * S means "Set" through a ptr,
+ * T means "Tell" directly
+ * G means "Get" (to a pointed var)
+ * Q means "Query", response is on the return value
+ * X means "eXchange": G and S atomically
+ * H means "sHift": T and Q atomically
+ */
+#define CPETD_IOCTPERIOD        _IO(CPETD_IOC_MAGIC,   1)
+#define CPETD_IOCQPERIOD        _IO(CPETD_IOC_MAGIC,   2)
+#define CPETD_IOCSETINFO        _IO(CPETD_IOC_MAGIC,   3)    /*sdh fix me: may need modifying */
+#define CPETD_IOCGETINFO        _IO(CPETD_IOC_MAGIC,   4)
+#define CPETD_IOCGETHIRESINFO   _IO(CPETD_IOC_MAGIC,   5)
+#define CPETD_IOCGETPHYSREGINFO _IO(CPETD_IOC_MAGIC,   6)
+#define CPETD_IOCPROCESSIDINFO  _IO(CPETD_IOC_MAGIC,   7)
+
+#define CPETD_IOC_MAXNR    7
+#define MAX_NUM_OF_PROCESSES  5
+#define MAX_NUM_OF_THREADS_PER_PROCESS 30
+
+
+/* STRUCTURE: ThreadInfoTag
+ * data structure to store thread specific information
+ */
+typedef struct CpetdThreadInfoTag
+{
+	unsigned int tid;
+	unsigned long incompleteTicks;
+	long         state;
+	int	preemptFlag;
+	unsigned int preemptPid;
+}CpetdThreadInfo;
+
+/* STRUCTURE: ProcessInfoTag 
+ *  data structure used to store process specific information
+ * MEMBERS:
+ * pid               process identifier
+ * sleepTime         time in jiffies for which the process is in sleep mode
+ * state             current state of the process
+ */
+typedef struct CpetdProcessInfoTag
+{
+        unsigned int numThreads;
+	CpetdThreadInfo threadInfo[MAX_NUM_OF_THREADS_PER_PROCESS];
+} CpetdProcessInfo;
+
+/* STRUCTURE: CpetdReadInfoV1Tag
+ *  data structure info returned by read(). Ordering of members is most important
+ *  to least so that read can not incur the overhead of reading unwanted data
+ * MEMBERS:
+ * kernelDelay   ret time - expected hb (ms)
+ * missedBeats   missed heartbeats (ms)
+ * userProc      read time minus ret time (ms)
+ * flags         e.g. indicates fast return
+ * jiffies       jiffies count at ret of read
+ * actualBeat    computed beat when the curernt read was supposed to finish.
+ */
+typedef struct CpetdReadInfoV1Tag
+{
+    unsigned char kernelDelay;
+    unsigned char missedBeats;
+    unsigned char userProc;
+    unsigned char flags;
+    unsigned int jiffies;
+    CpetdProcessInfo processInfo[MAX_NUM_OF_PROCESSES];
+    unsigned long numRunning;
+    int 	  globPreemptFlag;
+
+#ifdef CPETD_TEST
+    /* debug & test parameters at end of structure */
+    unsigned int actualBeat;
+#endif /* CPETD_TEST */
+
+} CpetdReadInfoV1;
+
+
+/* bit flags for CpetdReadInfoV1Tag.flags */
+#define CPETD_READINFO_F_FAST_RETURN     0x01
+
+
+/* STRUCTURE: CpetdInfoTag
+ * Data structure for CPETD_IOCSETINFO/CPETD_IOCGETINFO
+ * MEMBERS:
+ * flags;        e.g. indicates fast return
+ */
+typedef struct CpetdInfoTag
+{
+    unsigned int flags;
+} CpetdInfo;
+
+/* bit flags for CpetdInfoTag.flags */
+#define CPETD_INFO_F_FAST_RETURN            CPETD_READINFO_F_FAST_RETURN
+#define CPETD_INFO_F_VERSION_MASK           0xff000000
+#define CPETD_INFO_F_VERSION_1_0            0x01000000
+#define CPETD_INFO_F_DEBUG_MASK             0x00ff0000                      /* used for debug and test */
+#define CPETD_INFO_F_DEBUG_OFFSET_STEP      0x00010000                      /* used for debug and test */
+#define CPETD_INFO_F_DEBUG_OFFSET_RESET     0x00020000                      /* used for debug and test */
+
+
+/* STRUCTURE: CpetdHiresInfoTag
+ * Data structure for CPETD_IOCGETHIRESINFO
+ * MEMBERS:
+ * flags;        e.g. indicates fast return
+ */
+typedef struct CpetdHiresInfoTag
+{
+    unsigned int    lastBeatHiresTime;      /* hires timer value at last beat */
+    unsigned int    hiresTicksPerSecond;    /* number of high resoltuion timer ticks in one second */
+} CpetdHiresInfo;
+
+
+/* STRUCTURE: CpetdPhysRegInfoTag
+ * Data structure for CPETD_IOCGETPHYSREGINFO
+ * MEMBERS:
+ * timerRegisters;  The physical address of the Timer subsystem
+ * timerCountRegOff;  The offset of the hires current count register
+ */
+typedef struct CpetdPhysRegInfoTag
+{
+    unsigned long   timerRegisters;      /* Physical address of the timer registers */
+    unsigned long   timerCountRegOff;    /* Physical address of the hires timer */
+} CpetdPhysRegInfo;
+
+
+
diff -Naur pico_2.6.28/include/linux/ipa/dac7512.h ipa_2.6.28/include/linux/ipa/dac7512.h
--- pico_2.6.28/include/linux/ipa/dac7512.h	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/include/linux/ipa/dac7512.h	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,20 @@
+/* -*- C -*-
+ * dac7512.h -- definitions for the Burr Brown DAC7512 SPI DAC
+ *
+ * Copyright (C) 2009 ip.access Ltd
+ *
+ */
+
+#include <linux/ioctl.h>
+
+
+/*
+ * Ioctl definitions
+ */
+
+/* Use 'D' as magic number */
+#define DAC7512_IOCTL_MAGIC            'D'
+
+#define DAC7512_IOCTL_WRITE_VALUE      _IO(DAC7512_IOCTL_MAGIC,   0)
+
+#define DAC7512_IOCTL_MAXNR            0
diff -Naur pico_2.6.28/include/linux/ipa/ipa_keystream.h ipa_2.6.28/include/linux/ipa/ipa_keystream.h
--- pico_2.6.28/include/linux/ipa/ipa_keystream.h	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/include/linux/ipa/ipa_keystream.h	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,111 @@
+/* -*- C -*-
+ * ipacrypto.h -- definitions for the ipacrypto keystream driver
+ *
+ * Copyright (C) 2010 ip.access Ltd
+ *
+ */
+
+#ifndef IPA_KEYSTREAM_H_INCLUDED
+#define IPA_KEYSTREAM_H_INCLUDED
+
+#include <linux/ioctl.h>
+
+
+/*
+ * Ioctl definitions
+ */
+
+/* Use 'K' as magic number */
+#define IPAC_IOCTL_MAGIC          'K'
+
+#define IPAC_IOCTL_ALLOC_CONTEXT         _IO(IPAC_IOCTL_MAGIC,   0)
+#define IPAC_IOCTL_DEALLOC_CONTEXT       _IO(IPAC_IOCTL_MAGIC,   1)
+#define IPAC_IOCTL_CHECK_SPACE           _IO(IPAC_IOCTL_MAGIC,   2)
+#define IPAC_IOCTL_START_CRYPTO          _IO(IPAC_IOCTL_MAGIC,   3)
+#define IPAC_IOCTL_CHECK_CRYPTO_READY    _IO(IPAC_IOCTL_MAGIC,   4)
+#define IPAC_IOCTL_BUFFER_UNLOAD         _IO(IPAC_IOCTL_MAGIC,   5)
+
+#define IPAC_IOCTL_MAXNR          5
+
+/* The driver will limit the maximum number of requests that can be submitted
+ * to the cipher engine at any one time.  Each request can consist of multiple
+ * PDUs and these are submitted together.  This limit is therefore the maximum
+ * number of PDUs that can be requested in a single request.
+ */
+#define IPAC_MAX_ALLOWED_CIPHER_REQUESTS  0
+
+/* We have two nodes, one for uplink (/dev/ipacrypto_0) and another for downlink
+ * (/dev/ipacrypto_1)
+ */
+#define IPAC_MAX_DRIVER_NODES         2
+
+/* Each node can support a certain number of ciphering contexts */
+#define IPAC_NUM_CONTEXTS             96
+
+/* This is the maximum number of requests that can be made at once on each node.
+ * If this is set to 0 then the number will be unlimited.
+ */
+#define IPAC_MAX_NUM_BUFFERS_ALLOWED  0
+
+/* Each driver node has a memory buffer for results.  This buffer stores multiple
+ * requests.  A request has a header with info to be passed back to the caller and
+ * that's followed by the keystream data.  This size of the buffer is set by the
+ * following definition.
+ */
+#define IPAC_KEYSTREAM_BUFFER_SIZE  65536
+
+/* We support on f8(kasumi) in this driver */
+#define IPAC_CIPHER_KEY_LENGTH_BITS   128
+#define IPAC_IV_LENGTH_BITS           64
+
+#define IPAC_CIPHER_KEY_LENGTH_BYTES  ((IPAC_CIPHER_KEY_LENGTH_BITS + 7) / 8)
+#define IPAC_IV_LENGTH_BYTES          ((IPAC_IV_LENGTH_BITS + 7) / 8)
+#define IPAC_IV_LENGTH_LONGS          ((IPAC_IV_LENGTH_BITS + 31) / 32)
+
+typedef struct IpacContextIoctlTag  IpacContextIoctl;
+typedef struct IpacStartIoctlTag    IpacStartIoctl;
+
+typedef enum   IpacStateTag         IpacState;
+typedef struct IpacRequestTag       IpacRequest;
+
+struct IpacContextIoctlTag {
+    unsigned char     cipherKey[IPAC_CIPHER_KEY_LENGTH_BYTES];
+    unsigned char     bearerId;
+    signed char       contextId;
+};
+
+struct IpacStartIoctlTag {
+    unsigned long     transactionId;
+    unsigned          *counts;
+    unsigned short    numPdus;
+    unsigned short    pduLength;
+    signed long       contextId;
+};
+
+
+enum IpacStateTag
+{
+    IPAC_REQUEST_UNUSED,    /* Request freed. */
+    IPAC_REQUEST_WAITING,   /* Request not yet submitted to cipher engine */
+    IPAC_REQUEST_CIPHERING, /* Request submitted to the cipher engine */
+    IPAC_REQUEST_COMPLETED, /* All PDUs in request have been ciphered */
+    IPAC_REQUEST_RETURNED,  /* Results have been passed back to the user */
+    IPAC_REQUEST_WRAPPED,   /* Next request is at start of buffer */
+    IPAC_REQUEST_FINAL      /* No more requests in the buffer */
+};
+
+/* We have transactions in a ring buffer in memory */
+struct IpacRequestTag {
+    IpacState                  state;         /* The current state of the request */
+    unsigned long              transactionId; /* The transaction ID */
+    struct crypto_ablkcipher   *cipher_p;     /* Pointer to the cipher that was used for this request */
+    unsigned long              channel;       /* Which channel/node this request was for */
+    signed long                contextId;     /* The context used for the request */
+    unsigned short             reservedBytes; /* Number of bytes to skip to get to the next header */
+    unsigned short             numberOfPdus;  /* How many PDUs were requested */
+    unsigned short             pduLength;     /* How many bytes in each PDU */
+    unsigned short             pdusCompleted; /* How many PDU have already been ciphered. */
+    unsigned                   ivFixedPart;   /* The combination of binding ID and direction */
+};
+
+#endif /* IPA_KEYSTREAM_H_INCLUDED */
diff -Naur pico_2.6.28/include/linux/ipa/Kbuild ipa_2.6.28/include/linux/ipa/Kbuild
--- pico_2.6.28/include/linux/ipa/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/include/linux/ipa/Kbuild	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,24 @@
+################################################################################
+# 
+# Copyright (c) 2009 ip.access Ltd.
+#
+#  This program is free software; you can redistribute  it and/or modify it
+#  under  the terms of  the GNU General  Public License as published by the
+#  Free Software Foundation;  either version 2 of the  License, or (at your
+#  option) any later version.
+#
+# 22 Apr 2009 Created by Simon D Hughes.
+##############################################################################
+# Filename: 
+##############################################################################
+header-y += config_ipaccess.h
+header-y += config_ipaccess_i686_pc_linux_gnu.h
+header-y += config_ipaccess_ip202ff.h
+header-y += config_ipaccess_ip202ff_xbplus.h
+header-y += config_ipaccess_ip202ff_xc.h
+header-y += config_ipaccess_ip302ff.h
+header-y += ad7995.h
+header-y += cpetd.h
+header-y += max6662.h
+header-y += dac7512.h
+header-y += ipa_keystream.h
diff -Naur pico_2.6.28/include/linux/ipa/max6635.h ipa_2.6.28/include/linux/ipa/max6635.h
--- pico_2.6.28/include/linux/ipa/max6635.h	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/include/linux/ipa/max6635.h	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,49 @@
+/* -*- C -*-
+ * max6635.h -- definitions for the Maxim MAX6635 I2C Thermal Sensor
+ *
+ * Copyright (C) 2009 ip.access Ltd
+ *
+ */
+
+#include <linux/ioctl.h>
+
+
+/*
+ * Ioctl definitions
+ */
+
+/* Use 'T' as magic number */
+#define MAX6635_IOCTL_MAGIC          'T'
+
+#define MAX6635_IOCTL_READ_TEMP      _IO(MAX6635_IOCTL_MAGIC,   0)
+#define MAX6635_IOCTL_WRITE_CONFIG   _IO(MAX6635_IOCTL_MAGIC,   1)
+#define MAX6635_IOCTL_READ_CONFIG    _IO(MAX6635_IOCTL_MAGIC,   2)
+#define MAX6635_IOCTL_WRITE_LIMITS   _IO(MAX6635_IOCTL_MAGIC,   3)
+#define MAX6635_IOCTL_READ_LIMITS    _IO(MAX6635_IOCTL_MAGIC,   4)
+
+#define MAX6635_IOCTL_MAXNR          4
+
+typedef struct Max6635ConfigTag
+{
+	unsigned long  flags;
+	
+} Max6635Config;
+
+/* Range of limits is 255 to -256 degrees C */
+#define  MAX6635_DONT_UPDATE_LIMIT     999
+
+typedef struct Max6635LimitsTag
+{
+	int  thyst;
+	int  tmax;
+	int  tlow;
+	int  thigh;
+	
+} Max6635Limits;
+
+typedef struct Max6635StatusTag
+{
+	signed   long  scaledCelcius;
+	unsigned long  flags;
+	
+} Max6635Status;
diff -Naur pico_2.6.28/include/linux/ipa/max6662.h ipa_2.6.28/include/linux/ipa/max6662.h
--- pico_2.6.28/include/linux/ipa/max6662.h	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/include/linux/ipa/max6662.h	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,49 @@
+/* -*- C -*-
+ * max6662.h -- definitions for the Maxim MAX6662 SPI Thermal Sensor
+ *
+ * Copyright (C) 2009 ip.access Ltd
+ *
+ */
+
+#include <linux/ioctl.h>
+
+
+/*
+ * Ioctl definitions
+ */
+
+/* Use 'T' as magic number */
+#define MAX6662_IOCTL_MAGIC          'T'
+
+#define MAX6662_IOCTL_READ_TEMP      _IO(MAX6662_IOCTL_MAGIC,   0)
+#define MAX6662_IOCTL_WRITE_CONFIG   _IO(MAX6662_IOCTL_MAGIC,   1)
+#define MAX6662_IOCTL_READ_CONFIG    _IO(MAX6662_IOCTL_MAGIC,   2)    /*sdh fix me: may need modifying */
+#define MAX6662_IOCTL_WRITE_LIMITS   _IO(MAX6662_IOCTL_MAGIC,   3)
+#define MAX6662_IOCTL_READ_LIMITS    _IO(MAX6662_IOCTL_MAGIC,   4)
+
+#define MAX6662_IOCTL_MAXNR          4
+
+typedef struct Max6662ConfigTag
+{
+	unsigned long  flags;
+	
+} Max6662Config;
+
+/* Range of limits is 255 to -256 degrees C */
+#define  MAX6662_DONT_UPDATE_LIMIT     999
+
+typedef struct Max6662LimitsTag
+{
+	int  thyst;
+	int  tmax;
+	int  tlow;
+	int  thigh;
+	
+} Max6662Limits;
+
+typedef struct Max6662StatusTag
+{
+	signed   long  scaledCelcius;
+	unsigned long  flags;
+	
+} Max6662Status;
diff -Naur pico_2.6.28/include/linux/Kbuild ipa_2.6.28/include/linux/Kbuild
--- pico_2.6.28/include/linux/Kbuild	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/include/linux/Kbuild	2011-04-26 14:51:35.000000000 +0100
@@ -1,3 +1,16 @@
+################################################################################
+# 
+# Copyright (c) 2009 ip.access Ltd.
+#
+#  This program is free software; you can redistribute  it and/or modify it
+#  under  the terms of  the GNU General  Public License as published by the
+#  Free Software Foundation;  either version 2 of the  License, or (at your
+#  option) any later version.
+#
+# 22 Apr 2009 Created by Simon D Hughes.
+##############################################################################
+# Filename: 
+##############################################################################
 header-y += byteorder/
 header-y += can/
 header-y += dvb/
@@ -15,6 +28,8 @@
 header-y += netfilter_ipv4/
 header-y += netfilter_ipv6/
 header-y += usb/
+header-y += picochip/
+header-y += ipa/
 
 header-y += affs_hardblocks.h
 header-y += aio_abi.h
diff -Naur pico_2.6.28/include/linux/miscdevice.h ipa_2.6.28/include/linux/miscdevice.h
--- pico_2.6.28/include/linux/miscdevice.h	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/include/linux/miscdevice.h	2011-04-26 14:51:35.000000000 +0100
@@ -30,6 +30,11 @@
 #define TUN_MINOR	     200
 #define	HPET_MINOR	     228
 #define KVM_MINOR            232
+#define AD7995_MINOR     245
+#define MAX6635_MINOR    246
+#define DAC7512_MINOR    247
+#define MAX6662_MINOR    248
+#define PICOIF_MINOR     249
 
 struct device;
 
diff -Naur pico_2.6.28/include/linux/mtd/cfi.h ipa_2.6.28/include/linux/mtd/cfi.h
--- pico_2.6.28/include/linux/mtd/cfi.h	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/include/linux/mtd/cfi.h	2011-04-26 14:53:04.000000000 +0100
@@ -253,6 +253,7 @@
 #define P_ID_MITSUBISHI_STD     0x0100
 #define P_ID_MITSUBISHI_EXT     0x0101
 #define P_ID_SST_PAGE           0x0102
+#define P_ID_SST_OLD            0x0701
 #define P_ID_INTEL_PERFORMANCE  0x0200
 #define P_ID_INTEL_DATA         0x0210
 #define P_ID_RESERVED           0xffff
@@ -297,7 +298,7 @@
 	 * and 32bit devices on 16 bit busses
 	 * set the low bit of the alternating bit sequence of the address.
 	 */
-	if (((type * interleave) > bankwidth) && ((uint8_t)cmd_ofs == 0xaa))
+	if (((type * interleave) > bankwidth) && ((cmd_ofs & 0xff) == 0xaa))
 		addr |= (type >> 1)*interleave;
 
 	return  addr;
@@ -515,12 +516,26 @@
 	void* param;
 };
 
-#define CFI_MFR_ANY 0xffff
-#define CFI_ID_ANY  0xffff
-
-#define CFI_MFR_AMD 0x0001
-#define CFI_MFR_ATMEL 0x001F
-#define CFI_MFR_ST  0x0020 	/* STMicroelectronics */
+#define CFI_MFR_ANY		0xFFFF
+#define CFI_ID_ANY		0xFFFF
+#define CFI_MFR_CONTINUATION	0x007F
+
+#define CFI_MFR_AMD		0x0001
+#define CFI_MFR_ATMEL		0x001F
+#define CFI_MFR_EON		0x001C
+#define CFI_MFR_FUJITSU		0x0004
+#define CFI_MFR_HYUNDAI		0x00AD
+#define CFI_MFR_INTEL		0x0089
+#define CFI_MFR_MACRONIX	0x00C2
+#define CFI_MFR_NEC		0x0010
+#define CFI_MFR_PMC		0x009D
+#define CFI_MFR_SAMSUNG		0x00EC
+#define CFI_MFR_SHARP		0x00B0
+#define CFI_MFR_SST		0x00BF
+#define CFI_MFR_ST		0x0020 /* STMicroelectronics */
+#define CFI_MFR_NMX		0x0089 /* Micron */
+#define CFI_MFR_TOSHIBA		0x0098
+#define CFI_MFR_WINBOND		0x00DA
 
 void cfi_fixup(struct mtd_info *mtd, struct cfi_fixup* fixups);
 
diff -Naur pico_2.6.28/include/linux/mtd/flashchip.h ipa_2.6.28/include/linux/mtd/flashchip.h
--- pico_2.6.28/include/linux/mtd/flashchip.h	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/include/linux/mtd/flashchip.h	2011-04-26 14:51:35.000000000 +0100
@@ -15,6 +15,7 @@
  * has asm/spinlock.h, or 2.4, which has linux/spinlock.h
  */
 #include <linux/sched.h>
+#include <linux/mutex.h>
 
 typedef enum {
 	FL_READY,
@@ -65,8 +66,7 @@
 	unsigned int erase_suspended:1;
 	unsigned long in_progress_block_addr;
 
-	spinlock_t *mutex;
-	spinlock_t _spinlock; /* We do it like this because sometimes they'll be shared. */
+	struct mutex mutex;
 	wait_queue_head_t wq; /* Wait on here when we're waiting for the chip
 			     to be ready */
 	int word_write_time;
diff -Naur pico_2.6.28/include/linux/picochip/devices/Kbuild ipa_2.6.28/include/linux/picochip/devices/Kbuild
--- pico_2.6.28/include/linux/picochip/devices/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/include/linux/picochip/devices/Kbuild	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,15 @@
+################################################################################
+# 
+# Copyright (c) 2009 ip.access Ltd.
+#
+#  This program is free software; you can redistribute  it and/or modify it
+#  under  the terms of  the GNU General  Public License as published by the
+#  Free Software Foundation;  either version 2 of the  License, or (at your
+#  option) any later version.
+#
+##############################################################################
+# Filename: 
+##############################################################################
+header-y += pc202.h
+header-y += pc203.h
+header-y += pc302.h
diff -Naur pico_2.6.28/include/linux/picochip/Kbuild ipa_2.6.28/include/linux/picochip/Kbuild
--- pico_2.6.28/include/linux/picochip/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/include/linux/picochip/Kbuild	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,20 @@
+################################################################################
+# 
+# Copyright (c) 2009 ip.access Ltd.
+#
+#  This program is free software; you can redistribute  it and/or modify it
+#  under  the terms of  the GNU General  Public License as published by the
+#  Free Software Foundation;  either version 2 of the  License, or (at your
+#  option) any later version.
+#
+# 22 Apr 2009 Created by Simon D Hughes.
+##############################################################################
+# Filename: 
+##############################################################################
+header-y += devices/
+header-y += transports/
+
+header-y += fpga_cpe20x.h
+header-y += gpio.h
+header-y += picoif.h
+header-y += picoif_ioctl.h
diff -Naur pico_2.6.28/include/linux/picochip/picoif_ioctl.h ipa_2.6.28/include/linux/picochip/picoif_ioctl.h
--- pico_2.6.28/include/linux/picochip/picoif_ioctl.h	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/include/linux/picochip/picoif_ioctl.h	2011-04-26 14:51:35.000000000 +0100
@@ -24,15 +24,8 @@
 #ifndef __PICOIF_PICOIF_IOCTL_H__
 #define __PICOIF_PICOIF_IOCTL_H__
 
-#ifdef __KERNEL__
 #include <linux/types.h>
-#include <asm/ioctl.h>
-#else /* __KERNEL__ */
-#include <sys/types.h>
-#include <sys/ioctl.h>
-
-#define __user
-#endif /* __KERNEL__ */
+#include <linux/ioctl.h>
 
 /*!
  * \brief Structure to pass config read/write requests between userspace and
diff -Naur pico_2.6.28/include/linux/picochip/transports/Kbuild ipa_2.6.28/include/linux/picochip/transports/Kbuild
--- pico_2.6.28/include/linux/picochip/transports/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ ipa_2.6.28/include/linux/picochip/transports/Kbuild	2011-04-26 14:51:35.000000000 +0100
@@ -0,0 +1,16 @@
+################################################################################
+# 
+# Copyright (c) 2009 ip.access Ltd.
+#
+#  This program is free software; you can redistribute  it and/or modify it
+#  under  the terms of  the GNU General  Public License as published by the
+#  Free Software Foundation;  either version 2 of the  License, or (at your
+#  option) any later version.
+#
+##############################################################################
+# Filename: 
+##############################################################################
+header-y += dma.h
+header-y += gpr_interrupt.h
+header-y += hwif.h
+header-y += hwif2.h
diff -Naur pico_2.6.28/include/linux/sched.h ipa_2.6.28/include/linux/sched.h
--- pico_2.6.28/include/linux/sched.h	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/include/linux/sched.h	2011-04-26 14:51:35.000000000 +0100
@@ -1356,6 +1356,9 @@
 	unsigned long default_timer_slack_ns;
 
 	struct list_head	*scm_work_list;
+	int			preempt_flag;
+	int			preempt_pid;
+	int			incompleteTicks;
 };
 
 /*
@@ -2302,4 +2305,8 @@
 
 #endif /* __KERNEL__ */
 
+struct task_struct *find_task_struct_by_pid(pid_t pid);
+unsigned long long ret_now(pid_t pid);
+unsigned long ret_nr_running(void);
+
 #endif
diff -Naur pico_2.6.28/init/Kconfig ipa_2.6.28/init/Kconfig
--- pico_2.6.28/init/Kconfig	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/init/Kconfig	2011-04-26 14:51:35.000000000 +0100
@@ -1,3 +1,16 @@
+################################################################################
+# 
+# Copyright (c) 2009 ip.access Ltd.
+#
+#  This program is free software; you can redistribute  it and/or modify it
+#  under  the terms of  the GNU General  Public License as published by the
+#  Free Software Foundation;  either version 2 of the  License, or (at your
+#  option) any later version.
+#
+# 22 Apr 2009 Created by Simon D Hughes.
+##############################################################################
+# Filename: 
+##############################################################################
 config ARCH
 	string
 	option env="ARCH"
@@ -935,3 +948,49 @@
 	  designed for best read-side performance on non-realtime
 	  systems.  Classic RCU is the default.  Note that the
 	  PREEMPT_RCU symbol is used to select/deselect this option.
+
+menu "IPAccess 3GAP Oyster Product Variant Options"
+
+config IPACCESS_IP202FF
+	bool "Enable configuration define for Oyster 3GAP PC202 Variant"
+	help
+	  Note that the kernel is variant agnostic (almost) and
+	  this defined is for system and application variant
+	  specific compile behaviour
+	  
+config IPACCESS_IP202FF_686
+	bool "Enable configuration define for Oyster 3GAP Split System Build"
+	help
+	  Note that the kernel is variant agnostic (almost) and
+	  this defined is for system and application variant
+	  specific compile behaviour
+	  
+config IPACCESS_IP202FF_XC
+	bool "Enable configuration define for 202 xc variant"
+	help
+	  Note that the kernel is variant agnostic (almost) and
+	  this defined is for system and application variant
+	  specific compile behaviour
+	  
+config IPACCESS_IP202FF_XE
+	bool "Enable configuration define for 202 xe variant"
+	help
+	  Note that the kernel is variant agnostic (almost) and
+	  this defined is for system and application variant
+	  specific compile behaviour
+
+config IPACCESS_IP302FF
+	bool "Enable configuration define for Oyster 3GAP PC302 Variant"
+	help
+	  Note that the kernel is variant agnostic (almost) and
+	  this defined is for system and application variant
+	  specific compile behaviour
+	  
+config IPACCESS_IP302FF_XC
+	bool "Enable configuration define for 302 xc variant"
+	help
+	  Note that the kernel is variant agnostic (almost) and
+	  this defined is for system and application variant
+	  specific compile behaviour
+	  
+endmenu
diff -Naur pico_2.6.28/kernel/sched.c ipa_2.6.28/kernel/sched.c
--- pico_2.6.28/kernel/sched.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/kernel/sched.c	2011-04-26 14:51:35.000000000 +0100
@@ -637,7 +637,27 @@
 #define this_rq()		(&__get_cpu_var(runqueues))
 #define task_rq(p)		cpu_rq(task_cpu(p))
 #define cpu_curr(cpu)		(cpu_rq(cpu)->curr)
+unsigned long ret_nr_running()
+{
+	unsigned long num_running;
+	int cpu = smp_processor_id();
+	struct rq *rq = cpu_rq(cpu);
+
+	num_running = rq->cfs.nr_running; 
+	return num_running;
+}
+
+EXPORT_SYMBOL(ret_nr_running);
+
+unsigned long long ret_now(pid_t pid)
+{
+	unsigned long long now;
+	struct task_struct *t = find_task_struct_by_pid(pid);
+	now = task_rq(t)->clock;
+	return now;
+}
 
+EXPORT_SYMBOL(ret_now);
 static inline void update_rq_clock(struct rq *rq)
 {
 	rq->clock = sched_clock_cpu(cpu_of(rq));
@@ -4485,6 +4505,12 @@
 
 	if (likely(prev != next)) {
 		sched_info_switch(prev, next);
+		prev->preempt_pid = next;
+		prev->preempt_flag = (prev->state == TASK_RUNNING);
+		if (!prev->preempt_flag)
+		{
+			prev->incompleteTicks = 0;
+		}
 
 		rq->nr_switches++;
 		rq->curr = next;
@@ -5108,6 +5134,17 @@
 	return pid ? find_task_by_vpid(pid) : current;
 }
 
+/**
+ * find_task_struct_by_pid - this is similar to the above function
+ * The only difference is that this is a non static function
+ */
+struct task_struct *find_task_struct_by_pid(pid_t pid)
+{
+	return pid ? find_task_by_vpid(pid) : current;
+}
+
+EXPORT_SYMBOL(find_task_struct_by_pid);
+
 /* Actually do priority change: must hold rq lock. */
 static void
 __setscheduler(struct rq *rq, struct task_struct *p, int policy, int prio)
diff -Naur pico_2.6.28/net/ethernet/eth.c ipa_2.6.28/net/ethernet/eth.c
--- pico_2.6.28/net/ethernet/eth.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/net/ethernet/eth.c	2011-04-26 14:51:35.000000000 +0100
@@ -286,11 +286,22 @@
 {
 	struct sockaddr *addr = p;
 
+    printk("Attempt to change %s hw address to %02X:%02X:%02X:%02X:%02X:%02X in pid=%d\n",
+           dev->name,
+           addr->sa_data[0], addr->sa_data[1], addr->sa_data[2],
+           addr->sa_data[3], addr->sa_data[4], addr->sa_data[5],
+           current->pid);
+    show_stack(0, NULL);
+    
 	if (netif_running(dev))
 		return -EBUSY;
 	if (!is_valid_ether_addr(addr->sa_data))
 		return -EADDRNOTAVAIL;
 	memcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);
+    printk("Attempt to change %s hw address to %02X:%02X:%02X:%02X:%02X:%02X was successful\n",
+           dev->name,
+           addr->sa_data[0], addr->sa_data[1], addr->sa_data[2],
+           addr->sa_data[3], addr->sa_data[4], addr->sa_data[5]);
 	return 0;
 }
 
diff -Naur pico_2.6.28/net/ipv4/udp.c ipa_2.6.28/net/ipv4/udp.c
--- pico_2.6.28/net/ipv4/udp.c	2011-04-26 14:51:00.000000000 +0100
+++ ipa_2.6.28/net/ipv4/udp.c	2011-04-26 14:51:35.000000000 +0100
@@ -1159,7 +1159,7 @@
 		   int proto)
 {
 	struct sock *sk;
-	struct udphdr *uh = udp_hdr(skb);
+	struct udphdr *uh;
 	unsigned short ulen;
 	struct rtable *rt = (struct rtable*)skb->dst;
 	__be32 saddr = ip_hdr(skb)->saddr;
@@ -1172,6 +1172,7 @@
 	if (!pskb_may_pull(skb, sizeof(struct udphdr)))
 		goto drop;		/* No space for header. */
 
+	uh = udp_hdr(skb);
 	ulen = ntohs(uh->len);
 	if (ulen > skb->len)
 		goto short_packet;
diff -Naur pico_2.6.28/scripts/unifdef.c ipa_2.6.28/scripts/unifdef.c
--- pico_2.6.28/scripts/unifdef.c	2008-12-24 23:26:37.000000000 +0000
+++ ipa_2.6.28/scripts/unifdef.c	2011-04-26 14:51:35.000000000 +0100
@@ -206,7 +206,7 @@
 static void             error(const char *);
 static int              findsym(const char *);
 static void             flushline(bool);
-static Linetype         getline(void);
+static Linetype         get_line(void);
 static Linetype         ifeval(const char **);
 static void             ignoreoff(void);
 static void             ignoreon(void);
@@ -512,7 +512,7 @@
 
 	for (;;) {
 		linenum++;
-		lineval = getline();
+		lineval = get_line();
 		trans_table[ifstate[depth]][lineval]();
 		debug("process %s -> %s depth %d",
 		    linetype_name[lineval],
@@ -526,7 +526,7 @@
  * help from skipcomment().
  */
 static Linetype
-getline(void)
+get_line(void)
 {
 	const char *cp;
 	int cursym;
